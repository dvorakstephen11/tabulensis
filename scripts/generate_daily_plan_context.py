#!/usr/bin/env python3
"""
Generate a bounded "daily plan context" payload for local planning sessions.

This is intentionally deterministic and dependency-free: it reads a small set of
operator/docs inputs, prints a bounded repo tree, and embeds the unfinished
checklist index as generated by scripts/update_docs_index_checklists.py --print.
"""

from __future__ import annotations

import argparse
import io
import os
import platform
import shutil
import subprocess
import sys
from dataclasses import dataclass
from pathlib import Path


DEFAULT_MAX_CHARS = 200_000

EXCLUDED_DIR_NAMES = {
    ".codex_skills",
    ".git",
    "__pycache__",
    "node_modules",
    "target",
    "tmp",
    "vendor",
}


@dataclass
class _WriteResult:
    fully_written: bool
    truncated: bool


class _BoundedWriter:
    def __init__(self, *, max_chars: int, out) -> None:
        self._max_chars = int(max_chars)
        self._out = out
        self._written = 0
        self._truncated = False

    @property
    def truncated(self) -> bool:
        return self._truncated

    def write(self, s: str) -> _WriteResult:
        if self._max_chars <= 0:
            self._out.write(s)
            return _WriteResult(fully_written=True, truncated=False)

        if self._written >= self._max_chars:
            self._truncated = True
            return _WriteResult(fully_written=False, truncated=True)

        remaining = self._max_chars - self._written
        if len(s) <= remaining:
            self._out.write(s)
            self._written += len(s)
            return _WriteResult(fully_written=True, truncated=False)

        # Partial write, with a best-effort marker if we have space.
        marker = f"\n\n[OUTPUT TRUNCATED: reached --max-chars={self._max_chars:,}]\n"
        if remaining > len(marker):
            take = remaining - len(marker)
            self._out.write(s[:take])
            self._out.write(marker)
        else:
            self._out.write(s[:remaining])
        self._written = self._max_chars
        self._truncated = True
        return _WriteResult(fully_written=False, truncated=True)


def _normalize_text(s: str) -> str:
    s = s.replace("\r\n", "\n").replace("\r", "\n")
    if not s.endswith("\n"):
        s += "\n"
    return s


def _read_text_bounded(path: Path, *, max_bytes: int = 2_000_000) -> tuple[str, bool]:
    # Guardrail: avoid reading arbitrarily large files if the repo contains
    # large artifacts.
    try:
        with path.open("rb") as f:
            data = f.read(int(max_bytes) + 1)
    except OSError:
        return "", False
    truncated = len(data) > max_bytes
    if truncated:
        data = data[:max_bytes]
    text = data.decode("utf-8", errors="replace")
    return _normalize_text(text), truncated


def _format_path(repo_root: Path, path: Path) -> str:
    try:
        rel = path.resolve().relative_to(repo_root.resolve())
        return rel.as_posix()
    except Exception:
        return str(path)


def _iter_repo_tree(repo_root: Path, *, max_depth: int, max_entries: int) -> list[str]:
    lines: list[str] = []
    entries = 0

    def should_skip_dir(p: Path) -> bool:
        return any(part in EXCLUDED_DIR_NAMES for part in p.parts)

    def walk(dir_path: Path, depth: int) -> None:
        nonlocal entries
        if entries >= max_entries:
            return
        if depth > max_depth:
            return

        try:
            children = list(dir_path.iterdir())
        except OSError:
            return

        # Stable ordering: dirs first then files, each alpha.
        children.sort(key=lambda p: (0 if p.is_dir() else 1, p.name.lower()))
        for child in children:
            if entries >= max_entries:
                return
            if child.is_dir() and should_skip_dir(child):
                continue
            indent = "  " * depth
            name = child.name + ("/" if child.is_dir() else "")
            lines.append(f"{indent}{name}\n")
            entries += 1
            if child.is_dir() and depth < max_depth:
                walk(child, depth + 1)

    lines.append(".\n")
    walk(repo_root, 1)
    if entries >= max_entries:
        lines.append("[... repo tree truncated ...]\n")
    return lines


def _run_checklist_print(repo_root: Path) -> tuple[str, bool]:
    cmd = [sys.executable, str(repo_root / "scripts/update_docs_index_checklists.py"), "--print"]
    try:
        out = subprocess.check_output(cmd, cwd=str(repo_root), stderr=subprocess.STDOUT, text=True)
    except Exception as e:
        return f"[error running update_docs_index_checklists.py --print: {e}]\n", True
    return _normalize_text(out), False


def _find_latest_daily_log(repo_root: Path) -> Path | None:
    daily_dir = repo_root / "docs/meta/logs/daily"
    if not daily_dir.exists() or not daily_dir.is_dir():
        return None
    candidates = sorted(
        (p for p in daily_dir.glob("*.md") if p.is_file() and p.name != "_TEMPLATE.md"),
        key=lambda p: p.name,
    )
    return candidates[-1] if candidates else None


def _is_wsl() -> bool:
    # https://learn.microsoft.com/en-us/windows/wsl/
    if os.environ.get("WSL_DISTRO_NAME"):
        return True
    rel = platform.release().lower()
    return "microsoft" in rel or "wsl" in rel


def _run_clipboard_command(cmd: list[str], text: str) -> bool:
    try:
        subprocess.run(cmd, input=text.encode("utf-8"), check=True)
        return True
    except Exception:
        return False


def copy_to_clipboard(text: str) -> bool:
    # Prefer Windows clipboard when running under WSL (often pasting into Windows apps).
    if _is_wsl():
        clip = shutil.which("clip.exe") or shutil.which("clip")
        if clip and _run_clipboard_command([clip], text):
            return True
        pwsh = shutil.which("powershell.exe")
        if pwsh:
            return _run_clipboard_command([pwsh, "-NoProfile", "-Command", "Set-Clipboard"], text)

    system = platform.system()

    if system == "Windows":
        clip = shutil.which("clip.exe") or shutil.which("clip")
        if clip:
            return _run_clipboard_command([clip], text)
        pwsh = shutil.which("powershell") or shutil.which("powershell.exe")
        if pwsh:
            return _run_clipboard_command([pwsh, "-NoProfile", "-Command", "Set-Clipboard"], text)

    if system == "Darwin":
        pbcopy = shutil.which("pbcopy")
        if pbcopy:
            return _run_clipboard_command([pbcopy], text)

    # Linux: try Wayland first, then X11.
    wl = shutil.which("wl-copy")
    if wl:
        return _run_clipboard_command([wl], text)
    xclip = shutil.which("xclip")
    if xclip:
        return _run_clipboard_command([xclip, "-selection", "clipboard"], text)
    xsel = shutil.which("xsel")
    if xsel:
        return _run_clipboard_command([xsel, "--clipboard", "--input"], text)

    return False


def _write_payload(repo_root: Path, writer: _BoundedWriter) -> None:
    writer.write("# Daily Plan Context (generated)\n")
    writer.write("\n")
    writer.write(f"repo_root: {_format_path(repo_root, repo_root)}\n")
    writer.write("\n")

    # File contents / excerpts.
    input_paths: list[Path] = [
        repo_root / "docs/index.md",
        repo_root / "AGENTS.md",
        repo_root / "docs/meta/automation/overnight_operator_agent_plan.md",
        repo_root / "meta_methodology.md",
        repo_root / "META_METHODOLOGY_IMPLEMENTATION_CHECKLIST.md",
        repo_root / "product_roadmap.md",
        repo_root / "todo.md",
    ]
    latest_daily = _find_latest_daily_log(repo_root)
    if latest_daily is not None:
        input_paths.append(latest_daily)

    writer.write("## Included files\n\n")
    for p in input_paths:
        rel = _format_path(repo_root, p)
        if not p.exists() or not p.is_file():
            writer.write(f"===== BEGIN FILE: {rel} (missing) =====\n")
            writer.write("<<missing>>\n")
            writer.write(f"===== END FILE: {rel} =====\n\n")
            if writer.truncated:
                break
            continue

        text, truncated_by_bytes = _read_text_bounded(p)
        writer.write(f"===== BEGIN FILE: {rel} =====\n")
        writer.write(text)
        if truncated_by_bytes:
            writer.write("[... file read truncated (size guardrail) ...]\n")
        writer.write(f"===== END FILE: {rel} =====\n\n")
        if writer.truncated:
            break

    if not writer.truncated:
        writer.write("## Repo tree (bounded)\n\n")
        for line in _iter_repo_tree(repo_root, max_depth=4, max_entries=800):
            res = writer.write(line)
            if not res.fully_written:
                break
        writer.write("\n")

    if not writer.truncated:
        writer.write("## Unfinished checklists (generated)\n\n")
        checklist_text, _checklist_err = _run_checklist_print(repo_root)
        writer.write(checklist_text)


def main(argv: list[str]) -> int:
    parser = argparse.ArgumentParser(description="Generate a bounded daily plan context payload.")
    parser.add_argument(
        "--copy",
        action="store_true",
        help=(
            "Copy the generated payload to clipboard. In --copy mode, the payload is not printed to stdout. "
            "If clipboard copy fails, writes a backup under tmp/."
        ),
    )
    parser.add_argument(
        "--max-chars",
        type=int,
        default=DEFAULT_MAX_CHARS,
        help=f"Max output characters (default {DEFAULT_MAX_CHARS:,}; 0 disables truncation).",
    )
    args = parser.parse_args(argv)

    repo_root = Path(__file__).resolve().parent.parent

    if args.copy:
        buf = io.StringIO()
        writer = _BoundedWriter(max_chars=int(args.max_chars), out=buf)
        _write_payload(repo_root, writer)
        payload = buf.getvalue()
        if writer.truncated:
            sys.stderr.write(
                f"Output truncated to --max-chars={int(args.max_chars):,}. Re-run with a larger value or --max-chars=0.\n"
            )

        ok = copy_to_clipboard(payload)
        if ok:
            if sys.stderr.isatty():
                sys.stderr.write(f"Copied daily plan context to clipboard ({len(payload):,} chars).\n")
            return 0

        backup_dir = repo_root / "tmp"
        backup_dir.mkdir(parents=True, exist_ok=True)
        backup_path = backup_dir / "daily_plan_context_clipboard_backup.md"
        backup_path.write_text(payload, encoding="utf-8", newline="\n")
        sys.stderr.write("Clipboard copy failed.\n")
        sys.stderr.write(f"Wrote backup to: {_format_path(repo_root, backup_path)}\n")
        return 1

    writer = _BoundedWriter(max_chars=int(args.max_chars), out=sys.stdout)
    _write_payload(repo_root, writer)

    if writer.truncated:
        # Keep this message out of the payload (stderr only).
        sys.stderr.write(
            f"Output truncated to --max-chars={int(args.max_chars):,}. Re-run with a larger value or --max-chars=0.\n"
        )

    return 0


if __name__ == "__main__":
    raise SystemExit(main(sys.argv[1:]))
