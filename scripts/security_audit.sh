#!/usr/bin/env bash
set -euo pipefail

# Runs a minimal security sweep and appends a report to:
#   docs/meta/logs/ops/YYYY-MM-DD_security_audit.md
#
# This script is best-effort: it records missing tools as "YELLOW" and continues.

repo_root="$(cd "$(dirname "${BASH_SOURCE[0]}")/.." && pwd)"
cd "$repo_root"

yyyy_mm_dd="$(date +%F)"
run_ts="$(date +%F' '%T)"
out_dir="docs/meta/logs/ops"
out_path="${out_dir}/${yyyy_mm_dd}_security_audit.md"

mkdir -p "$out_dir"

if [[ ! -f "$out_path" ]]; then
  {
    echo "# Security Audit (${yyyy_mm_dd})"
    echo
    echo "Append-only report generated by \`bash scripts/security_audit.sh\`."
    echo
  } >"$out_path"
fi

have_cmd() {
  command -v "$1" >/dev/null 2>&1
}

append_block() {
  # $1: title, $2: status label, $3: body (preformatted text)
  local title="$1"
  local status="$2"
  local body="$3"
  {
    echo "### ${title}"
    echo
    echo "- Status: ${status}"
    echo
    echo '```text'
    printf "%s\n" "$body"
    echo '```'
    echo
  } >>"$out_path"
}

run_and_capture() {
  # Usage: run_and_capture <cmd...>
  # Prints stdout+stderr and returns the command exit code.
  local tmp
  tmp="$(mktemp -t security_audit.XXXXXX)"
  set +e
  "$@" >"$tmp" 2>&1
  local code=$?
  set -e
  cat "$tmp"
  rm -f "$tmp"
  return "$code"
}

trim_output() {
  # Keep the last ~200 lines to avoid gigantic committed logs.
  local max_lines=200
  local input="$1"
  local lines
  lines="$(printf "%s\n" "$input" | wc -l | tr -d ' ')"
  if [[ "$lines" -le "$max_lines" ]]; then
    printf "%s" "$input"
    return 0
  fi
  printf "%s\n\n[... truncated: showing last %d of %d lines ...]\n\n%s" \
    "$(printf "%s\n" "$input" | head -n 5)" \
    "$max_lines" \
    "$lines" \
    "$(printf "%s\n" "$input" | tail -n "$max_lines")"
}

any_red=0
any_yellow=0

{
  echo "## Run (${run_ts})"
  echo
  if have_cmd git; then
    echo "- git branch: $(git rev-parse --abbrev-ref HEAD 2>/dev/null || echo '?')"
    echo "- git commit: $(git rev-parse --short HEAD 2>/dev/null || echo '?')"
  fi
  echo
} >>"$out_path"

#
# Rust dependency audit (cargo audit).
#
if have_cmd cargo && cargo audit --version >/dev/null 2>&1; then
  set +e
  output="$(run_and_capture cargo audit)"
  code=$?
  set -e
  if [[ "$code" -eq 0 ]]; then
    status="GREEN"
  else
    status="RED"
    any_red=1
  fi
  append_block "Rust: cargo audit" "$status" "$(trim_output "$output")"
else
  any_yellow=1
  append_block "Rust: cargo audit" "YELLOW" \
    "cargo-audit not found.

Install:
  cargo install cargo-audit

Then re-run:
  cargo audit"
fi

#
# npm dependency audit (tabulensis-api).
#
if [[ -d "tabulensis-api" && -f "tabulensis-api/package.json" ]]; then
  if have_cmd npm; then
    set +e
    output="$( (cd tabulensis-api && run_and_capture npm audit --omit=dev) )"
    code=$?
    set -e
    if [[ "$code" -eq 0 ]]; then
      status="GREEN"
    else
      status="RED"
      any_red=1
    fi
    append_block "npm: tabulensis-api npm audit --omit=dev" "$status" "$(trim_output "$output")"
  else
    any_yellow=1
    append_block "npm: tabulensis-api npm audit" "YELLOW" "npm not found."
  fi
else
  append_block "npm: tabulensis-api npm audit" "GREEN" "tabulensis-api/ not present; skipped."
fi

#
# Secret scanning (gitleaks).
#
if have_cmd gitleaks; then
  set +e
  output="$(run_and_capture gitleaks detect --source . --no-banner)"
  code=$?
  set -e
  if [[ "$code" -eq 0 ]]; then
    status="GREEN"
  else
    status="RED"
    any_red=1
  fi
  append_block "Secrets: gitleaks detect" "$status" "$(trim_output "$output")"
else
  any_yellow=1
  append_block "Secrets: gitleaks detect" "YELLOW" \
    "gitleaks not found.

Install:
  https://github.com/gitleaks/gitleaks

Then re-run:
  gitleaks detect --source ."
fi

#
# Minimal SAST (semgrep auto rules).
#
if have_cmd semgrep; then
  set +e
  output="$(run_and_capture semgrep --config auto --error --quiet)"
  code=$?
  set -e
  if [[ "$code" -eq 0 ]]; then
    status="GREEN"
  else
    status="RED"
    any_red=1
  fi
  append_block "SAST: semgrep --config auto" "$status" "$(trim_output "$output")"
else
  any_yellow=1
  append_block "SAST: semgrep" "YELLOW" \
    "semgrep not found.

Install:
  python3 -m pip install semgrep

Then re-run:
  semgrep --config auto --error"
fi

{
  echo "## Summary"
  echo
  if [[ "$any_red" -eq 0 && "$any_yellow" -eq 0 ]]; then
    echo "- Overall: GREEN"
  elif [[ "$any_red" -ne 0 ]]; then
    echo "- Overall: RED (action required)"
  else
    echo "- Overall: YELLOW (tooling missing or errors)"
  fi
  echo
} >>"$out_path"

echo "$out_path"

if [[ "$any_red" -ne 0 ]]; then
  exit 1
fi
if [[ "$any_yellow" -ne 0 ]]; then
  exit 1
fi
exit 0
