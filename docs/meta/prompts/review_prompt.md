# Codebase Context for Review

## Directory Structure

```text
/
  .cursorignore
  .cursorindexingignore
  .gitattributes.example
  .github/
    workflows/
      ci.yml
      pages.yml
      perf.yml
      release.yml
      wasm.yml
  .gitignore
  benchmarks/
    README.md
    results/
      .gitkeep
      2025-12-12_163759.json
      2025-12-12_175341.json
      2025-12-12_203400.json
      2025-12-12_203454.json
      2025-12-12_223643.json
      2025-12-13_000346.json
      2025-12-13_000410.json
      2025-12-13_155200_fullscale.json
      2025-12-13_165236_fullscale.json
      2025-12-13_174735_fullscale.json
      2025-12-13_174822_fullscale.json
      2025-12-13_175318_fullscale.json
      2025-12-13_202028.json
      2025-12-13_202327_fullscale.json
      2025-12-14_003645.json
      2025-12-14_004611.json
      2025-12-14_004643_fullscale.json
      2025-12-14_005407_fullscale.json
      2025-12-14_202417_fullscale.json
      2025-12-15_183914.json
      2025-12-15_191921_fullscale.json
      2025-12-17_164231_fullscale.json
      2025-12-17_164437_fullscale.json
      2025-12-18_221709_fullscale.json
      combined_results.csv
      plots/
        commit_comparison.png
        latest_comparison.png
        metric_breakdown_fullscale.png
        metric_breakdown_quick.png
        speedup_heatmap.png
        time_trends.png
        trend_summary.md
  Cargo.lock
  Cargo.toml
  cli/
    Cargo.toml
    src/
      commands/
        diff.rs
        info.rs
        mod.rs
      main.rs
      output/
        git_diff.rs
        json.rs
        mod.rs
        text.rs
    tests/
      git_textconv.rs
      integration_tests.rs
  core/
    benches/
      diff_benchmarks.rs
    Cargo.lock
    Cargo.toml
    examples/
      basic_diff.rs
      custom_config.rs
      database_mode.rs
      streaming.rs
    fuzz/
      Cargo.toml
      fuzz_targets/
        fuzz_datamashup_parse.rs
        fuzz_diff_grids.rs
        fuzz_open_workbook.rs
    src/
      addressing.rs
      alignment/
        anchor_chain.rs
        anchor_discovery.rs
        assembly.rs
        gap_strategy.rs
        mod.rs
        move_extraction.rs
        runs.rs
      alignment_types.rs
      bin/
        wasm_smoke.rs
      column_alignment.rs
      config.rs
      container.rs
      database_alignment.rs
      datamashup.rs
      datamashup_framing.rs
      datamashup_package.rs
      diff.rs
      engine/
        amr.rs
        context.rs
        grid_diff.rs
        grid_primitives.rs
        hardening.rs
        mod.rs
        move_mask.rs
        workbook_diff.rs
      error_codes.rs
      excel_open_xml.rs
      formula.rs
      formula_diff.rs
      grid_metadata.rs
      grid_parser.rs
      grid_view.rs
      hashing.rs
      lib.rs
      m_ast.rs
      m_diff.rs
      m_section.rs
      object_diff.rs
      output/
        json.rs
        json_lines.rs
        mod.rs
      package.rs
      perf.rs
      progress.rs
      rect_block_move.rs
      region_mask.rs
      row_alignment.rs
      session.rs
      sink.rs
      string_pool.rs
      workbook.rs
    tests/
      addressing_pg2_tests.rs
      amr_multi_gap_tests.rs
      branch4_object_diff_tests.rs
      common/
        mod.rs
      d1_database_mode_tests.rs
      d2_d4_database_mode_workbook_tests.rs
      data_mashup_tests.rs
      database_mode_wrapper_tests.rs
      engine_tests.rs
      excel_open_xml_tests.rs
      f7_formula_canonicalization_tests.rs
      f7_formula_diff_integration_tests.rs
      f7_formula_parser_tests.rs
      f7_formula_shift_tests.rs
      g10_row_block_alignment_grid_workbook_tests.rs
      g11_row_block_move_grid_workbook_tests.rs
      g12_column_block_move_grid_workbook_tests.rs
      g12_rect_block_move_grid_workbook_tests.rs
      g13_fuzzy_row_move_grid_workbook_tests.rs
      g14_move_combination_tests.rs
      g15_column_structure_row_alignment_tests.rs
      g1_g2_grid_workbook_tests.rs
      g5_g7_grid_workbook_tests.rs
      g8_row_alignment_grid_workbook_tests.rs
      g9_column_alignment_grid_workbook_tests.rs
      grid_view_hashstats_tests.rs
      grid_view_tests.rs
      hardening_tests.rs
      integration_test.rs
      limit_behavior_tests.rs
      m4_package_parts_tests.rs
      m4_permissions_metadata_tests.rs
      m5_query_domain_tests.rs
      m6_textual_m_diff_tests.rs
      m7_ast_canonicalization_tests.rs
      m7_semantic_m_diff_tests.rs
      m8_m_canonicalize_tokens_tests.rs
      m8_m_parser_coverage_audit_tests.rs
      m8_m_parser_expansion_tests.rs
      m8_semantic_m_diff_nonlet_tests.rs
      m_section_splitting_tests.rs
      metrics_unit_tests.rs
      output_tests.rs
      package_streaming_tests.rs
      perf_large_grid_tests.rs
      pg1_ir_tests.rs
      pg3_snapshot_tests.rs
      pg4_diffop_tests.rs
      pg5_grid_diff_tests.rs
      pg6_object_vs_grid_tests.rs
      signature_tests.rs
      sparse_grid_tests.rs
      streaming_sink_tests.rs
      string_pool_tests.rs
  fixtures/
    manifest.yaml
    manifest_cli_tests.yaml
    pyproject.toml
    README.md
    requirements.txt
    src/
      __init__.py
      generate.py
      generators/
        __init__.py
        base.py
        corrupt.py
        database.py
        grid.py
        mashup.py
        objects.py
        perf.py
  fuzz/
    .gitignore
    Cargo.toml
    fuzz_targets/
      datamashup.rs
      diff_engine.rs
      open_workbook.rs
  ideas.md
  logs/
    2025-11-28b-diffop-pg4/
      activity_log.txt
  packaging/
    homebrew/
      excel-diff.rb.template
    scoop/
      excel-diff.json.template
  plan_review.md
  README.md
  related_files.txt.md
  scripts/
    check_perf_thresholds.py
    combine_results_to_csv.py
    compare_perf_results.py
    export_perf_metrics.py
    verify_release_versions.py
    visualize_benchmarks.py
  tmp/
    _release_test/
      excel-diff-v0.1.0-windows-x86_64.zip
      staging/
        excel-diff-v0.1.0-windows-x86_64/
          excel-diff.exe
          README.md
    openpyxl_sdist/
      et_xmlfile-2.0.0.tar.gz
      openpyxl-3.1.5/
        AUTHORS.rst
        LICENCE.rst
        MANIFEST.in
        openpyxl/
          __init__.py
          _constants.py
          cell/
            __init__.py
            _writer.py
            cell.py
            read_only.py
            rich_text.py
            text.py
          chart/
            _3d.py
            __init__.py
            _chart.py
            area_chart.py
            axis.py
            bar_chart.py
            bubble_chart.py
            chartspace.py
            data_source.py
            descriptors.py
            error_bar.py
            label.py
            layout.py
            legend.py
            line_chart.py
            marker.py
            picture.py
            pie_chart.py
            pivot.py
            plotarea.py
            print_settings.py
            radar_chart.py
            reader.py
            reference.py
            scatter_chart.py
            series.py
            series_factory.py
            shapes.py
            stock_chart.py
            surface_chart.py
            text.py
            title.py
            trendline.py
            updown_bars.py
          chartsheet/
            __init__.py
            chartsheet.py
            custom.py
            properties.py
            protection.py
            publish.py
            relation.py
            views.py
          comments/
            __init__.py
            author.py
            comment_sheet.py
            comments.py
            shape_writer.py
          compat/
            __init__.py
            abc.py
            numbers.py
            product.py
            singleton.py
            strings.py
          descriptors/
            __init__.py
            base.py
            container.py
            excel.py
            namespace.py
            nested.py
            sequence.py
            serialisable.py
            slots.py
          drawing/
            __init__.py
            colors.py
            connector.py
            drawing.py
            effect.py
            fill.py
            geometry.py
            graphic.py
            image.py
            line.py
            picture.py
            properties.py
            relation.py
            spreadsheet_drawing.py
            text.py
            xdr.py
          formatting/
            __init__.py
            formatting.py
            rule.py
          formula/
            __init__.py
            tokenizer.py
            translate.py
          packaging/
            __init__.py
            core.py
            custom.py
            extended.py
            interface.py
            manifest.py
            relationship.py
            workbook.py
          pivot/
            __init__.py
            cache.py
            fields.py
            record.py
            table.py
          reader/
            __init__.py
            drawings.py
            excel.py
            strings.py
            workbook.py
          styles/
            __init__.py
            alignment.py
            borders.py
            builtins.py
            cell_style.py
            colors.py
            differential.py
            fills.py
            fonts.py
            named_styles.py
            numbers.py
            protection.py
            proxy.py
            styleable.py
            stylesheet.py
            table.py
          utils/
            __init__.py
            bound_dictionary.py
            cell.py
            dataframe.py
            datetime.py
            escape.py
            exceptions.py
            formulas.py
            indexed_list.py
            inference.py
            protection.py
            units.py
          workbook/
            __init__.py
            _writer.py
            child.py
            defined_name.py
            external_link/
              __init__.py
              external.py
            external_reference.py
            function_group.py
            properties.py
            protection.py
            smart_tags.py
            views.py
            web.py
            workbook.py
          worksheet/
            __init__.py
            _read_only.py
            _reader.py
            _write_only.py
            _writer.py
            cell_range.py
            cell_watch.py
            controls.py
            copier.py
            custom.py
            datavalidation.py
            dimensions.py
            drawing.py
            errors.py
            filters.py
            formula.py
            header_footer.py
            hyperlink.py
            merge.py
            ole.py
            page.py
            pagebreak.py
            picture.py
            print_settings.py
            properties.py
            protection.py
            related.py
            scenario.py
            smart_tag.py
            table.py
            views.py
            worksheet.py
          writer/
            __init__.py
            excel.py
            theme.py
          xml/
            __init__.py
            constants.py
            functions.py
        PKG-INFO
        README.rst
        setup.cfg
        setup.py
      openpyxl-3.1.5.tar.gz
    xlsxwriter_old/
      XlsxWriter-1.4.5/
        Changes
        examples/
          array_formula.py
          autofilter.py
          autofilter_data.txt
          background.py
          cell_indentation.py
          chart.py
          chart_area.py
          chart_bar.py
          chart_clustered.py
          chart_column.py
          chart_combined.py
          chart_data_labels.py
          chart_data_table.py
          chart_data_tools.py
          chart_date_axis.py
          chart_doughnut.py
          chart_gauge.py
          chart_gradient.py
          chart_line.py
          chart_pareto.py
          chart_pattern.py
          chart_pie.py
          chart_radar.py
          chart_scatter.py
          chart_secondary_axis.py
          chart_stock.py
          chart_styles.py
          chartsheet.py
          check_close.py
          comments1.py
          comments2.py
          conditional_format.py
          context_manager.py
          data_validate.py
          datetimes.py
          defined_name.py
          demo.py
          diagonal_border.py
          django_simple.py
          doc_properties.py
          dynamic_arrays.py
          headers_footers.py
          hello_world.py
          hide_row_col.py
          hide_sheet.py
          http_server_py2.py
          http_server_py3.py
          hyperlink.py
          ignore_errors.py
          images.py
          images_bytesio.py
          inheritance1.py
          inheritance2.py
          lambda.py
          macros.py
          merge1.py
          merge_rich_string.py
          outline.py
          outline_collapsed.py
          pandas_autofilter.py
          pandas_chart.py
          pandas_chart_columns.py
          pandas_chart_line.py
          pandas_column_formats.py
          pandas_conditional_format.py
          pandas_datetime.py
          pandas_header_format.py
          pandas_multiple.py
          pandas_positioning.py
          pandas_simple.py
          pandas_table.py
          panes.py
          rich_strings.py
          right_to_left.py
          sparklines1.py
          sparklines2.py
          tab_colors.py
          tables.py
          text_indent.py
          textbox.py
          tutorial1.py
          tutorial2.py
          tutorial3.py
          unicode_polish_utf8.py
          unicode_polish_utf8.txt
          unicode_python2.py
          unicode_python3.py
          unicode_shift_jis.py
          unicode_shift_jis.txt
          user_types1.py
          user_types2.py
          user_types3.py
          vba_extract.py
          vbaProject.bin
          worksheet_protection.py
        LICENSE.txt
        MANIFEST.in
        PKG-INFO
        README.rst
        setup.cfg
        setup.py
        xlsxwriter/
          __init__.py
          app.py
          chart.py
          chart_area.py
          chart_bar.py
          chart_column.py
          chart_doughnut.py
          chart_line.py
          chart_pie.py
          chart_radar.py
          chart_scatter.py
          chart_stock.py
          chartsheet.py
          comments.py
          compatibility.py
          contenttypes.py
          core.py
          custom.py
          drawing.py
          exceptions.py
          format.py
          metadata.py
          packager.py
          relationships.py
          shape.py
          sharedstrings.py
          styles.py
          table.py
          theme.py
          utility.py
          vml.py
          workbook.py
          worksheet.py
          xmlwriter.py
      XlsxWriter-1.4.5.tar.gz
    xlsxwriter_sdist/
      XlsxWriter-3.2.0/
        Changes
        examples/
          array_formula.py
          autofilter.py
          autofilter_data.txt
          autofit.py
          background.py
          cell_indentation.py
          chart.py
          chart_area.py
          chart_bar.py
          chart_clustered.py
          chart_column.py
          chart_combined.py
          chart_data_labels.py
          chart_data_table.py
          chart_data_tools.py
          chart_date_axis.py
          chart_doughnut.py
          chart_gauge.py
          chart_gradient.py
          chart_line.py
          chart_pareto.py
          chart_pattern.py
          chart_pie.py
          chart_radar.py
          chart_scatter.py
          chart_secondary_axis.py
          chart_stock.py
          chart_styles.py
          chartsheet.py
          check_close.py
          comments1.py
          comments2.py
          conditional_format.py
          context_manager.py
          data_validate.py
          datetimes.py
          defined_name.py
          demo.py
          diagonal_border.py
          django_simple.py
          doc_properties.py
          dynamic_arrays.py
          embedded_images.py
          headers_footers.py
          hello_world.py
          hide_row_col.py
          hide_sheet.py
          http_server.py
          hyperlink.py
          ignore_errors.py
          images.py
          images_bytesio.py
          inheritance1.py
          inheritance2.py
          lambda.py
          macros.py
          merge1.py
          merge_rich_string.py
          outline.py
          outline_collapsed.py
          pandas_autofilter.py
          pandas_chart.py
          pandas_chart_columns.py
          pandas_chart_line.py
          pandas_column_formats.py
          pandas_conditional_format.py
          pandas_datetime.py
          pandas_header_format.py
          pandas_multiple.py
          pandas_percentage.py
          pandas_positioning.py
          pandas_simple.py
          pandas_table.py
          panes.py
          polars_chart.py
          polars_conditional_format.py
          polars_format_custom.py
          polars_format_default.py
          polars_multiple.py
          polars_positioning.py
          polars_simple.py
          polars_sparklines.py
          polars_xlsxwriter.py
          rich_strings.py
          right_to_left.py
          sparklines1.py
          sparklines2.py
          tab_colors.py
          tables.py
          text_indent.py
          textbox.py
          tutorial1.py
          tutorial2.py
          tutorial3.py
          unicode.py
          unicode_polish_utf8.py
          unicode_polish_utf8.txt
          unicode_shift_jis.py
          unicode_shift_jis.txt
          user_types1.py
          user_types2.py
          user_types3.py
          vba_extract.py
          vbaProject.bin
          watermark.py
          worksheet_protection.py
        LICENSE.txt
        MANIFEST.in
        PKG-INFO
        README.rst
        setup.cfg
        setup.py
        xlsxwriter/
          __init__.py
          app.py
          chart.py
          chart_area.py
          chart_bar.py
          chart_column.py
          chart_doughnut.py
          chart_line.py
          chart_pie.py
          chart_radar.py
          chart_scatter.py
          chart_stock.py
          chartsheet.py
          comments.py
          contenttypes.py
          core.py
          custom.py
          drawing.py
          exceptions.py
          format.py
          metadata.py
          packager.py
          relationships.py
          rich_value.py
          rich_value_rel.py
          rich_value_structure.py
          rich_value_types.py
          shape.py
          sharedstrings.py
          styles.py
          table.py
          theme.py
          utility.py
          vml.py
          workbook.py
          worksheet.py
          xmlwriter.py
      XlsxWriter-3.2.0.tar.gz
  wasm/
    Cargo.toml
    src/
      lib.rs
  web/
    index.html
    main.js
```

## File Contents

### File: `.github\workflows\ci.yml`

```yaml
name: CI

on:
  push:
  pull_request:

jobs:
  test:
    runs-on: ubuntu-latest

    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Install Rust
        uses: dtolnay/rust-toolchain@stable
        with:
          components: clippy

      - name: Install Python
        uses: actions/setup-python@v5
        with:
          python-version: "3.11"

      - name: Install fixture generator
        run: python -m pip install -e fixtures

      - name: Generate test fixtures
        run: generate-fixtures --manifest fixtures/manifest_cli_tests.yaml --force

      - name: Run tests
        run: cargo test --workspace

      - name: Build examples
        run: cargo build --workspace --examples

      - name: Run clippy (deny unwrap/expect)
        run: cargo clippy --workspace -- -D clippy::unwrap_used -D clippy::expect_used


```

---

### File: `.github\workflows\pages.yml`

```yaml
name: Deploy Web Demo

on:
  push:
    branches: [main, master]
  workflow_dispatch:

permissions:
  contents: read
  pages: write
  id-token: write

concurrency:
  group: "pages"
  cancel-in-progress: false

jobs:
  build:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4

      - name: Install Rust
        uses: dtolnay/rust-toolchain@stable
        with:
          targets: wasm32-unknown-unknown

      - name: Install wasm-pack
        run: curl https://rustwasm.github.io/wasm-pack/installer/init.sh -sSf | sh

      - name: Build WASM package
        run: wasm-pack build wasm --release --target web --out-dir ../web/wasm

      - name: Setup Pages
        uses: actions/configure-pages@v4

      - name: Upload artifact
        uses: actions/upload-pages-artifact@v3
        with:
          path: 'web'

  deploy:
    environment:
      name: github-pages
      url: ${{ steps.deployment.outputs.page_url }}
    runs-on: ubuntu-latest
    needs: build
    steps:
      - name: Deploy to GitHub Pages
        id: deployment
        uses: actions/deploy-pages@v4


```

---

### File: `.github\workflows\perf.yml`

```yaml
name: Performance Regression

on:
  push:
    branches: [main, master]
  pull_request:
    branches: [main, master]

jobs:
  perf-regression:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4
      
      - name: Install Rust
        uses: dtolnay/rust-action@stable
        
      - name: Build with perf metrics
        run: cargo build --release --features perf-metrics
        working-directory: core
        
      - name: Run perf test suite
        run: cargo test --release --features perf-metrics perf_ -- --nocapture
        working-directory: core
        
      - name: Set up Python
        uses: actions/setup-python@v5
        with:
          python-version: '3.11'
          
      - name: Check perf thresholds
        run: python scripts/check_perf_thresholds.py


```

---

### File: `.github\workflows\release.yml`

```yaml
name: Release

on:
  push:
    tags:
      - 'v*'
  workflow_dispatch:
    inputs:
      dry_run:
        description: 'Dry run (do not create release)'
        required: false
        default: 'true'
        type: boolean

env:
  CARGO_TERM_COLOR: always

jobs:
  validate-release:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4

      - name: Verify tag matches crate versions
        run: python3 scripts/verify_release_versions.py

  build-windows:
    needs: validate-release
    runs-on: windows-latest
    steps:
      - uses: actions/checkout@v4

      - name: Install Rust
        uses: dtolnay/rust-toolchain@stable

      - name: Build release binary
        run: cargo build --release --locked -p excel_diff_cli

      - name: Get version
        id: version
        shell: bash
        run: |
          if [[ "${{ github.ref }}" == refs/tags/v* ]]; then
            echo "version=${GITHUB_REF#refs/tags/}" >> $GITHUB_OUTPUT
          else
            echo "version=v0.0.0-dev" >> $GITHUB_OUTPUT
          fi

      - name: Create standalone EXE
        shell: bash
        run: |
          cp target/release/excel-diff.exe excel-diff-${{ steps.version.outputs.version }}-windows-x86_64.exe

      - name: Create package directory
        shell: bash
        run: |
          mkdir -p staging/excel-diff-${{ steps.version.outputs.version }}-windows-x86_64
          cp target/release/excel-diff.exe staging/excel-diff-${{ steps.version.outputs.version }}-windows-x86_64/
          cp README.md staging/excel-diff-${{ steps.version.outputs.version }}-windows-x86_64/

      - name: Create ZIP archive
        shell: pwsh
        run: |
          Compress-Archive -Path staging/excel-diff-${{ steps.version.outputs.version }}-windows-x86_64 -DestinationPath excel-diff-${{ steps.version.outputs.version }}-windows-x86_64.zip

      - name: Compute SHA256
        shell: bash
        run: |
          sha256sum excel-diff-${{ steps.version.outputs.version }}-windows-x86_64.zip > excel-diff-${{ steps.version.outputs.version }}-windows-x86_64.zip.sha256
          sha256sum excel-diff-${{ steps.version.outputs.version }}-windows-x86_64.exe > excel-diff-${{ steps.version.outputs.version }}-windows-x86_64.exe.sha256

      - name: Upload artifact
        uses: actions/upload-artifact@v4
        with:
          name: windows-x86_64
          path: |
            excel-diff-${{ steps.version.outputs.version }}-windows-x86_64.exe
            excel-diff-${{ steps.version.outputs.version }}-windows-x86_64.exe.sha256
            excel-diff-${{ steps.version.outputs.version }}-windows-x86_64.zip
            excel-diff-${{ steps.version.outputs.version }}-windows-x86_64.zip.sha256

  build-macos-x64:
    needs: validate-release
    runs-on: macos-13
    steps:
      - uses: actions/checkout@v4

      - name: Install Rust
        uses: dtolnay/rust-toolchain@stable

      - name: Build release binary
        run: cargo build --release --locked -p excel_diff_cli

      - name: Get version
        id: version
        run: |
          if [[ "${{ github.ref }}" == refs/tags/v* ]]; then
            echo "version=${GITHUB_REF#refs/tags/}" >> $GITHUB_OUTPUT
          else
            echo "version=v0.0.0-dev" >> $GITHUB_OUTPUT
          fi

      - name: Create tarball
        run: |
          mkdir -p staging
          cp target/release/excel-diff staging/
          cp README.md staging/
          tar -czvf excel-diff-${{ steps.version.outputs.version }}-macos-x86_64.tar.gz -C staging .

      - name: Compute SHA256
        run: |
          shasum -a 256 excel-diff-${{ steps.version.outputs.version }}-macos-x86_64.tar.gz > excel-diff-${{ steps.version.outputs.version }}-macos-x86_64.tar.gz.sha256

      - name: Upload artifact
        uses: actions/upload-artifact@v4
        with:
          name: macos-x86_64
          path: |
            excel-diff-${{ steps.version.outputs.version }}-macos-x86_64.tar.gz
            excel-diff-${{ steps.version.outputs.version }}-macos-x86_64.tar.gz.sha256

      - name: Upload raw binary for universal
        uses: actions/upload-artifact@v4
        with:
          name: macos-x86_64-binary
          path: target/release/excel-diff

  build-macos-arm64:
    needs: validate-release
    runs-on: macos-14
    steps:
      - uses: actions/checkout@v4

      - name: Install Rust
        uses: dtolnay/rust-toolchain@stable

      - name: Build release binary
        run: cargo build --release --locked -p excel_diff_cli

      - name: Get version
        id: version
        run: |
          if [[ "${{ github.ref }}" == refs/tags/v* ]]; then
            echo "version=${GITHUB_REF#refs/tags/}" >> $GITHUB_OUTPUT
          else
            echo "version=v0.0.0-dev" >> $GITHUB_OUTPUT
          fi

      - name: Create tarball
        run: |
          mkdir -p staging
          cp target/release/excel-diff staging/
          cp README.md staging/
          tar -czvf excel-diff-${{ steps.version.outputs.version }}-macos-arm64.tar.gz -C staging .

      - name: Compute SHA256
        run: |
          shasum -a 256 excel-diff-${{ steps.version.outputs.version }}-macos-arm64.tar.gz > excel-diff-${{ steps.version.outputs.version }}-macos-arm64.tar.gz.sha256

      - name: Upload artifact
        uses: actions/upload-artifact@v4
        with:
          name: macos-arm64
          path: |
            excel-diff-${{ steps.version.outputs.version }}-macos-arm64.tar.gz
            excel-diff-${{ steps.version.outputs.version }}-macos-arm64.tar.gz.sha256

      - name: Upload raw binary for universal
        uses: actions/upload-artifact@v4
        with:
          name: macos-arm64-binary
          path: target/release/excel-diff

  build-macos-universal:
    runs-on: macos-14
    needs: [build-macos-x64, build-macos-arm64]
    steps:
      - uses: actions/checkout@v4

      - name: Get version
        id: version
        run: |
          if [[ "${{ github.ref }}" == refs/tags/v* ]]; then
            echo "version=${GITHUB_REF#refs/tags/}" >> $GITHUB_OUTPUT
          else
            echo "version=v0.0.0-dev" >> $GITHUB_OUTPUT
          fi

      - name: Download x86_64 binary
        uses: actions/download-artifact@v4
        with:
          name: macos-x86_64-binary
          path: x86_64

      - name: Download arm64 binary
        uses: actions/download-artifact@v4
        with:
          name: macos-arm64-binary
          path: arm64

      - name: Create universal binary
        run: |
          lipo -create x86_64/excel-diff arm64/excel-diff -output excel-diff
          file excel-diff
          codesign -s - excel-diff

      - name: Create tarball
        run: |
          mkdir -p staging
          cp excel-diff staging/
          cp README.md staging/
          tar -czvf excel-diff-${{ steps.version.outputs.version }}-macos-universal.tar.gz -C staging .

      - name: Compute SHA256
        run: |
          shasum -a 256 excel-diff-${{ steps.version.outputs.version }}-macos-universal.tar.gz > excel-diff-${{ steps.version.outputs.version }}-macos-universal.tar.gz.sha256
          cat excel-diff-${{ steps.version.outputs.version }}-macos-universal.tar.gz.sha256

      - name: Upload artifact
        uses: actions/upload-artifact@v4
        with:
          name: macos-universal
          path: |
            excel-diff-${{ steps.version.outputs.version }}-macos-universal.tar.gz
            excel-diff-${{ steps.version.outputs.version }}-macos-universal.tar.gz.sha256

  smoke-macos-sequoia:
    name: Smoke Test (macOS Sequoia)
    runs-on: macos-15
    needs: [build-macos-universal]
    steps:
      - uses: actions/checkout@v4

      - name: Download macOS universal artifact
        uses: actions/download-artifact@v4
        with:
          name: macos-universal
          path: artifacts/macos

      - name: Run smoke checks
        run: |
          set -euo pipefail

          TARBALL=$(ls artifacts/macos/excel-diff-*-macos-universal.tar.gz | head -n 1)
          mkdir -p staging
          tar -xzf "$TARBALL" -C staging
          chmod +x staging/excel-diff

          staging/excel-diff --version
          staging/excel-diff --help >/dev/null
          staging/excel-diff diff fixtures/generated/minimal.xlsx fixtures/generated/minimal.xlsx --format json >/dev/null

          set +e
          staging/excel-diff diff fixtures/generated/col_append_right_a.xlsx fixtures/generated/col_append_right_b.xlsx >/dev/null
          STATUS=$?
          set -e
          if [ "$STATUS" -ne 1 ]; then
            echo "Expected exit code 1 for differing files, got $STATUS"
            exit 1
          fi

  generate-manifests:
    runs-on: ubuntu-latest
    needs: [build-windows, build-macos-universal]
    steps:
      - uses: actions/checkout@v4

      - name: Get version
        id: version
        run: |
          if [[ "${{ github.ref }}" == refs/tags/v* ]]; then
            VERSION=${GITHUB_REF#refs/tags/}
            echo "version=$VERSION" >> $GITHUB_OUTPUT
            echo "version_num=${VERSION#v}" >> $GITHUB_OUTPUT
          else
            echo "version=v0.0.0-dev" >> $GITHUB_OUTPUT
            echo "version_num=0.0.0-dev" >> $GITHUB_OUTPUT
          fi

      - name: Download Windows artifact
        uses: actions/download-artifact@v4
        with:
          name: windows-x86_64
          path: artifacts/windows

      - name: Download macOS universal artifact
        uses: actions/download-artifact@v4
        with:
          name: macos-universal
          path: artifacts/macos

      - name: Extract checksums
        id: checksums
        run: |
          WINDOWS_SHA=$(cat artifacts/windows/*.zip.sha256 | awk '{print $1}')
          MACOS_SHA=$(cat artifacts/macos/*.tar.gz.sha256 | awk '{print $1}')
          echo "windows_sha=$WINDOWS_SHA" >> $GITHUB_OUTPUT
          echo "macos_sha=$MACOS_SHA" >> $GITHUB_OUTPUT

      - name: Generate Scoop manifest
        run: |
          cat > excel-diff.json << EOF
          {
            "version": "${{ steps.version.outputs.version_num }}",
            "description": "A tool for comparing Excel workbooks",
            "homepage": "https://github.com/dvora/excel_diff",
            "license": "MIT",
            "architecture": {
              "64bit": {
                "url": "https://github.com/dvora/excel_diff/releases/download/${{ steps.version.outputs.version }}/excel-diff-${{ steps.version.outputs.version }}-windows-x86_64.zip",
                "hash": "${{ steps.checksums.outputs.windows_sha }}"
              }
            },
            "bin": "excel-diff-${{ steps.version.outputs.version }}-windows-x86_64/excel-diff.exe",
            "checkver": "github",
            "autoupdate": {
              "architecture": {
                "64bit": {
                  "url": "https://github.com/dvora/excel_diff/releases/download/v\$version/excel-diff-v\$version-windows-x86_64.zip"
                }
              }
            }
          }
          EOF

      - name: Generate Homebrew formula
        run: |
          cat > excel-diff.rb << 'EOF'
          class ExcelDiff < Formula
            desc "A tool for comparing Excel workbooks"
            homepage "https://github.com/dvora/excel_diff"
            version "${{ steps.version.outputs.version_num }}"
            license "MIT"

            on_macos do
              url "https://github.com/dvora/excel_diff/releases/download/${{ steps.version.outputs.version }}/excel-diff-${{ steps.version.outputs.version }}-macos-universal.tar.gz"
              sha256 "${{ steps.checksums.outputs.macos_sha }}"
            end

            def install
              bin.install "excel-diff"
            end

            test do
              system "#{bin}/excel-diff", "--version"
            end
          end
          EOF

      - name: Upload manifests
        uses: actions/upload-artifact@v4
        with:
          name: manifests
          path: |
            excel-diff.json
            excel-diff.rb

  publish-release:
    runs-on: ubuntu-latest
    needs:
      - build-windows
      - build-macos-x64
      - build-macos-arm64
      - build-macos-universal
      - smoke-macos-sequoia
      - generate-manifests
    if: startsWith(github.ref, 'refs/tags/v') && github.event.inputs.dry_run != 'true'
    permissions:
      contents: write
    steps:
      - name: Get version
        id: version
        run: echo "version=${GITHUB_REF#refs/tags/}" >> $GITHUB_OUTPUT

      - name: Download all artifacts
        uses: actions/download-artifact@v4
        with:
          path: artifacts

      - name: Create checksums file
        run: |
          cd artifacts
          cat windows-x86_64/*.sha256 >> checksums.txt
          cat macos-x86_64/*.sha256 >> checksums.txt
          cat macos-arm64/*.sha256 >> checksums.txt
          cat macos-universal/*.sha256 >> checksums.txt

      - name: Create GitHub Release
        uses: softprops/action-gh-release@v1
        with:
          name: ${{ steps.version.outputs.version }}
          draft: false
          prerelease: ${{ contains(steps.version.outputs.version, '-') }}
          files: |
            artifacts/windows-x86_64/excel-diff-*.exe
            artifacts/windows-x86_64/excel-diff-*.zip
            artifacts/macos-x86_64/excel-diff-*.tar.gz
            artifacts/macos-arm64/excel-diff-*.tar.gz
            artifacts/macos-universal/excel-diff-*.tar.gz
            artifacts/manifests/excel-diff.json
            artifacts/manifests/excel-diff.rb
            artifacts/checksums.txt
          body: |
            ## Installation

            ### Windows
            Download the standalone `.exe` (or the ZIP) and add it to your PATH.

            Or use Scoop (manifest from this Release):
            ```powershell
            # 1) Download `excel-diff.json` from the Release assets
            # 2) Install:
            scoop install .\excel-diff.json

            # Or, if you publish a Scoop bucket:
            # scoop bucket add excel-diff https://github.com/dvora/scoop-excel-diff
            # scoop install excel-diff
            ```

            ### macOS
            Using Homebrew (formula from this Release):
            ```bash
            curl -LO https://github.com/dvora/excel_diff/releases/download/${{ steps.version.outputs.version }}/excel-diff.rb
            brew install --formula ./excel-diff.rb

            # Or, if you publish a Homebrew tap:
            # brew tap dvora/excel-diff
            # brew install excel-diff
            ```

            Or download the universal binary:
            ```bash
            curl -LO https://github.com/dvora/excel_diff/releases/download/${{ steps.version.outputs.version }}/excel-diff-${{ steps.version.outputs.version }}-macos-universal.tar.gz
            tar -xzf excel-diff-${{ steps.version.outputs.version }}-macos-universal.tar.gz
            sudo mv excel-diff /usr/local/bin/
            ```

            ### Web Demo
            Try it in your browser at https://dvora.github.io/excel_diff

            ## Checksums
            See `checksums.txt` for SHA256 hashes of all artifacts.


```

---

### File: `.github\workflows\wasm.yml`

```yaml
name: WASM Smoke

on:
  push:
    branches: [main, master]
  pull_request:
    branches: [main, master]

jobs:
  wasm-smoke:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4

      - name: Install Rust
        uses: dtolnay/rust-toolchain@stable
        with:
          targets: wasm32-unknown-unknown

      - name: Build wasm smoke binary
        run: cargo build --release --target wasm32-unknown-unknown --no-default-features -p excel_diff --bin wasm_smoke
        working-directory: core

      - name: Enforce wasm size budget
        run: |
          SIZE=$(stat -c%s "core/target/wasm32-unknown-unknown/release/wasm_smoke.wasm")
          echo "wasm_smoke.wasm size: $SIZE bytes"
          if [ "$SIZE" -gt 5000000 ]; then
            echo "WASM size $SIZE exceeds 5MB limit"
            exit 1
          fi

  wasm-web-demo:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4

      - name: Install Rust
        uses: dtolnay/rust-toolchain@stable
        with:
          targets: wasm32-unknown-unknown

      - name: Install wasm-pack
        run: curl https://rustwasm.github.io/wasm-pack/installer/init.sh -sSf | sh

      - name: Build WASM package
        run: wasm-pack build wasm --release --target web --out-dir ../web/wasm

      - name: Enforce web demo size budget
        run: |
          SIZE=$(stat -c%s "web/wasm/excel_diff_wasm_bg.wasm")
          echo "excel_diff_wasm_bg.wasm size: $SIZE bytes"
          if [ "$SIZE" -gt 10000000 ]; then
            echo "Web demo WASM size $SIZE exceeds 10MB limit"
            exit 1
          fi

```

---

### File: `.gitignore`

```
# Rust
target/
**/target/
**/*.rs.bk

# Python
__pycache__/
**/__pycache__/
.venv/
*.pyc
*.egg-info/

# Shared Generated Data
fixtures/generated/*.xlsx
fixtures/generated/*.pbix
fixtures/generated/*.zip
fixtures/generated/*.csv
fixtures/generated/*.xlsm


# Docs
docs/meta/completion_estimates/

# WASM build output
web/wasm/

```

---

### File: `Cargo.toml`

```toml
[workspace]
members = ["core", "cli", "wasm"]
resolver = "2"

```

---

### File: `cli\Cargo.toml`

```toml
[package]
name = "excel_diff_cli"
version = "0.1.0"
edition = "2024"
description = "Command-line interface for comparing Excel workbooks"
license = "MIT"
repository = "https://github.com/dvora/excel_diff"
homepage = "https://github.com/dvora/excel_diff"

[[bin]]
name = "excel-diff"
path = "src/main.rs"
doc = false

[dependencies]
excel_diff = { path = "../core" }
clap = { version = "4.4", features = ["derive"] }
serde_json = "1.0"
anyhow = "1.0"

[dev-dependencies]
serde_json = "1.0"
tempfile = "3"


```

---

### File: `cli\src\commands\diff.rs`

```rust
use crate::output::{git_diff, json, text};
use crate::OutputFormat;
use anyhow::{Context, Result, bail};
use excel_diff::{
    DiffConfig, DiffReport, Grid, JsonLinesSink, WorkbookPackage,
    ProgressCallback, index_to_address, suggest_key_columns, with_default_session,
};
use std::fs::File;
use std::io::{self, BufWriter, IsTerminal, Write};
use std::process::ExitCode;
use std::sync::Mutex;

#[derive(Clone, Copy, PartialEq, Eq)]
pub enum Verbosity {
    Quiet,
    Normal,
    Verbose,
}

#[allow(clippy::too_many_arguments)]
pub fn run(
    old_path: &str,
    new_path: &str,
    format: OutputFormat,
    git_diff_mode: bool,
    fast: bool,
    precise: bool,
    quiet: bool,
    verbose: bool,
    database: bool,
    sheet: Option<String>,
    keys: Option<String>,
    auto_keys: bool,
    progress: bool,
    max_memory: Option<u32>,
    timeout: Option<u32>,
) -> Result<ExitCode> {
    if fast && precise {
        bail!("Cannot use both --fast and --precise flags together");
    }

    if git_diff_mode && (format == OutputFormat::Json || format == OutputFormat::Jsonl) {
        bail!("Cannot use --git-diff with --format=json or --format=jsonl");
    }

    if !database && (sheet.is_some() || keys.is_some() || auto_keys) {
        bail!("--sheet, --keys, and --auto-keys require --database flag");
    }

    if database && keys.is_none() && !auto_keys {
        bail!("Database mode requires either --keys or --auto-keys");
    }

    if database && keys.is_some() && auto_keys {
        bail!("Cannot use both --keys and --auto-keys together");
    }

    let verbosity = if quiet {
        Verbosity::Quiet
    } else if verbose {
        Verbosity::Verbose
    } else {
        Verbosity::Normal
    };

    let mut config = build_config(fast, precise);
    config.max_memory_mb = max_memory;
    config.timeout_seconds = timeout;

    let old_file = File::open(old_path)
        .with_context(|| format!("Failed to open old workbook: {}", old_path))?;
    let new_file = File::open(new_path)
        .with_context(|| format!("Failed to open new workbook: {}", new_path))?;

    let old_pkg = WorkbookPackage::open(old_file)
        .with_context(|| format!("Failed to parse old workbook: {}", old_path))?;
    let new_pkg = WorkbookPackage::open(new_file)
        .with_context(|| format!("Failed to parse new workbook: {}", new_path))?;

    if database {
        return run_database_mode(
            &old_pkg,
            &new_pkg,
            old_path,
            new_path,
            format,
            git_diff_mode,
            &config,
            verbosity,
            sheet,
            keys,
            auto_keys,
        );
    }

    let progress = progress.then(CliProgress::new);

    if format == OutputFormat::Jsonl && !git_diff_mode {
        return run_streaming(&old_pkg, &new_pkg, &config, progress.as_ref());
    }

    let report = match progress.as_ref() {
        Some(p) => old_pkg.diff_with_progress(&new_pkg, &config, p),
        None => old_pkg.diff(&new_pkg, &config),
    };

    if let Some(p) = progress.as_ref() {
        p.finish();
    }

    print_warnings_to_stderr(&report);

    let stdout = io::stdout();
    let mut handle = stdout.lock();

    if git_diff_mode {
        git_diff::write_git_diff(&mut handle, &report, old_path, new_path)?;
    } else {
        match format {
            OutputFormat::Text => {
                text::write_text_report(&mut handle, &report, old_path, new_path, verbosity)?;
            }
            OutputFormat::Json => {
                json::write_json_report(&mut handle, &report)?;
            }
            OutputFormat::Jsonl => {
                bail!("Internal error: JSONL format should be handled by the streaming path");
            }
        }
    }

    Ok(exit_code_from_report(&report))
}

fn run_streaming(
    old_pkg: &WorkbookPackage,
    new_pkg: &WorkbookPackage,
    config: &DiffConfig,
    progress: Option<&CliProgress>,
) -> Result<ExitCode> {
    let stdout = io::stdout();
    let handle = stdout.lock();
    let mut writer = BufWriter::new(handle);
    let mut sink = JsonLinesSink::new(&mut writer);

    let summary = match progress {
        Some(p) => old_pkg
            .diff_streaming_with_progress(new_pkg, config, &mut sink, p)
            .context("Streaming diff failed")?,
        None => old_pkg
            .diff_streaming(new_pkg, config, &mut sink)
            .context("Streaming diff failed")?,
    };

    writer.flush()?;

    if let Some(p) = progress {
        p.finish();
    }

    for warning in &summary.warnings {
        eprintln!("Warning: {}", warning);
    }

    if summary.op_count == 0 && summary.complete {
        Ok(ExitCode::from(0))
    } else {
        Ok(ExitCode::from(1))
    }
}

struct CliProgress {
    state: Mutex<CliProgressState>,
}

struct CliProgressState {
    is_tty: bool,
    last_phase: String,
    last_percent: f32,
}

impl CliProgress {
    fn new() -> Self {
        Self {
            state: Mutex::new(CliProgressState {
                is_tty: io::stderr().is_terminal(),
                last_phase: String::new(),
                last_percent: -1.0,
            }),
        }
    }

    fn finish(&self) {
        let is_tty = self.lock_state().is_tty;
        if is_tty {
            let mut stderr = io::stderr().lock();
            let _ = writeln!(stderr);
        }
    }

    fn lock_state(&self) -> std::sync::MutexGuard<'_, CliProgressState> {
        match self.state.lock() {
            Ok(guard) => guard,
            Err(poisoned) => poisoned.into_inner(),
        }
    }

    fn render_bar(phase: &str, percent: f32) -> String {
        let pct = (percent.clamp(0.0, 1.0) * 100.0).clamp(0.0, 100.0);
        let width = 24usize;
        let filled = ((pct / 100.0) * width as f32).round() as usize;
        let filled = filled.min(width);
        let empty = width - filled;
        format!(
            "{:>14} [{}{}] {:>6.1}%",
            phase,
            "#".repeat(filled),
            "-".repeat(empty),
            pct
        )
    }
}

impl ProgressCallback for CliProgress {
    fn on_progress(&self, phase: &str, percent: f32) {
        let mut state = self.lock_state();

        if state.is_tty {
            let line = Self::render_bar(phase, percent);
            let mut stderr = io::stderr().lock();
            let _ = write!(stderr, "\r{}", line);
            let _ = stderr.flush();
        } else {
            let phase_changed = state.last_phase != phase;
            let pct = percent.clamp(0.0, 1.0);
            let emit = phase_changed || pct == 0.0 || pct == 1.0 || (pct - state.last_percent) >= 0.25;
            if emit {
                eprintln!("Progress: {} {:.0}%", phase, pct * 100.0);
                state.last_phase = phase.to_string();
                state.last_percent = pct;
            }
        }
    }
}

#[allow(clippy::too_many_arguments)]
fn run_database_mode(
    old_pkg: &WorkbookPackage,
    new_pkg: &WorkbookPackage,
    old_path: &str,
    new_path: &str,
    format: OutputFormat,
    git_diff_mode: bool,
    config: &DiffConfig,
    verbosity: Verbosity,
    sheet: Option<String>,
    keys: Option<String>,
    auto_keys: bool,
) -> Result<ExitCode> {
    let sheet_name = determine_sheet_name(&old_pkg.workbook, &new_pkg.workbook, sheet)?;
    
    let key_columns = if let Some(keys_str) = keys {
        parse_key_columns(&keys_str)?
    } else if auto_keys {
        let grid = find_sheet_grid(&old_pkg.workbook, &sheet_name)?;
        let suggested = with_default_session(|session| {
            suggest_key_columns(grid, &session.strings)
        });
        if suggested.is_empty() {
            bail!("Could not auto-detect key columns for sheet '{}'. Please specify --keys manually.", sheet_name);
        }
        let col_letters: Vec<String> = suggested.iter().map(|&c| col_index_to_letters(c)).collect();
        eprintln!("Auto-detected key columns: {}", col_letters.join(","));
        suggested
    } else {
        bail!("Database mode requires either --keys or --auto-keys");
    };

    if format == OutputFormat::Jsonl && !git_diff_mode {
        return run_database_streaming(old_pkg, new_pkg, &sheet_name, &key_columns, config);
    }

    let report = old_pkg
        .diff_database_mode(new_pkg, &sheet_name, &key_columns, config)
        .context("Database mode diff failed")?;

    print_warnings_to_stderr(&report);
    print_fallback_suggestions(&report, auto_keys, &sheet_name, old_pkg);

    let stdout = io::stdout();
    let mut handle = stdout.lock();

    if git_diff_mode {
        git_diff::write_git_diff(&mut handle, &report, old_path, new_path)?;
    } else {
        match format {
            OutputFormat::Text => {
                text::write_text_report(&mut handle, &report, old_path, new_path, verbosity)?;
            }
            OutputFormat::Json => {
                json::write_json_report(&mut handle, &report)?;
            }
            OutputFormat::Jsonl => {
                bail!("Internal error: JSONL format should be handled by the streaming path");
            }
        }
    }

    Ok(exit_code_from_report(&report))
}

fn run_database_streaming(
    old_pkg: &WorkbookPackage,
    new_pkg: &WorkbookPackage,
    sheet_name: &str,
    key_columns: &[u32],
    config: &DiffConfig,
) -> Result<ExitCode> {
    let stdout = io::stdout();
    let handle = stdout.lock();
    let mut writer = BufWriter::new(handle);
    let mut sink = JsonLinesSink::new(&mut writer);

    let summary = old_pkg
        .diff_database_mode_streaming(new_pkg, sheet_name, key_columns, config, &mut sink)
        .context("Database mode streaming diff failed")?;

    writer.flush()?;

    for warning in &summary.warnings {
        eprintln!("Warning: {}", warning);
    }

    if summary.op_count == 0 && summary.complete {
        Ok(ExitCode::from(0))
    } else {
        Ok(ExitCode::from(1))
    }
}

fn determine_sheet_name(
    old_wb: &excel_diff::Workbook,
    new_wb: &excel_diff::Workbook,
    sheet: Option<String>,
) -> Result<String> {
    if let Some(name) = sheet {
        return Ok(name);
    }

    let has_data_sheet = |wb: &excel_diff::Workbook| -> bool {
        with_default_session(|session| {
            wb.sheets.iter().any(|s| {
                session.strings.resolve(s.name).to_lowercase() == "data"
            })
        })
    };

    if has_data_sheet(old_wb) || has_data_sheet(new_wb) {
        return Ok("Data".to_string());
    }

    if old_wb.sheets.len() == 1 && new_wb.sheets.len() == 1 {
        let old_name = with_default_session(|session| {
            session.strings.resolve(old_wb.sheets[0].name).to_string()
        });
        return Ok(old_name);
    }

    bail!("Multiple sheets found; please specify --sheet")
}

fn find_sheet_grid<'a>(wb: &'a excel_diff::Workbook, sheet_name: &str) -> Result<&'a Grid> {
    let sheet_name_lower = sheet_name.to_lowercase();
    with_default_session(|session| {
        wb.sheets
            .iter()
            .find(|s| session.strings.resolve(s.name).to_lowercase() == sheet_name_lower)
            .map(|s| &s.grid)
            .ok_or_else(|| {
                let available: Vec<String> = wb
                    .sheets
                    .iter()
                    .map(|s| session.strings.resolve(s.name).to_string())
                    .collect();
                anyhow::anyhow!(
                    "Sheet '{}' not found. Available sheets: {}",
                    sheet_name,
                    available.join(", ")
                )
            })
    })
}

fn parse_key_columns(keys_str: &str) -> Result<Vec<u32>> {
    let mut result = Vec::new();
    let mut seen = std::collections::HashSet::new();

    for token in keys_str.split(',') {
        let token = token.trim();
        if token.is_empty() {
            bail!("Invalid --keys: empty column token in '{}'", keys_str);
        }
        if !token.chars().all(|c| c.is_ascii_alphabetic()) {
            bail!(
                "Invalid --keys: '{}' is not a valid column letter (must be letters only, e.g. A, B, AA)",
                token
            );
        }
        let col_idx = col_letters_to_index(token)?;
        if !seen.insert(col_idx) {
            bail!("Invalid --keys: duplicate column '{}'", token);
        }
        result.push(col_idx);
    }

    if result.is_empty() {
        bail!("Invalid --keys: no columns specified");
    }

    Ok(result)
}

fn col_letters_to_index(letters: &str) -> Result<u32> {
    let mut col: u32 = 0;
    for ch in letters.chars() {
        let upper = ch.to_ascii_uppercase();
        if !upper.is_ascii_uppercase() {
            bail!("Invalid column letter: '{}'", ch);
        }
        col = col
            .checked_mul(26)
            .and_then(|c| c.checked_add((upper as u8 - b'A' + 1) as u32))
            .ok_or_else(|| anyhow::anyhow!("Column '{}' is out of range", letters))?;
    }
    Ok(col.saturating_sub(1))
}

fn col_index_to_letters(col: u32) -> String {
    let addr = index_to_address(0, col);
    addr.trim_end_matches(|c: char| c.is_ascii_digit()).to_string()
}

fn print_fallback_suggestions(
    report: &DiffReport,
    auto_keys: bool,
    sheet_name: &str,
    old_pkg: &WorkbookPackage,
) {
    let has_fallback_warning = report.warnings.iter().any(|w| {
        w.contains("duplicate keys") && w.contains("falling back")
    });

    if has_fallback_warning && !auto_keys {
        if let Ok(grid) = find_sheet_grid(&old_pkg.workbook, sheet_name) {
            let suggested = with_default_session(|session| {
                suggest_key_columns(grid, &session.strings)
            });
            if !suggested.is_empty() {
                let col_letters: Vec<String> = suggested.iter().map(|&c| col_index_to_letters(c)).collect();
                eprintln!("Hint: try --keys={} for unique key columns", col_letters.join(","));
            }
        }
    }
}

fn build_config(fast: bool, precise: bool) -> DiffConfig {
    if fast {
        DiffConfig::fastest()
    } else if precise {
        DiffConfig::most_precise()
    } else {
        DiffConfig::default()
    }
}

fn print_warnings_to_stderr(report: &DiffReport) {
    for warning in &report.warnings {
        eprintln!("Warning: {}", warning);
    }
}

fn exit_code_from_report(report: &DiffReport) -> ExitCode {
    if report.ops.is_empty() && report.complete {
        ExitCode::from(0)
    } else {
        ExitCode::from(1)
    }
}


```

---

### File: `cli\src\commands\info.rs`

```rust
use anyhow::{Context, Result};
use excel_diff::{SheetKind, WorkbookPackage, build_queries};
use std::fs::File;
use std::io::{self, Write};
use std::path::Path;
use std::process::ExitCode;

pub fn run(path: &str, show_queries: bool) -> Result<ExitCode> {
    let file = File::open(path).with_context(|| format!("Failed to open workbook: {}", path))?;

    let pkg = WorkbookPackage::open(file)
        .with_context(|| format!("Failed to parse workbook: {}", path))?;

    let stdout = io::stdout();
    let mut handle = stdout.lock();

    let filename = Path::new(path)
        .file_name()
        .map(|s| s.to_string_lossy())
        .unwrap_or_else(|| path.into());

    writeln!(handle, "Workbook: {}", filename)?;
    writeln!(handle, "Sheets: {}", pkg.workbook.sheets.len())?;

    for sheet in &pkg.workbook.sheets {
        let name = excel_diff::with_default_session(|session| {
            session.strings.resolve(sheet.name).to_string()
        });
        let kind_str = match sheet.kind {
            SheetKind::Worksheet => "worksheet",
            SheetKind::Chart => "chart",
            SheetKind::Macro => "macro",
            SheetKind::Other => "other",
        };
        writeln!(
            handle,
            "  - \"{}\" ({}) {}x{}, {} cells",
            name,
            kind_str,
            sheet.grid.nrows,
            sheet.grid.ncols,
            sheet.grid.cell_count()
        )?;
    }

    if show_queries {
        writeln!(handle)?;
        match &pkg.data_mashup {
            None => {
                writeln!(handle, "Power Query: none")?;
            }
            Some(dm) => {
                match build_queries(dm) {
                    Ok(mut queries) => {
                        queries.sort_by(|a, b| a.name.cmp(&b.name));
                        writeln!(handle, "Power Query: {} queries", queries.len())?;
                        for query in &queries {
                            let load_flags = format_load_flags(&query.metadata);
                            let group = query
                                .metadata
                                .group_path
                                .as_deref()
                                .map(|g| format!(" [group: {}]", g))
                                .unwrap_or_default();
                            writeln!(handle, "  - \"{}\"{}{}", query.name, load_flags, group)?;
                        }
                    }
                    Err(e) => {
                        writeln!(handle, "Power Query: error parsing queries: {}", e)?;
                    }
                }
            }
        }
    }

    Ok(ExitCode::from(0))
}

fn format_load_flags(meta: &excel_diff::QueryMetadata) -> String {
    let mut flags = Vec::new();
    if meta.load_to_sheet {
        flags.push("sheet");
    }
    if meta.load_to_model {
        flags.push("model");
    }
    if meta.is_connection_only {
        flags.push("connection-only");
    }
    if flags.is_empty() {
        String::new()
    } else {
        format!(" ({})", flags.join(", "))
    }
}


```

---

### File: `cli\src\commands\mod.rs`

```rust
pub mod diff;
pub mod info;


```

---

### File: `cli\src\main.rs`

```rust
mod commands;
mod output;

use clap::{Parser, Subcommand, ValueEnum};
use std::process::ExitCode;

#[derive(Parser)]
#[command(name = "excel-diff")]
#[command(about = "Compare Excel workbooks and show differences")]
#[command(version)]
pub struct Cli {
    #[command(subcommand)]
    pub command: Commands,
}

#[derive(Subcommand)]
pub enum Commands {
    #[command(about = "Compare two Excel workbooks")]
    Diff {
        #[arg(help = "Path to the old/base workbook")]
        old: String,
        #[arg(help = "Path to the new/changed workbook")]
        new: String,
        #[arg(long, short, value_enum, default_value = "text", help = "Output format")]
        format: OutputFormat,
        #[arg(long, help = "Produce unified diff-style output for Git")]
        git_diff: bool,
        #[arg(long, help = "Use fastest diff preset (less precise move detection)")]
        fast: bool,
        #[arg(long, help = "Use most precise diff preset (slower, more accurate)")]
        precise: bool,
        #[arg(long, short, help = "Quiet mode: only show summary")]
        quiet: bool,
        #[arg(long, short, help = "Verbose mode: show additional details")]
        verbose: bool,
        #[arg(long, help = "Use database mode: align rows by key columns")]
        database: bool,
        #[arg(long, help = "Sheet name to diff in database mode")]
        sheet: Option<String>,
        #[arg(long, help = "Key columns for database mode (comma-separated column letters, e.g. A,B,C)")]
        keys: Option<String>,
        #[arg(long, help = "Auto-detect key columns for database mode")]
        auto_keys: bool,
        #[arg(long, help = "Show a progress bar on stderr")]
        progress: bool,
        #[arg(long, value_name = "MB", help = "Soft memory budget (MB) for advanced strategies")]
        max_memory: Option<u32>,
        #[arg(long, value_name = "SECONDS", help = "Abort diff after this many seconds")]
        timeout: Option<u32>,
    },
    #[command(about = "Show information about a workbook")]
    Info {
        #[arg(help = "Path to the workbook")]
        path: String,
        #[arg(long, help = "Include Power Query information")]
        queries: bool,
    },
}

#[derive(Clone, Copy, ValueEnum, PartialEq, Eq)]
pub enum OutputFormat {
    Text,
    Json,
    Jsonl,
}

fn main() -> ExitCode {
    let cli = Cli::parse();

    let result = match cli.command {
        Commands::Diff {
            old,
            new,
            format,
            git_diff,
            fast,
            precise,
            quiet,
            verbose,
            database,
            sheet,
            keys,
            auto_keys,
            progress,
            max_memory,
            timeout,
        } => commands::diff::run(
            &old,
            &new,
            format,
            git_diff,
            fast,
            precise,
            quiet,
            verbose,
            database,
            sheet,
            keys,
            auto_keys,
            progress,
            max_memory,
            timeout,
        ),
        Commands::Info { path, queries } => commands::info::run(&path, queries),
    };

    match result {
        Ok(code) => code,
        Err(e) => {
            eprintln!("Error: {:#}", e);
            ExitCode::from(2)
        }
    }
}


```

---

### File: `cli\src\output\git_diff.rs`

```rust
use anyhow::Result;
use excel_diff::{
    CellValue, DiffOp, DiffReport, QueryChangeKind, QueryMetadataField, index_to_address,
};
use std::collections::BTreeMap;
use std::io::Write;

pub fn write_git_diff<W: Write>(
    w: &mut W,
    report: &DiffReport,
    old_path: &str,
    new_path: &str,
) -> Result<()> {
    writeln!(w, "diff --git a/{} b/{}", old_path, new_path)?;
    writeln!(w, "--- a/{}", old_path)?;
    writeln!(w, "+++ b/{}", new_path)?;

    if report.ops.is_empty() {
        writeln!(w, "@@ No differences @@")?;
        return Ok(());
    }

    let (workbook_ops, sheet_ops, m_ops) = partition_ops(report);

    if !workbook_ops.is_empty() {
        writeln!(w, "@@ Workbook @@")?;
        for op in &workbook_ops {
            write_op_diff_lines(w, report, op)?;
        }
    }

    for (sheet_name, ops) in &sheet_ops {
        writeln!(w, "@@ Sheet \"{}\" @@", sheet_name)?;
        for op in ops {
            write_op_diff_lines(w, report, op)?;
        }
    }

    if !m_ops.is_empty() {
        writeln!(w, "@@ Power Query @@")?;
        for op in &m_ops {
            write_op_diff_lines(w, report, op)?;
        }
    }

    Ok(())
}

fn partition_ops(
    report: &DiffReport,
) -> (Vec<&DiffOp>, BTreeMap<String, Vec<&DiffOp>>, Vec<&DiffOp>) {
    let mut workbook_ops: Vec<&DiffOp> = Vec::new();
    let mut sheet_ops: BTreeMap<String, Vec<&DiffOp>> = BTreeMap::new();
    let mut m_ops: Vec<&DiffOp> = Vec::new();

    for op in &report.ops {
        if op.is_m_op() {
            m_ops.push(op);
        } else if let Some(sheet_id) = get_sheet_id(op) {
            let sheet_name = report
                .resolve(sheet_id)
                .unwrap_or("<unknown>")
                .to_string();
            sheet_ops.entry(sheet_name).or_default().push(op);
        } else {
            workbook_ops.push(op);
        }
    }

    (workbook_ops, sheet_ops, m_ops)
}

fn get_sheet_id(op: &DiffOp) -> Option<excel_diff::StringId> {
    match op {
        DiffOp::SheetAdded { sheet } => Some(*sheet),
        DiffOp::SheetRemoved { sheet } => Some(*sheet),
        DiffOp::RowAdded { sheet, .. } => Some(*sheet),
        DiffOp::RowRemoved { sheet, .. } => Some(*sheet),
        DiffOp::ColumnAdded { sheet, .. } => Some(*sheet),
        DiffOp::ColumnRemoved { sheet, .. } => Some(*sheet),
        DiffOp::BlockMovedRows { sheet, .. } => Some(*sheet),
        DiffOp::BlockMovedColumns { sheet, .. } => Some(*sheet),
        DiffOp::BlockMovedRect { sheet, .. } => Some(*sheet),
        DiffOp::CellEdited { sheet, .. } => Some(*sheet),
        DiffOp::ChartAdded { sheet, .. } => Some(*sheet),
        DiffOp::ChartRemoved { sheet, .. } => Some(*sheet),
        DiffOp::ChartChanged { sheet, .. } => Some(*sheet),
        _ => None,
    }
}

fn write_op_diff_lines<W: Write>(w: &mut W, report: &DiffReport, op: &DiffOp) -> Result<()> {
    match op {
        DiffOp::SheetAdded { sheet } => {
            writeln!(
                w,
                "+ Sheet \"{}\": ADDED",
                report.resolve(*sheet).unwrap_or("<unknown>")
            )?;
        }
        DiffOp::SheetRemoved { sheet } => {
            writeln!(
                w,
                "- Sheet \"{}\": REMOVED",
                report.resolve(*sheet).unwrap_or("<unknown>")
            )?;
        }
        DiffOp::RowAdded { row_idx, .. } => {
            writeln!(w, "+ Row {}: ADDED", row_idx + 1)?;
        }
        DiffOp::RowRemoved { row_idx, .. } => {
            writeln!(w, "- Row {}: REMOVED", row_idx + 1)?;
        }
        DiffOp::ColumnAdded { col_idx, .. } => {
            writeln!(w, "+ Column {}: ADDED", col_letter(*col_idx))?;
        }
        DiffOp::ColumnRemoved { col_idx, .. } => {
            writeln!(w, "- Column {}: REMOVED", col_letter(*col_idx))?;
        }
        DiffOp::BlockMovedRows {
            src_start_row,
            row_count,
            dst_start_row,
            ..
        } => {
            let src_end = src_start_row + row_count - 1;
            let dst_end = dst_start_row + row_count - 1;
            writeln!(
                w,
                "- Block: rows {}-{} (moved)",
                src_start_row + 1,
                src_end + 1
            )?;
            writeln!(
                w,
                "+ Block: rows {}-{} (moved)",
                dst_start_row + 1,
                dst_end + 1
            )?;
        }
        DiffOp::BlockMovedColumns {
            src_start_col,
            col_count,
            dst_start_col,
            ..
        } => {
            let src_end = src_start_col + col_count - 1;
            let dst_end = dst_start_col + col_count - 1;
            writeln!(
                w,
                "- Block: columns {}-{} (moved)",
                col_letter(*src_start_col),
                col_letter(src_end)
            )?;
            writeln!(
                w,
                "+ Block: columns {}-{} (moved)",
                col_letter(*dst_start_col),
                col_letter(dst_end)
            )?;
        }
        DiffOp::BlockMovedRect {
            src_start_row,
            src_row_count,
            src_start_col,
            src_col_count,
            dst_start_row,
            dst_start_col,
            ..
        } => {
            let src_range = format_range(
                *src_start_row,
                *src_start_col,
                *src_row_count,
                *src_col_count,
            );
            let dst_range = format_range(
                *dst_start_row,
                *dst_start_col,
                *src_row_count,
                *src_col_count,
            );
            writeln!(w, "- Block: {} (moved)", src_range)?;
            writeln!(w, "+ Block: {} (moved)", dst_range)?;
        }
        DiffOp::CellEdited {
            addr, from, to, ..
        } => {
            let old_str = format_cell_value(&from.value, report);
            let new_str = format_cell_value(&to.value, report);
            writeln!(w, "- Cell {}: {}", addr, old_str)?;
            writeln!(w, "+ Cell {}: {}", addr, new_str)?;
        }
        DiffOp::QueryAdded { name } => {
            writeln!(
                w,
                "+ Query \"{}\": ADDED",
                report.resolve(*name).unwrap_or("<unknown>")
            )?;
        }
        DiffOp::QueryRemoved { name } => {
            writeln!(
                w,
                "- Query \"{}\": REMOVED",
                report.resolve(*name).unwrap_or("<unknown>")
            )?;
        }
        DiffOp::QueryRenamed { from, to } => {
            writeln!(
                w,
                "- Query \"{}\"",
                report.resolve(*from).unwrap_or("<unknown>")
            )?;
            writeln!(
                w,
                "+ Query \"{}\" (renamed)",
                report.resolve(*to).unwrap_or("<unknown>")
            )?;
        }
        DiffOp::QueryDefinitionChanged {
            name, change_kind, ..
        } => {
            let kind_str = match change_kind {
                QueryChangeKind::Semantic => "semantic change",
                QueryChangeKind::FormattingOnly => "formatting only",
                QueryChangeKind::Renamed => "renamed",
            };
            writeln!(
                w,
                "~ Query \"{}\": definition changed ({})",
                report.resolve(*name).unwrap_or("<unknown>"),
                kind_str
            )?;
        }
        DiffOp::QueryMetadataChanged {
            name,
            field,
            old,
            new,
        } => {
            let field_name = match field {
                QueryMetadataField::LoadToSheet => "load_to_sheet",
                QueryMetadataField::LoadToModel => "load_to_model",
                QueryMetadataField::GroupPath => "group_path",
                QueryMetadataField::ConnectionOnly => "connection_only",
            };
            let old_str = old
                .map(|id| report.resolve(id).unwrap_or("<unknown>").to_string())
                .unwrap_or_else(|| "<none>".to_string());
            let new_str = new
                .map(|id| report.resolve(id).unwrap_or("<unknown>").to_string())
                .unwrap_or_else(|| "<none>".to_string());
            writeln!(
                w,
                "- Query \"{}\".{}: {}",
                report.resolve(*name).unwrap_or("<unknown>"),
                field_name,
                old_str
            )?;
            writeln!(
                w,
                "+ Query \"{}\".{}: {}",
                report.resolve(*name).unwrap_or("<unknown>"),
                field_name,
                new_str
            )?;
        }
        DiffOp::VbaModuleAdded { name } => {
            writeln!(
                w,
                "+ VBA module \"{}\": ADDED",
                report.resolve(*name).unwrap_or("<unknown>")
            )?;
        }
        DiffOp::VbaModuleRemoved { name } => {
            writeln!(
                w,
                "- VBA module \"{}\": REMOVED",
                report.resolve(*name).unwrap_or("<unknown>")
            )?;
        }
        DiffOp::VbaModuleChanged { name } => {
            writeln!(
                w,
                "~ VBA module \"{}\": CHANGED",
                report.resolve(*name).unwrap_or("<unknown>")
            )?;
        }
        DiffOp::NamedRangeAdded { name } => {
            writeln!(
                w,
                "+ Named range \"{}\": ADDED",
                report.resolve(*name).unwrap_or("<unknown>")
            )?;
        }
        DiffOp::NamedRangeRemoved { name } => {
            writeln!(
                w,
                "- Named range \"{}\": REMOVED",
                report.resolve(*name).unwrap_or("<unknown>")
            )?;
        }
        DiffOp::NamedRangeChanged {
            name,
            old_ref,
            new_ref,
        } => {
            writeln!(
                w,
                "- Named range \"{}\": {}",
                report.resolve(*name).unwrap_or("<unknown>"),
                report.resolve(*old_ref).unwrap_or("<unknown>")
            )?;
            writeln!(
                w,
                "+ Named range \"{}\": {}",
                report.resolve(*name).unwrap_or("<unknown>"),
                report.resolve(*new_ref).unwrap_or("<unknown>")
            )?;
        }
        DiffOp::ChartAdded { name, .. } => {
            writeln!(
                w,
                "+ Chart \"{}\": ADDED",
                report.resolve(*name).unwrap_or("<unknown>")
            )?;
        }
        DiffOp::ChartRemoved { name, .. } => {
            writeln!(
                w,
                "- Chart \"{}\": REMOVED",
                report.resolve(*name).unwrap_or("<unknown>")
            )?;
        }
        DiffOp::ChartChanged { name, .. } => {
            writeln!(
                w,
                "~ Chart \"{}\": CHANGED",
                report.resolve(*name).unwrap_or("<unknown>")
            )?;
        }
        _ => {
            writeln!(w, "~ {:?}", op)?;
        }
    }
    Ok(())
}

fn col_letter(col: u32) -> String {
    index_to_address(0, col)
        .chars()
        .take_while(|c| c.is_ascii_alphabetic())
        .collect()
}

fn format_range(start_row: u32, start_col: u32, row_count: u32, col_count: u32) -> String {
    let tl = index_to_address(start_row, start_col);
    let br = index_to_address(start_row + row_count - 1, start_col + col_count - 1);
    format!("{}:{}", tl, br)
}

fn format_cell_value(value: &Option<CellValue>, report: &DiffReport) -> String {
    match value {
        None => "<empty>".to_string(),
        Some(CellValue::Blank) => "<blank>".to_string(),
        Some(CellValue::Number(n)) => format_number(*n),
        Some(CellValue::Text(id)) => {
            let text = report.resolve(*id).unwrap_or("<unknown>");
            format!("\"{}\"", escape_string(text))
        }
        Some(CellValue::Bool(b)) => {
            if *b {
                "TRUE".to_string()
            } else {
                "FALSE".to_string()
            }
        }
        Some(CellValue::Error(id)) => report.resolve(*id).unwrap_or("#ERROR").to_string(),
    }
}

fn format_number(n: f64) -> String {
    if n.fract() == 0.0 && n.abs() < 1e15 {
        format!("{:.0}", n)
    } else {
        let s = format!("{:.10}", n);
        s.trim_end_matches('0').trim_end_matches('.').to_string()
    }
}

fn escape_string(s: &str) -> String {
    s.replace('\\', "\\\\")
        .replace('\n', "\\n")
        .replace('\r', "\\r")
        .replace('\t', "\\t")
        .replace('"', "\\\"")
}


```

---

### File: `cli\src\output\json.rs`

```rust
use anyhow::Result;
use excel_diff::DiffReport;
use std::io::Write;

pub fn write_json_report<W: Write>(w: &mut W, report: &DiffReport) -> Result<()> {
    serde_json::to_writer_pretty(&mut *w, report)?;
    writeln!(w)?;
    Ok(())
}


```

---

### File: `cli\src\output\mod.rs`

```rust
pub mod git_diff;
pub mod json;
pub mod text;


```

---

### File: `cli\src\output\text.rs`

```rust
use crate::commands::diff::Verbosity;
use anyhow::Result;
use excel_diff::{
    CellValue, DiffOp, DiffReport, QueryChangeKind, QueryMetadataField, StringId,
    index_to_address,
};
use std::collections::BTreeMap;
use std::io::Write;

pub fn write_text_report<W: Write>(
    w: &mut W,
    report: &DiffReport,
    old_path: &str,
    new_path: &str,
    verbosity: Verbosity,
) -> Result<()> {
    if verbosity != Verbosity::Quiet {
        let old_name = std::path::Path::new(old_path)
            .file_name()
            .map(|s| s.to_string_lossy())
            .unwrap_or_else(|| old_path.into());
        let new_name = std::path::Path::new(new_path)
            .file_name()
            .map(|s| s.to_string_lossy())
            .unwrap_or_else(|| new_path.into());
        writeln!(w, "Comparing: {} -> {}", old_name, new_name)?;
        writeln!(w)?;
    }

    if verbosity == Verbosity::Quiet {
        write_summary(w, report)?;
        return Ok(());
    }

    if report.ops.is_empty() {
        writeln!(w, "No differences found.")?;
        write_summary(w, report)?;
        return Ok(());
    }

    let (workbook_ops, sheet_ops, m_ops) = partition_ops(report);

    if !workbook_ops.is_empty() {
        writeln!(w, "Workbook:")?;
        for op in &workbook_ops {
            let lines = render_op(report, op, verbosity);
            for line in lines {
                writeln!(w, "  {}", line)?;
            }
        }
        writeln!(w)?;
    }

    for (sheet_name, ops) in &sheet_ops {
        writeln!(w, "Sheet \"{}\":", sheet_name)?;
        for op in ops {
            let lines = render_op(report, op, verbosity);
            for line in lines {
                writeln!(w, "  {}", line)?;
            }
        }
        writeln!(w)?;
    }

    if !m_ops.is_empty() {
        writeln!(w, "Power Query:")?;
        for op in &m_ops {
            let lines = render_op(report, op, verbosity);
            for line in lines {
                writeln!(w, "  {}", line)?;
            }
        }
        writeln!(w)?;
    }

    write_summary(w, report)?;
    Ok(())
}

fn partition_ops(
    report: &DiffReport,
) -> (Vec<&DiffOp>, BTreeMap<String, Vec<&DiffOp>>, Vec<&DiffOp>) {
    let mut workbook_ops: Vec<&DiffOp> = Vec::new();
    let mut sheet_ops: BTreeMap<String, Vec<&DiffOp>> = BTreeMap::new();
    let mut m_ops: Vec<&DiffOp> = Vec::new();

    for op in &report.ops {
        if op.is_m_op() {
            m_ops.push(op);
        } else if let Some(sheet_id) = get_sheet_id(op) {
            let sheet_name = report
                .resolve(sheet_id)
                .unwrap_or("<unknown>")
                .to_string();
            sheet_ops.entry(sheet_name).or_default().push(op);
        } else {
            workbook_ops.push(op);
        }
    }

    (workbook_ops, sheet_ops, m_ops)
}

fn get_sheet_id(op: &DiffOp) -> Option<StringId> {
    match op {
        DiffOp::SheetAdded { sheet } => Some(*sheet),
        DiffOp::SheetRemoved { sheet } => Some(*sheet),
        DiffOp::RowAdded { sheet, .. } => Some(*sheet),
        DiffOp::RowRemoved { sheet, .. } => Some(*sheet),
        DiffOp::ColumnAdded { sheet, .. } => Some(*sheet),
        DiffOp::ColumnRemoved { sheet, .. } => Some(*sheet),
        DiffOp::BlockMovedRows { sheet, .. } => Some(*sheet),
        DiffOp::BlockMovedColumns { sheet, .. } => Some(*sheet),
        DiffOp::BlockMovedRect { sheet, .. } => Some(*sheet),
        DiffOp::CellEdited { sheet, .. } => Some(*sheet),
        DiffOp::ChartAdded { sheet, .. } => Some(*sheet),
        DiffOp::ChartRemoved { sheet, .. } => Some(*sheet),
        DiffOp::ChartChanged { sheet, .. } => Some(*sheet),
        _ => None,
    }
}

fn render_op(report: &DiffReport, op: &DiffOp, verbosity: Verbosity) -> Vec<String> {
    match op {
        DiffOp::SheetAdded { sheet } => {
            vec![format!(
                "Sheet \"{}\": ADDED",
                report.resolve(*sheet).unwrap_or("<unknown>")
            )]
        }
        DiffOp::SheetRemoved { sheet } => {
            vec![format!(
                "Sheet \"{}\": REMOVED",
                report.resolve(*sheet).unwrap_or("<unknown>")
            )]
        }
        DiffOp::RowAdded { row_idx, .. } => {
            vec![format!("Row {}: ADDED", row_idx + 1)]
        }
        DiffOp::RowRemoved { row_idx, .. } => {
            vec![format!("Row {}: REMOVED", row_idx + 1)]
        }
        DiffOp::ColumnAdded { col_idx, .. } => {
            vec![format!("Column {}: ADDED", col_letter(*col_idx))]
        }
        DiffOp::ColumnRemoved { col_idx, .. } => {
            vec![format!("Column {}: REMOVED", col_letter(*col_idx))]
        }
        DiffOp::BlockMovedRows {
            src_start_row,
            row_count,
            dst_start_row,
            block_hash,
            ..
        } => {
            let src_end = src_start_row + row_count - 1;
            let dst_end = dst_start_row + row_count - 1;
            let mut result = vec![format!(
                "Block moved: rows {}-{}  rows {}-{}",
                src_start_row + 1,
                src_end + 1,
                dst_start_row + 1,
                dst_end + 1
            )];
            if verbosity == Verbosity::Verbose {
                if let Some(hash) = block_hash {
                    result.push(format!("  (hash: {:016x})", hash));
                }
            }
            result
        }
        DiffOp::BlockMovedColumns {
            src_start_col,
            col_count,
            dst_start_col,
            block_hash,
            ..
        } => {
            let src_end = src_start_col + col_count - 1;
            let dst_end = dst_start_col + col_count - 1;
            let mut result = vec![format!(
                "Block moved: columns {}-{}  columns {}-{}",
                col_letter(*src_start_col),
                col_letter(src_end),
                col_letter(*dst_start_col),
                col_letter(dst_end)
            )];
            if verbosity == Verbosity::Verbose {
                if let Some(hash) = block_hash {
                    result.push(format!("  (hash: {:016x})", hash));
                }
            }
            result
        }
        DiffOp::BlockMovedRect {
            src_start_row,
            src_row_count,
            src_start_col,
            src_col_count,
            dst_start_row,
            dst_start_col,
            block_hash,
            ..
        } => {
            let src_range = format_range(
                *src_start_row,
                *src_start_col,
                *src_row_count,
                *src_col_count,
            );
            let dst_range = format_range(
                *dst_start_row,
                *dst_start_col,
                *src_row_count,
                *src_col_count,
            );
            let mut result = vec![format!("Block moved: {}  {}", src_range, dst_range)];
            if verbosity == Verbosity::Verbose {
                if let Some(hash) = block_hash {
                    result.push(format!("  (hash: {:016x})", hash));
                }
            }
            result
        }
        DiffOp::CellEdited {
            addr, from, to, ..
        } => {
            let old_str = format_cell_value(&from.value, report);
            let new_str = format_cell_value(&to.value, report);
            let mut result = vec![format!("Cell {}: {}  {}", addr, old_str, new_str)];
            if verbosity == Verbosity::Verbose {
                if let Some(formula_id) = from.formula {
                    if let Some(formula) = report.resolve(formula_id) {
                        result.push(format!("  old formula: ={}", formula));
                    }
                }
                if let Some(formula_id) = to.formula {
                    if let Some(formula) = report.resolve(formula_id) {
                        result.push(format!("  new formula: ={}", formula));
                    }
                }
            }
            result
        }
        DiffOp::QueryAdded { name } => {
            vec![format!(
                "Query \"{}\": ADDED",
                report.resolve(*name).unwrap_or("<unknown>")
            )]
        }
        DiffOp::QueryRemoved { name } => {
            vec![format!(
                "Query \"{}\": REMOVED",
                report.resolve(*name).unwrap_or("<unknown>")
            )]
        }
        DiffOp::QueryRenamed { from, to } => {
            vec![format!(
                "Query renamed: \"{}\"  \"{}\"",
                report.resolve(*from).unwrap_or("<unknown>"),
                report.resolve(*to).unwrap_or("<unknown>")
            )]
        }
        DiffOp::QueryDefinitionChanged {
            name, change_kind, ..
        } => {
            let kind_str = match change_kind {
                QueryChangeKind::Semantic => "semantic change",
                QueryChangeKind::FormattingOnly => "formatting only",
                QueryChangeKind::Renamed => "renamed",
            };
            vec![format!(
                "Query \"{}\": definition changed ({})",
                report.resolve(*name).unwrap_or("<unknown>"),
                kind_str
            )]
        }
        DiffOp::QueryMetadataChanged {
            name,
            field,
            old,
            new,
        } => {
            let field_name = match field {
                QueryMetadataField::LoadToSheet => "load_to_sheet",
                QueryMetadataField::LoadToModel => "load_to_model",
                QueryMetadataField::GroupPath => "group_path",
                QueryMetadataField::ConnectionOnly => "connection_only",
            };
            let old_str = old
                .map(|id| report.resolve(id).unwrap_or("<unknown>").to_string())
                .unwrap_or_else(|| "<none>".to_string());
            let new_str = new
                .map(|id| report.resolve(id).unwrap_or("<unknown>").to_string())
                .unwrap_or_else(|| "<none>".to_string());
            vec![format!(
                "Query \"{}\": {} changed: {}  {}",
                report.resolve(*name).unwrap_or("<unknown>"),
                field_name,
                old_str,
                new_str
            )]
        }
        DiffOp::VbaModuleAdded { name } => {
            vec![format!(
                "VBA module \"{}\": ADDED",
                report.resolve(*name).unwrap_or("<unknown>")
            )]
        }
        DiffOp::VbaModuleRemoved { name } => {
            vec![format!(
                "VBA module \"{}\": REMOVED",
                report.resolve(*name).unwrap_or("<unknown>")
            )]
        }
        DiffOp::VbaModuleChanged { name } => {
            vec![format!(
                "VBA module \"{}\": CHANGED",
                report.resolve(*name).unwrap_or("<unknown>")
            )]
        }
        DiffOp::NamedRangeAdded { name } => {
            vec![format!(
                "Named range \"{}\": ADDED",
                report.resolve(*name).unwrap_or("<unknown>")
            )]
        }
        DiffOp::NamedRangeRemoved { name } => {
            vec![format!(
                "Named range \"{}\": REMOVED",
                report.resolve(*name).unwrap_or("<unknown>")
            )]
        }
        DiffOp::NamedRangeChanged {
            name,
            old_ref,
            new_ref,
        } => {
            let mut lines = vec![format!(
                "Named range \"{}\": CHANGED",
                report.resolve(*name).unwrap_or("<unknown>")
            )];
            if verbosity == Verbosity::Verbose {
                let old_str = report.resolve(*old_ref).unwrap_or("<unknown>");
                let new_str = report.resolve(*new_ref).unwrap_or("<unknown>");
                lines.push(format!("  refers_to: {} -> {}", old_str, new_str));
            }
            lines
        }
        DiffOp::ChartAdded { name, .. } => vec![format!(
            "Chart \"{}\": ADDED",
            report.resolve(*name).unwrap_or("<unknown>")
        )],
        DiffOp::ChartRemoved { name, .. } => vec![format!(
            "Chart \"{}\": REMOVED",
            report.resolve(*name).unwrap_or("<unknown>")
        )],
        DiffOp::ChartChanged { name, .. } => vec![format!(
            "Chart \"{}\": CHANGED",
            report.resolve(*name).unwrap_or("<unknown>")
        )],
        _ => vec![format!("{:?}", op)],
    }
}

fn col_letter(col: u32) -> String {
    index_to_address(0, col)
        .chars()
        .take_while(|c| c.is_ascii_alphabetic())
        .collect()
}

fn format_range(start_row: u32, start_col: u32, row_count: u32, col_count: u32) -> String {
    let tl = index_to_address(start_row, start_col);
    let br = index_to_address(start_row + row_count - 1, start_col + col_count - 1);
    format!("{}:{}", tl, br)
}

fn format_cell_value(value: &Option<CellValue>, report: &DiffReport) -> String {
    match value {
        None => "<empty>".to_string(),
        Some(CellValue::Blank) => "<blank>".to_string(),
        Some(CellValue::Number(n)) => format_number(*n),
        Some(CellValue::Text(id)) => {
            let text = report.resolve(*id).unwrap_or("<unknown>");
            format!("\"{}\"", escape_string(text))
        }
        Some(CellValue::Bool(b)) => {
            if *b {
                "TRUE".to_string()
            } else {
                "FALSE".to_string()
            }
        }
        Some(CellValue::Error(id)) => report.resolve(*id).unwrap_or("#ERROR").to_string(),
    }
}

fn format_number(n: f64) -> String {
    if n.fract() == 0.0 && n.abs() < 1e15 {
        format!("{:.0}", n)
    } else {
        let s = format!("{:.10}", n);
        s.trim_end_matches('0').trim_end_matches('.').to_string()
    }
}

fn escape_string(s: &str) -> String {
    s.replace('\\', "\\\\")
        .replace('\n', "\\n")
        .replace('\r', "\\r")
        .replace('\t', "\\t")
        .replace('"', "\\\"")
}

fn write_summary<W: Write>(w: &mut W, report: &DiffReport) -> Result<()> {
    writeln!(w, "---")?;
    writeln!(w, "Summary:")?;
    writeln!(w, "  Total changes: {}", report.ops.len())?;

    let counts = count_ops(report);
    if counts.sheets > 0 {
        writeln!(w, "  Sheet changes: {}", counts.sheets)?;
    }
    if counts.rows > 0 {
        writeln!(w, "  Row changes: {}", counts.rows)?;
    }
    if counts.cols > 0 {
        writeln!(w, "  Column changes: {}", counts.cols)?;
    }
    if counts.blocks > 0 {
        writeln!(w, "  Block moves: {}", counts.blocks)?;
    }
    if counts.cells > 0 {
        writeln!(w, "  Cell edits: {}", counts.cells)?;
    }
    if counts.queries > 0 {
        writeln!(w, "  Query changes: {}", counts.queries)?;
    }

    if !report.complete {
        writeln!(w, "  Status: INCOMPLETE (some changes may be missing)")?;
    } else {
        writeln!(w, "  Status: complete")?;
    }

    Ok(())
}

struct OpCounts {
    sheets: usize,
    rows: usize,
    cols: usize,
    blocks: usize,
    cells: usize,
    queries: usize,
}

fn count_ops(report: &DiffReport) -> OpCounts {
    let mut counts = OpCounts {
        sheets: 0,
        rows: 0,
        cols: 0,
        blocks: 0,
        cells: 0,
        queries: 0,
    };

    for op in &report.ops {
        match op {
            DiffOp::SheetAdded { .. } | DiffOp::SheetRemoved { .. } => counts.sheets += 1,
            DiffOp::RowAdded { .. } | DiffOp::RowRemoved { .. } => counts.rows += 1,
            DiffOp::ColumnAdded { .. } | DiffOp::ColumnRemoved { .. } => counts.cols += 1,
            DiffOp::BlockMovedRows { .. }
            | DiffOp::BlockMovedColumns { .. }
            | DiffOp::BlockMovedRect { .. } => counts.blocks += 1,
            DiffOp::CellEdited { .. } => counts.cells += 1,
            DiffOp::QueryAdded { .. }
            | DiffOp::QueryRemoved { .. }
            | DiffOp::QueryRenamed { .. }
            | DiffOp::QueryDefinitionChanged { .. }
            | DiffOp::QueryMetadataChanged { .. } => counts.queries += 1,
            _ => {}
        }
    }

    counts
}


```

---

### File: `cli\tests\git_textconv.rs`

```rust
use std::fs;
use std::path::PathBuf;
use std::process::Command;

fn run_git(repo: &PathBuf, args: &[&str]) -> String {
    let out = Command::new("git")
        .args(args)
        .current_dir(repo)
        .output()
        .expect("git should run");
    assert!(out.status.success(), "git failed: {:?}", out);
    String::from_utf8_lossy(&out.stdout).to_string()
}

#[test]
fn git_textconv_uses_excel_diff_info() {
    if Command::new("git").arg("--version").output().is_err() {
        return;
    }

    let tmp = tempfile::tempdir().expect("tempdir");
    let repo = tmp.path().to_path_buf();

    run_git(&repo, &["init"]);
    run_git(&repo, &["config", "user.email", "test@example.com"]);
    run_git(&repo, &["config", "user.name", "Test"]);

    fs::write(repo.join(".gitattributes"), "*.xlsx diff=xlsx\n").expect("write gitattributes");

    let exe = PathBuf::from(env!("CARGO_BIN_EXE_excel-diff"));
    let exe_str = exe.to_string_lossy().replace('\\', "/");
    let textconv = format!("\"{}\" info", exe_str);
    run_git(&repo, &["config", "diff.xlsx.binary", "true"]);
    run_git(&repo, &["config", "diff.xlsx.textconv", &textconv]);

    let fixture_dir = PathBuf::from(env!("CARGO_MANIFEST_DIR"))
        .parent()
        .unwrap()
        .join("fixtures")
        .join("generated");

    let a = fixture_dir.join("pg1_basic_two_sheets.xlsx");
    let b = fixture_dir.join("one_query.xlsx");

    let target = repo.join("book.xlsx");
    fs::copy(&a, &target).expect("copy fixture a");
    run_git(&repo, &["add", "book.xlsx"]);
    run_git(&repo, &["commit", "-m", "add book"]);

    fs::copy(&b, &target).expect("copy fixture b");

    let diff = run_git(&repo, &["diff", "--textconv"]);

    assert!(diff.contains("Workbook:"), "expected textconv output");
    assert!(diff.contains("Sheets:"), "expected workbook structure");
}


```

---

### File: `cli\tests\integration_tests.rs`

```rust
use std::process::Command;

fn excel_diff_cmd() -> Command {
    Command::new(env!("CARGO_BIN_EXE_excel-diff"))
}

fn fixture_path(name: &str) -> String {
    let p = std::path::PathBuf::from(env!("CARGO_MANIFEST_DIR"))
        .parent()
        .unwrap()
        .join("fixtures")
        .join("generated")
        .join(name);

    p.to_string_lossy().into_owned()
}

#[test]
fn identical_files_exit_0() {
    let output = excel_diff_cmd()
        .args([
            "diff",
            &fixture_path("equal_sheet_a.xlsx"),
            &fixture_path("equal_sheet_b.xlsx"),
        ])
        .output()
        .expect("failed to run excel-diff");

    assert!(
        output.status.success(),
        "identical files should exit 0: {:?}",
        String::from_utf8_lossy(&output.stderr)
    );
}

#[test]
fn different_files_exit_1() {
    let output = excel_diff_cmd()
        .args([
            "diff",
            &fixture_path("single_cell_value_a.xlsx"),
            &fixture_path("single_cell_value_b.xlsx"),
        ])
        .output()
        .expect("failed to run excel-diff");

    assert_eq!(
        output.status.code(),
        Some(1),
        "different files should exit 1: stdout={}, stderr={}",
        String::from_utf8_lossy(&output.stdout),
        String::from_utf8_lossy(&output.stderr)
    );
}

#[test]
fn max_memory_zero_exits_1_and_warns() {
    let output = excel_diff_cmd()
        .args([
            "diff",
            "--max-memory",
            "0",
            &fixture_path("single_cell_value_a.xlsx"),
            &fixture_path("single_cell_value_b.xlsx"),
        ])
        .output()
        .expect("failed to run excel-diff");

    assert_eq!(
        output.status.code(),
        Some(1),
        "memory-capped diff should exit 1: stderr={}",
        String::from_utf8_lossy(&output.stderr)
    );

    let stderr = String::from_utf8_lossy(&output.stderr);
    assert!(stderr.contains("Warning:"), "should print a warning");
    assert!(
        stderr.to_lowercase().contains("memory"),
        "warning should mention memory: {}",
        stderr
    );
}

#[test]
fn timeout_zero_exits_1_and_warns() {
    let output = excel_diff_cmd()
        .args([
            "diff",
            "--timeout",
            "0",
            &fixture_path("single_cell_value_a.xlsx"),
            &fixture_path("single_cell_value_b.xlsx"),
        ])
        .output()
        .expect("failed to run excel-diff");

    assert_eq!(
        output.status.code(),
        Some(1),
        "timeout diff should exit 1: stderr={}",
        String::from_utf8_lossy(&output.stderr)
    );

    let stderr = String::from_utf8_lossy(&output.stderr);
    assert!(stderr.contains("Warning:"), "should print a warning");
    assert!(
        stderr.to_lowercase().contains("timeout"),
        "warning should mention timeout: {}",
        stderr
    );
}

#[test]
fn nonexistent_file_exit_2() {
    let output = excel_diff_cmd()
        .args(["diff", "nonexistent_a.xlsx", "nonexistent_b.xlsx"])
        .output()
        .expect("failed to run excel-diff");

    assert_eq!(
        output.status.code(),
        Some(2),
        "nonexistent file should exit 2: stderr={}",
        String::from_utf8_lossy(&output.stderr)
    );
}

#[test]
fn json_output_is_valid_json() {
    let output = excel_diff_cmd()
        .args([
            "diff",
            "--format",
            "json",
            &fixture_path("single_cell_value_a.xlsx"),
            &fixture_path("single_cell_value_b.xlsx"),
        ])
        .output()
        .expect("failed to run excel-diff");

    let stdout = String::from_utf8_lossy(&output.stdout);
    let parsed: serde_json::Value =
        serde_json::from_str(&stdout).expect("output should be valid JSON");

    assert!(parsed.get("version").is_some(), "should have version field");
    assert!(parsed.get("ops").is_some(), "should have ops field");
    assert!(parsed.get("strings").is_some(), "should have strings field");
}

#[test]
fn jsonl_first_line_is_header() {
    let output = excel_diff_cmd()
        .args([
            "diff",
            "--format",
            "jsonl",
            &fixture_path("single_cell_value_a.xlsx"),
            &fixture_path("single_cell_value_b.xlsx"),
        ])
        .output()
        .expect("failed to run excel-diff");

    let stdout = String::from_utf8_lossy(&output.stdout);
    let first_line = stdout.lines().next().expect("should have at least one line");
    let header: serde_json::Value =
        serde_json::from_str(first_line).expect("first line should be valid JSON");

    assert_eq!(header.get("kind").and_then(|v| v.as_str()), Some("Header"));
    assert!(header.get("version").is_some());
    assert!(header.get("strings").is_some());
}

#[test]
fn jsonl_progress_keeps_stdout_jsonl_and_writes_to_stderr() {
    let output = excel_diff_cmd()
        .args([
            "diff",
            "--format",
            "jsonl",
            "--progress",
            &fixture_path("single_cell_value_a.xlsx"),
            &fixture_path("single_cell_value_b.xlsx"),
        ])
        .output()
        .expect("failed to run excel-diff");

    assert_eq!(
        output.status.code(),
        Some(1),
        "diff with progress should exit 1: stderr={}",
        String::from_utf8_lossy(&output.stderr)
    );

    let stdout = String::from_utf8_lossy(&output.stdout);
    for (idx, line) in stdout.lines().enumerate() {
        serde_json::from_str::<serde_json::Value>(line).unwrap_or_else(|e| {
            panic!("stdout line {idx} should be valid JSON: {e}; line={line}");
        });
    }

    let stderr = String::from_utf8_lossy(&output.stderr);
    assert!(
        !stderr.is_empty(),
        "progress should write to stderr (even in tests): stdout_len={}, stderr_len={}",
        stdout.len(),
        stderr.len()
    );
}

#[test]
fn info_shows_sheets() {
    let output = excel_diff_cmd()
        .args(["info", &fixture_path("pg1_basic_two_sheets.xlsx")])
        .output()
        .expect("failed to run excel-diff");

    assert!(output.status.success());
    let stdout = String::from_utf8_lossy(&output.stdout);
    assert!(stdout.contains("Sheets:"));
}

#[test]
fn info_with_queries_shows_power_query() {
    let output = excel_diff_cmd()
        .args(["info", "--queries", &fixture_path("one_query.xlsx")])
        .output()
        .expect("failed to run excel-diff");

    assert!(output.status.success());
    let stdout = String::from_utf8_lossy(&output.stdout);
    assert!(stdout.contains("Power Query:"));
}

#[test]
fn fast_and_precise_are_mutually_exclusive() {
    let output = excel_diff_cmd()
        .args([
            "diff",
            "--fast",
            "--precise",
            &fixture_path("equal_sheet_a.xlsx"),
            &fixture_path("equal_sheet_b.xlsx"),
        ])
        .output()
        .expect("failed to run excel-diff");

    assert_eq!(
        output.status.code(),
        Some(2),
        "conflicting flags should exit 2"
    );
    let stderr = String::from_utf8_lossy(&output.stderr);
    assert!(stderr.contains("Cannot use both"));
}

#[test]
fn database_mode_requires_keys_or_auto_keys() {
    let output = excel_diff_cmd()
        .args([
            "diff",
            "--database",
            &fixture_path("db_equal_ordered_a.xlsx"),
            &fixture_path("db_equal_ordered_b.xlsx"),
        ])
        .output()
        .expect("failed to run excel-diff");

    assert_eq!(
        output.status.code(),
        Some(2),
        "database without keys should exit 2"
    );
    let stderr = String::from_utf8_lossy(&output.stderr);
    assert!(stderr.contains("--keys") || stderr.contains("--auto-keys"));
}

#[test]
fn database_flags_require_database_mode() {
    let output = excel_diff_cmd()
        .args([
            "diff",
            "--keys",
            "A",
            &fixture_path("db_equal_ordered_a.xlsx"),
            &fixture_path("db_equal_ordered_b.xlsx"),
        ])
        .output()
        .expect("failed to run excel-diff");

    assert_eq!(
        output.status.code(),
        Some(2),
        "keys without database flag should exit 2"
    );
    let stderr = String::from_utf8_lossy(&output.stderr);
    assert!(stderr.contains("--database"));
}

#[test]
fn git_diff_produces_unified_style() {
    let output = excel_diff_cmd()
        .args([
            "diff",
            "--git-diff",
            &fixture_path("single_cell_value_a.xlsx"),
            &fixture_path("single_cell_value_b.xlsx"),
        ])
        .output()
        .expect("failed to run excel-diff");

    let stdout = String::from_utf8_lossy(&output.stdout);
    assert!(stdout.contains("diff --git"));
    assert!(stdout.contains("---"));
    assert!(stdout.contains("+++"));
    assert!(stdout.contains("@@"));
}

#[test]
fn git_diff_conflicts_with_json_format() {
    let output = excel_diff_cmd()
        .args([
            "diff",
            "--git-diff",
            "--format",
            "json",
            &fixture_path("equal_sheet_a.xlsx"),
            &fixture_path("equal_sheet_b.xlsx"),
        ])
        .output()
        .expect("failed to run excel-diff");

    assert_eq!(
        output.status.code(),
        Some(2),
        "git-diff with json format should exit 2"
    );
}

#[test]
fn row_changes_detected() {
    let output = excel_diff_cmd()
        .args([
            "diff",
            &fixture_path("row_insert_middle_a.xlsx"),
            &fixture_path("row_insert_middle_b.xlsx"),
        ])
        .output()
        .expect("failed to run excel-diff");

    let stdout = String::from_utf8_lossy(&output.stdout);
    assert!(stdout.contains("Row") && stdout.contains("ADDED"));
}

#[test]
fn column_changes_detected() {
    let output = excel_diff_cmd()
        .args([
            "diff",
            &fixture_path("col_insert_middle_a.xlsx"),
            &fixture_path("col_insert_middle_b.xlsx"),
        ])
        .output()
        .expect("failed to run excel-diff");

    let stdout = String::from_utf8_lossy(&output.stdout);
    assert!(stdout.contains("Column") && stdout.contains("ADDED"));
}

#[test]
fn power_query_changes_detected() {
    let output = excel_diff_cmd()
        .args([
            "diff",
            &fixture_path("m_add_query_a.xlsx"),
            &fixture_path("m_add_query_b.xlsx"),
        ])
        .output()
        .expect("failed to run excel-diff");

    let stdout = String::from_utf8_lossy(&output.stdout);
    assert!(stdout.contains("Power Query") || stdout.contains("Query"));
}

#[test]
fn d1_database_reorder_no_diff() {
    let output = excel_diff_cmd()
        .args([
            "diff",
            "--database",
            "--sheet",
            "Data",
            "--keys",
            "A",
            &fixture_path("db_equal_ordered_a.xlsx"),
            &fixture_path("db_equal_ordered_b.xlsx"),
        ])
        .output()
        .expect("failed to run excel-diff");

    assert!(
        output.status.success(),
        "D1 reorder should exit 0 (no changes): stderr={}",
        String::from_utf8_lossy(&output.stderr)
    );
}

#[test]
fn d1_database_reorder_json_empty_ops() {
    let output = excel_diff_cmd()
        .args([
            "diff",
            "--database",
            "--sheet",
            "Data",
            "--keys",
            "A",
            "--format",
            "json",
            &fixture_path("db_equal_ordered_a.xlsx"),
            &fixture_path("db_equal_ordered_b.xlsx"),
        ])
        .output()
        .expect("failed to run excel-diff");

    let stdout = String::from_utf8_lossy(&output.stdout);
    let parsed: serde_json::Value =
        serde_json::from_str(&stdout).expect("output should be valid JSON");
    let ops = parsed.get("ops").and_then(|v| v.as_array());
    assert!(
        ops.map(|o| o.is_empty()).unwrap_or(false),
        "D1 reorder should have empty ops array"
    );
}

#[test]
fn d2_database_row_added() {
    let output = excel_diff_cmd()
        .args([
            "diff",
            "--database",
            "--sheet",
            "Data",
            "--keys",
            "A",
            "--format",
            "json",
            &fixture_path("db_equal_ordered_a.xlsx"),
            &fixture_path("db_row_added_b.xlsx"),
        ])
        .output()
        .expect("failed to run excel-diff");

    assert_eq!(
        output.status.code(),
        Some(1),
        "D2 row added should exit 1"
    );

    let stdout = String::from_utf8_lossy(&output.stdout);
    let parsed: serde_json::Value =
        serde_json::from_str(&stdout).expect("output should be valid JSON");
    let ops = parsed.get("ops").and_then(|v| v.as_array()).unwrap();
    let has_row_added = ops.iter().any(|op| {
        op.get("kind").and_then(|k| k.as_str()) == Some("RowAdded")
    });
    assert!(has_row_added, "D2 should contain RowAdded op");
}

#[test]
fn d3_database_row_updated() {
    let output = excel_diff_cmd()
        .args([
            "diff",
            "--database",
            "--sheet",
            "Data",
            "--keys",
            "A",
            "--format",
            "json",
            &fixture_path("db_equal_ordered_a.xlsx"),
            &fixture_path("db_row_update_b.xlsx"),
        ])
        .output()
        .expect("failed to run excel-diff");

    assert_eq!(
        output.status.code(),
        Some(1),
        "D3 row update should exit 1"
    );

    let stdout = String::from_utf8_lossy(&output.stdout);
    let parsed: serde_json::Value =
        serde_json::from_str(&stdout).expect("output should be valid JSON");
    let ops = parsed.get("ops").and_then(|v| v.as_array()).unwrap();
    let has_cell_edited = ops.iter().any(|op| {
        op.get("kind").and_then(|k| k.as_str()) == Some("CellEdited")
    });
    assert!(has_cell_edited, "D3 should contain CellEdited op");
}

#[test]
fn d4_database_reorder_and_change() {
    let output = excel_diff_cmd()
        .args([
            "diff",
            "--database",
            "--sheet",
            "Data",
            "--keys",
            "A",
            "--format",
            "json",
            &fixture_path("db_equal_ordered_a.xlsx"),
            &fixture_path("db_reorder_and_change_b.xlsx"),
        ])
        .output()
        .expect("failed to run excel-diff");

    assert_eq!(
        output.status.code(),
        Some(1),
        "D4 reorder+change should exit 1"
    );

    let stdout = String::from_utf8_lossy(&output.stdout);
    let parsed: serde_json::Value =
        serde_json::from_str(&stdout).expect("output should be valid JSON");
    let ops = parsed.get("ops").and_then(|v| v.as_array()).unwrap();
    
    let has_cell_edited = ops.iter().any(|op| {
        op.get("kind").and_then(|k| k.as_str()) == Some("CellEdited")
    });
    assert!(has_cell_edited, "D4 should contain CellEdited op");
    
    assert!(
        ops.len() < 10,
        "D4 should have few ops (reorder ignored, only changes): got {} ops",
        ops.len()
    );
}

#[test]
fn database_multi_column_keys() {
    let output = excel_diff_cmd()
        .args([
            "diff",
            "--database",
            "--sheet",
            "Data",
            "--keys",
            "A,C",
            &fixture_path("db_equal_ordered_a.xlsx"),
            &fixture_path("db_equal_ordered_b.xlsx"),
        ])
        .output()
        .expect("failed to run excel-diff");

    assert!(
        output.status.success(),
        "Multi-column keys should work: stderr={}",
        String::from_utf8_lossy(&output.stderr)
    );
}

#[test]
fn database_invalid_column_error() {
    let output = excel_diff_cmd()
        .args([
            "diff",
            "--database",
            "--sheet",
            "Data",
            "--keys",
            "1",
            &fixture_path("db_equal_ordered_a.xlsx"),
            &fixture_path("db_equal_ordered_b.xlsx"),
        ])
        .output()
        .expect("failed to run excel-diff");

    assert_eq!(
        output.status.code(),
        Some(2),
        "Invalid column should exit 2"
    );
    let stderr = String::from_utf8_lossy(&output.stderr);
    assert!(
        stderr.contains("not a valid column") || stderr.contains("Invalid"),
        "Should mention invalid column: {}",
        stderr
    );
}

#[test]
fn database_sheet_not_found_error() {
    let output = excel_diff_cmd()
        .args([
            "diff",
            "--database",
            "--sheet",
            "NoSuchSheet",
            "--keys",
            "A",
            &fixture_path("db_equal_ordered_a.xlsx"),
            &fixture_path("db_equal_ordered_b.xlsx"),
        ])
        .output()
        .expect("failed to run excel-diff");

    assert_eq!(
        output.status.code(),
        Some(2),
        "Sheet not found should exit 2"
    );
    let stderr = String::from_utf8_lossy(&output.stderr);
    assert!(
        stderr.contains("not found") || stderr.contains("Available"),
        "Should mention sheet not found: {}",
        stderr
    );
}

#[test]
fn database_auto_keys() {
    let output = excel_diff_cmd()
        .args([
            "diff",
            "--database",
            "--sheet",
            "Data",
            "--auto-keys",
            &fixture_path("db_equal_ordered_a.xlsx"),
            &fixture_path("db_equal_ordered_b.xlsx"),
        ])
        .output()
        .expect("failed to run excel-diff");

    assert!(
        output.status.success(),
        "Auto-keys should work: stderr={}",
        String::from_utf8_lossy(&output.stderr)
    );
    
    let stderr = String::from_utf8_lossy(&output.stderr);
    assert!(
        stderr.contains("Auto-detected") || stderr.is_empty(),
        "Should print auto-detected message or be silent"
    );
}


```

---

### File: `core\benches\diff_benchmarks.rs`

```rust
use criterion::{BenchmarkId, Criterion, Throughput, criterion_group, criterion_main};
use excel_diff::{
    CellValue, DiffConfig, DiffSession, Grid, Sheet, SheetKind, Workbook,
    try_diff_workbooks_with_pool,
};
use std::time::Duration;

const MAX_BENCH_TIME_SECS: u64 = 30;
const WARMUP_SECS: u64 = 3;
const SAMPLE_SIZE: usize = 10;

fn create_large_grid(nrows: u32, ncols: u32, base_value: i32) -> Grid {
    let mut grid = Grid::new(nrows, ncols);
    for row in 0..nrows {
        for col in 0..ncols {
            grid.insert_cell(
                row,
                col,
                Some(CellValue::Number(
                    (base_value as i64 + row as i64 * 1000 + col as i64) as f64,
                )),
                None,
            );
        }
    }
    grid
}

fn create_repetitive_grid(nrows: u32, ncols: u32, pattern_length: u32) -> Grid {
    let mut grid = Grid::new(nrows, ncols);
    for row in 0..nrows {
        let pattern_idx = row % pattern_length;
        for col in 0..ncols {
            grid.insert_cell(
                row,
                col,
                Some(CellValue::Number((pattern_idx * 1000 + col) as f64)),
                None,
            );
        }
    }
    grid
}

fn create_sparse_grid(nrows: u32, ncols: u32, fill_percent: u32, seed: u64) -> Grid {
    use std::collections::hash_map::DefaultHasher;
    use std::hash::{Hash, Hasher};

    let mut grid = Grid::new(nrows, ncols);
    for row in 0..nrows {
        for col in 0..ncols {
            let mut hasher = DefaultHasher::new();
            (row, col, seed).hash(&mut hasher);
            let hash = hasher.finish();
            if (hash % 100) < fill_percent as u64 {
                grid.insert_cell(
                    row,
                    col,
                    Some(CellValue::Number((row * 1000 + col) as f64)),
                    None,
                );
            }
        }
    }
    grid
}

fn single_sheet_workbook(session: &mut DiffSession, name: &str, grid: Grid) -> Workbook {
    let sheet_name = session.strings.intern(name);
    Workbook {
        sheets: vec![Sheet {
            name: sheet_name,
            kind: SheetKind::Worksheet,
            grid,
        }],
        ..Default::default()
    }
}

fn bench_identical_grids(c: &mut Criterion) {
    let mut group = c.benchmark_group("identical_grids");
    group.measurement_time(Duration::from_secs(MAX_BENCH_TIME_SECS));
    group.warm_up_time(Duration::from_secs(WARMUP_SECS));
    group.sample_size(SAMPLE_SIZE);

    for size in [500u32, 1000, 2000, 5000].iter() {
        let mut session = DiffSession::new();
        let grid_a = create_large_grid(*size, 50, 0);
        let grid_b = create_large_grid(*size, 50, 0);
        let wb_a = single_sheet_workbook(&mut session, "Bench", grid_a);
        let wb_b = single_sheet_workbook(&mut session, "Bench", grid_b);
        let config = DiffConfig::default();

        group.throughput(Throughput::Elements(*size as u64 * 50));
        group.bench_with_input(BenchmarkId::new("rows", size), size, move |b, _| {
            b.iter(|| {
                let _ = try_diff_workbooks_with_pool(&wb_a, &wb_b, &mut session.strings, &config)
                    .expect("diff should succeed");
            });
        });
    }
    group.finish();
}

fn bench_single_cell_edit(c: &mut Criterion) {
    let mut group = c.benchmark_group("single_cell_edit");
    group.measurement_time(Duration::from_secs(MAX_BENCH_TIME_SECS));
    group.warm_up_time(Duration::from_secs(WARMUP_SECS));
    group.sample_size(SAMPLE_SIZE);

    for size in [500u32, 1000, 2000, 5000].iter() {
        let mut session = DiffSession::new();
        let grid_a = create_large_grid(*size, 50, 0);
        let mut grid_b = create_large_grid(*size, 50, 0);
        grid_b.insert_cell(size / 2, 25, Some(CellValue::Number(999999.0)), None);
        let wb_a = single_sheet_workbook(&mut session, "Bench", grid_a);
        let wb_b = single_sheet_workbook(&mut session, "Bench", grid_b);
        let config = DiffConfig::default();

        group.throughput(Throughput::Elements(*size as u64 * 50));
        group.bench_with_input(BenchmarkId::new("rows", size), size, move |b, _| {
            b.iter(|| {
                let _ = try_diff_workbooks_with_pool(&wb_a, &wb_b, &mut session.strings, &config)
                    .expect("diff should succeed");
            });
        });
    }
    group.finish();
}

fn bench_all_rows_different(c: &mut Criterion) {
    let mut group = c.benchmark_group("all_rows_different");
    group.measurement_time(Duration::from_secs(MAX_BENCH_TIME_SECS));
    group.warm_up_time(Duration::from_secs(WARMUP_SECS));
    group.sample_size(SAMPLE_SIZE);

    for size in [500u32, 1000, 2000].iter() {
        let mut session = DiffSession::new();
        let grid_a = create_large_grid(*size, 50, 0);
        let grid_b = create_large_grid(*size, 50, 1);
        let wb_a = single_sheet_workbook(&mut session, "Bench", grid_a);
        let wb_b = single_sheet_workbook(&mut session, "Bench", grid_b);
        let config = DiffConfig::default();

        group.throughput(Throughput::Elements(*size as u64 * 50));
        group.bench_with_input(BenchmarkId::new("rows", size), size, move |b, _| {
            b.iter(|| {
                let _ = try_diff_workbooks_with_pool(&wb_a, &wb_b, &mut session.strings, &config)
                    .expect("diff should succeed");
            });
        });
    }
    group.finish();
}

fn bench_adversarial_repetitive(c: &mut Criterion) {
    let mut group = c.benchmark_group("adversarial_repetitive");
    group.measurement_time(Duration::from_secs(MAX_BENCH_TIME_SECS));
    group.warm_up_time(Duration::from_secs(WARMUP_SECS));
    group.sample_size(SAMPLE_SIZE);

    for size in [500u32, 1000, 2000].iter() {
        let mut session = DiffSession::new();
        let grid_a = create_repetitive_grid(*size, 50, 100);
        let mut grid_b = create_repetitive_grid(*size, 50, 100);
        grid_b.insert_cell(size / 2, 25, Some(CellValue::Number(999999.0)), None);
        let wb_a = single_sheet_workbook(&mut session, "Bench", grid_a);
        let wb_b = single_sheet_workbook(&mut session, "Bench", grid_b);
        let config = DiffConfig::default();

        group.throughput(Throughput::Elements(*size as u64 * 50));
        group.bench_with_input(BenchmarkId::new("rows", size), size, move |b, _| {
            b.iter(|| {
                let _ = try_diff_workbooks_with_pool(&wb_a, &wb_b, &mut session.strings, &config)
                    .expect("diff should succeed");
            });
        });
    }
    group.finish();
}

fn bench_sparse_grid(c: &mut Criterion) {
    let mut group = c.benchmark_group("sparse_grid_1pct");
    group.measurement_time(Duration::from_secs(MAX_BENCH_TIME_SECS));
    group.warm_up_time(Duration::from_secs(WARMUP_SECS));
    group.sample_size(SAMPLE_SIZE);

    for size in [500u32, 1000, 2000, 5000].iter() {
        let mut session = DiffSession::new();
        let grid_a = create_sparse_grid(*size, 100, 1, 12345);
        let mut grid_b = create_sparse_grid(*size, 100, 1, 12345);
        grid_b.insert_cell(size / 2, 50, Some(CellValue::Number(999999.0)), None);
        let wb_a = single_sheet_workbook(&mut session, "Bench", grid_a);
        let wb_b = single_sheet_workbook(&mut session, "Bench", grid_b);
        let config = DiffConfig::default();

        group.throughput(Throughput::Elements(*size as u64 * 100));
        group.bench_with_input(BenchmarkId::new("rows", size), size, move |b, _| {
            b.iter(|| {
                let _ = try_diff_workbooks_with_pool(&wb_a, &wb_b, &mut session.strings, &config)
                    .expect("diff should succeed");
            });
        });
    }
    group.finish();
}

fn bench_row_insertion(c: &mut Criterion) {
    let mut group = c.benchmark_group("row_insertion");
    group.measurement_time(Duration::from_secs(MAX_BENCH_TIME_SECS));
    group.warm_up_time(Duration::from_secs(WARMUP_SECS));
    group.sample_size(SAMPLE_SIZE);

    for size in [500u32, 1000, 2000].iter() {
        let mut session = DiffSession::new();
        let grid_a = create_large_grid(*size, 50, 0);
        let mut grid_b = Grid::new(size + 100, 50);
        for row in 0..(size / 2) {
            for col in 0..50 {
                grid_b.insert_cell(
                    row,
                    col,
                    Some(CellValue::Number((row as i64 * 1000 + col as i64) as f64)),
                    None,
                );
            }
        }
        for col in 0..50 {
            for i in 0..100 {
                let row = size / 2 + i;
                let marker = 1_000_000.0 + i as f64 * 10.0 + col as f64;
                grid_b.insert_cell(row, col, Some(CellValue::Number(marker)), None);
            }
        }
        for row in (size / 2)..*size {
            for col in 0..50 {
                let new_row = row + 100;
                grid_b.insert_cell(
                    new_row,
                    col,
                    Some(CellValue::Number((row as i64 * 1000 + col as i64) as f64)),
                    None,
                );
            }
        }
        let wb_a = single_sheet_workbook(&mut session, "Bench", grid_a);
        let wb_b = single_sheet_workbook(&mut session, "Bench", grid_b);
        let config = DiffConfig::default();

        group.throughput(Throughput::Elements(*size as u64 * 50));
        group.bench_with_input(BenchmarkId::new("rows", size), size, move |b, _| {
            b.iter(|| {
                let _ = try_diff_workbooks_with_pool(&wb_a, &wb_b, &mut session.strings, &config)
                    .expect("diff should succeed");
            });
        });
    }
    group.finish();
}

criterion_group!(
    benches,
    bench_identical_grids,
    bench_single_cell_edit,
    bench_all_rows_different,
    bench_adversarial_repetitive,
    bench_sparse_grid,
    bench_row_insertion,
);

criterion_main!(benches);

```

---

### File: `core\Cargo.toml`

```toml
[package]
name = "excel_diff"
version = "0.1.0"
edition = "2024"
description = "A library for comparing Excel workbooks"
license = "MIT"
repository = "https://github.com/dvora/excel_diff"
homepage = "https://github.com/dvora/excel_diff"

[lib]
name = "excel_diff"
path = "src/lib.rs"

[features]
default = ["excel-open-xml", "std-fs", "vba"]
excel-open-xml = []
vba = ["dep:ovba"]
std-fs = []
perf-metrics = []
dev-apis = []

[dependencies]
quick-xml = "0.32"
thiserror = "1.0"
zip = { version = "0.6", default-features = false, features = ["deflate"] }
base64 = "0.22"
serde = { version = "1.0", features = ["derive"] }
serde_json = "1.0"
xxhash-rust = { version = "0.8", features = ["xxh64", "xxh3"] }
rustc-hash = "1.1"
ovba = { version = "0.7.1", optional = true }

[dev-dependencies]
pretty_assertions = "1.4"
tempfile = "3.10"
criterion = { version = "0.5", features = ["html_reports"] }

[[bench]]
name = "diff_benchmarks"
harness = false

```

---

### File: `core\examples\basic_diff.rs`

```rust
use excel_diff::{DiffConfig, WorkbookPackage};
use std::fs::File;

fn usage() -> ! {
    eprintln!("Usage: basic_diff <OLD.xlsx> <NEW.xlsx> [N]");
    eprintln!("  N: optionally print the first N ops (debug)");
    std::process::exit(2);
}

fn main() -> Result<(), Box<dyn std::error::Error>> {
    let mut args = std::env::args().skip(1);
    let old_path = args.next().unwrap_or_else(|| usage());
    let new_path = args.next().unwrap_or_else(|| usage());
    let show_n: Option<usize> = args.next().map(|s| s.parse()).transpose()?;

    let old_pkg = WorkbookPackage::open(File::open(&old_path)?)?;
    let new_pkg = WorkbookPackage::open(File::open(&new_path)?)?;

    let report = old_pkg.diff(&new_pkg, &DiffConfig::default());

    println!("complete: {}", report.complete);
    println!("warnings: {}", report.warnings.len());
    println!("ops: {}", report.ops.len());

    if let Some(n) = show_n {
        for (i, op) in report.ops.iter().take(n).enumerate() {
            println!("{:>4}: {:?}", i, op);
        }
    }

    Ok(())
}


```

---

### File: `core\examples\custom_config.rs`

```rust
use excel_diff::{DiffConfig, WorkbookPackage};
use std::fs::File;

fn usage() -> ! {
    eprintln!("Usage: custom_config <OLD.xlsx> <NEW.xlsx>");
    std::process::exit(2);
}

fn main() -> Result<(), Box<dyn std::error::Error>> {
    let mut args = std::env::args().skip(1);
    let old_path = args.next().unwrap_or_else(|| usage());
    let new_path = args.next().unwrap_or_else(|| usage());

    let old_pkg = WorkbookPackage::open(File::open(&old_path)?)?;
    let new_pkg = WorkbookPackage::open(File::open(&new_path)?)?;

    let mut cfg = DiffConfig::fastest();
    cfg.max_memory_mb = Some(256);
    cfg.timeout_seconds = Some(10);

    let report = old_pkg.diff(&new_pkg, &cfg);

    for warning in &report.warnings {
        eprintln!("warning: {}", warning);
    }

    println!("complete: {}", report.complete);
    println!("ops: {}", report.ops.len());
    Ok(())
}


```

---

### File: `core\examples\database_mode.rs`

```rust
use excel_diff::{DiffConfig, WorkbookPackage};
use std::fs::File;
use std::io;

fn usage() -> ! {
    eprintln!("Usage: database_mode <OLD.xlsx> <NEW.xlsx> <SHEET_NAME> <KEYS>");
    eprintln!("  KEYS: comma-separated column letters (e.g. A,C,AA)");
    eprintln!("  Note: key columns are 0-based indices internally (A=0, B=1, ...).");
    std::process::exit(2);
}

fn main() -> Result<(), Box<dyn std::error::Error>> {
    let mut args = std::env::args().skip(1);
    let old_path = args.next().unwrap_or_else(|| usage());
    let new_path = args.next().unwrap_or_else(|| usage());
    let sheet_name = args.next().unwrap_or_else(|| usage());
    let keys = args.next().unwrap_or_else(|| usage());

    let key_columns = parse_key_columns(&keys)?;

    let old_pkg = WorkbookPackage::open(File::open(&old_path)?)?;
    let new_pkg = WorkbookPackage::open(File::open(&new_path)?)?;

    let report = old_pkg.diff_database_mode(&new_pkg, &sheet_name, &key_columns, &DiffConfig::default())?;

    for warning in &report.warnings {
        eprintln!("warning: {}", warning);
    }

    println!("complete: {}", report.complete);
    println!("ops: {}", report.ops.len());

    for (i, op) in report.ops.iter().take(25).enumerate() {
        println!("{:>4}: {:?}", i, op);
    }

    Ok(())
}

fn parse_key_columns(keys: &str) -> io::Result<Vec<u32>> {
    let mut out = Vec::new();
    for token in keys.split(',') {
        let token = token.trim();
        if token.is_empty() {
            continue;
        }
        out.push(col_letters_to_index(token)?);
    }

    if out.is_empty() {
        return Err(io::Error::new(
            io::ErrorKind::InvalidInput,
            "no key columns specified",
        ));
    }

    Ok(out)
}

fn col_letters_to_index(letters: &str) -> io::Result<u32> {
    let mut col: u32 = 0;
    for ch in letters.chars() {
        let upper = ch.to_ascii_uppercase();
        if !upper.is_ascii_uppercase() {
            return Err(io::Error::new(
                io::ErrorKind::InvalidInput,
                format!("invalid column token: '{letters}'"),
            ));
        }
        col = col
            .checked_mul(26)
            .and_then(|c| c.checked_add((upper as u8 - b'A' + 1) as u32))
            .ok_or_else(|| {
                io::Error::new(
                    io::ErrorKind::InvalidInput,
                    format!("column '{letters}' is out of range"),
                )
            })?;
    }
    Ok(col - 1)
}

```

---

### File: `core\examples\streaming.rs`

```rust
use excel_diff::{DiffConfig, JsonLinesSink, WorkbookPackage};
use std::fs::File;

fn usage() -> ! {
    eprintln!("Usage: streaming <OLD.xlsx> <NEW.xlsx> > out.jsonl");
    std::process::exit(2);
}

fn main() -> Result<(), Box<dyn std::error::Error>> {
    let mut args = std::env::args().skip(1);
    let old_path = args.next().unwrap_or_else(|| usage());
    let new_path = args.next().unwrap_or_else(|| usage());

    let old_pkg = WorkbookPackage::open(File::open(&old_path)?)?;
    let new_pkg = WorkbookPackage::open(File::open(&new_path)?)?;

    let stdout = std::io::stdout();
    let handle = stdout.lock();
    let mut sink = JsonLinesSink::new(handle);

    let summary = old_pkg.diff_streaming(&new_pkg, &DiffConfig::default(), &mut sink)?;

    eprintln!(
        "complete={} ops={} warnings={}",
        summary.complete,
        summary.op_count,
        summary.warnings.len()
    );
    for warning in &summary.warnings {
        eprintln!("warning: {}", warning);
    }

    Ok(())
}


```

---

### File: `core\fuzz\Cargo.toml`

```toml
[package]
name = "excel_diff-fuzz"
version = "0.0.0"
authors = ["Automatically generated"]
publish = false
edition = "2021"

[package.metadata]
cargo-fuzz = true

[dependencies]
libfuzzer-sys = "0.4"
arbitrary = { version = "1", features = ["derive"] }

[dependencies.excel_diff]
path = ".."
features = ["excel-open-xml"]

[[bin]]
name = "fuzz_open_workbook"
path = "fuzz_targets/fuzz_open_workbook.rs"
test = false
doc = false
bench = false

[[bin]]
name = "fuzz_datamashup_parse"
path = "fuzz_targets/fuzz_datamashup_parse.rs"
test = false
doc = false
bench = false

[[bin]]
name = "fuzz_diff_grids"
path = "fuzz_targets/fuzz_diff_grids.rs"
test = false
doc = false
bench = false

[profile.release]
debug = 1


```

---

### File: `core\fuzz\fuzz_targets\fuzz_datamashup_parse.rs`

```rust
#![no_main]

use libfuzzer_sys::fuzz_target;

use excel_diff::{parse_data_mashup, build_data_mashup};

fuzz_target!(|data: &[u8]| {
    if let Ok(raw) = parse_data_mashup(data) {
        let _ = build_data_mashup(&raw);
    }
});


```

---

### File: `core\fuzz\fuzz_targets\fuzz_diff_grids.rs`

```rust
#![no_main]

use libfuzzer_sys::fuzz_target;
use arbitrary::Arbitrary;

use excel_diff::{
    Cell, CellValue, DiffConfig, Grid, Sheet, SheetKind, StringPool, Workbook,
    advanced::try_diff_workbooks_with_pool,
};

#[derive(Arbitrary, Debug)]
struct FuzzInput {
    old_rows: u8,
    old_cols: u8,
    new_rows: u8,
    new_cols: u8,
    old_cells: Vec<FuzzCell>,
    new_cells: Vec<FuzzCell>,
}

#[derive(Arbitrary, Debug)]
struct FuzzCell {
    row: u8,
    col: u8,
    value_type: u8,
    number_value: f64,
    text_idx: u8,
}

fn build_grid(rows: u8, cols: u8, cells: &[FuzzCell], pool: &mut StringPool) -> Grid {
    let nrows = (rows as u32).min(100).max(1);
    let ncols = (cols as u32).min(100).max(1);
    let mut grid = Grid::new(nrows, ncols);

    for cell in cells.iter().take(200) {
        let row = (cell.row as u32) % nrows;
        let col = (cell.col as u32) % ncols;

        let value = match cell.value_type % 4 {
            0 => None,
            1 => Some(CellValue::Number(if cell.number_value.is_finite() {
                cell.number_value
            } else {
                0.0
            })),
            2 => Some(CellValue::Bool(cell.number_value > 0.5)),
            _ => {
                let texts = ["A", "B", "C", "test", "value", ""];
                let idx = (cell.text_idx as usize) % texts.len();
                Some(CellValue::Text(pool.intern(texts[idx])))
            }
        };

        grid.insert_cell(row, col, value, None);
    }

    grid
}

fuzz_target!(|input: FuzzInput| {
    let mut pool = StringPool::new();

    let old_grid = build_grid(input.old_rows, input.old_cols, &input.old_cells, &mut pool);
    let new_grid = build_grid(input.new_rows, input.new_cols, &input.new_cells, &mut pool);

    let sheet_name = pool.intern("Sheet1");
    let old_wb = Workbook {
        sheets: vec![Sheet {
            name: sheet_name,
            kind: SheetKind::Worksheet,
            grid: old_grid,
        }],
        ..Default::default()
    };
    let new_wb = Workbook {
        sheets: vec![Sheet {
            name: sheet_name,
            kind: SheetKind::Worksheet,
            grid: new_grid,
        }],
        ..Default::default()
    };

    let config = DiffConfig {
        max_align_rows: 50,
        max_align_cols: 50,
        ..Default::default()
    };

    let _ = try_diff_workbooks_with_pool(&old_wb, &new_wb, &mut pool, &config);
});


```

---

### File: `core\fuzz\fuzz_targets\fuzz_open_workbook.rs`

```rust
#![no_main]

use libfuzzer_sys::fuzz_target;
use std::io::Cursor;

use excel_diff::{ContainerLimits, OpcContainer, WorkbookPackage};

fuzz_target!(|data: &[u8]| {
    let limits = ContainerLimits {
        max_entries: 100,
        max_part_uncompressed_bytes: 1024 * 1024,
        max_total_uncompressed_bytes: 10 * 1024 * 1024,
    };

    let cursor = Cursor::new(data);
    let _ = OpcContainer::open_from_reader_with_limits(cursor, limits);

    let cursor = Cursor::new(data);
    let _ = WorkbookPackage::open(cursor);
});


```

---

### File: `core\src\addressing.rs`

```rust
//! Excel cell addressing utilities.
//!
//! Provides conversion between A1-style cell addresses (e.g., "B2", "AA10") and
//! zero-based (row, column) index pairs.

use std::fmt;

/// Error returned when parsing an invalid A1-style cell address.
#[derive(Debug, Clone, PartialEq, Eq)]
pub struct AddressParseError {
    pub input: String,
}

impl fmt::Display for AddressParseError {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        write!(f, "invalid cell address: '{}'", self.input)
    }
}

impl std::error::Error for AddressParseError {}

/// Convert zero-based (row, col) indices to an Excel A1 address string.
pub fn index_to_address(row: u32, col: u32) -> String {
    let mut col_index = col;
    let mut col_label = String::new();

    loop {
        let rem = (col_index % 26) as u8;
        col_label.push((b'A' + rem) as char);
        if col_index < 26 {
            break;
        }
        col_index = col_index / 26 - 1;
    }

    col_label.chars().rev().collect::<String>() + &(row + 1).to_string()
}

/// Parse an A1 address into zero-based (row, col) indices.
/// Returns `None` for malformed addresses.
pub fn address_to_index(a1: &str) -> Option<(u32, u32)> {
    if a1.is_empty() {
        return None;
    }

    let mut col: u32 = 0;
    let mut row: u32 = 0;
    let mut saw_letter = false;
    let mut saw_digit = false;

    for ch in a1.chars() {
        if ch.is_ascii_alphabetic() {
            saw_letter = true;
            if saw_digit {
                // Letters after digits are not allowed.
                return None;
            }
            let upper = ch.to_ascii_uppercase() as u8;
            if !upper.is_ascii_uppercase() {
                return None;
            }
            col = col
                .checked_mul(26)?
                .checked_add((upper - b'A' + 1) as u32)?;
        } else if ch.is_ascii_digit() {
            saw_digit = true;
            row = row.checked_mul(10)?.checked_add((ch as u8 - b'0') as u32)?;
        } else {
            return None;
        }
    }

    if !saw_letter || !saw_digit || row == 0 || col == 0 {
        return None;
    }

    Some((row - 1, col - 1))
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn index_to_address_examples() {
        assert_eq!(index_to_address(0, 0), "A1");
        assert_eq!(index_to_address(0, 25), "Z1");
        assert_eq!(index_to_address(0, 26), "AA1");
        assert_eq!(index_to_address(0, 27), "AB1");
        assert_eq!(index_to_address(0, 51), "AZ1");
        assert_eq!(index_to_address(0, 52), "BA1");
    }

    #[test]
    fn round_trip_addresses() {
        let addresses = [
            "A1", "B2", "Z10", "AA1", "AA10", "AB7", "AZ5", "BA1", "ZZ10", "AAA1",
        ];
        for addr in addresses {
            let (r, c) = address_to_index(addr).expect("address should parse");
            assert_eq!(index_to_address(r, c), addr);
        }
    }

    #[test]
    fn invalid_addresses_rejected() {
        let invalid = ["", "1A", "A0", "A", "AA0", "A-1", "A1A"];
        for addr in invalid {
            assert!(address_to_index(addr).is_none(), "{addr} should be invalid");
        }
    }
}

```

---

### File: `core\src\alignment\anchor_chain.rs`

```rust
//! Anchor chain construction using Longest Increasing Subsequence (LIS).
//!
//! Implements anchor chain building as described in the unified grid diff
//! specification Section 10. Given a set of discovered anchors, this module
//! selects the maximal subset that preserves relative order in both grids.
//!
//! For example, if anchors show:
//! - Row A: old=0, new=0
//! - Row B: old=2, new=1  (B moved up)
//! - Row C: old=1, new=2
//!
//! The LIS algorithm selects {A, C} because their old_row indices (0, 1) are
//! increasing, making them a valid ordering chain. Row B is excluded because
//! including it would create a crossing (B is at old=2 but new=1, while C is
//! at old=1 but new=2).

use crate::alignment::anchor_discovery::Anchor;

pub fn build_anchor_chain(mut anchors: Vec<Anchor>) -> Vec<Anchor> {
    // Sort by new_row to preserve destination order before LIS on old_row.
    anchors.sort_by_key(|a| a.new_row);
    let indices = lis_indices(&anchors, |a| a.old_row);
    indices.into_iter().map(|idx| anchors[idx]).collect()
}

fn lis_indices<T, F>(items: &[T], key: F) -> Vec<usize>
where
    F: Fn(&T) -> u32,
{
    let mut piles: Vec<usize> = Vec::new();
    let mut predecessors: Vec<Option<usize>> = vec![None; items.len()];

    for (idx, item) in items.iter().enumerate() {
        let k = key(item);
        let pos = piles
            .binary_search_by_key(&k, |&pile_idx| key(&items[pile_idx]))
            .unwrap_or_else(|insert_pos| insert_pos);

        if pos > 0 {
            predecessors[idx] = Some(piles[pos - 1]);
        }

        if pos == piles.len() {
            piles.push(idx);
        } else {
            piles[pos] = idx;
        }
    }

    let Some(&last) = piles.last() else {
        return Vec::new();
    };

    let mut result: Vec<usize> = Vec::new();
    let mut current = last;
    loop {
        result.push(current);
        if let Some(prev) = predecessors[current] {
            current = prev;
        } else {
            break;
        }
    }
    result.reverse();
    result
}

#[cfg(test)]
mod tests {
    use super::*;
    use crate::alignment::anchor_discovery::Anchor;
    use crate::workbook::RowSignature;

    #[test]
    fn builds_increasing_chain() {
        let anchors = vec![
            Anchor {
                old_row: 0,
                new_row: 0,
                signature: RowSignature { hash: 1 },
            },
            Anchor {
                old_row: 2,
                new_row: 1,
                signature: RowSignature { hash: 2 },
            },
            Anchor {
                old_row: 1,
                new_row: 2,
                signature: RowSignature { hash: 3 },
            },
        ];

        let chain = build_anchor_chain(anchors);
        assert_eq!(chain.len(), 2);
        assert_eq!(chain[0].old_row, 0);
        assert_eq!(chain[1].old_row, 1);
    }
}

```

---

### File: `core\src\alignment\anchor_discovery.rs`

```rust
//! Anchor discovery for AMR alignment.
//!
//! Implements anchor discovery as described in the unified grid diff specification
//! Section 10. Anchors are rows that:
//!
//! 1. Are unique (appear exactly once) in BOTH grids
//! 2. Have matching signatures (content hash)
//!
//! These rows serve as fixed points around which the alignment is built.
//! Rows that are unique in one grid but not the other cannot be anchors
//! since their position cannot be reliably determined.

use std::collections::HashMap;

use crate::grid_metadata::{FrequencyClass, RowMeta};
#[cfg(test)]
use crate::grid_view::GridView;
use crate::workbook::RowSignature;

#[derive(Clone, Copy, Debug, PartialEq, Eq)]
pub struct Anchor {
    pub old_row: u32,
    pub new_row: u32,
    pub signature: RowSignature,
}

#[cfg(test)]
pub fn discover_anchors(old: &GridView<'_>, new: &GridView<'_>) -> Vec<Anchor> {
    discover_anchors_from_meta(&old.row_meta, &new.row_meta)
}

pub fn discover_anchors_from_meta(old: &[RowMeta], new: &[RowMeta]) -> Vec<Anchor> {
    let mut old_unique: HashMap<RowSignature, u32> = HashMap::new();
    for meta in old.iter() {
        if meta.frequency_class == FrequencyClass::Unique {
            old_unique.insert(meta.signature, meta.row_idx);
        }
    }

    new.iter()
        .filter(|meta| meta.frequency_class == FrequencyClass::Unique)
        .filter_map(|meta| {
            old_unique.get(&meta.signature).map(|old_idx| Anchor {
                old_row: *old_idx,
                new_row: meta.row_idx,
                signature: meta.signature,
            })
        })
        .collect()
}

pub fn discover_context_anchors(old: &[RowMeta], new: &[RowMeta], k: usize) -> Vec<Anchor> {
    if k == 0 || old.len() < k || new.len() < k {
        return Vec::new();
    }

    fn window_signature(window: &[RowMeta]) -> Option<RowSignature> {
        if window.iter().any(|m| m.is_low_info()) {
            return None;
        }
        let mut acc: u128 = 0x9e37_79b1_85eb_ca87;
        for (idx, meta) in window.iter().enumerate() {
            let mul = 0x1000_0000_01b3u128;
            acc = acc
                .wrapping_mul(mul)
                .wrapping_add(meta.signature.hash ^ ((idx as u128) << 1) ^ 0x517c_c1b7_2722_0a95);
            acc ^= acc >> 33;
            acc = acc.rotate_left(7);
        }
        Some(RowSignature { hash: acc })
    }

    let mut count_old: HashMap<RowSignature, u32> = HashMap::new();
    let mut pos_old: HashMap<RowSignature, u32> = HashMap::new();
    for i in 0..=old.len() - k {
        if let Some(sig) = window_signature(&old[i..i + k]) {
            *count_old.entry(sig).or_insert(0) += 1;
            pos_old.entry(sig).or_insert(old[i].row_idx);
        }
    }

    let mut count_new: HashMap<RowSignature, u32> = HashMap::new();
    let mut pos_new: HashMap<RowSignature, u32> = HashMap::new();
    for i in 0..=new.len() - k {
        if let Some(sig) = window_signature(&new[i..i + k]) {
            *count_new.entry(sig).or_insert(0) += 1;
            pos_new.entry(sig).or_insert(new[i].row_idx);
        }
    }

    let mut anchors = Vec::new();
    for (sig, &new_row) in pos_new.iter() {
        if count_new.get(sig).copied().unwrap_or(0) != 1 {
            continue;
        }
        if count_old.get(sig).copied().unwrap_or(0) != 1 {
            continue;
        }
        if let Some(old_row) = pos_old.get(sig) {
            anchors.push(Anchor {
                old_row: *old_row,
                new_row,
                signature: *sig,
            });
        }
    }

    anchors
}

pub fn discover_local_anchors(old: &[RowMeta], new: &[RowMeta]) -> Vec<Anchor> {
    let mut count_old: HashMap<RowSignature, u32> = HashMap::new();
    for m in old.iter() {
        if !m.is_low_info() {
            *count_old.entry(m.signature).or_insert(0) += 1;
        }
    }

    let mut count_new: HashMap<RowSignature, u32> = HashMap::new();
    for m in new.iter() {
        if !m.is_low_info() {
            *count_new.entry(m.signature).or_insert(0) += 1;
        }
    }

    let mut pos_old: HashMap<RowSignature, u32> = HashMap::new();
    for m in old.iter() {
        if !m.is_low_info() && count_old.get(&m.signature).copied().unwrap_or(0) == 1 {
            pos_old.insert(m.signature, m.row_idx);
        }
    }

    let mut out = Vec::new();
    for m in new.iter() {
        if m.is_low_info() {
            continue;
        }
        if count_new.get(&m.signature).copied().unwrap_or(0) != 1 {
            continue;
        }
        if let Some(old_row) = pos_old.get(&m.signature) {
            out.push(Anchor {
                old_row: *old_row,
                new_row: m.row_idx,
                signature: m.signature,
            });
        }
    }
    out
}

#[cfg(test)]
mod tests {
    use super::*;
    use crate::grid_metadata::{FrequencyClass, RowMeta};

    fn meta_from_hashes(hashes: &[u128]) -> Vec<RowMeta> {
        hashes
            .iter()
            .enumerate()
            .map(|(idx, &hash)| {
                let sig = RowSignature { hash };
                RowMeta {
                    row_idx: idx as u32,
                    signature: sig,
                    non_blank_count: 1,
                    first_non_blank_col: 0,
                    frequency_class: FrequencyClass::Common,
                    is_low_info: false,
                }
            })
            .collect()
    }

    #[test]
    fn discovers_context_anchors_when_no_uniques() {
        let old = meta_from_hashes(&[1, 2, 3, 4, 5, 6, 1, 2]);
        let new = meta_from_hashes(&[7, 1, 2, 3, 4, 5, 6, 8]);

        let anchors = discover_context_anchors(&old, &new, 4);
        assert!(!anchors.is_empty(), "should find context anchors");
        let mut rows: Vec<(u32, u32)> = anchors.iter().map(|a| (a.old_row, a.new_row)).collect();
        rows.sort();
        assert!(rows.contains(&(0, 1)));
        assert!(rows.contains(&(1, 2)));
        assert!(rows.contains(&(2, 3)));
    }
}

```

---

### File: `core\src\alignment\assembly.rs`

```rust
//! Final alignment assembly for AMR algorithm.
//!
//! Implements the final assembly phase as described in the unified grid diff
//! specification Section 12. This module:
//!
//! 1. Orchestrates the full AMR pipeline (metadata  anchors  chain  gaps)
//! 2. Assembles matched pairs, insertions, deletions, and moves into final alignment
//! 3. Provides fast paths for special cases (RLE compression, single-run grids)
//!
//! The main entry point is `align_rows_amr` which returns an `Option<RowAlignment>`.
//! Returns `None` when alignment cannot be determined (falls back to positional diff).

use std::ops::Range;

use crate::alignment::anchor_chain::build_anchor_chain;
use crate::alignment::anchor_discovery::{
    Anchor, discover_anchors_from_meta, discover_context_anchors, discover_local_anchors,
};
use crate::alignment::gap_strategy::{GapStrategy, select_gap_strategy};
use crate::alignment::move_extraction::{find_block_move, moves_from_matched_pairs};
use crate::alignment::runs::{RowRun, compress_to_runs};
use crate::alignment_types::{RowAlignment, RowBlockMove};
use crate::config::DiffConfig;
use crate::grid_metadata::RowMeta;
use crate::grid_view::GridView;
#[cfg(any(test, feature = "dev-apis"))]
use crate::workbook::Grid;
use crate::workbook::RowSignature;

#[derive(Default)]
struct GapAlignmentResult {
    matched: Vec<(u32, u32)>,
    inserted: Vec<u32>,
    deleted: Vec<u32>,
    moves: Vec<RowBlockMove>,
}

struct GapCtx<'a> {
    old_range: Range<u32>,
    new_range: Range<u32>,
    old_slice: &'a [RowMeta],
    new_slice: &'a [RowMeta],
}

impl<'a> GapCtx<'a> {
    fn new(
        old_meta: &'a [RowMeta],
        new_meta: &'a [RowMeta],
        old_range: Range<u32>,
        new_range: Range<u32>,
    ) -> Self {
        let old_slice = slice_by_range(old_meta, &old_range);
        let new_slice = slice_by_range(new_meta, &new_range);
        Self {
            old_range,
            new_range,
            old_slice,
            new_slice,
        }
    }

    fn insert_all(&self) -> GapAlignmentResult {
        GapAlignmentResult {
            inserted: (self.new_range.start..self.new_range.end).collect(),
            ..Default::default()
        }
    }

    fn delete_all(&self) -> GapAlignmentResult {
        GapAlignmentResult {
            deleted: (self.old_range.start..self.old_range.end).collect(),
            ..Default::default()
        }
    }
}

#[derive(Debug, Clone, PartialEq, Eq)]
pub struct RowAlignmentWithSignatures {
    pub alignment: RowAlignment,
    pub row_signatures_a: Vec<RowSignature>,
    pub row_signatures_b: Vec<RowSignature>,
}

#[cfg(test)]
pub fn align_rows_amr(old: &Grid, new: &Grid, config: &DiffConfig) -> Option<RowAlignment> {
    align_rows_amr_with_signatures(old, new, config).map(|result| result.alignment)
}

#[cfg(any(test, feature = "dev-apis"))]
pub fn align_rows_amr_with_signatures(
    old: &Grid,
    new: &Grid,
    config: &DiffConfig,
) -> Option<RowAlignmentWithSignatures> {
    let view_a = GridView::from_grid_with_config(old, config);
    let view_b = GridView::from_grid_with_config(new, config);
    align_rows_amr_with_signatures_from_views(&view_a, &view_b, config)
}

pub fn align_rows_amr_with_signatures_from_views(
    view_a: &GridView,
    view_b: &GridView,
    config: &DiffConfig,
) -> Option<RowAlignmentWithSignatures> {
    let alignment = align_rows_from_meta(&view_a.row_meta, &view_b.row_meta, config)?;
    let row_signatures_a: Vec<RowSignature> =
        view_a.row_meta.iter().map(|meta| meta.signature).collect();
    let row_signatures_b: Vec<RowSignature> =
        view_b.row_meta.iter().map(|meta| meta.signature).collect();

    Some(RowAlignmentWithSignatures {
        alignment,
        row_signatures_a,
        row_signatures_b,
    })
}

fn align_rows_from_meta(
    rows_a: &[RowMeta],
    rows_b: &[RowMeta],
    config: &DiffConfig,
) -> Option<RowAlignment> {
    if rows_a.len() == rows_b.len()
        && rows_a
            .iter()
            .zip(rows_b.iter())
            .all(|(a, b)| a.signature == b.signature)
    {
        let mut matched = Vec::with_capacity(rows_a.len());
        for (a, b) in rows_a.iter().zip(rows_b.iter()) {
            matched.push((a.row_idx, b.row_idx));
        }
        return Some(RowAlignment {
            matched,
            inserted: Vec::new(),
            deleted: Vec::new(),
            moves: Vec::new(),
        });
    }

    let runs_a = compress_to_runs(rows_a);
    let runs_b = compress_to_runs(rows_b);
    if runs_a.len() == 1 && runs_b.len() == 1 && runs_a[0].signature == runs_b[0].signature {
        let shared = runs_a[0].count.min(runs_b[0].count);
        let mut matched = Vec::new();
        for offset in 0..shared {
            matched.push((runs_a[0].start_row + offset, runs_b[0].start_row + offset));
        }
        let mut inserted = Vec::new();
        if runs_b[0].count > shared {
            inserted
                .extend((runs_b[0].start_row + shared)..(runs_b[0].start_row + runs_b[0].count));
        }
        let mut deleted = Vec::new();
        if runs_a[0].count > shared {
            deleted.extend((runs_a[0].start_row + shared)..(runs_a[0].start_row + runs_a[0].count));
        }
        return Some(RowAlignment {
            matched,
            inserted,
            deleted,
            moves: Vec::new(),
        });
    }

    let compressed_a = runs_a.len() * 2 <= rows_a.len();
    let compressed_b = runs_b.len() * 2 <= rows_b.len();
    if (compressed_a || compressed_b)
        && !runs_a.is_empty()
        && !runs_b.is_empty()
        && let Some(alignment) = align_runs_stable(&runs_a, &runs_b)
    {
        return Some(alignment);
    }

    let anchors = build_anchor_chain(discover_anchors_from_meta(rows_a, rows_b));
    Some(assemble_from_meta(rows_a, rows_b, anchors, config, 0))
}

fn assemble_from_meta(
    old_meta: &[RowMeta],
    new_meta: &[RowMeta],
    anchors: Vec<Anchor>,
    config: &DiffConfig,
    depth: u32,
) -> RowAlignment {
    if old_meta.is_empty() && new_meta.is_empty() {
        return RowAlignment::default();
    }

    let mut matched = Vec::new();
    let mut inserted = Vec::new();
    let mut deleted = Vec::new();
    let mut moves = Vec::new();

    let mut prev_old = old_meta.first().map(|m| m.row_idx).unwrap_or(0);
    let mut prev_new = new_meta.first().map(|m| m.row_idx).unwrap_or(0);

    for anchor in anchors.iter() {
        let gap_old = prev_old..anchor.old_row;
        let gap_new = prev_new..anchor.new_row;
        let gap_result = fill_gap(gap_old, gap_new, old_meta, new_meta, config, depth);
        matched.extend(gap_result.matched);
        inserted.extend(gap_result.inserted);
        deleted.extend(gap_result.deleted);
        moves.extend(gap_result.moves);

        matched.push((anchor.old_row, anchor.new_row));
        prev_old = anchor.old_row + 1;
        prev_new = anchor.new_row + 1;
    }

    let old_end = old_meta.last().map(|m| m.row_idx + 1).unwrap_or(prev_old);
    let new_end = new_meta.last().map(|m| m.row_idx + 1).unwrap_or(prev_new);
    let tail_result = fill_gap(
        prev_old..old_end,
        prev_new..new_end,
        old_meta,
        new_meta,
        config,
        depth,
    );
    matched.extend(tail_result.matched);
    inserted.extend(tail_result.inserted);
    deleted.extend(tail_result.deleted);
    moves.extend(tail_result.moves);

    matched.sort_by_key(|(a, b)| (*a, *b));
    inserted.sort_unstable();
    deleted.sort_unstable();
    moves.sort_by_key(|m| (m.src_start_row, m.dst_start_row, m.row_count));

    RowAlignment {
        matched,
        inserted,
        deleted,
        moves,
    }
}

fn fill_gap(
    old_gap: Range<u32>,
    new_gap: Range<u32>,
    old_meta: &[RowMeta],
    new_meta: &[RowMeta],
    config: &DiffConfig,
    depth: u32,
) -> GapAlignmentResult {
    let ctx = GapCtx::new(old_meta, new_meta, old_gap, new_gap);
    let has_recursed = depth >= config.max_recursion_depth;
    let strategy = select_gap_strategy(ctx.old_slice, ctx.new_slice, config, has_recursed);

    match strategy {
        GapStrategy::Empty => GapAlignmentResult::default(),
        GapStrategy::InsertAll => ctx.insert_all(),
        GapStrategy::DeleteAll => ctx.delete_all(),
        GapStrategy::SmallEdit => align_gap_default(ctx.old_slice, ctx.new_slice, config),
        GapStrategy::HashFallback => align_gap_hash(ctx.old_slice, ctx.new_slice),
        GapStrategy::MoveCandidate => align_gap_with_moves(ctx.old_slice, ctx.new_slice, config),
        GapStrategy::RecursiveAlign => {
            align_gap_recursive(ctx.old_slice, ctx.new_slice, config, depth)
        }
    }
}

fn align_gap_default(
    old_slice: &[RowMeta],
    new_slice: &[RowMeta],
    config: &DiffConfig,
) -> GapAlignmentResult {
    if old_slice.len() as u32 > config.max_lcs_gap_size
        || new_slice.len() as u32 > config.max_lcs_gap_size
    {
        return align_gap_via_hash(old_slice, new_slice);
    }
    align_small_gap(old_slice, new_slice, config)
}

fn align_gap_hash(old_slice: &[RowMeta], new_slice: &[RowMeta]) -> GapAlignmentResult {
    let mut result = align_gap_via_hash(old_slice, new_slice);
    result
        .moves
        .extend(moves_from_matched_pairs(&result.matched));
    result
}

fn align_gap_with_moves(
    old_slice: &[RowMeta],
    new_slice: &[RowMeta],
    config: &DiffConfig,
) -> GapAlignmentResult {
    let mut result = if old_slice.len() as u32 > config.max_lcs_gap_size
        || new_slice.len() as u32 > config.max_lcs_gap_size
    {
        align_gap_via_hash(old_slice, new_slice)
    } else {
        align_small_gap(old_slice, new_slice, config)
    };

    let mut detected_moves = moves_from_matched_pairs(&result.matched);

    if detected_moves.is_empty() {
        let has_nonzero_offset = result
            .matched
            .iter()
            .any(|(a, b)| (*b as i64 - *a as i64) != 0);

        if has_nonzero_offset
            && let Some(mv) =
                find_block_move(old_slice, new_slice, config.min_block_size_for_move, config)
        {
            detected_moves.push(mv);
        }
    }

    result.moves.extend(detected_moves);
    result
}

fn recursive_anchor_candidates(
    old_slice: &[RowMeta],
    new_slice: &[RowMeta],
    depth: u32,
    config: &DiffConfig,
) -> Vec<Anchor> {
    if depth == 0 {
        return discover_anchors_from_meta(old_slice, new_slice);
    }

    let k1 = config.context_anchor_k1 as usize;
    let k2 = config.context_anchor_k2 as usize;

    let mut anchors = discover_local_anchors(old_slice, new_slice);
    if anchors.is_empty() {
        anchors = discover_context_anchors(old_slice, new_slice, k1);
        if anchors.is_empty() {
            anchors = discover_context_anchors(old_slice, new_slice, k2);
        }
        return anchors;
    }

    if anchors.len() < k1 {
        let mut ctx_anchors = discover_context_anchors(old_slice, new_slice, k1);
        anchors.append(&mut ctx_anchors);
    }

    anchors
}

fn align_gap_recursive(
    old_slice: &[RowMeta],
    new_slice: &[RowMeta],
    config: &DiffConfig,
    depth: u32,
) -> GapAlignmentResult {
    let at_limit = depth >= config.max_recursion_depth;
    if at_limit {
        return align_gap_default(old_slice, new_slice, config);
    }

    let anchors = build_anchor_chain(recursive_anchor_candidates(
        old_slice, new_slice, depth, config,
    ));

    if anchors.is_empty() {
        return align_gap_default(old_slice, new_slice, config);
    }

    let alignment = assemble_from_meta(old_slice, new_slice, anchors, config, depth + 1);
    GapAlignmentResult {
        matched: alignment.matched,
        inserted: alignment.inserted,
        deleted: alignment.deleted,
        moves: alignment.moves,
    }
}

fn align_runs_stable(runs_a: &[RowRun], runs_b: &[RowRun]) -> Option<RowAlignment> {
    let mut matched = Vec::new();
    let mut inserted = Vec::new();
    let mut deleted = Vec::new();

    let mut idx_a = 0usize;
    let mut idx_b = 0usize;

    while idx_a < runs_a.len() && idx_b < runs_b.len() {
        let run_a = &runs_a[idx_a];
        let run_b = &runs_b[idx_b];

        if run_a.signature != run_b.signature {
            return None;
        }

        let shared = run_a.count.min(run_b.count);
        for offset in 0..shared {
            matched.push((run_a.start_row + offset, run_b.start_row + offset));
        }

        if run_a.count > shared {
            for offset in shared..run_a.count {
                deleted.push(run_a.start_row + offset);
            }
        }

        if run_b.count > shared {
            for offset in shared..run_b.count {
                inserted.push(run_b.start_row + offset);
            }
        }

        idx_a += 1;
        idx_b += 1;
    }

    for run in runs_a.iter().skip(idx_a) {
        for offset in 0..run.count {
            deleted.push(run.start_row + offset);
        }
    }

    for run in runs_b.iter().skip(idx_b) {
        for offset in 0..run.count {
            inserted.push(run.start_row + offset);
        }
    }

    matched.sort_by_key(|(a, b)| (*a, *b));
    inserted.sort_unstable();
    deleted.sort_unstable();

    Some(RowAlignment {
        matched,
        inserted,
        deleted,
        moves: Vec::new(),
    })
}

fn slice_by_range<'a>(meta: &'a [RowMeta], range: &Range<u32>) -> &'a [RowMeta] {
    if meta.is_empty() || range.start >= range.end {
        return &[];
    }
    let base = meta.first().map(|m| m.row_idx).unwrap_or(0);
    if range.start < base {
        return &[];
    }
    let start = (range.start - base) as usize;
    if start >= meta.len() {
        return &[];
    }
    let end = (start + (range.end - range.start) as usize).min(meta.len());
    &meta[start..end]
}

fn align_small_gap(
    old_slice: &[RowMeta],
    new_slice: &[RowMeta],
    config: &DiffConfig,
) -> GapAlignmentResult {
    let m = old_slice.len();
    let n = new_slice.len();
    if m == 0 && n == 0 {
        return GapAlignmentResult::default();
    }

    if m as u32 > config.max_lcs_gap_size || n as u32 > config.max_lcs_gap_size {
        return align_gap_via_hash(old_slice, new_slice);
    }

    if m.saturating_mul(n) > config.lcs_dp_work_limit {
        return align_gap_via_myers(old_slice, new_slice);
    }

    let mut dp = vec![vec![0u32; n + 1]; m + 1];
    for i in (0..m).rev() {
        for j in (0..n).rev() {
            if old_slice[i].signature == new_slice[j].signature {
                dp[i][j] = dp[i + 1][j + 1] + 1;
            } else {
                dp[i][j] = dp[i + 1][j].max(dp[i][j + 1]);
            }
        }
    }

    let mut matched = Vec::new();
    let mut inserted = Vec::new();
    let mut deleted = Vec::new();

    let mut i = 0usize;
    let mut j = 0usize;
    while i < m && j < n {
        if old_slice[i].signature == new_slice[j].signature {
            matched.push((old_slice[i].row_idx, new_slice[j].row_idx));
            i += 1;
            j += 1;
        } else if dp[i + 1][j] >= dp[i][j + 1] {
            deleted.push(old_slice[i].row_idx);
            i += 1;
        } else {
            inserted.push(new_slice[j].row_idx);
            j += 1;
        }
    }

    while i < m {
        deleted.push(old_slice[i].row_idx);
        i += 1;
    }
    while j < n {
        inserted.push(new_slice[j].row_idx);
        j += 1;
    }

    if matched.is_empty() && m == n {
        matched = old_slice
            .iter()
            .zip(new_slice.iter())
            .map(|(a, b)| (a.row_idx, b.row_idx))
            .collect();
        inserted.clear();
        deleted.clear();
    }

    GapAlignmentResult {
        matched,
        inserted,
        deleted,
        moves: Vec::new(),
    }
}

fn align_gap_via_myers(old_slice: &[RowMeta], new_slice: &[RowMeta]) -> GapAlignmentResult {
    let m = old_slice.len();
    let n = new_slice.len();
    if m == 0 && n == 0 {
        return GapAlignmentResult::default();
    }

    let edits = myers_edit_script(old_slice, new_slice);

    let mut matched = Vec::new();
    let mut inserted = Vec::new();
    let mut deleted = Vec::new();

    for edit in edits {
        match edit {
            Edit::Match(i, j) => matched.push((old_slice[i].row_idx, new_slice[j].row_idx)),
            Edit::Insert(j) => inserted.push(new_slice[j].row_idx),
            Edit::Delete(i) => deleted.push(old_slice[i].row_idx),
        }
    }

    if matched.is_empty() && m == n {
        matched = old_slice
            .iter()
            .zip(new_slice.iter())
            .map(|(a, b)| (a.row_idx, b.row_idx))
            .collect();
        inserted.clear();
        deleted.clear();
    }

    matched.sort_by_key(|(a, b)| (*a, *b));
    inserted.sort_unstable();
    deleted.sort_unstable();

    GapAlignmentResult {
        matched,
        inserted,
        deleted,
        moves: Vec::new(),
    }
}

#[derive(Clone, Copy, Debug, PartialEq, Eq)]
enum Edit {
    Match(usize, usize),
    Insert(usize),
    Delete(usize),
}

fn myers_edit_script(old_slice: &[RowMeta], new_slice: &[RowMeta]) -> Vec<Edit> {
    let n = old_slice.len() as isize;
    let m = new_slice.len() as isize;
    if n == 0 {
        return (0..m as usize).map(Edit::Insert).collect();
    }
    if m == 0 {
        return (0..n as usize).map(Edit::Delete).collect();
    }

    let max = (n + m) as usize;
    let offset = max as isize;
    let mut v = vec![0isize; 2 * max + 1];
    let mut trace: Vec<Vec<isize>> = Vec::new();

    for d in 0..=max {
        let mut v_next = v.clone();
        for k in (-(d as isize)..=d as isize).step_by(2) {
            let idx = (k + offset) as usize;
            let x_start = if k == -(d as isize) || (k != d as isize && v[idx - 1] < v[idx + 1]) {
                v[idx + 1]
            } else {
                v[idx - 1] + 1
            };

            let mut x = x_start;
            let mut y = x - k;
            while x < n
                && y < m
                && old_slice[x as usize].signature == new_slice[y as usize].signature
            {
                x += 1;
                y += 1;
            }
            v_next[idx] = x;
            if x >= n && y >= m {
                trace.push(v_next);
                return reconstruct_myers(trace, old_slice.len(), new_slice.len(), offset);
            }
        }
        trace.push(v_next.clone());
        v = v_next;
    }

    Vec::new()
}

fn reconstruct_myers(
    trace: Vec<Vec<isize>>,
    old_len: usize,
    new_len: usize,
    offset: isize,
) -> Vec<Edit> {
    let mut edits = Vec::new();
    let mut x = old_len as isize;
    let mut y = new_len as isize;

    for d_rev in (0..trace.len()).rev() {
        let v = &trace[d_rev];
        let k = x - y;
        let idx = (k + offset) as usize;

        let (prev_x, prev_y, from_down);
        if d_rev == 0 {
            prev_x = 0;
            prev_y = 0;
            from_down = false;
        } else {
            let use_down =
                k == -(d_rev as isize) || (k != d_rev as isize && v[idx - 1] < v[idx + 1]);
            let prev_k = if use_down { k + 1 } else { k - 1 };
            let prev_idx = (prev_k + offset) as usize;
            let prev_v = &trace[d_rev - 1];
            prev_x = prev_v[prev_idx].max(0);
            prev_y = (prev_x - prev_k).max(0);
            from_down = use_down;
        }

        let mut cur_x = x;
        let mut cur_y = y;
        while cur_x > prev_x && cur_y > prev_y {
            cur_x -= 1;
            cur_y -= 1;
            edits.push(Edit::Match(cur_x as usize, cur_y as usize));
        }

        if d_rev > 0 {
            if from_down {
                edits.push(Edit::Insert(prev_y as usize));
            } else {
                edits.push(Edit::Delete(prev_x as usize));
            }
        }

        x = prev_x;
        y = prev_y;
    }

    edits.reverse();
    edits
}

fn align_gap_via_hash(old_slice: &[RowMeta], new_slice: &[RowMeta]) -> GapAlignmentResult {
    use std::collections::{HashMap, VecDeque};

    let m = old_slice.len();
    let n = new_slice.len();
    if m == 0 && n == 0 {
        return GapAlignmentResult::default();
    }

    let mut sig_to_new: HashMap<crate::workbook::RowSignature, VecDeque<u32>> = HashMap::new();
    for (j, meta) in new_slice.iter().enumerate() {
        sig_to_new
            .entry(meta.signature)
            .or_default()
            .push_back(j as u32);
    }

    let mut candidate_pairs: Vec<(u32, u32)> = Vec::new();
    for (i, meta) in old_slice.iter().enumerate() {
        if let Some(q) = sig_to_new.get_mut(&meta.signature)
            && let Some(j) = q.pop_front()
        {
            candidate_pairs.push((i as u32, j));
        }
    }

    if candidate_pairs.is_empty() && m == n {
        let matched = old_slice
            .iter()
            .zip(new_slice.iter())
            .map(|(a, b)| (a.row_idx, b.row_idx))
            .collect();

        return GapAlignmentResult {
            matched,
            inserted: Vec::new(),
            deleted: Vec::new(),
            moves: Vec::new(),
        };
    }

    let lis = lis_indices_u32(&candidate_pairs, |&(_, new_j)| new_j);

    let mut keep = vec![false; candidate_pairs.len()];
    for idx in lis {
        keep[idx] = true;
    }

    let mut used_old = vec![false; m];
    let mut used_new = vec![false; n];
    let mut matched: Vec<(u32, u32)> = Vec::new();

    for (k, (old_i, new_j)) in candidate_pairs.iter().copied().enumerate() {
        if keep[k] {
            used_old[old_i as usize] = true;
            used_new[new_j as usize] = true;
            matched.push((
                old_slice[old_i as usize].row_idx,
                new_slice[new_j as usize].row_idx,
            ));
        }
    }

    let mut deleted: Vec<u32> = Vec::new();
    for i in 0..m {
        if !used_old[i] {
            deleted.push(old_slice[i].row_idx);
        }
    }

    let mut inserted: Vec<u32> = Vec::new();
    for j in 0..n {
        if !used_new[j] {
            inserted.push(new_slice[j].row_idx);
        }
    }

    matched.sort_by_key(|(a, b)| (*a, *b));
    inserted.sort_unstable();
    deleted.sort_unstable();

    GapAlignmentResult {
        matched,
        inserted,
        deleted,
        moves: Vec::new(),
    }
}

fn lis_indices_u32<T, F>(items: &[T], key: F) -> Vec<usize>
where
    F: Fn(&T) -> u32,
{
    let mut piles: Vec<usize> = Vec::new();
    let mut predecessors: Vec<Option<usize>> = vec![None; items.len()];

    for (idx, item) in items.iter().enumerate() {
        let k = key(item);
        let pos = piles
            .binary_search_by_key(&k, |&pile_idx| key(&items[pile_idx]))
            .unwrap_or_else(|insert_pos| insert_pos);

        if pos > 0 {
            predecessors[idx] = Some(piles[pos - 1]);
        }

        if pos == piles.len() {
            piles.push(idx);
        } else {
            piles[pos] = idx;
        }
    }

    let Some(&last) = piles.last() else {
        return Vec::new();
    };

    let mut result: Vec<usize> = Vec::new();
    let mut current = last;
    loop {
        result.push(current);
        if let Some(prev) = predecessors[current] {
            current = prev;
        } else {
            break;
        }
    }
    result.reverse();
    result
}

#[cfg(test)]
mod tests {
    use super::*;
    use crate::grid_metadata::{FrequencyClass, RowMeta};
    use crate::workbook::CellValue;

    fn grid_from_run_lengths(pattern: &[(i32, u32)]) -> Grid {
        let total_rows: u32 = pattern.iter().map(|(_, count)| *count).sum();
        let mut grid = Grid::new(total_rows, 1);
        let mut row_idx = 0u32;
        for (val, count) in pattern {
            for _ in 0..*count {
                grid.insert_cell(row_idx, 0, Some(CellValue::Number(*val as f64)), None);
                row_idx = row_idx.saturating_add(1);
            }
        }
        grid
    }

    fn grid_with_unique_rows(rows: &[i32]) -> Grid {
        let nrows = rows.len() as u32;
        let mut grid = Grid::new(nrows, 1);
        for (r, &val) in rows.iter().enumerate() {
            grid.insert_cell(r as u32, 0, Some(CellValue::Number(val as f64)), None);
        }
        grid
    }

    fn row_meta_from_hashes(start_row: u32, hashes: &[u128]) -> Vec<RowMeta> {
        hashes
            .iter()
            .enumerate()
            .map(|(idx, &hash)| {
                let signature = crate::workbook::RowSignature { hash };
                RowMeta {
                    row_idx: start_row + idx as u32,
                    signature,
                    non_blank_count: 1,
                    first_non_blank_col: 0,
                    frequency_class: FrequencyClass::Common,
                    is_low_info: false,
                }
            })
            .collect()
    }

    #[test]
    fn aligns_compressed_runs_with_insert_and_delete() {
        let grid_a = grid_from_run_lengths(&[(1, 50), (2, 5), (1, 50)]);
        let grid_b = grid_from_run_lengths(&[(1, 52), (2, 3), (1, 50)]);

        let config = DiffConfig::default();
        let alignment = align_rows_amr(&grid_a, &grid_b, &config)
            .expect("alignment should succeed for repetitive runs");
        assert!(alignment.moves.is_empty());
        assert_eq!(alignment.inserted.len(), 2);
        assert_eq!(alignment.deleted.len(), 2);
        assert_eq!(alignment.matched.len(), 103);
        assert_eq!(alignment.matched[0], (0, 0));
    }

    #[test]
    fn run_alignment_falls_back_on_mismatch() {
        let grid_a = grid_from_run_lengths(&[(1, 3), (2, 3), (1, 3)]);
        let grid_b = grid_from_run_lengths(&[(1, 3), (3, 3), (1, 3)]);

        let config = DiffConfig::default();
        let alignment = align_rows_amr(&grid_a, &grid_b, &config)
            .expect("alignment should still produce result via full AMR");
        assert!(!alignment.matched.is_empty());
    }

    #[test]
    fn amr_disjoint_gaps_with_insertions_and_deletions() {
        let grid_a = grid_with_unique_rows(&[1, 2, 3, 100, 4, 5, 6, 200, 7, 8, 9]);
        let grid_b = grid_with_unique_rows(&[1, 2, 10, 3, 4, 5, 6, 7, 20, 8, 9]);

        let config = DiffConfig::default();
        let alignment = align_rows_amr(&grid_a, &grid_b, &config)
            .expect("alignment should succeed with disjoint gaps");

        assert!(!alignment.matched.is_empty(), "should have matched pairs");

        let matched_is_monotonic = alignment
            .matched
            .windows(2)
            .all(|w| w[0].0 <= w[1].0 && w[0].1 <= w[1].1);
        assert!(
            matched_is_monotonic,
            "matched pairs should be monotonically increasing"
        );

        assert!(
            !alignment.inserted.is_empty() || !alignment.deleted.is_empty(),
            "should have insertions and/or deletions"
        );
    }

    #[test]
    fn amr_recursive_gap_alignment_returns_monotonic_alignment() {
        let grid_a = grid_with_unique_rows(&[1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15]);
        let rows_b = vec![
            1, 2, 100, 3, 4, 5, 200, 6, 7, 8, 300, 9, 10, 11, 400, 12, 13, 14, 15,
        ];
        let grid_b = grid_with_unique_rows(&rows_b);

        let config = DiffConfig {
            recursive_align_threshold: 5,
            small_gap_threshold: 2,
            ..Default::default()
        };

        let alignment = align_rows_amr(&grid_a, &grid_b, &config)
            .expect("alignment should succeed with recursive gaps");

        let matched_is_monotonic = alignment
            .matched
            .windows(2)
            .all(|w| w[0].0 <= w[1].0 && w[0].1 <= w[1].1);
        assert!(
            matched_is_monotonic,
            "recursive alignment should produce monotonic matched pairs"
        );

        for &inserted_row in &alignment.inserted {
            assert!(
                !alignment.matched.iter().any(|(_, b)| *b == inserted_row),
                "inserted rows should not appear in matched pairs"
            );
        }

        for &deleted_row in &alignment.deleted {
            assert!(
                !alignment.matched.iter().any(|(a, _)| *a == deleted_row),
                "deleted rows should not appear in matched pairs"
            );
        }
    }

    #[test]
    fn amr_multi_gap_move_detection_produces_expected_row_block_move() {
        let grid_a = grid_with_unique_rows(&[1, 2, 3, 4, 5, 6, 7, 8, 9, 10]);
        let grid_b = grid_with_unique_rows(&[1, 2, 6, 7, 8, 3, 4, 5, 9, 10]);

        let config = DiffConfig::default();
        let alignment = align_rows_amr(&grid_a, &grid_b, &config)
            .expect("alignment should succeed with moved block");

        assert!(
            !alignment.matched.is_empty(),
            "should have matched pairs even with moves"
        );

        let old_rows: std::collections::HashSet<_> =
            alignment.matched.iter().map(|(a, _)| *a).collect();
        let new_rows: std::collections::HashSet<_> =
            alignment.matched.iter().map(|(_, b)| *b).collect();

        assert!(
            old_rows.len() <= 10 && new_rows.len() <= 10,
            "matched rows should not exceed input size"
        );
    }

    #[test]
    fn amr_alignment_empty_grids() {
        let grid_a = Grid::new(0, 0);
        let grid_b = Grid::new(0, 0);

        let config = DiffConfig::default();
        let alignment = align_rows_amr(&grid_a, &grid_b, &config)
            .expect("alignment should succeed for empty grids");

        assert!(alignment.matched.is_empty());
        assert!(alignment.inserted.is_empty());
        assert!(alignment.deleted.is_empty());
        assert!(alignment.moves.is_empty());
    }

    #[test]
    fn align_rows_amr_with_signatures_exposes_row_hashes() {
        let grid_a = grid_with_unique_rows(&[1, 2, 3, 4]);
        let grid_b = grid_with_unique_rows(&[1, 2, 3, 4]);

        let config = DiffConfig::default();
        let result =
            align_rows_amr_with_signatures(&grid_a, &grid_b, &config).expect("should align");

        assert_eq!(result.row_signatures_a.len(), grid_a.nrows as usize);
        assert_eq!(result.row_signatures_b.len(), grid_b.nrows as usize);
        assert_eq!(result.alignment.matched.len(), grid_a.nrows as usize);

        for row in 0..grid_a.nrows {
            let expected_a = grid_a.compute_row_signature(row);
            let expected_b = grid_b.compute_row_signature(row);
            assert_eq!(
                Some(expected_a),
                result.row_signatures_a.get(row as usize).copied(),
                "row {} signature for grid A should match compute_row_signature",
                row
            );
            assert_eq!(
                Some(expected_b),
                result.row_signatures_b.get(row as usize).copied(),
                "row {} signature for grid B should match compute_row_signature",
                row
            );
        }
    }

    #[test]
    fn amr_alignment_all_deleted() {
        let grid_a = grid_with_unique_rows(&[1, 2, 3, 4, 5]);
        let grid_b = Grid::new(0, 1);

        let config = DiffConfig::default();
        let alignment = align_rows_amr(&grid_a, &grid_b, &config)
            .expect("alignment should succeed when all rows deleted");

        assert!(alignment.matched.is_empty());
        assert!(alignment.inserted.is_empty());
        assert_eq!(alignment.deleted.len(), 5);
    }

    #[test]
    fn amr_alignment_all_inserted() {
        let grid_a = Grid::new(0, 1);
        let grid_b = grid_with_unique_rows(&[1, 2, 3, 4, 5]);

        let config = DiffConfig::default();
        let alignment = align_rows_amr(&grid_a, &grid_b, &config)
            .expect("alignment should succeed when all rows inserted");

        assert!(alignment.matched.is_empty());
        assert_eq!(alignment.inserted.len(), 5);
        assert!(alignment.deleted.is_empty());
    }

    #[test]
    fn align_small_gap_enforces_cap_with_hash_fallback() {
        let config = DiffConfig::default();
        let large = (config.max_lcs_gap_size + 1) as usize;
        let old_hashes: Vec<u128> = (0..large as u32).map(|i| i as u128).collect();
        let new_hashes: Vec<u128> = (0..large as u32).map(|i| (10_000 + i) as u128).collect();

        let old_meta = row_meta_from_hashes(10, &old_hashes);
        let new_meta = row_meta_from_hashes(20, &new_hashes);

        let result = align_small_gap(&old_meta, &new_meta, &config);
        assert_eq!(result.matched.len(), large);
        assert!(result.inserted.is_empty());
        assert!(result.deleted.is_empty());
        assert_eq!(result.matched.first(), Some(&(10, 20)));
        assert_eq!(
            result.matched.last(),
            Some(&(10 + large as u32 - 1, 20 + large as u32 - 1))
        );
    }

    #[test]
    fn hash_fallback_produces_monotone_pairs() {
        let old_meta = row_meta_from_hashes(0, &[1, 2, 3, 4]);
        let new_meta = row_meta_from_hashes(0, &[2, 1, 3, 4]);

        let result = align_gap_via_hash(&old_meta, &new_meta);
        assert_eq!(result.matched, vec![(1, 0), (2, 2), (3, 3)]);

        let is_monotone = result
            .matched
            .windows(2)
            .all(|w| w[0].0 <= w[1].0 && w[0].1 <= w[1].1);
        assert!(is_monotone, "hash fallback must preserve monotone ordering");
        assert_eq!(result.inserted, vec![1]);
        assert_eq!(result.deleted, vec![0]);
    }

    #[test]
    fn myers_handles_medium_gap_with_single_insertion() {
        let count = 300usize;
        let old_hashes: Vec<u128> = (0..count as u128).collect();
        let mut new_hashes: Vec<u128> = old_hashes.clone();
        new_hashes.insert(150, 9_999);

        let old_meta = row_meta_from_hashes(0, &old_hashes);
        let new_meta = row_meta_from_hashes(0, &new_hashes);

        let result = align_small_gap(&old_meta, &new_meta, &DiffConfig::default());
        assert_eq!(result.inserted, vec![150]);
        assert!(result.deleted.is_empty());
        assert_eq!(result.matched.len(), count);
        assert_eq!(result.matched.first(), Some(&(0, 0)));
        assert_eq!(
            result.matched.last(),
            Some(&(count as u32 - 1, (count + 1) as u32 - 1))
        );
    }
}

```

---

### File: `core\src\alignment\gap_strategy.rs`

```rust
//! Gap strategy selection for AMR alignment.
//!
//! Implements gap strategy selection as described in the unified grid diff
//! specification Sections 9.6 and 12. After anchors divide the grids into
//! gaps, each gap is processed according to its characteristics:
//!
//! - **Empty**: Both sides empty, nothing to do
//! - **InsertAll**: Old side empty, all new rows are insertions
//! - **DeleteAll**: New side empty, all old rows are deletions
//! - **SmallEdit**: Both sides small enough for O(n*m) LCS alignment
//! - **MoveCandidate**: Gap contains matching unique signatures that may indicate moves
//! - **RecursiveAlign**: Gap is large; recursively apply AMR with rare anchors
//! - **HashFallback**: Monotone hash/LIS fallback for large gaps

use std::collections::HashSet;

use crate::config::DiffConfig;
use crate::grid_metadata::{FrequencyClass, RowMeta};

#[derive(Clone, Copy, Debug, PartialEq, Eq)]
pub enum GapStrategy {
    Empty,
    InsertAll,
    DeleteAll,
    SmallEdit,
    MoveCandidate,
    RecursiveAlign,
    HashFallback,
}

pub fn select_gap_strategy(
    old_slice: &[RowMeta],
    new_slice: &[RowMeta],
    config: &DiffConfig,
    has_recursed: bool,
) -> GapStrategy {
    let old_len = old_slice.len() as u32;
    let new_len = new_slice.len() as u32;

    if old_len == 0 && new_len == 0 {
        return GapStrategy::Empty;
    }
    if old_len == 0 {
        return GapStrategy::InsertAll;
    }
    if new_len == 0 {
        return GapStrategy::DeleteAll;
    }

    let is_move_candidate = has_matching_signatures(old_slice, new_slice);

    let small_threshold = config.small_gap_threshold.min(config.max_lcs_gap_size);
    if old_len <= small_threshold && new_len <= small_threshold {
        return if is_move_candidate {
            GapStrategy::MoveCandidate
        } else {
            GapStrategy::SmallEdit
        };
    }

    if (old_len > config.recursive_align_threshold || new_len > config.recursive_align_threshold)
        && !has_recursed
    {
        return GapStrategy::RecursiveAlign;
    }

    if is_move_candidate {
        return GapStrategy::MoveCandidate;
    }

    if old_len > config.max_lcs_gap_size || new_len > config.max_lcs_gap_size {
        return GapStrategy::HashFallback;
    }

    GapStrategy::SmallEdit
}

fn has_matching_signatures(old_slice: &[RowMeta], new_slice: &[RowMeta]) -> bool {
    let set: HashSet<_> = old_slice
        .iter()
        .filter(|m| m.frequency_class == FrequencyClass::Unique)
        .map(|m| m.signature)
        .collect();

    new_slice
        .iter()
        .filter(|m| m.frequency_class == FrequencyClass::Unique)
        .any(|m| set.contains(&m.signature))
}

#[cfg(test)]
mod tests {
    use super::*;
    use crate::grid_metadata::{FrequencyClass, RowMeta};
    use crate::workbook::RowSignature;

    fn meta(row_idx: u32, hash: u128) -> RowMeta {
        let signature = RowSignature { hash };
        RowMeta {
            row_idx,
            signature,
            non_blank_count: 1,
            first_non_blank_col: 0,
            frequency_class: FrequencyClass::Common,
            is_low_info: false,
        }
    }

    #[test]
    fn respects_configured_max_lcs_gap_size() {
        let config = DiffConfig {
            max_lcs_gap_size: 2,
            small_gap_threshold: 10,
            ..Default::default()
        };
        let rows_a = vec![meta(0, 1), meta(1, 2), meta(2, 3)];
        let rows_b = vec![meta(0, 4), meta(1, 5), meta(2, 6)];

        let strategy = select_gap_strategy(&rows_a, &rows_b, &config, false);
        assert_eq!(strategy, GapStrategy::HashFallback);
    }
}

```

---

### File: `core\src\alignment\mod.rs`

```rust
//! Anchor-Move-Refine (AMR) row alignment algorithm.
//!
//! This module implements a simplified version of the AMR algorithm described in the
//! unified grid diff specification. The implementation follows the general structure:
//!
//! 1. **Row Metadata Collection** (`grid_metadata.rs`, Spec Section 9.11)
//!    - Compute row signatures and classify by frequency (Unique/Rare/Common/LowInfo)
//!
//! 2. **Anchor Discovery** (`anchor_discovery.rs`, Spec Section 10)
//!    - Find rows that are unique in both grids with matching signatures
//!
//! 3. **Anchor Chain Construction** (`anchor_chain.rs`, Spec Section 10)
//!    - Build longest increasing subsequence (LIS) of anchors to preserve relative order
//!
//! 4. **Gap Strategy Selection** (`gap_strategy.rs`, Spec Sections 9.6, 12)
//!    - For each gap between anchors, select appropriate strategy:
//!      Empty, InsertAll, DeleteAll, SmallEdit, MoveCandidate, or RecursiveAlign
//!
//! 5. **Assembly** (`assembly.rs`, Spec Section 12)
//!    - Assemble final alignment by processing gaps and anchors
//!
//! ## Intentional Spec Deviations
//!
//! The current implementation simplifies the full AMR spec in the following ways:
//!
//! - **No global move-candidate extraction phase**: The full spec (Sections 9.5-9.7, 11)
//!   describes a global phase that extracts out-of-order matches before gap filling.
//!   This implementation instead detects moves opportunistically within gaps via
//!   `GapStrategy::MoveCandidate` and `find_block_move`. This is simpler but may miss
//!   some complex multi-block move patterns that the full spec would detect.
//!
//! - **No explicit move validation phase**: The spec describes validating move candidates
//!   (Section 11) to resolve conflicts. The current implementation accepts the first
//!   valid move found within each gap.
//!
//! - **RLE fast path**: For highly repetitive grids (>50% compression), the implementation
//!   uses a run-length encoded alignment path (`runs.rs`) that bypasses full AMR.
//!
//! These simplifications are acceptable for most real-world Excel workbooks and keep
//! the implementation maintainable. Future work may implement the full global move
//! extraction if complex reordering scenarios require it.

pub(crate) mod anchor_chain;
pub(crate) mod anchor_discovery;
pub(crate) mod assembly;
pub(crate) mod gap_strategy;
pub(crate) mod move_extraction;
pub(crate) mod runs;

pub(crate) use crate::alignment_types::RowBlockMove;
pub(crate) use assembly::align_rows_amr_with_signatures_from_views;

```

---

### File: `core\src\alignment\move_extraction.rs`

```rust
//! Move extraction from alignment gaps.
//!
//! Implements localized move detection within gaps. This is a simplified approach
//! compared to the full spec (Sections 9.5-9.7, 11) which describes global
//! move-candidate extraction and validation phases.
//!
//! ## Current Implementation
//!
//! - `find_block_move`: Scans for contiguous blocks of matching signatures
//!   between old and new slices within a gap. Returns the largest found.
//!
//! - `moves_from_matched_pairs`: Extracts block moves from matched row pairs
//!   where consecutive pairs have the same offset (indicating they moved together).
//!
//! ## Future Work (TODO)
//!
//! To implement full spec compliance, this module would need:
//!
//! 1. Global unanchored match collection (all out-of-order signature matches)
//! 2. Candidate move construction from unanchored matches
//! 3. Move validation to resolve overlapping/conflicting candidates
//! 4. Integration with gap filling to consume validated moves

use std::collections::HashMap;

use crate::alignment::RowBlockMove;
use crate::config::DiffConfig;
use crate::grid_metadata::RowMeta;
use crate::workbook::RowSignature;

pub fn find_block_move(
    old_slice: &[RowMeta],
    new_slice: &[RowMeta],
    min_len: u32,
    config: &DiffConfig,
) -> Option<RowBlockMove> {
    let max_slice_len = config.move_extraction_max_slice_len as usize;
    if old_slice.len() > max_slice_len || new_slice.len() > max_slice_len {
        return None;
    }

    let mut positions: HashMap<RowSignature, Vec<usize>> = HashMap::new();
    for (idx, meta) in old_slice.iter().enumerate() {
        if meta.is_low_info() {
            continue;
        }
        positions.entry(meta.signature).or_default().push(idx);
    }

    let mut best: Option<RowBlockMove> = None;
    let mut best_len: usize = 0;

    for (new_idx, meta) in new_slice.iter().enumerate() {
        if meta.is_low_info() {
            continue;
        }

        let Some(candidates) = positions.get(&meta.signature) else {
            continue;
        };

        let max_candidates = config.move_extraction_max_candidates_per_sig as usize;
        for &old_idx in candidates.iter().take(max_candidates) {
            let max_possible = (old_slice.len() - old_idx).min(new_slice.len() - new_idx);
            if max_possible <= best_len {
                continue;
            }

            let mut len = 0usize;
            while len < max_possible
                && old_slice[old_idx + len].signature == new_slice[new_idx + len].signature
            {
                len += 1;
            }

            if len >= min_len as usize && len > best_len {
                best_len = len;
                best = Some(RowBlockMove {
                    src_start_row: old_slice[old_idx].row_idx,
                    dst_start_row: new_slice[new_idx].row_idx,
                    row_count: len as u32,
                });
            }
        }
    }

    best
}

pub fn moves_from_matched_pairs(pairs: &[(u32, u32)]) -> Vec<RowBlockMove> {
    if pairs.is_empty() {
        return Vec::new();
    }

    let mut sorted = pairs.to_vec();
    sorted.sort_by_key(|(a, b)| (*a, *b));

    let mut moves = Vec::new();
    let mut start = sorted[0];
    let mut prev = sorted[0];
    let mut run_len = 1u32;
    let mut current_offset: i64 = prev.1 as i64 - prev.0 as i64;

    for &(a, b) in sorted.iter().skip(1) {
        let offset = b as i64 - a as i64;
        if offset == current_offset && a == prev.0 + 1 && b == prev.1 + 1 {
            run_len += 1;
            prev = (a, b);
            continue;
        }

        if run_len > 1 && current_offset != 0 {
            moves.push(RowBlockMove {
                src_start_row: start.0,
                dst_start_row: start.1,
                row_count: run_len,
            });
        }

        start = (a, b);
        prev = (a, b);
        current_offset = offset;
        run_len = 1;
    }

    if run_len > 1 && current_offset != 0 {
        moves.push(RowBlockMove {
            src_start_row: start.0,
            dst_start_row: start.1,
            row_count: run_len,
        });
    }

    moves
}

```

---

### File: `core\src\alignment\runs.rs`

```rust
//! Run-length encoding for repetitive row patterns.
//!
//! Implements run-length compression as described in the unified grid diff
//! specification Section 2.6 (optional optimization). For grids where >50%
//! of rows share signatures with adjacent rows, this provides a fast path
//! that avoids full AMR computation.
//!
//! This is particularly effective for:
//! - Template-based workbooks with many identical rows
//! - Data with long runs of blank or placeholder rows
//! - Adversarial cases designed to stress the alignment algorithm

use crate::grid_metadata::RowMeta;
use crate::workbook::RowSignature;

#[derive(Clone, Debug, PartialEq, Eq)]
pub struct RowRun {
    pub signature: RowSignature,
    pub start_row: u32,
    pub count: u32,
}

pub fn compress_to_runs(meta: &[RowMeta]) -> Vec<RowRun> {
    let mut runs = Vec::new();
    let mut i = 0usize;
    while i < meta.len() {
        let sig = meta[i].signature;
        let start = i;
        while i < meta.len() && meta[i].signature == sig {
            i += 1;
        }
        runs.push(RowRun {
            signature: sig,
            start_row: meta[start].row_idx,
            count: (i - start) as u32,
        });
    }
    runs
}

#[cfg(test)]
mod tests {
    use super::*;

    fn make_meta(idx: u32, hash: u128) -> RowMeta {
        let sig = RowSignature { hash };
        RowMeta {
            row_idx: idx,
            signature: sig,
            non_blank_count: 1,
            first_non_blank_col: 0,
            frequency_class: crate::grid_metadata::FrequencyClass::Common,
            is_low_info: false,
        }
    }

    #[test]
    fn compresses_identical_rows() {
        let meta = vec![make_meta(0, 1), make_meta(1, 1), make_meta(2, 2)];
        let runs = compress_to_runs(&meta);
        assert_eq!(runs.len(), 2);
        assert_eq!(runs[0].count, 2);
        assert_eq!(runs[1].count, 1);
    }

    #[test]
    fn compresses_10k_identical_rows_to_single_run() {
        let meta: Vec<RowMeta> = (0..10_000).map(|i| make_meta(i, 42)).collect();
        let runs = compress_to_runs(&meta);

        assert_eq!(
            runs.len(),
            1,
            "10K identical rows should compress to a single run"
        );
        assert_eq!(
            runs[0].count, 10_000,
            "single run should have count of 10,000"
        );
        assert_eq!(
            runs[0].signature.hash, 42,
            "run signature should match input"
        );
        assert_eq!(runs[0].start_row, 0, "run should start at row 0");
    }

    #[test]
    fn alternating_pattern_ab_does_not_overcompress() {
        let meta: Vec<RowMeta> = (0..10_000)
            .map(|i| {
                let hash = if i % 2 == 0 { 1 } else { 2 };
                make_meta(i, hash)
            })
            .collect();
        let runs = compress_to_runs(&meta);

        assert_eq!(
            runs.len(),
            10_000,
            "alternating A-B pattern should produce 10K runs (no compression benefit)"
        );

        for (i, run) in runs.iter().enumerate() {
            assert_eq!(
                run.count, 1,
                "each run should have count of 1 for alternating pattern"
            );
            let expected_hash = if i % 2 == 0 { 1 } else { 2 };
            assert_eq!(
                run.signature.hash, expected_hash,
                "run signature should alternate"
            );
        }
    }

    #[test]
    fn mixed_runs_with_varying_lengths() {
        let mut meta = Vec::new();
        let mut row_idx = 0u32;

        for _ in 0..100 {
            meta.push(make_meta(row_idx, 1));
            row_idx += 1;
        }
        for _ in 0..50 {
            meta.push(make_meta(row_idx, 2));
            row_idx += 1;
        }
        for _ in 0..200 {
            meta.push(make_meta(row_idx, 3));
            row_idx += 1;
        }
        for _ in 0..1 {
            meta.push(make_meta(row_idx, 4));
            row_idx += 1;
        }

        let runs = compress_to_runs(&meta);

        assert_eq!(
            runs.len(),
            4,
            "should produce 4 runs for 4 distinct signatures"
        );
        assert_eq!(runs[0].count, 100);
        assert_eq!(runs[1].count, 50);
        assert_eq!(runs[2].count, 200);
        assert_eq!(runs[3].count, 1);
    }

    #[test]
    fn empty_input_produces_empty_runs() {
        let meta: Vec<RowMeta> = vec![];
        let runs = compress_to_runs(&meta);
        assert!(runs.is_empty(), "empty input should produce empty runs");
    }

    #[test]
    fn single_row_produces_single_run() {
        let meta = vec![make_meta(0, 999)];
        let runs = compress_to_runs(&meta);

        assert_eq!(runs.len(), 1);
        assert_eq!(runs[0].count, 1);
        assert_eq!(runs[0].start_row, 0);
        assert_eq!(runs[0].signature.hash, 999);
    }

    #[test]
    fn run_compression_preserves_row_indices() {
        let meta: Vec<RowMeta> = (0..1000u32)
            .map(|i| make_meta(i, (i / 100) as u128))
            .collect();
        let runs = compress_to_runs(&meta);

        assert_eq!(runs.len(), 10, "should have 10 runs (one per 100 rows)");

        for (group_idx, run) in runs.iter().enumerate() {
            let expected_start = (group_idx * 100) as u32;
            assert_eq!(
                run.start_row, expected_start,
                "run {} should start at row {}",
                group_idx, expected_start
            );
            assert_eq!(run.count, 100, "each run should have 100 rows");
        }
    }
}

```

---

### File: `core\src\alignment_types.rs`

```rust
#[derive(Debug, Clone, PartialEq, Eq, Default)]
pub struct RowAlignment {
    pub matched: Vec<(u32, u32)>,
    pub inserted: Vec<u32>,
    pub deleted: Vec<u32>,
    pub moves: Vec<RowBlockMove>,
}

#[derive(Debug, Clone, Copy, PartialEq, Eq)]
pub struct RowBlockMove {
    pub src_start_row: u32,
    pub dst_start_row: u32,
    pub row_count: u32,
}

```

---

### File: `core\src\bin\wasm_smoke.rs`

```rust
use excel_diff::{
    CallbackSink, CellValue, DiffConfig, DiffSession, Grid, Sheet, SheetKind, Workbook,
    try_diff_workbooks_streaming,
};
use core::hint::black_box;

fn make_workbook(session: &mut DiffSession, value: f64) -> Workbook {
    let mut grid = Grid::new(1, 1);
    grid.insert_cell(0, 0, Some(CellValue::Number(value)), None);

    let sheet_name = session.strings.intern("WasmSmoke");

    Workbook {
        sheets: vec![Sheet {
            name: sheet_name,
            kind: SheetKind::Worksheet,
            grid,
        }],
        ..Default::default()
    }
}

fn main() {
    let mut session = DiffSession::new();
    let wb_a = make_workbook(&mut session, 1.0);
    let wb_b = make_workbook(&mut session, 2.0);

    let mut op_count = 0usize;
    let mut sink = CallbackSink::new(|_op| op_count += 1);
    if let Ok(summary) = try_diff_workbooks_streaming(
        &wb_a,
        &wb_b,
        &mut session.strings,
        &DiffConfig::default(),
        &mut sink,
    ) {
        black_box(summary.complete);
        black_box(summary.op_count);
        black_box(op_count);
    }
}

```

---

### File: `core\src\column_alignment.rs`

```rust
use crate::config::DiffConfig;
use crate::grid_view::{ColHash, ColMeta, GridView, HashStats};
use crate::hashing::hash_col_content_unordered_128;
use crate::workbook::{ColSignature, Grid};

#[derive(Debug, Clone, PartialEq, Eq)]
pub(crate) struct ColumnAlignment {
    pub(crate) matched: Vec<(u32, u32)>, // (col_idx_a, col_idx_b)
    pub(crate) inserted: Vec<u32>,       // columns present only in B
    pub(crate) deleted: Vec<u32>,        // columns present only in A
}

#[derive(Debug, Clone, Copy, PartialEq, Eq)]
pub(crate) struct ColumnBlockMove {
    pub src_start_col: u32,
    pub dst_start_col: u32,
    pub col_count: u32,
}

fn unordered_col_hashes(grid: &Grid) -> Vec<ColHash> {
    let mut col_cells: Vec<Vec<&crate::workbook::Cell>> = vec![Vec::new(); grid.ncols as usize];
    for ((_, col), cell) in grid.iter_cells() {
        let idx = col as usize;
        if idx < col_cells.len() {
            col_cells[idx].push(cell);
        }
    }
    col_cells
        .iter()
        .map(|cells| ColSignature {
            hash: hash_col_content_unordered_128(cells),
        })
        .collect()
}

pub(crate) fn detect_exact_column_block_move(
    old: &Grid,
    new: &Grid,
    config: &DiffConfig,
) -> Option<ColumnBlockMove> {
    if old.ncols != new.ncols || old.nrows != new.nrows {
        return None;
    }

    if old.ncols == 0 {
        return None;
    }

    if !is_within_size_bounds(old, new, config) {
        return None;
    }

    let view_a = GridView::from_grid_with_config(old, config);
    let view_b = GridView::from_grid_with_config(new, config);

    let unordered_a = unordered_col_hashes(old);
    let unordered_b = unordered_col_hashes(new);

    let col_meta_a: Vec<ColMeta> = view_a
        .col_meta
        .iter()
        .enumerate()
        .map(|(idx, meta)| ColMeta {
            hash: *unordered_a.get(idx).unwrap_or(&meta.hash),
            ..*meta
        })
        .collect();
    let col_meta_b: Vec<ColMeta> = view_b
        .col_meta
        .iter()
        .enumerate()
        .map(|(idx, meta)| ColMeta {
            hash: *unordered_b.get(idx).unwrap_or(&meta.hash),
            ..*meta
        })
        .collect();

    if view_a.is_blank_dominated() || view_b.is_blank_dominated() {
        return None;
    }

    let stats = HashStats::from_col_meta(&col_meta_a, &col_meta_b);
    if stats.has_heavy_repetition(config.max_hash_repeat) {
        return None;
    }

    let meta_a = &col_meta_a;
    let meta_b = &col_meta_b;
    let n = meta_a.len();

    if meta_a
        .iter()
        .zip(meta_b.iter())
        .all(|(a, b)| a.hash == b.hash)
    {
        return None;
    }

    let prefix = (0..n).find(|&idx| meta_a[idx].hash != meta_b[idx].hash)?;

    let mut suffix_len = 0usize;
    while suffix_len < n.saturating_sub(prefix) {
        let idx_a = n - 1 - suffix_len;
        let idx_b = n - 1 - suffix_len;
        if meta_a[idx_a].hash == meta_b[idx_b].hash {
            suffix_len += 1;
        } else {
            break;
        }
    }
    let tail_start = n - suffix_len;

    let try_candidate = |src_start: usize, dst_start: usize| -> Option<ColumnBlockMove> {
        if src_start >= tail_start || dst_start >= tail_start {
            return None;
        }

        let mut len = 0usize;
        while src_start + len < tail_start && dst_start + len < tail_start {
            if meta_a[src_start + len].hash != meta_b[dst_start + len].hash {
                break;
            }
            len += 1;
        }

        if len == 0 {
            return None;
        }

        let src_end = src_start + len;
        let dst_end = dst_start + len;

        if !(src_end <= dst_start || dst_end <= src_start) {
            return None;
        }

        let mut idx_a = 0usize;
        let mut idx_b = 0usize;

        loop {
            if idx_a == src_start {
                idx_a = src_end;
            }
            if idx_b == dst_start {
                idx_b = dst_end;
            }

            if idx_a >= n && idx_b >= n {
                break;
            }

            if idx_a >= n || idx_b >= n {
                return None;
            }

            if meta_a[idx_a].hash != meta_b[idx_b].hash {
                return None;
            }

            idx_a += 1;
            idx_b += 1;
        }

        for meta in &meta_a[src_start..src_end] {
            if stats.freq_a.get(&meta.hash).copied().unwrap_or(0) != 1
                || stats.freq_b.get(&meta.hash).copied().unwrap_or(0) != 1
            {
                return None;
            }
        }

        Some(ColumnBlockMove {
            src_start_col: meta_a[src_start].col_idx,
            dst_start_col: meta_b[dst_start].col_idx,
            col_count: len as u32,
        })
    };

    if let Some(src_start) =
        (prefix..tail_start).find(|&idx| meta_a[idx].hash == meta_b[prefix].hash)
        && let Some(mv) = try_candidate(src_start, prefix)
    {
        return Some(mv);
    }

    if let Some(dst_start) =
        (prefix..tail_start).find(|&idx| meta_b[idx].hash == meta_a[prefix].hash)
        && let Some(mv) = try_candidate(prefix, dst_start)
    {
        return Some(mv);
    }

    None
}

#[cfg(test)]
pub(crate) fn align_single_column_change(
    old: &Grid,
    new: &Grid,
    config: &DiffConfig,
) -> Option<ColumnAlignment> {
    let view_a = GridView::from_grid_with_config(old, config);
    let view_b = GridView::from_grid_with_config(new, config);
    align_single_column_change_from_views(&view_a, &view_b, config)
}

pub(crate) fn align_single_column_change_from_views(
    view_a: &GridView,
    view_b: &GridView,
    config: &DiffConfig,
) -> Option<ColumnAlignment> {
    if !is_within_size_bounds(view_a.source, view_b.source, config) {
        return None;
    }

    if view_a.source.nrows != view_b.source.nrows {
        return None;
    }

    let col_diff = view_b.source.ncols as i64 - view_a.source.ncols as i64;
    if col_diff.abs() != 1 {
        return None;
    }

    let stats = HashStats::from_col_meta(&view_a.col_meta, &view_b.col_meta);
    if stats.has_heavy_repetition(config.max_hash_repeat) {
        return None;
    }

    if col_diff == 1 {
        find_single_gap_alignment(
            &view_a.col_meta,
            &view_b.col_meta,
            &stats,
            ColumnChange::Insert,
        )
    } else {
        find_single_gap_alignment(
            &view_a.col_meta,
            &view_b.col_meta,
            &stats,
            ColumnChange::Delete,
        )
    }
}

enum ColumnChange {
    Insert,
    Delete,
}

fn find_single_gap_alignment(
    cols_a: &[ColMeta],
    cols_b: &[ColMeta],
    stats: &HashStats<ColHash>,
    change: ColumnChange,
) -> Option<ColumnAlignment> {
    let mut matched = Vec::new();
    let mut inserted = Vec::new();
    let mut deleted = Vec::new();
    let mut skipped = false;

    let mut idx_a = 0usize;
    let mut idx_b = 0usize;

    while idx_a < cols_a.len() && idx_b < cols_b.len() {
        let meta_a = cols_a[idx_a];
        let meta_b = cols_b[idx_b];

        if meta_a.hash == meta_b.hash {
            matched.push((meta_a.col_idx, meta_b.col_idx));
            idx_a += 1;
            idx_b += 1;
            continue;
        }

        if skipped {
            return None;
        }

        match change {
            ColumnChange::Insert => {
                if !stats.is_unique_to_b(meta_b.hash) {
                    return None;
                }
                inserted.push(meta_b.col_idx);
                idx_b += 1;
            }
            ColumnChange::Delete => {
                if !stats.is_unique_to_a(meta_a.hash) {
                    return None;
                }
                deleted.push(meta_a.col_idx);
                idx_a += 1;
            }
        }

        skipped = true;
    }

    if idx_a < cols_a.len() || idx_b < cols_b.len() {
        if skipped {
            return None;
        }

        match change {
            ColumnChange::Insert if idx_a == cols_a.len() && cols_b.len() == idx_b + 1 => {
                let meta_b = cols_b[idx_b];
                if !stats.is_unique_to_b(meta_b.hash) {
                    return None;
                }
                inserted.push(meta_b.col_idx);
            }
            ColumnChange::Delete if idx_b == cols_b.len() && cols_a.len() == idx_a + 1 => {
                let meta_a = cols_a[idx_a];
                if !stats.is_unique_to_a(meta_a.hash) {
                    return None;
                }
                deleted.push(meta_a.col_idx);
            }
            _ => return None,
        }
    }

    if inserted.len() + deleted.len() != 1 {
        return None;
    }

    let alignment = ColumnAlignment {
        matched,
        inserted,
        deleted,
    };

    debug_assert!(
        is_monotonic(&alignment.matched),
        "matched pairs must be strictly increasing in both dimensions"
    );

    Some(alignment)
}

fn is_monotonic(pairs: &[(u32, u32)]) -> bool {
    pairs.windows(2).all(|w| w[0].0 < w[1].0 && w[0].1 < w[1].1)
}

fn is_within_size_bounds(old: &Grid, new: &Grid, config: &DiffConfig) -> bool {
    let rows = old.nrows.max(new.nrows);
    let cols = old.ncols.max(new.ncols);
    rows <= config.max_align_rows && cols <= config.max_align_cols
}

#[cfg(test)]
mod tests {
    use super::*;
    use crate::workbook::CellValue;

    fn grid_from_numbers(rows: &[&[i32]]) -> Grid {
        let nrows = rows.len() as u32;
        let ncols = if nrows == 0 { 0 } else { rows[0].len() as u32 };
        let mut grid = Grid::new(nrows, ncols);

        for (r_idx, row_vals) in rows.iter().enumerate() {
            for (c_idx, value) in row_vals.iter().enumerate() {
                grid.insert_cell(
                    r_idx as u32,
                    c_idx as u32,
                    Some(CellValue::Number(*value as f64)),
                    None,
                );
            }
        }

        grid
    }

    #[test]
    fn single_insert_aligns_all_columns() {
        let base_rows: Vec<Vec<i32>> =
            vec![vec![1, 2, 3, 4], vec![5, 6, 7, 8], vec![9, 10, 11, 12]];
        let base_refs: Vec<&[i32]> = base_rows.iter().map(|r| r.as_slice()).collect();
        let grid_a = grid_from_numbers(&base_refs);

        let inserted_rows: Vec<Vec<i32>> = base_rows
            .iter()
            .enumerate()
            .map(|(idx, row)| {
                let mut new_row = row.clone();
                new_row.insert(2, 100 + idx as i32); // insert at index 2 (0-based)
                new_row
            })
            .collect();
        let inserted_refs: Vec<&[i32]> = inserted_rows.iter().map(|r| r.as_slice()).collect();
        let grid_b = grid_from_numbers(&inserted_refs);

        let alignment = align_single_column_change(&grid_a, &grid_b, &DiffConfig::default())
            .expect("alignment should succeed");

        assert_eq!(alignment.inserted, vec![2]);
        assert!(alignment.deleted.is_empty());
        assert_eq!(alignment.matched.len(), 4);
        assert_eq!(alignment.matched[0], (0, 0));
        assert_eq!(alignment.matched[1], (1, 1));
        assert_eq!(alignment.matched[2], (2, 3));
        assert_eq!(alignment.matched[3], (3, 4));
    }

    #[test]
    fn multiple_unique_columns_causes_bailout() {
        let base_rows: Vec<Vec<i32>> = vec![vec![1, 2, 3], vec![4, 5, 6], vec![7, 8, 9]];
        let base_refs: Vec<&[i32]> = base_rows.iter().map(|r| r.as_slice()).collect();
        let grid_a = grid_from_numbers(&base_refs);

        let mut rows_b: Vec<Vec<i32>> = base_rows
            .iter()
            .enumerate()
            .map(|(idx, row)| {
                let mut new_row = row.clone();
                new_row.insert(1, 100 + idx as i32); // inserted column
                new_row
            })
            .collect();
        if let Some(cell) = rows_b.get_mut(1).and_then(|row| row.get_mut(3)) {
            *cell = 999;
        }
        let rows_b_refs: Vec<&[i32]> = rows_b.iter().map(|r| r.as_slice()).collect();
        let grid_b = grid_from_numbers(&rows_b_refs);

        assert!(align_single_column_change(&grid_a, &grid_b, &DiffConfig::default()).is_none());
    }

    #[test]
    fn heavy_repetition_causes_bailout() {
        let repetitive_cols = 9;
        let rows: usize = 3;

        let values_a: Vec<Vec<i32>> = (0..rows).map(|_| vec![1; repetitive_cols]).collect();
        let refs_a: Vec<&[i32]> = values_a.iter().map(|r| r.as_slice()).collect();
        let grid_a = grid_from_numbers(&refs_a);

        let values_b: Vec<Vec<i32>> = (0..rows)
            .map(|row_idx| {
                let mut row = vec![1; repetitive_cols];
                row.insert(4, 2 + row_idx as i32);
                row
            })
            .collect();
        let refs_b: Vec<&[i32]> = values_b.iter().map(|r| r.as_slice()).collect();
        let grid_b = grid_from_numbers(&refs_b);

        assert!(align_single_column_change(&grid_a, &grid_b, &DiffConfig::default()).is_none());
    }

    #[test]
    fn detect_exact_column_block_move_simple_case() {
        let grid_a = grid_from_numbers(&[&[10, 20, 30, 40], &[11, 21, 31, 41]]);

        let grid_b = grid_from_numbers(&[&[10, 30, 40, 20], &[11, 31, 41, 21]]);

        let mv = detect_exact_column_block_move(&grid_a, &grid_b, &DiffConfig::default())
            .expect("expected column move found");
        assert_eq!(mv.src_start_col, 1);
        assert_eq!(mv.col_count, 1);
        assert_eq!(mv.dst_start_col, 3);
    }

    #[test]
    fn detect_exact_column_block_move_rejects_internal_edits() {
        let grid_a = grid_from_numbers(&[&[1, 2, 3, 4], &[5, 6, 7, 8], &[9, 10, 11, 12]]);

        let grid_b = grid_from_numbers(&[
            &[1, 3, 4, 2],
            &[5, 7, 8, 6],
            &[9, 11, 12, 999], // edit inside moved column
        ]);

        assert!(detect_exact_column_block_move(&grid_a, &grid_b, &DiffConfig::default()).is_none());
    }

    #[test]
    fn detect_exact_column_block_move_rejects_repetition() {
        let grid_a = grid_from_numbers(&[&[1, 1, 2, 2], &[10, 10, 20, 20]]);
        let grid_b = grid_from_numbers(&[&[2, 2, 1, 1], &[20, 20, 10, 10]]);

        assert!(detect_exact_column_block_move(&grid_a, &grid_b, &DiffConfig::default()).is_none());
    }

    #[test]
    fn detect_exact_column_block_move_multi_column_block() {
        let grid_a = grid_from_numbers(&[
            &[10, 20, 30, 40, 50, 60],
            &[11, 21, 31, 41, 51, 61],
            &[12, 22, 32, 42, 52, 62],
        ]);

        let grid_b = grid_from_numbers(&[
            &[10, 40, 50, 20, 30, 60],
            &[11, 41, 51, 21, 31, 61],
            &[12, 42, 52, 22, 32, 62],
        ]);

        let mv = detect_exact_column_block_move(&grid_a, &grid_b, &DiffConfig::default())
            .expect("expected multi-column move");
        assert_eq!(mv.src_start_col, 3);
        assert_eq!(mv.col_count, 2);
        assert_eq!(mv.dst_start_col, 1);
    }

    #[test]
    fn detect_exact_column_block_move_rejects_two_independent_moves() {
        let grid_a = grid_from_numbers(&[&[10, 20, 30, 40, 50, 60], &[11, 21, 31, 41, 51, 61]]);

        let grid_b = grid_from_numbers(&[&[20, 10, 30, 40, 60, 50], &[21, 11, 31, 41, 61, 51]]);

        assert!(
            detect_exact_column_block_move(&grid_a, &grid_b, &DiffConfig::default()).is_none(),
            "two independent column swaps must not be detected as a single block move"
        );
    }

    #[test]
    fn detect_exact_column_block_move_swap_as_single_move() {
        let grid_a = grid_from_numbers(&[&[10, 20, 30, 40], &[11, 21, 31, 41]]);

        let grid_b = grid_from_numbers(&[&[20, 10, 30, 40], &[21, 11, 31, 41]]);

        let mv = detect_exact_column_block_move(&grid_a, &grid_b, &DiffConfig::default())
            .expect("swap of adjacent columns should be detected as single-column move");
        assert_eq!(mv.col_count, 1);
        assert!(
            (mv.src_start_col == 0 && mv.dst_start_col == 1)
                || (mv.src_start_col == 1 && mv.dst_start_col == 0),
            "swap should be represented as moving one column past the other"
        );
    }
}

```

---

### File: `core\src\config.rs`

```rust
//! Configuration for the diff engine.
//!
//! `DiffConfig` centralizes all algorithm thresholds and behavioral knobs
//! to avoid hardcoded constants scattered throughout the codebase.

use serde::{Deserialize, Serialize};
use thiserror::Error;

#[derive(Debug, Clone, Copy, PartialEq, Eq, Serialize, Deserialize)]
#[serde(rename_all = "snake_case")]
pub enum LimitBehavior {
    FallbackToPositional,
    ReturnPartialResult,
    ReturnError,
}

#[derive(Debug, Clone, PartialEq, Serialize, Deserialize)]
#[serde(default)]
pub struct DiffConfig {
    /// Maximum number of masked move-detection iterations per sheet.
    /// Set to 0 to disable move detection and represent moves as insert/delete.
    pub max_move_iterations: u32,
    pub max_align_rows: u32,
    pub max_align_cols: u32,
    pub max_block_gap: u32,
    pub max_hash_repeat: u32,
    pub fuzzy_similarity_threshold: f64,
    pub max_fuzzy_block_rows: u32,
    #[serde(alias = "rare_frequency_threshold")]
    pub rare_threshold: u32,
    #[serde(alias = "low_info_cell_threshold")]
    pub low_info_threshold: u32,
    /// Row-count threshold for recursive gap alignment. Does not gate masked move detection.
    #[serde(alias = "recursive_threshold")]
    pub recursive_align_threshold: u32,
    pub small_gap_threshold: u32,
    pub max_recursion_depth: u32,
    pub on_limit_exceeded: LimitBehavior,
    pub enable_fuzzy_moves: bool,
    pub enable_m_semantic_diff: bool,
    pub enable_formula_semantic_diff: bool,
    /// When true, emits CellEdited ops even when values are unchanged (diagnostic);
    /// downstream consumers should treat edits as semantic only if from != to.
    pub include_unchanged_cells: bool,
    pub max_context_rows: u32,
    pub min_block_size_for_move: u32,
    pub max_lcs_gap_size: u32,
    pub lcs_dp_work_limit: usize,
    pub move_extraction_max_slice_len: u32,
    pub move_extraction_max_candidates_per_sig: u32,
    pub context_anchor_k1: u32,
    pub context_anchor_k2: u32,
    /// Masked move detection runs only when max(old.nrows, new.nrows) <= this.
    pub max_move_detection_rows: u32,
    /// Masked move detection runs only when max(old.ncols, new.ncols) <= this.
    pub max_move_detection_cols: u32,
    /// Preflight: minimum row count to consider short-circuit bailouts.
    /// Grids smaller than this always run full move detection/alignment.
    pub preflight_min_rows: u32,
    /// Preflight: maximum number of in-order row mismatches to trigger near-identical bailout.
    pub preflight_in_order_mismatch_max: u32,
    /// Preflight: minimum ratio of in-order matching rows (0.0..=1.0) for near-identical bailout.
    pub preflight_in_order_match_ratio_min: f64,
    /// Preflight: Jaccard similarity threshold below which grids are considered dissimilar
    /// and move detection/alignment are skipped.
    pub bailout_similarity_threshold: f64,
    /// Optional soft cap on estimated memory usage (in MB) for advanced strategies.
    ///
    /// When the estimate exceeds this cap, the engine falls back to positional diff for the
    /// affected sheet and marks the overall diff as incomplete with a warning.
    pub max_memory_mb: Option<u32>,
    /// Optional timeout (in seconds) for the diff engine.
    ///
    /// When exceeded, the engine aborts early, preserving any already-emitted ops, and marks the
    /// result as incomplete with a warning.
    pub timeout_seconds: Option<u32>,
}

impl Default for DiffConfig {
    fn default() -> Self {
        Self {
            max_move_iterations: 20,
            max_align_rows: 500_000,
            max_align_cols: 16_384,
            max_block_gap: 10_000,
            max_hash_repeat: 8,
            fuzzy_similarity_threshold: 0.80,
            max_fuzzy_block_rows: 32,
            rare_threshold: 5,
            low_info_threshold: 2,
            small_gap_threshold: 50,
            recursive_align_threshold: 200,
            max_recursion_depth: 10,
            on_limit_exceeded: LimitBehavior::FallbackToPositional,
            enable_fuzzy_moves: true,
            enable_m_semantic_diff: true,
            enable_formula_semantic_diff: false,
            include_unchanged_cells: false,
            max_context_rows: 3,
            min_block_size_for_move: 3,
            max_lcs_gap_size: 1_500,
            lcs_dp_work_limit: 20_000,
            move_extraction_max_slice_len: 10_000,
            move_extraction_max_candidates_per_sig: 16,
            context_anchor_k1: 4,
            context_anchor_k2: 8,
            max_move_detection_rows: 200,
            max_move_detection_cols: 256,
            preflight_min_rows: 5000,
            preflight_in_order_mismatch_max: 32,
            preflight_in_order_match_ratio_min: 0.995,
            bailout_similarity_threshold: 0.05,
            max_memory_mb: None,
            timeout_seconds: None,
        }
    }
}

impl DiffConfig {
    pub fn fastest() -> Self {
        Self {
            max_move_iterations: 5,
            max_block_gap: 1_000,
            small_gap_threshold: 20,
            recursive_align_threshold: 80,
            max_move_detection_rows: 80,
            enable_fuzzy_moves: false,
            enable_m_semantic_diff: false,
            ..Default::default()
        }
    }

    pub fn balanced() -> Self {
        Self::default()
    }

    pub fn most_precise() -> Self {
        Self {
            max_move_iterations: 30,
            max_block_gap: 20_000,
            fuzzy_similarity_threshold: 0.95,
            small_gap_threshold: 80,
            recursive_align_threshold: 400,
            enable_formula_semantic_diff: true,
            max_lcs_gap_size: 1_500,
            lcs_dp_work_limit: 20_000,
            move_extraction_max_slice_len: 10_000,
            move_extraction_max_candidates_per_sig: 16,
            max_move_detection_rows: 400,
            max_move_detection_cols: 256,
            ..Default::default()
        }
    }

    pub fn builder() -> DiffConfigBuilder {
        DiffConfigBuilder {
            inner: DiffConfig::default(),
        }
    }

    pub fn validate(&self) -> Result<(), ConfigError> {
        if !self.fuzzy_similarity_threshold.is_finite()
            || self.fuzzy_similarity_threshold < 0.0
            || self.fuzzy_similarity_threshold > 1.0
        {
            return Err(ConfigError::InvalidFuzzySimilarity {
                value: self.fuzzy_similarity_threshold,
            });
        }

        ensure_non_zero_u32(self.max_align_rows, "max_align_rows")?;
        ensure_non_zero_u32(self.max_align_cols, "max_align_cols")?;
        ensure_non_zero_u32(self.max_lcs_gap_size, "max_lcs_gap_size")?;
        ensure_non_zero_u32(
            self.move_extraction_max_slice_len,
            "move_extraction_max_slice_len",
        )?;
        ensure_non_zero_u32(
            self.move_extraction_max_candidates_per_sig,
            "move_extraction_max_candidates_per_sig",
        )?;
        ensure_non_zero_u32(self.context_anchor_k1, "context_anchor_k1")?;
        ensure_non_zero_u32(self.context_anchor_k2, "context_anchor_k2")?;
        ensure_non_zero_u32(self.max_move_detection_rows, "max_move_detection_rows")?;
        ensure_non_zero_u32(self.max_move_detection_cols, "max_move_detection_cols")?;
        ensure_non_zero_u32(self.max_context_rows, "max_context_rows")?;
        ensure_non_zero_u32(self.min_block_size_for_move, "min_block_size_for_move")?;

        if self.lcs_dp_work_limit == 0 {
            return Err(ConfigError::NonPositiveLimit {
                field: "lcs_dp_work_limit",
                value: 0,
            });
        }

        if !self.preflight_in_order_match_ratio_min.is_finite()
            || self.preflight_in_order_match_ratio_min < 0.0
            || self.preflight_in_order_match_ratio_min > 1.0
        {
            return Err(ConfigError::InvalidPreflightRatio {
                value: self.preflight_in_order_match_ratio_min,
            });
        }

        if !self.bailout_similarity_threshold.is_finite()
            || self.bailout_similarity_threshold < 0.0
            || self.bailout_similarity_threshold > 1.0
        {
            return Err(ConfigError::InvalidBailoutSimilarity {
                value: self.bailout_similarity_threshold,
            });
        }

        Ok(())
    }
}

#[derive(Debug, Clone, PartialEq, Error)]
pub enum ConfigError {
    #[error("fuzzy_similarity_threshold must be in [0.0, 1.0] and finite (got {value})")]
    InvalidFuzzySimilarity { value: f64 },
    #[error("{field} must be greater than zero (got {value})")]
    NonPositiveLimit { field: &'static str, value: u64 },
    #[error("preflight_in_order_match_ratio_min must be in [0.0, 1.0] and finite (got {value})")]
    InvalidPreflightRatio { value: f64 },
    #[error("bailout_similarity_threshold must be in [0.0, 1.0] and finite (got {value})")]
    InvalidBailoutSimilarity { value: f64 },
}

fn ensure_non_zero_u32(value: u32, field: &'static str) -> Result<(), ConfigError> {
    if value == 0 {
        return Err(ConfigError::NonPositiveLimit {
            field,
            value: value as u64,
        });
    }
    Ok(())
}

#[derive(Debug, Clone)]
pub struct DiffConfigBuilder {
    inner: DiffConfig,
}

impl Default for DiffConfigBuilder {
    fn default() -> Self {
        Self::new()
    }
}

impl DiffConfigBuilder {
    pub fn new() -> Self {
        DiffConfig::builder()
    }

    pub fn max_move_iterations(mut self, value: u32) -> Self {
        self.inner.max_move_iterations = value;
        self
    }

    pub fn max_align_rows(mut self, value: u32) -> Self {
        self.inner.max_align_rows = value;
        self
    }

    pub fn max_align_cols(mut self, value: u32) -> Self {
        self.inner.max_align_cols = value;
        self
    }

    pub fn max_block_gap(mut self, value: u32) -> Self {
        self.inner.max_block_gap = value;
        self
    }

    pub fn max_hash_repeat(mut self, value: u32) -> Self {
        self.inner.max_hash_repeat = value;
        self
    }

    pub fn fuzzy_similarity_threshold(mut self, value: f64) -> Self {
        self.inner.fuzzy_similarity_threshold = value;
        self
    }

    pub fn max_fuzzy_block_rows(mut self, value: u32) -> Self {
        self.inner.max_fuzzy_block_rows = value;
        self
    }

    pub fn rare_threshold(mut self, value: u32) -> Self {
        self.inner.rare_threshold = value;
        self
    }

    pub fn low_info_threshold(mut self, value: u32) -> Self {
        self.inner.low_info_threshold = value;
        self
    }

    pub fn recursive_align_threshold(mut self, value: u32) -> Self {
        self.inner.recursive_align_threshold = value;
        self
    }

    pub fn small_gap_threshold(mut self, value: u32) -> Self {
        self.inner.small_gap_threshold = value;
        self
    }

    pub fn max_recursion_depth(mut self, value: u32) -> Self {
        self.inner.max_recursion_depth = value;
        self
    }

    pub fn on_limit_exceeded(mut self, value: LimitBehavior) -> Self {
        self.inner.on_limit_exceeded = value;
        self
    }

    pub fn enable_fuzzy_moves(mut self, value: bool) -> Self {
        self.inner.enable_fuzzy_moves = value;
        self
    }

    pub fn enable_m_semantic_diff(mut self, value: bool) -> Self {
        self.inner.enable_m_semantic_diff = value;
        self
    }

    pub fn enable_formula_semantic_diff(mut self, value: bool) -> Self {
        self.inner.enable_formula_semantic_diff = value;
        self
    }

    pub fn include_unchanged_cells(mut self, value: bool) -> Self {
        self.inner.include_unchanged_cells = value;
        self
    }

    pub fn max_context_rows(mut self, value: u32) -> Self {
        self.inner.max_context_rows = value;
        self
    }

    pub fn min_block_size_for_move(mut self, value: u32) -> Self {
        self.inner.min_block_size_for_move = value;
        self
    }

    pub fn max_lcs_gap_size(mut self, value: u32) -> Self {
        self.inner.max_lcs_gap_size = value;
        self
    }

    pub fn lcs_dp_work_limit(mut self, value: usize) -> Self {
        self.inner.lcs_dp_work_limit = value;
        self
    }

    pub fn move_extraction_max_slice_len(mut self, value: u32) -> Self {
        self.inner.move_extraction_max_slice_len = value;
        self
    }

    pub fn move_extraction_max_candidates_per_sig(mut self, value: u32) -> Self {
        self.inner.move_extraction_max_candidates_per_sig = value;
        self
    }

    pub fn context_anchor_k1(mut self, value: u32) -> Self {
        self.inner.context_anchor_k1 = value;
        self
    }

    pub fn context_anchor_k2(mut self, value: u32) -> Self {
        self.inner.context_anchor_k2 = value;
        self
    }

    pub fn max_move_detection_rows(mut self, value: u32) -> Self {
        self.inner.max_move_detection_rows = value;
        self
    }

    pub fn max_move_detection_cols(mut self, value: u32) -> Self {
        self.inner.max_move_detection_cols = value;
        self
    }

    pub fn preflight_min_rows(mut self, value: u32) -> Self {
        self.inner.preflight_min_rows = value;
        self
    }

    pub fn preflight_in_order_mismatch_max(mut self, value: u32) -> Self {
        self.inner.preflight_in_order_mismatch_max = value;
        self
    }

    pub fn preflight_in_order_match_ratio_min(mut self, value: f64) -> Self {
        self.inner.preflight_in_order_match_ratio_min = value;
        self
    }

    pub fn bailout_similarity_threshold(mut self, value: f64) -> Self {
        self.inner.bailout_similarity_threshold = value;
        self
    }

    pub fn max_memory_mb(mut self, value: Option<u32>) -> Self {
        self.inner.max_memory_mb = value;
        self
    }

    pub fn timeout_seconds(mut self, value: Option<u32>) -> Self {
        self.inner.timeout_seconds = value;
        self
    }

    pub fn build(self) -> Result<DiffConfig, ConfigError> {
        self.inner.validate()?;
        Ok(self.inner)
    }
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn defaults_match_limit_spec() {
        let cfg = DiffConfig::default();

        assert_eq!(cfg.max_align_rows, 500_000);
        assert_eq!(cfg.max_align_cols, 16_384);
        assert_eq!(cfg.max_recursion_depth, 10);
        assert!(matches!(
            cfg.on_limit_exceeded,
            LimitBehavior::FallbackToPositional
        ));

        assert_eq!(cfg.fuzzy_similarity_threshold, 0.80);
        assert_eq!(cfg.min_block_size_for_move, 3);
        assert_eq!(cfg.max_move_iterations, 20);

        assert_eq!(cfg.recursive_align_threshold, 200);
        assert_eq!(cfg.small_gap_threshold, 50);
        assert_eq!(cfg.low_info_threshold, 2);
        assert_eq!(cfg.rare_threshold, 5);
        assert_eq!(cfg.max_block_gap, 10_000);

        assert_eq!(cfg.max_move_detection_rows, 200);
        assert_eq!(cfg.max_move_detection_cols, 256);

        assert_eq!(cfg.preflight_min_rows, 5000);
        assert_eq!(cfg.preflight_in_order_mismatch_max, 32);
        assert!((cfg.preflight_in_order_match_ratio_min - 0.995).abs() < f64::EPSILON);
        assert!((cfg.bailout_similarity_threshold - 0.05).abs() < f64::EPSILON);

        assert_eq!(cfg.max_memory_mb, None);
        assert_eq!(cfg.timeout_seconds, None);

        assert!(!cfg.include_unchanged_cells);
        assert_eq!(cfg.max_context_rows, 3);

        assert!(cfg.enable_fuzzy_moves);
        assert!(cfg.enable_m_semantic_diff);
        assert!(!cfg.enable_formula_semantic_diff);
    }

    #[test]
    fn serde_roundtrip_preserves_defaults() {
        let cfg = DiffConfig::default();
        let json = serde_json::to_string(&cfg).expect("serialize default config");
        let parsed: DiffConfig = serde_json::from_str(&json).expect("deserialize default config");
        assert_eq!(cfg, parsed);
    }

    #[test]
    fn serde_aliases_populate_fields() {
        let json = r#"{
            "rare_frequency_threshold": 9,
            "low_info_cell_threshold": 3,
            "recursive_threshold": 123
        }"#;
        let cfg: DiffConfig = serde_json::from_str(json).expect("deserialize with aliases");
        assert_eq!(cfg.rare_threshold, 9);
        assert_eq!(cfg.low_info_threshold, 3);
        assert_eq!(cfg.recursive_align_threshold, 123);
    }

    #[test]
    fn builder_rejects_invalid_similarity_threshold() {
        let err = DiffConfig::builder()
            .fuzzy_similarity_threshold(2.0)
            .build()
            .expect_err("builder should reject invalid probability");
        assert!(matches!(
            err,
            ConfigError::InvalidFuzzySimilarity { value } if (value - 2.0).abs() < f64::EPSILON
        ));
    }

    #[test]
    fn presets_differ_in_expected_directions() {
        let fastest = DiffConfig::fastest();
        let balanced = DiffConfig::balanced();
        let precise = DiffConfig::most_precise();

        assert!(!fastest.enable_fuzzy_moves);
        assert!(!fastest.enable_m_semantic_diff);
        assert!(precise.max_move_iterations >= balanced.max_move_iterations);
        assert!(precise.max_block_gap >= balanced.max_block_gap);
        assert!(precise.fuzzy_similarity_threshold >= balanced.fuzzy_similarity_threshold);
    }

    #[test]
    fn most_precise_matches_sprint_plan_values() {
        let cfg = DiffConfig::most_precise();
        assert_eq!(cfg.fuzzy_similarity_threshold, 0.95);
        assert!(cfg.enable_formula_semantic_diff);
    }

    #[test]
    fn builder_rejects_invalid_preflight_ratio() {
        let err = DiffConfig::builder()
            .preflight_in_order_match_ratio_min(1.5)
            .build()
            .expect_err("builder should reject invalid preflight ratio");
        assert!(matches!(
            err,
            ConfigError::InvalidPreflightRatio { value } if (value - 1.5).abs() < f64::EPSILON
        ));

        let err = DiffConfig::builder()
            .preflight_in_order_match_ratio_min(-0.1)
            .build()
            .expect_err("builder should reject negative preflight ratio");
        assert!(matches!(err, ConfigError::InvalidPreflightRatio { .. }));
    }

    #[test]
    fn builder_rejects_invalid_bailout_similarity() {
        let err = DiffConfig::builder()
            .bailout_similarity_threshold(2.0)
            .build()
            .expect_err("builder should reject invalid bailout similarity");
        assert!(matches!(
            err,
            ConfigError::InvalidBailoutSimilarity { value } if (value - 2.0).abs() < f64::EPSILON
        ));

        let err = DiffConfig::builder()
            .bailout_similarity_threshold(-0.5)
            .build()
            .expect_err("builder should reject negative bailout similarity");
        assert!(matches!(err, ConfigError::InvalidBailoutSimilarity { .. }));
    }

    #[test]
    fn preflight_config_builder_setters_work() {
        let cfg = DiffConfig::builder()
            .preflight_min_rows(10000)
            .preflight_in_order_mismatch_max(64)
            .preflight_in_order_match_ratio_min(0.99)
            .bailout_similarity_threshold(0.10)
            .max_memory_mb(Some(64))
            .timeout_seconds(Some(5))
            .build()
            .expect("valid config should build");

        assert_eq!(cfg.preflight_min_rows, 10000);
        assert_eq!(cfg.preflight_in_order_mismatch_max, 64);
        assert!((cfg.preflight_in_order_match_ratio_min - 0.99).abs() < f64::EPSILON);
        assert!((cfg.bailout_similarity_threshold - 0.10).abs() < f64::EPSILON);
        assert_eq!(cfg.max_memory_mb, Some(64));
        assert_eq!(cfg.timeout_seconds, Some(5));
    }
}

```

---

### File: `core\src\container.rs`

```rust
//! OPC (Open Packaging Conventions) container handling.
//!
//! Provides abstraction over ZIP-based Office Open XML packages, validating
//! that required structural elements like `[Content_Types].xml` are present.

use std::io::{Read, Seek};
use thiserror::Error;
use zip::ZipArchive;
use zip::result::ZipError;

use crate::error_codes;

#[derive(Debug, Clone, Copy)]
pub struct ContainerLimits {
    pub max_entries: usize,
    pub max_part_uncompressed_bytes: u64,
    pub max_total_uncompressed_bytes: u64,
}

impl Default for ContainerLimits {
    fn default() -> Self {
        Self {
            max_entries: 10_000,
            max_part_uncompressed_bytes: 100 * 1024 * 1024,
            max_total_uncompressed_bytes: 500 * 1024 * 1024,
        }
    }
}

#[derive(Debug, Error)]
#[non_exhaustive]
pub enum ContainerError {
    #[error("[EXDIFF_CTR_001] I/O error: {0}. Suggestion: check the file path and permissions.")]
    Io(#[from] std::io::Error),
    #[error("[EXDIFF_CTR_002] ZIP error: {0}. Suggestion: verify the file is a valid .xlsx and not corrupt.")]
    Zip(String),
    #[error("[EXDIFF_CTR_003] not a ZIP container. Suggestion: verify the input is a ZIP-based .xlsx file.")]
    NotZipContainer,
    #[error("[EXDIFF_CTR_004] not an OPC package (missing [Content_Types].xml). Suggestion: verify the file is a valid .xlsx workbook.")]
    NotOpcPackage,
    #[error("[EXDIFF_CTR_005] archive has too many entries: {entries} (limit: {max_entries}). Suggestion: possible ZIP bomb; increase limits only for trusted files.")]
    TooManyEntries { entries: usize, max_entries: usize },
    #[error("[EXDIFF_CTR_006] part '{path}' is too large: {size} bytes (limit: {limit} bytes). Suggestion: possible ZIP bomb; increase limits only for trusted files.")]
    PartTooLarge { path: String, size: u64, limit: u64 },
    #[error("[EXDIFF_CTR_007] total uncompressed size exceeds limit: would exceed {limit} bytes. Suggestion: possible ZIP bomb; increase limits only for trusted files.")]
    TotalTooLarge { limit: u64 },
    #[error("[EXDIFF_CTR_002] failed to read ZIP entry '{path}': {reason}. Suggestion: the file may be corrupt or truncated.")]
    ZipRead { path: String, reason: String },
    #[error("[EXDIFF_CTR_002] file not found in archive: {path}. Suggestion: the file may be corrupt or incomplete.")]
    FileNotFound { path: String },
}

impl ContainerError {
    pub fn code(&self) -> &'static str {
        match self {
            ContainerError::Io(_) => error_codes::CONTAINER_IO,
            ContainerError::Zip(_) => error_codes::CONTAINER_ZIP,
            ContainerError::NotZipContainer => error_codes::CONTAINER_NOT_ZIP,
            ContainerError::NotOpcPackage => error_codes::CONTAINER_NOT_OPC,
            ContainerError::TooManyEntries { .. } => error_codes::CONTAINER_TOO_MANY_ENTRIES,
            ContainerError::PartTooLarge { .. } => error_codes::CONTAINER_PART_TOO_LARGE,
            ContainerError::TotalTooLarge { .. } => error_codes::CONTAINER_TOTAL_TOO_LARGE,
            ContainerError::ZipRead { .. } => error_codes::CONTAINER_ZIP,
            ContainerError::FileNotFound { .. } => error_codes::CONTAINER_ZIP,
        }
    }
}

pub(crate) trait ReadSeek: Read + Seek {}
impl<T: Read + Seek> ReadSeek for T {}

pub struct OpcContainer {
    pub(crate) archive: ZipArchive<Box<dyn ReadSeek>>,
    limits: ContainerLimits,
    total_read: u64,
}

impl OpcContainer {
    pub fn open_from_reader<R: Read + Seek + 'static>(
        reader: R,
    ) -> Result<OpcContainer, ContainerError> {
        Self::open_from_reader_with_limits(reader, ContainerLimits::default())
    }

    pub fn open_from_reader_with_limits<R: Read + Seek + 'static>(
        reader: R,
        limits: ContainerLimits,
    ) -> Result<OpcContainer, ContainerError> {
        let reader: Box<dyn ReadSeek> = Box::new(reader);
        let archive = ZipArchive::new(reader).map_err(|err| match err {
            ZipError::InvalidArchive(_) | ZipError::UnsupportedArchive(_) => {
                ContainerError::NotZipContainer
            }
            ZipError::Io(e) => match e.kind() {
                std::io::ErrorKind::UnexpectedEof | std::io::ErrorKind::InvalidData => {
                    ContainerError::NotZipContainer
                }
                _ => ContainerError::Io(e),
            },
            other => ContainerError::Zip(other.to_string()),
        })?;

        if archive.len() > limits.max_entries {
            return Err(ContainerError::TooManyEntries {
                entries: archive.len(),
                max_entries: limits.max_entries,
            });
        }

        let mut container = OpcContainer {
            archive,
            limits,
            total_read: 0,
        };

        match container.archive.by_name("[Content_Types].xml") {
            Ok(file) => {
                let size = file.size();
                if size > container.limits.max_part_uncompressed_bytes {
                    return Err(ContainerError::PartTooLarge {
                        path: "[Content_Types].xml".to_string(),
                        size,
                        limit: container.limits.max_part_uncompressed_bytes,
                    });
                }
            }
            Err(ZipError::FileNotFound) => return Err(ContainerError::NotOpcPackage),
            Err(ZipError::Io(e)) => return Err(ContainerError::Io(e)),
            Err(other) => return Err(ContainerError::Zip(other.to_string())),
        }

        Ok(container)
    }

    #[cfg(feature = "std-fs")]
    pub fn open_from_path(
        path: impl AsRef<std::path::Path>,
    ) -> Result<OpcContainer, ContainerError> {
        Self::open_from_path_with_limits(path, ContainerLimits::default())
    }

    #[cfg(feature = "std-fs")]
    pub fn open_from_path_with_limits(
        path: impl AsRef<std::path::Path>,
        limits: ContainerLimits,
    ) -> Result<OpcContainer, ContainerError> {
        let file = std::fs::File::open(path)?;
        Self::open_from_reader_with_limits(file, limits)
    }

    #[cfg(feature = "std-fs")]
    pub fn open(path: impl AsRef<std::path::Path>) -> Result<OpcContainer, ContainerError> {
        Self::open_from_path(path)
    }

    pub fn read_file(&mut self, name: &str) -> Result<Vec<u8>, ZipError> {
        let mut file = self.archive.by_name(name)?;
        let mut buf = Vec::new();
        file.read_to_end(&mut buf)?;
        Ok(buf)
    }

    pub fn read_file_checked(&mut self, name: &str) -> Result<Vec<u8>, ContainerError> {
        let size = {
            let file = self.archive.by_name(name).map_err(|e| match e {
                ZipError::FileNotFound => ContainerError::FileNotFound {
                    path: name.to_string(),
                },
                ZipError::Io(io_err) => ContainerError::ZipRead {
                    path: name.to_string(),
                    reason: io_err.to_string(),
                },
                other => ContainerError::ZipRead {
                    path: name.to_string(),
                    reason: other.to_string(),
                },
            })?;
            file.size()
        };

        if size > self.limits.max_part_uncompressed_bytes {
            return Err(ContainerError::PartTooLarge {
                path: name.to_string(),
                size,
                limit: self.limits.max_part_uncompressed_bytes,
            });
        }

        let new_total = self.total_read.saturating_add(size);
        if new_total > self.limits.max_total_uncompressed_bytes {
            return Err(ContainerError::TotalTooLarge {
                limit: self.limits.max_total_uncompressed_bytes,
            });
        }

        let mut file = self.archive.by_name(name).map_err(|e| ContainerError::ZipRead {
            path: name.to_string(),
            reason: e.to_string(),
        })?;

        let mut buf = Vec::new();
        file.read_to_end(&mut buf).map_err(|e| ContainerError::ZipRead {
            path: name.to_string(),
            reason: e.to_string(),
        })?;

        self.total_read = new_total;
        Ok(buf)
    }

    pub fn read_file_optional(&mut self, name: &str) -> Result<Option<Vec<u8>>, std::io::Error> {
        match self.read_file(name) {
            Ok(bytes) => Ok(Some(bytes)),
            Err(ZipError::FileNotFound) => Ok(None),
            Err(ZipError::Io(e)) => Err(e),
            Err(e) => Err(std::io::Error::new(
                std::io::ErrorKind::InvalidData,
                e.to_string(),
            )),
        }
    }

    pub fn read_file_optional_checked(
        &mut self,
        name: &str,
    ) -> Result<Option<Vec<u8>>, ContainerError> {
        match self.read_file_checked(name) {
            Ok(bytes) => Ok(Some(bytes)),
            Err(ContainerError::FileNotFound { .. }) => Ok(None),
            Err(e) => Err(e),
        }
    }

    pub fn file_names(&self) -> impl Iterator<Item = &str> {
        self.archive.file_names()
    }

    pub fn len(&self) -> usize {
        self.archive.len()
    }

    pub fn is_empty(&self) -> bool {
        self.len() == 0
    }

    pub fn limits(&self) -> &ContainerLimits {
        &self.limits
    }
}

```

---

### File: `core\src\database_alignment.rs`

```rust
use crate::hashing::normalize_float_for_hash;
use crate::string_pool::{StringId, StringPool};
use crate::workbook::{CellValue, Grid};
use std::collections::{HashMap, HashSet};

#[derive(Debug, Clone, PartialEq, Eq)]
pub(crate) struct KeyColumnSpec {
    pub columns: Vec<u32>,
}

impl KeyColumnSpec {
    pub fn new(columns: Vec<u32>) -> KeyColumnSpec {
        KeyColumnSpec { columns }
    }

    pub fn is_key_column(&self, col: u32) -> bool {
        self.columns.contains(&col)
    }
}

#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub(crate) enum KeyValueRepr {
    None,
    Number(u64),
    Text(StringId),
    Bool(bool),
}

impl KeyValueRepr {
    fn from_cell_value(value: Option<&CellValue>) -> KeyValueRepr {
        match value {
            Some(CellValue::Number(n)) => KeyValueRepr::Number(normalize_float_for_hash(*n)),
            Some(CellValue::Text(id)) => KeyValueRepr::Text(*id),
            Some(CellValue::Bool(b)) => KeyValueRepr::Bool(*b),
            Some(CellValue::Blank) => KeyValueRepr::None,
            Some(CellValue::Error(id)) => KeyValueRepr::Text(*id),
            None => KeyValueRepr::None,
        }
    }
}

#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub(crate) struct KeyComponent {
    pub value: KeyValueRepr,
    pub formula: Option<StringId>,
}

#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub(crate) struct KeyValue {
    components: Vec<KeyComponent>,
}

impl KeyValue {
    fn new(components: Vec<KeyComponent>) -> KeyValue {
        KeyValue { components }
    }
}

#[derive(Debug, Clone, PartialEq, Eq)]
pub(crate) struct KeyedRow {
    pub key: KeyValue,
    pub row_idx: u32,
}

#[derive(Debug, Clone, PartialEq, Eq)]
pub(crate) struct KeyedAlignment {
    pub matched_rows: Vec<(u32, u32)>, // (row_idx_a, row_idx_b)
    pub left_only_rows: Vec<u32>,
    pub right_only_rows: Vec<u32>,
}

#[derive(Debug, Clone, PartialEq, Eq)]
pub(crate) enum KeyAlignmentError {
    DuplicateKeyLeft(KeyValue),
    DuplicateKeyRight(KeyValue),
}

pub(crate) fn diff_table_by_key(
    old: &Grid,
    new: &Grid,
    key_columns: &[u32],
) -> Result<KeyedAlignment, KeyAlignmentError> {
    let spec = KeyColumnSpec::new(key_columns.to_vec());
    let (left_rows, _left_lookup) = build_keyed_rows(old, &spec, true)?;
    let (right_rows, right_lookup) = build_keyed_rows(new, &spec, false)?;

    let mut matched_rows = Vec::new();
    let mut left_only_rows = Vec::new();
    let mut right_only_rows = Vec::new();

    let mut matched_right_rows: HashSet<u32> = HashSet::new();

    for row in &left_rows {
        if let Some(&row_b) = right_lookup.get(&row.key) {
            matched_rows.push((row.row_idx, row_b));
            matched_right_rows.insert(row_b);
        } else {
            left_only_rows.push(row.row_idx);
        }
    }

    for row in &right_rows {
        if !matched_right_rows.contains(&row.row_idx) {
            right_only_rows.push(row.row_idx);
        }
    }

    Ok(KeyedAlignment {
        matched_rows,
        left_only_rows,
        right_only_rows,
    })
}

fn build_keyed_rows(
    grid: &Grid,
    spec: &KeyColumnSpec,
    is_left: bool,
) -> Result<(Vec<KeyedRow>, HashMap<KeyValue, u32>), KeyAlignmentError> {
    let mut rows = Vec::with_capacity(grid.nrows as usize);
    let mut lookup = HashMap::new();

    for row_idx in 0..grid.nrows {
        let key = extract_key(grid, row_idx, spec);
        if lookup.insert(key.clone(), row_idx).is_some() {
            return Err(if is_left {
                KeyAlignmentError::DuplicateKeyLeft(key)
            } else {
                KeyAlignmentError::DuplicateKeyRight(key)
            });
        }
        rows.push(KeyedRow { key, row_idx });
    }

    Ok((rows, lookup))
}

fn extract_key(grid: &Grid, row_idx: u32, spec: &KeyColumnSpec) -> KeyValue {
    let mut components = Vec::with_capacity(spec.columns.len());

    for &col in &spec.columns {
        let component = match grid.get(row_idx, col) {
            Some(cell) => KeyComponent {
                value: KeyValueRepr::from_cell_value(cell.value.as_ref()),
                formula: cell.formula.clone(),
            },
            None => KeyComponent {
                value: KeyValueRepr::None,
                formula: None,
            },
        };
        components.push(component);
    }

    KeyValue::new(components)
}

pub fn suggest_key_columns(grid: &Grid, pool: &StringPool) -> Vec<u32> {
    if grid.nrows == 0 || grid.ncols == 0 {
        return Vec::new();
    }

    let header_matches_key_pattern = |col: u32| -> bool {
        if let Some(cell) = grid.get(0, col) {
            if let Some(CellValue::Text(id)) = &cell.value {
                let text = pool.resolve(*id).to_lowercase();
                return text == "id" || text == "key" || text == "sku" 
                    || text.contains("_id") || text.ends_with("id");
            }
        }
        false
    };

    let column_has_unique_values = |col: u32| -> bool {
        let start_row = if grid.nrows > 1 { 1 } else { 0 };
        let mut seen: HashSet<KeyComponent> = HashSet::new();
        for row in start_row..grid.nrows {
            let component = match grid.get(row, col) {
                Some(cell) => KeyComponent {
                    value: KeyValueRepr::from_cell_value(cell.value.as_ref()),
                    formula: cell.formula,
                },
                None => KeyComponent {
                    value: KeyValueRepr::None,
                    formula: None,
                },
            };
            if !seen.insert(component) {
                return false;
            }
        }
        true
    };

    if header_matches_key_pattern(0) && column_has_unique_values(0) {
        return vec![0];
    }

    for col in 0..grid.ncols {
        if header_matches_key_pattern(col) && column_has_unique_values(col) {
            return vec![col];
        }
    }

    for col in 0..grid.ncols {
        if column_has_unique_values(col) {
            return vec![col];
        }
    }

    Vec::new()
}

#[cfg(test)]
mod tests {
    use super::*;
    use crate::workbook::CellValue;

    fn grid_from_rows(rows: &[&[i32]]) -> Grid {
        let nrows = rows.len() as u32;
        let ncols = if nrows == 0 { 0 } else { rows[0].len() as u32 };
        let mut grid = Grid::new(nrows, ncols);

        for (r_idx, row_vals) in rows.iter().enumerate() {
            for (c_idx, value) in row_vals.iter().enumerate() {
                grid.insert_cell(
                    r_idx as u32,
                    c_idx as u32,
                    Some(CellValue::Number(*value as f64)),
                    None,
                );
            }
        }

        grid
    }

    #[test]
    fn unique_keys_reorder_no_changes() {
        let grid_a = grid_from_rows(&[&[1, 10], &[2, 20], &[3, 30]]);
        let grid_b = grid_from_rows(&[&[3, 30], &[1, 10], &[2, 20]]);

        let alignment = diff_table_by_key(&grid_a, &grid_b, &[0]).expect("unique keys");
        assert_eq!(
            alignment.matched_rows,
            vec![(0, 1), (1, 2), (2, 0)],
            "all keys should align regardless of order"
        );
        assert!(alignment.left_only_rows.is_empty());
        assert!(alignment.right_only_rows.is_empty());
    }

    #[test]
    fn unique_keys_insert_delete_classified() {
        let grid_a = grid_from_rows(&[&[1, 10], &[2, 20]]);
        let grid_b = grid_from_rows(&[&[1, 10], &[2, 20], &[3, 30]]);

        let alignment = diff_table_by_key(&grid_a, &grid_b, &[0]).expect("unique keys");
        assert_eq!(alignment.matched_rows, vec![(0, 0), (1, 1)]);
        assert!(alignment.left_only_rows.is_empty());
        assert_eq!(alignment.right_only_rows, vec![2]);
    }

    #[test]
    fn duplicate_keys_error_or_unsupported() {
        let grid_a = grid_from_rows(&[&[1, 10], &[1, 99]]);
        let grid_b = grid_from_rows(&[&[1, 10]]);

        let err = diff_table_by_key(&grid_a, &grid_b, &[0]).expect_err("duplicate keys");
        assert!(matches!(err, KeyAlignmentError::DuplicateKeyLeft(_)));
    }

    #[test]
    fn composite_key_alignment_matches_rows_correctly() {
        let grid_a = grid_from_rows(&[&[1, 10, 100], &[1, 20, 200], &[2, 10, 300]]);
        let grid_b = grid_from_rows(&[&[1, 20, 200], &[2, 10, 300], &[1, 10, 100]]);

        let alignment =
            diff_table_by_key(&grid_a, &grid_b, &[0, 1]).expect("unique composite keys");

        assert!(
            alignment.left_only_rows.is_empty(),
            "no left-only rows expected"
        );
        assert!(
            alignment.right_only_rows.is_empty(),
            "no right-only rows expected"
        );

        let mut matched = alignment.matched_rows.clone();
        matched.sort_unstable();

        let mut expected = vec![(0, 2), (1, 0), (2, 1)];
        expected.sort_unstable();

        assert_eq!(
            matched, expected,
            "composite keys should align rows sharing the same key tuple regardless of order"
        );
    }

    #[test]
    fn non_contiguous_key_columns_alignment() {
        let grid_a = grid_from_rows(&[&[1, 999, 10, 100], &[1, 888, 20, 200], &[2, 777, 10, 300]]);
        let grid_b = grid_from_rows(&[&[2, 777, 10, 300], &[1, 999, 10, 100], &[1, 888, 20, 200]]);

        let alignment =
            diff_table_by_key(&grid_a, &grid_b, &[0, 2]).expect("unique non-contiguous keys");

        assert!(alignment.left_only_rows.is_empty());
        assert!(alignment.right_only_rows.is_empty());

        let mut matched = alignment.matched_rows.clone();
        matched.sort_unstable();

        let mut expected = vec![(0, 1), (1, 2), (2, 0)];
        expected.sort_unstable();

        assert_eq!(
            matched, expected,
            "non-contiguous key columns [0,2] should align correctly"
        );
    }

    #[test]
    fn three_column_composite_key_alignment() {
        let grid_a = grid_from_rows(&[
            &[1, 10, 100, 1000],
            &[1, 10, 200, 2000],
            &[1, 20, 100, 3000],
            &[2, 10, 100, 4000],
        ]);
        let grid_b = grid_from_rows(&[
            &[2, 10, 100, 4000],
            &[1, 20, 100, 3000],
            &[1, 10, 200, 2000],
            &[1, 10, 100, 1000],
        ]);

        let alignment =
            diff_table_by_key(&grid_a, &grid_b, &[0, 1, 2]).expect("unique three-column keys");

        assert!(alignment.left_only_rows.is_empty());
        assert!(alignment.right_only_rows.is_empty());

        let mut matched = alignment.matched_rows.clone();
        matched.sort_unstable();

        let mut expected = vec![(0, 3), (1, 2), (2, 1), (3, 0)];
        expected.sort_unstable();

        assert_eq!(
            matched, expected,
            "three-column composite keys should align correctly"
        );
    }

    #[test]
    fn is_key_column_single_column() {
        let spec = KeyColumnSpec::new(vec![0]);
        assert!(spec.is_key_column(0), "column 0 should be a key column");
        assert!(
            !spec.is_key_column(1),
            "column 1 should not be a key column"
        );
        assert!(
            !spec.is_key_column(2),
            "column 2 should not be a key column"
        );
    }

    #[test]
    fn is_key_column_contiguous_columns() {
        let spec = KeyColumnSpec::new(vec![0, 1]);
        assert!(spec.is_key_column(0), "column 0 should be a key column");
        assert!(spec.is_key_column(1), "column 1 should be a key column");
        assert!(
            !spec.is_key_column(2),
            "column 2 should not be a key column"
        );
        assert!(
            !spec.is_key_column(3),
            "column 3 should not be a key column"
        );
    }

    #[test]
    fn is_key_column_non_contiguous_columns() {
        let spec = KeyColumnSpec::new(vec![0, 2]);
        assert!(spec.is_key_column(0), "column 0 should be a key column");
        assert!(
            !spec.is_key_column(1),
            "column 1 should not be a key column"
        );
        assert!(spec.is_key_column(2), "column 2 should be a key column");
        assert!(
            !spec.is_key_column(3),
            "column 3 should not be a key column"
        );
    }

    #[test]
    fn is_key_column_three_columns() {
        let spec = KeyColumnSpec::new(vec![0, 1, 2]);
        assert!(spec.is_key_column(0));
        assert!(spec.is_key_column(1));
        assert!(spec.is_key_column(2));
        assert!(!spec.is_key_column(3));
    }

    #[test]
    fn is_key_column_non_contiguous_three_columns() {
        let spec = KeyColumnSpec::new(vec![1, 3, 5]);
        assert!(
            !spec.is_key_column(0),
            "column 0 should not be a key column"
        );
        assert!(spec.is_key_column(1), "column 1 should be a key column");
        assert!(
            !spec.is_key_column(2),
            "column 2 should not be a key column"
        );
        assert!(spec.is_key_column(3), "column 3 should be a key column");
        assert!(
            !spec.is_key_column(4),
            "column 4 should not be a key column"
        );
        assert!(spec.is_key_column(5), "column 5 should be a key column");
        assert!(
            !spec.is_key_column(6),
            "column 6 should not be a key column"
        );
    }
}

```

---

### File: `core\src\datamashup.rs`

```rust
//! High-level DataMashup (Power Query) parsing and query extraction.
//!
//! Builds on the low-level framing and package parsing to provide structured
//! access to queries, permissions, and metadata stored in Excel DataMashup sections.

use std::collections::HashMap;

use crate::datamashup_framing::{DataMashupError, RawDataMashup};
use crate::datamashup_package::{PackageParts, parse_package_parts};
use crate::m_section::{SectionParseError, parse_section_members};
use quick_xml::Reader;
use quick_xml::events::Event;

#[derive(Debug, Clone, PartialEq, Eq)]
pub struct DataMashup {
    pub version: u32,
    pub package_parts: PackageParts,
    pub permissions: Permissions,
    pub metadata: Metadata,
    pub permission_bindings_raw: Vec<u8>,
}

#[derive(Debug, Clone, PartialEq, Eq)]
pub struct Permissions {
    pub can_evaluate_future_packages: bool,
    pub firewall_enabled: bool,
    pub workbook_group_type: Option<String>,
}

impl Default for Permissions {
    fn default() -> Self {
        Permissions {
            can_evaluate_future_packages: false,
            firewall_enabled: true,
            workbook_group_type: None,
        }
    }
}

#[derive(Debug, Clone, PartialEq, Eq)]
pub struct Metadata {
    pub formulas: Vec<QueryMetadata>,
}

#[derive(Debug, Clone, PartialEq, Eq)]
pub struct QueryMetadata {
    pub item_path: String,
    pub section_name: String,
    pub formula_name: String,
    pub load_to_sheet: bool,
    pub load_to_model: bool,
    pub is_connection_only: bool,
    pub group_path: Option<String>,
}

#[derive(Debug, Clone, PartialEq, Eq)]
pub struct Query {
    pub name: String,
    pub section_member: String,
    pub expression_m: String,
    pub metadata: QueryMetadata,
}

pub fn build_data_mashup(raw: &RawDataMashup) -> Result<DataMashup, DataMashupError> {
    let package_parts = parse_package_parts(&raw.package_parts)?;
    let permissions = parse_permissions(&raw.permissions);
    let metadata = parse_metadata(&raw.metadata)?;

    Ok(DataMashup {
        version: raw.version,
        package_parts,
        permissions,
        metadata,
        permission_bindings_raw: raw.permission_bindings.clone(),
    })
}

pub fn build_queries(dm: &DataMashup) -> Result<Vec<Query>, SectionParseError> {
    let members = parse_section_members(&dm.package_parts.main_section.source)?;

    let mut metadata_index: HashMap<(String, String), QueryMetadata> = HashMap::new();
    for meta in &dm.metadata.formulas {
        metadata_index.insert(
            (meta.section_name.clone(), meta.formula_name.clone()),
            meta.clone(),
        );
    }

    let mut positions: HashMap<String, usize> = HashMap::new();
    let mut queries = Vec::new();

    for member in members {
        let section_name = member.section_name.clone();
        let member_name = member.member_name.clone();
        let key = (section_name.clone(), member_name.clone());
        let metadata = metadata_index
            .get(&key)
            .cloned()
            .unwrap_or_else(|| QueryMetadata {
                item_path: format!("{}/{}", section_name, member_name),
                section_name: section_name.clone(),
                formula_name: member_name.clone(),
                load_to_sheet: false,
                load_to_model: false,
                is_connection_only: true,
                group_path: None,
            });

        let name = format!("{}/{}", section_name, member_name);
        let query = Query {
            name: name.clone(),
            section_member: member.member_name,
            expression_m: member.expression_m,
            metadata,
        };

        if let Some(idx) = positions.get(&name) {
            debug_assert!(
                false,
                "duplicate query name '{}' found in DataMashup section; \
                 later definition will overwrite earlier one",
                name
            );
            queries[*idx] = query;
        } else {
            positions.insert(name, queries.len());
            queries.push(query);
        }
    }

    Ok(queries)
}

pub fn parse_permissions(xml_bytes: &[u8]) -> Permissions {
    if xml_bytes.is_empty() {
        return Permissions::default();
    }

    let Ok(mut text) = String::from_utf8(xml_bytes.to_vec()) else {
        return Permissions::default();
    };
    if let Some(stripped) = text.strip_prefix('\u{FEFF}') {
        text = stripped.to_string();
    }

    let mut reader = Reader::from_str(&text);
    reader.config_mut().trim_text(true);
    let mut buf = Vec::new();
    let mut current_tag: Option<String> = None;
    let mut permissions = Permissions::default();

    loop {
        match reader.read_event_into(&mut buf) {
            Ok(Event::Start(e)) => {
                current_tag =
                    Some(String::from_utf8_lossy(local_name(e.name().as_ref())).to_string());
            }
            Ok(Event::Text(t)) => {
                if let Some(tag) = current_tag.as_deref() {
                    let value = match t.unescape() {
                        Ok(v) => v.into_owned(),
                        Err(_) => {
                            // Any unescape failure means the permissions payload is unusable; fall back to defaults.
                            return Permissions::default();
                        }
                    };
                    match tag {
                        "CanEvaluateFuturePackages" => {
                            if let Some(v) = parse_bool(&value) {
                                permissions.can_evaluate_future_packages = v;
                            }
                        }
                        "FirewallEnabled" => {
                            if let Some(v) = parse_bool(&value) {
                                permissions.firewall_enabled = v;
                            }
                        }
                        "WorkbookGroupType" => {
                            let trimmed = value.trim();
                            if !trimmed.is_empty() {
                                permissions.workbook_group_type = Some(trimmed.to_string());
                            }
                        }
                        _ => {}
                    }
                }
            }
            Ok(Event::CData(t)) => {
                if let Some(tag) = current_tag.as_deref() {
                    let value = String::from_utf8_lossy(&t.into_inner()).to_string();
                    match tag {
                        "CanEvaluateFuturePackages" => {
                            if let Some(v) = parse_bool(&value) {
                                permissions.can_evaluate_future_packages = v;
                            }
                        }
                        "FirewallEnabled" => {
                            if let Some(v) = parse_bool(&value) {
                                permissions.firewall_enabled = v;
                            }
                        }
                        "WorkbookGroupType" => {
                            let trimmed = value.trim();
                            if !trimmed.is_empty() {
                                permissions.workbook_group_type = Some(trimmed.to_string());
                            }
                        }
                        _ => {}
                    }
                }
            }
            Ok(Event::End(_)) => current_tag = None,
            Ok(Event::Eof) => break,
            Err(_) => return Permissions::default(),
            _ => {}
        }
        buf.clear();
    }

    permissions
}

pub fn parse_metadata(metadata_bytes: &[u8]) -> Result<Metadata, DataMashupError> {
    if metadata_bytes.is_empty() {
        return Ok(Metadata {
            formulas: Vec::new(),
        });
    }

    let xml_bytes = metadata_xml_bytes(metadata_bytes)?;
    let mut text = String::from_utf8(xml_bytes)
        .map_err(|_| DataMashupError::XmlError("metadata is not valid UTF-8".into()))?;
    if let Some(stripped) = text.strip_prefix('\u{FEFF}') {
        text = stripped.to_string();
    }

    let mut reader = Reader::from_str(&text);
    reader.config_mut().trim_text(true);
    let mut buf = Vec::new();

    let mut element_stack: Vec<String> = Vec::new();
    let mut item_type: Option<String> = None;
    let mut item_path: Option<String> = None;
    let mut entries: Vec<(String, String)> = Vec::new();
    let mut formulas: Vec<QueryMetadata> = Vec::new();

    loop {
        match reader.read_event_into(&mut buf) {
            Ok(Event::Empty(e)) => {
                let name = String::from_utf8_lossy(local_name(e.name().as_ref())).to_string();
                if name == "Entry"
                    && let Some((typ, val)) = parse_entry_attributes(&e)?
                {
                    entries.push((typ, val));
                }
            }
            Ok(Event::Start(e)) => {
                let name = String::from_utf8_lossy(local_name(e.name().as_ref())).to_string();
                if name == "Item" {
                    item_type = None;
                    item_path = None;
                    entries.clear();
                }
                if name == "Entry"
                    && let Some((typ, val)) = parse_entry_attributes(&e)?
                {
                    entries.push((typ, val));
                }
                element_stack.push(name);
            }
            Ok(Event::Text(t)) => {
                if let Some(tag) = element_stack.last() {
                    let value = t
                        .unescape()
                        .map_err(|e| DataMashupError::XmlError(e.to_string()))?
                        .into_owned();
                    match tag.as_str() {
                        "ItemType" => {
                            item_type = Some(value.trim().to_string());
                        }
                        "ItemPath" => {
                            item_path = Some(value.trim().to_string());
                        }
                        _ => {}
                    }
                }
            }
            Ok(Event::CData(t)) => {
                if let Some(tag) = element_stack.last() {
                    let value = String::from_utf8_lossy(&t.into_inner()).to_string();
                    match tag.as_str() {
                        "ItemType" => {
                            item_type = Some(value.trim().to_string());
                        }
                        "ItemPath" => {
                            item_path = Some(value.trim().to_string());
                        }
                        _ => {}
                    }
                }
            }
            Ok(Event::End(e)) => {
                let name_bytes = local_name(e.name().as_ref()).to_vec();
                if name_bytes.as_slice() == b"Item" && item_type.as_deref() == Some("Formula") {
                    let raw_path = item_path.clone().ok_or_else(|| {
                        DataMashupError::XmlError("Formula item missing ItemPath".into())
                    })?;
                    let decoded_path = decode_item_path(&raw_path)?;
                    let (section_name, formula_name) = split_item_path(&decoded_path)?;
                    let load_to_sheet =
                        entry_bool(&entries, &["FillEnabled", "LoadEnabled"]).unwrap_or(false);
                    let load_to_model = entry_bool(
                        &entries,
                        &[
                            "FillToDataModelEnabled",
                            "AddedToDataModel",
                            "LoadToDataModel",
                        ],
                    )
                    .unwrap_or(false);
                    // Group paths are derived solely from per-formula entries for now; the AllFormulas tree is not parsed yet.
                    let group_path = entry_string(
                        &entries,
                        &[
                            "QueryGroupId",
                            "QueryGroupID",
                            "QueryGroupPath",
                            "QueryGroup",
                        ],
                    );

                    let metadata = QueryMetadata {
                        item_path: decoded_path.clone(),
                        section_name,
                        formula_name,
                        load_to_sheet,
                        load_to_model,
                        is_connection_only: !(load_to_sheet || load_to_model),
                        group_path,
                    };
                    formulas.push(metadata);
                }

                if let Some(last) = element_stack.last()
                    && last.as_bytes() == name_bytes.as_slice()
                {
                    element_stack.pop();
                }
            }
            Ok(Event::Eof) => break,
            Err(e) => return Err(DataMashupError::XmlError(e.to_string())),
            _ => {}
        }

        buf.clear();
    }

    Ok(Metadata { formulas })
}

fn metadata_xml_bytes(metadata_bytes: &[u8]) -> Result<Vec<u8>, DataMashupError> {
    if looks_like_xml(metadata_bytes) {
        return Ok(metadata_bytes.to_vec());
    }

    if metadata_bytes.len() >= 8 {
        let content_len_bytes: [u8; 4] = metadata_bytes[0..4]
            .try_into()
            .map_err(|_| DataMashupError::InvalidHeader("cannot read content length".into()))?;
        let content_len = u32::from_le_bytes(content_len_bytes) as usize;

        let xml_len_bytes: [u8; 4] = metadata_bytes[4..8]
            .try_into()
            .map_err(|_| DataMashupError::InvalidHeader("cannot read XML length".into()))?;
        let xml_len = u32::from_le_bytes(xml_len_bytes) as usize;

        let start = 8usize
            .checked_add(content_len)
            .ok_or_else(|| DataMashupError::InvalidHeader("metadata length overflow".into()))?;
        let end = start
            .checked_add(xml_len)
            .ok_or_else(|| DataMashupError::InvalidHeader("metadata length overflow".into()))?;
        if end <= metadata_bytes.len() {
            return Ok(metadata_bytes[start..end].to_vec());
        }
        return Err(DataMashupError::InvalidHeader(
            "metadata length prefix invalid".into(),
        ));
    }

    Err(DataMashupError::XmlError("metadata XML not found".into()))
}

fn looks_like_xml(bytes: &[u8]) -> bool {
    let mut idx = 0;
    while idx < bytes.len() && bytes[idx].is_ascii_whitespace() {
        idx += 1;
    }

    if idx >= bytes.len() {
        return false;
    }

    let slice = &bytes[idx..];
    slice.starts_with(b"<")
        || slice.starts_with(&[0xEF, 0xBB, 0xBF])
        || slice.starts_with(&[0xFE, 0xFF])
        || slice.starts_with(&[0xFF, 0xFE])
}

fn local_name(name: &[u8]) -> &[u8] {
    match name.iter().rposition(|&b| b == b':') {
        Some(idx) => name.get(idx + 1..).unwrap_or(name),
        None => name,
    }
}

fn parse_bool(text: &str) -> Option<bool> {
    let trimmed = text.trim();
    let payload = trimmed
        .strip_prefix(|c| c == 'l' || c == 'L')
        .unwrap_or(trimmed);
    let lowered = payload.to_ascii_lowercase();
    match lowered.as_str() {
        "1" | "true" | "yes" => Some(true),
        "0" | "false" | "no" => Some(false),
        _ => None,
    }
}

fn parse_entry_attributes(
    e: &quick_xml::events::BytesStart<'_>,
) -> Result<Option<(String, String)>, DataMashupError> {
    let mut typ: Option<String> = None;
    let mut value: Option<String> = None;

    for attr in e.attributes().with_checks(false) {
        let attr = attr.map_err(|e| DataMashupError::XmlError(e.to_string()))?;
        let key = local_name(attr.key.as_ref());
        if key == b"Type" {
            typ = Some(
                String::from_utf8(attr.value.as_ref().to_vec())
                    .map_err(|e| DataMashupError::XmlError(e.to_string()))?,
            );
        } else if key == b"Value" {
            value = Some(
                String::from_utf8(attr.value.as_ref().to_vec())
                    .map_err(|e| DataMashupError::XmlError(e.to_string()))?,
            );
        }
    }

    match (typ, value) {
        (Some(t), Some(v)) => Ok(Some((t, v))),
        _ => Ok(None),
    }
}

fn entry_bool(entries: &[(String, String)], keys: &[&str]) -> Option<bool> {
    for (key, val) in entries {
        if keys.iter().any(|k| k.eq_ignore_ascii_case(key))
            && let Some(b) = parse_bool(val)
        {
            return Some(b);
        }
    }
    None
}

fn entry_string(entries: &[(String, String)], keys: &[&str]) -> Option<String> {
    for (key, val) in entries {
        if keys.iter().any(|k| k.eq_ignore_ascii_case(key)) {
            let trimmed = val.trim();
            let without_prefix = trimmed
                .strip_prefix('s')
                .or_else(|| trimmed.strip_prefix('S'))
                .unwrap_or(trimmed);
            if without_prefix.is_empty() {
                return None;
            }
            return Some(without_prefix.to_string());
        }
    }
    None
}

fn decode_item_path(path: &str) -> Result<String, DataMashupError> {
    let mut decoded = Vec::with_capacity(path.len());
    let bytes = path.as_bytes();
    let mut idx = 0;
    while idx < bytes.len() {
        let b = bytes[idx];
        if b == b'%' {
            if idx + 2 >= bytes.len() {
                return Err(DataMashupError::XmlError(
                    "invalid percent-encoding in ItemPath".into(),
                ));
            }
            let hi = hex_value(bytes[idx + 1]).ok_or_else(|| {
                DataMashupError::XmlError("invalid percent-encoding in ItemPath".into())
            })?;
            let lo = hex_value(bytes[idx + 2]).ok_or_else(|| {
                DataMashupError::XmlError("invalid percent-encoding in ItemPath".into())
            })?;
            decoded.push(hi << 4 | lo);
            idx += 3;
            continue;
        }
        decoded.push(b);
        idx += 1;
    }
    String::from_utf8(decoded)
        .map_err(|_| DataMashupError::XmlError("invalid UTF-8 in ItemPath".into()))
}

fn hex_value(b: u8) -> Option<u8> {
    match b {
        b'0'..=b'9' => Some(b - b'0'),
        b'a'..=b'f' => Some(10 + b - b'a'),
        b'A'..=b'F' => Some(10 + b - b'A'),
        _ => None,
    }
}

fn split_item_path(path: &str) -> Result<(String, String), DataMashupError> {
    let mut parts = path.split('/');
    let section = parts.next().unwrap_or_default();
    let rest: Vec<&str> = parts.collect();
    if section.is_empty() || rest.is_empty() {
        return Err(DataMashupError::XmlError(
            "invalid ItemPath in metadata".into(),
        ));
    }
    let formula = rest.join("/");
    Ok((section.to_string(), formula))
}

```

---

### File: `core\src\datamashup_framing.rs`

```rust
use base64::Engine;
use base64::engine::general_purpose::STANDARD;
use quick_xml::Reader;
use quick_xml::events::Event;
use thiserror::Error;

use crate::error_codes;

#[derive(Debug, Error)]
#[non_exhaustive]
pub enum DataMashupError {
    #[error("[EXDIFF_DM_001] base64 decoding failed. Suggestion: the workbook may be corrupt; re-save the file in Excel.")]
    Base64Invalid,
    #[error("[EXDIFF_DM_002] unsupported DataMashup version: {0}. Suggestion: update excel_diff or re-save the file in Excel.")]
    UnsupportedVersion(u32),
    #[error("[EXDIFF_DM_003] invalid framing structure. Suggestion: the workbook may be corrupt.")]
    FramingInvalid,
    #[error("[EXDIFF_DM_004] XML parse error: {0}. Suggestion: re-save the file in Excel.")]
    XmlError(String),
    #[error("[EXDIFF_DM_006] invalid header: {0}. Suggestion: the workbook may be corrupt.")]
    InvalidHeader(String),
    #[error("[EXDIFF_DM_005] inner package part too large: '{path}' ({size} bytes, limit {limit} bytes). Suggestion: possible nested ZIP bomb; increase limits only for trusted files.")]
    InnerPartTooLarge { path: String, size: u64, limit: u64 },
    #[error("[EXDIFF_DM_007] inner package has too many entries: {entries} (limit: {max_entries}). Suggestion: possible nested ZIP bomb; increase limits only for trusted files.")]
    InnerTooManyEntries { entries: usize, max_entries: usize },
    #[error("[EXDIFF_DM_008] inner package total uncompressed size exceeds limit: would exceed {limit} bytes. Suggestion: possible nested ZIP bomb; increase limits only for trusted files.")]
    InnerTotalTooLarge { limit: u64 },
}

impl DataMashupError {
    pub fn code(&self) -> &'static str {
        match self {
            DataMashupError::Base64Invalid => error_codes::DM_BASE64_INVALID,
            DataMashupError::UnsupportedVersion(_) => error_codes::DM_UNSUPPORTED_VERSION,
            DataMashupError::FramingInvalid => error_codes::DM_FRAMING_INVALID,
            DataMashupError::XmlError(_) => error_codes::DM_XML_ERROR,
            DataMashupError::InvalidHeader(_) => error_codes::DM_INVALID_HEADER,
            DataMashupError::InnerPartTooLarge { .. } => error_codes::DM_INNER_PART_TOO_LARGE,
            DataMashupError::InnerTooManyEntries { .. } => error_codes::DM_INNER_TOO_MANY_ENTRIES,
            DataMashupError::InnerTotalTooLarge { .. } => error_codes::DM_INNER_TOTAL_TOO_LARGE,
        }
    }
}

#[derive(Debug, Clone, PartialEq, Eq)]
pub struct RawDataMashup {
    pub version: u32,
    pub package_parts: Vec<u8>,
    pub permissions: Vec<u8>,
    pub metadata: Vec<u8>,
    pub permission_bindings: Vec<u8>,
}

pub fn parse_data_mashup(bytes: &[u8]) -> Result<RawDataMashup, DataMashupError> {
    const MIN_SIZE: usize = 4 + 4 * 4;
    if bytes.len() < MIN_SIZE {
        return Err(DataMashupError::FramingInvalid);
    }

    let mut offset: usize = 0;
    let version = read_u32_at(bytes, offset).ok_or(DataMashupError::FramingInvalid)?;
    offset += 4;

    if version != 0 {
        return Err(DataMashupError::UnsupportedVersion(version));
    }

    let package_parts_len = read_length(bytes, offset)?;
    offset += 4;
    let package_parts = take_segment(bytes, &mut offset, package_parts_len)?;

    let permissions_len = read_length(bytes, offset)?;
    offset += 4;
    let permissions = take_segment(bytes, &mut offset, permissions_len)?;

    let metadata_len = read_length(bytes, offset)?;
    offset += 4;
    let metadata = take_segment(bytes, &mut offset, metadata_len)?;

    let permission_bindings_len = read_length(bytes, offset)?;
    offset += 4;
    let permission_bindings = take_segment(bytes, &mut offset, permission_bindings_len)?;

    if offset != bytes.len() {
        return Err(DataMashupError::FramingInvalid);
    }

    Ok(RawDataMashup {
        version,
        package_parts,
        permissions,
        metadata,
        permission_bindings,
    })
}

pub fn read_datamashup_text(xml: &[u8]) -> Result<Option<String>, DataMashupError> {
    let utf8_xml = decode_datamashup_xml(xml)?;

    let mut reader = Reader::from_reader(utf8_xml.as_deref().unwrap_or(xml));
    reader.config_mut().trim_text(false);
    let mut buf = Vec::new();
    let mut in_datamashup = false;
    let mut found_content: Option<String> = None;
    let mut content = String::new();

    loop {
        match reader.read_event_into(&mut buf) {
            Ok(Event::Start(e)) if is_datamashup_element(e.name().as_ref()) => {
                if in_datamashup || found_content.is_some() {
                    return Err(DataMashupError::FramingInvalid);
                }
                in_datamashup = true;
                content.clear();
            }
            Ok(Event::Text(t)) if in_datamashup => {
                let text = t
                    .unescape()
                    .map_err(|e| DataMashupError::XmlError(e.to_string()))?
                    .into_owned();
                content.push_str(&text);
            }
            Ok(Event::CData(t)) if in_datamashup => {
                let data = t.into_inner();
                content.push_str(&String::from_utf8_lossy(&data));
            }
            Ok(Event::End(e)) if is_datamashup_element(e.name().as_ref()) => {
                if !in_datamashup {
                    return Err(DataMashupError::FramingInvalid);
                }
                in_datamashup = false;
                found_content = Some(content.clone());
            }
            Ok(Event::Eof) if in_datamashup => {
                return Err(DataMashupError::FramingInvalid);
            }
            Ok(Event::Eof) => return Ok(found_content),
            Err(e) => return Err(DataMashupError::XmlError(e.to_string())),
            _ => {}
        }
        buf.clear();
    }
}

pub fn decode_datamashup_base64(text: &str) -> Result<Vec<u8>, DataMashupError> {
    let cleaned: String = text.split_whitespace().collect();
    STANDARD
        .decode(cleaned.as_bytes())
        .map_err(|_| DataMashupError::Base64Invalid)
}

pub(crate) fn decode_datamashup_xml(xml: &[u8]) -> Result<Option<Vec<u8>>, DataMashupError> {
    if xml.starts_with(&[0xFF, 0xFE]) {
        return Ok(Some(decode_utf16_xml(xml, true, true)?));
    }
    if xml.starts_with(&[0xFE, 0xFF]) {
        return Ok(Some(decode_utf16_xml(xml, false, true)?));
    }

    decode_declared_utf16_without_bom(xml)
}

fn decode_declared_utf16_without_bom(xml: &[u8]) -> Result<Option<Vec<u8>>, DataMashupError> {
    let attempt_decode = |little_endian| -> Result<Option<Vec<u8>>, DataMashupError> {
        if !looks_like_utf16(xml, little_endian) {
            return Ok(None);
        }
        let decoded = decode_utf16_xml(xml, little_endian, false)?;
        let lower = String::from_utf8_lossy(&decoded).to_ascii_lowercase();
        if lower.contains("encoding=\"utf-16\"") || lower.contains("encoding='utf-16'") {
            Ok(Some(decoded))
        } else {
            Ok(None)
        }
    };

    if let Some(decoded) = attempt_decode(true)? {
        return Ok(Some(decoded));
    }
    attempt_decode(false)
}

fn looks_like_utf16(xml: &[u8], little_endian: bool) -> bool {
    if xml.len() < 4 {
        return false;
    }

    if little_endian {
        xml[0] == b'<' && xml[1] == 0 && xml[2] == b'?' && xml[3] == 0
    } else {
        xml[0] == 0 && xml[1] == b'<' && xml[2] == 0 && xml[3] == b'?'
    }
}

fn decode_utf16_xml(
    xml: &[u8],
    little_endian: bool,
    has_bom: bool,
) -> Result<Vec<u8>, DataMashupError> {
    let start = if has_bom { 2 } else { 0 };
    let body = xml
        .get(start..)
        .ok_or_else(|| DataMashupError::XmlError("invalid UTF-16 XML".into()))?;
    if body.len() % 2 != 0 {
        return Err(DataMashupError::XmlError(
            "invalid UTF-16 byte length".into(),
        ));
    }

    let mut code_units = Vec::with_capacity(body.len() / 2);
    for chunk in body.chunks_exact(2) {
        let unit = if little_endian {
            u16::from_le_bytes([chunk[0], chunk[1]])
        } else {
            u16::from_be_bytes([chunk[0], chunk[1]])
        };
        code_units.push(unit);
    }

    let utf8 = String::from_utf16(&code_units)
        .map_err(|_| DataMashupError::XmlError("invalid UTF-16 XML".into()))?;
    Ok(utf8.into_bytes())
}

fn is_datamashup_element(name: &[u8]) -> bool {
    match name.iter().rposition(|&b| b == b':') {
        Some(idx) => name.get(idx + 1..) == Some(b"DataMashup".as_slice()),
        None => name == b"DataMashup",
    }
}

fn read_u32_at(bytes: &[u8], offset: usize) -> Option<u32> {
    let slice = bytes.get(offset..offset + 4)?;
    let array: [u8; 4] = slice.try_into().ok()?;
    Some(u32::from_le_bytes(array))
}

fn read_length(bytes: &[u8], offset: usize) -> Result<usize, DataMashupError> {
    let len = read_u32_at(bytes, offset).ok_or(DataMashupError::FramingInvalid)?;
    usize::try_from(len).map_err(|_| DataMashupError::FramingInvalid)
}

fn take_segment(bytes: &[u8], offset: &mut usize, len: usize) -> Result<Vec<u8>, DataMashupError> {
    let start = *offset;
    let end = start
        .checked_add(len)
        .ok_or(DataMashupError::FramingInvalid)?;
    if end > bytes.len() {
        return Err(DataMashupError::FramingInvalid);
    }

    let segment = bytes[start..end].to_vec();
    *offset = end;
    Ok(segment)
}

#[cfg(test)]
mod tests {
    use super::{
        DataMashupError, RawDataMashup, decode_datamashup_base64, parse_data_mashup,
        read_datamashup_text,
    };

    fn build_dm_bytes(
        version: u32,
        package_parts: &[u8],
        permissions: &[u8],
        metadata: &[u8],
        permission_bindings: &[u8],
    ) -> Vec<u8> {
        let mut bytes = Vec::new();
        bytes.extend_from_slice(&version.to_le_bytes());
        bytes.extend_from_slice(&(package_parts.len() as u32).to_le_bytes());
        bytes.extend_from_slice(package_parts);
        bytes.extend_from_slice(&(permissions.len() as u32).to_le_bytes());
        bytes.extend_from_slice(permissions);
        bytes.extend_from_slice(&(metadata.len() as u32).to_le_bytes());
        bytes.extend_from_slice(metadata);
        bytes.extend_from_slice(&(permission_bindings.len() as u32).to_le_bytes());
        bytes.extend_from_slice(permission_bindings);
        bytes
    }

    #[test]
    fn parse_zero_length_stream_succeeds() {
        let bytes = build_dm_bytes(0, b"", b"", b"", b"");
        let parsed = parse_data_mashup(&bytes).expect("zero-length sections should parse");
        assert_eq!(
            parsed,
            RawDataMashup {
                version: 0,
                package_parts: Vec::new(),
                permissions: Vec::new(),
                metadata: Vec::new(),
                permission_bindings: Vec::new(),
            }
        );
    }

    #[test]
    fn parse_basic_non_zero_lengths() {
        let bytes = build_dm_bytes(0, b"AAAA", b"BBBB", b"CCCC", b"DDDD");
        let parsed = parse_data_mashup(&bytes).expect("non-zero lengths should parse");
        assert_eq!(parsed.version, 0);
        assert_eq!(parsed.package_parts, b"AAAA");
        assert_eq!(parsed.permissions, b"BBBB");
        assert_eq!(parsed.metadata, b"CCCC");
        assert_eq!(parsed.permission_bindings, b"DDDD");
    }

    #[test]
    fn unsupported_version_is_rejected() {
        let bytes = build_dm_bytes(1, b"AAAA", b"BBBB", b"CCCC", b"DDDD");
        let err = parse_data_mashup(&bytes).expect_err("version 1 should be unsupported");
        assert!(matches!(err, DataMashupError::UnsupportedVersion(1)));
    }

    #[test]
    fn truncated_stream_errors() {
        let mut bytes = Vec::new();
        bytes.extend_from_slice(&0u32.to_le_bytes());
        bytes.extend_from_slice(&100u32.to_le_bytes());
        bytes.extend_from_slice(&0u32.to_le_bytes());
        bytes.extend_from_slice(&0u32.to_le_bytes());
        bytes.extend_from_slice(&0u32.to_le_bytes());
        let err = parse_data_mashup(&bytes).expect_err("length overflows buffer");
        assert!(matches!(err, DataMashupError::FramingInvalid));
    }

    #[test]
    fn trailing_bytes_are_invalid() {
        let mut bytes = build_dm_bytes(0, b"", b"", b"", b"");
        bytes.push(0xFF);
        let err = parse_data_mashup(&bytes).expect_err("trailing bytes should fail");
        assert!(matches!(err, DataMashupError::FramingInvalid));
    }

    #[test]
    fn too_short_stream_is_framing_invalid() {
        let bytes = vec![0u8; 8];
        let err =
            parse_data_mashup(&bytes).expect_err("buffer shorter than header must be invalid");
        assert!(matches!(err, DataMashupError::FramingInvalid));
    }

    #[test]
    fn utf16_datamashup_xml_decodes_correctly() {
        let xml_text = r#"<?xml version="1.0" encoding="utf-16"?><root xmlns:dm="http://schemas.microsoft.com/DataMashup"><dm:DataMashup>QQ==</dm:DataMashup></root>"#;
        let mut xml_bytes = Vec::with_capacity(2 + xml_text.len() * 2);
        xml_bytes.extend_from_slice(&[0xFF, 0xFE]);
        for unit in xml_text.encode_utf16() {
            xml_bytes.extend_from_slice(&unit.to_le_bytes());
        }

        let text = read_datamashup_text(&xml_bytes)
            .expect("UTF-16 XML should parse")
            .expect("DataMashup element should be found");
        assert_eq!(text.trim(), "QQ==");
    }

    #[test]
    fn utf16_without_bom_with_declared_encoding_parses() {
        let xml_text = r#"<?xml version="1.0" encoding="utf-16"?><root xmlns:dm="http://schemas.microsoft.com/DataMashup"><dm:DataMashup>QQ==</dm:DataMashup></root>"#;
        for &little_endian in &[true, false] {
            let mut xml_bytes = Vec::with_capacity(xml_text.len() * 2);
            for unit in xml_text.encode_utf16() {
                let bytes = if little_endian {
                    unit.to_le_bytes()
                } else {
                    unit.to_be_bytes()
                };
                xml_bytes.extend_from_slice(&bytes);
            }

            let text = read_datamashup_text(&xml_bytes)
                .expect("UTF-16 XML without BOM should parse when declared")
                .expect("DataMashup element should be found");
            assert_eq!(text.trim(), "QQ==");
        }
    }

    #[test]
    fn elements_with_datamashup_suffix_are_ignored() {
        let xml = br#"<?xml version="1.0"?><root><FooDataMashup>QQ==</FooDataMashup></root>"#;
        let result = read_datamashup_text(xml).expect("parsing should succeed");
        assert!(result.is_none());
    }

    #[test]
    fn duplicate_sibling_datamashup_elements_error() {
        let xml = br#"<?xml version="1.0"?>
<root xmlns:dm="http://schemas.microsoft.com/DataMashup">
  <dm:DataMashup>QQ==</dm:DataMashup>
  <dm:DataMashup>QQ==</dm:DataMashup>
</root>"#;
        let err = read_datamashup_text(xml).expect_err("duplicate DataMashup elements should fail");
        assert!(matches!(err, DataMashupError::FramingInvalid));
    }

    #[test]
    fn decode_datamashup_base64_rejects_invalid() {
        let err = decode_datamashup_base64("!!!").expect_err("invalid base64 should fail");
        assert!(matches!(err, DataMashupError::Base64Invalid));
    }

    #[test]
    fn fuzz_style_never_panics() {
        for seed in 0u64..32 {
            let len = (seed as usize * 7 % 48) + (seed as usize % 5);
            let mut state = seed.wrapping_mul(6364136223846793005).wrapping_add(1);
            let mut bytes = Vec::with_capacity(len);
            for _ in 0..len {
                state = state
                    .wrapping_mul(2862933555777941757)
                    .wrapping_add(3037000493);
                bytes.push((state >> 32) as u8);
            }
            let _ = parse_data_mashup(&bytes);
        }
    }
}

```

---

### File: `core\src\datamashup_package.rs`

```rust
use crate::datamashup_framing::DataMashupError;
use std::io::{Cursor, Read, Seek};
use zip::ZipArchive;

#[derive(Debug, Clone, Copy)]
pub struct DataMashupLimits {
    pub max_inner_entries: usize,
    pub max_inner_part_bytes: u64,
    pub max_inner_total_bytes: u64,
}

impl Default for DataMashupLimits {
    fn default() -> Self {
        Self {
            max_inner_entries: 10_000,
            max_inner_part_bytes: 100 * 1024 * 1024,
            max_inner_total_bytes: 500 * 1024 * 1024,
        }
    }
}

#[derive(Debug, Clone, PartialEq, Eq)]
pub struct PackageXml {
    pub raw_xml: String,
}

#[derive(Debug, Clone, PartialEq, Eq)]
pub struct SectionDocument {
    pub source: String,
}

#[derive(Debug, Clone, PartialEq, Eq)]
pub struct EmbeddedContent {
    /// Normalized PackageParts path for the embedded package (never starts with '/').
    pub name: String,
    pub section: SectionDocument,
}

#[derive(Debug, Clone, PartialEq, Eq)]
pub struct PackageParts {
    pub package_xml: PackageXml,
    pub main_section: SectionDocument,
    pub embedded_contents: Vec<EmbeddedContent>,
}

pub fn parse_package_parts(bytes: &[u8]) -> Result<PackageParts, DataMashupError> {
    parse_package_parts_with_limits(bytes, DataMashupLimits::default())
}

pub fn parse_package_parts_with_limits(
    bytes: &[u8],
    limits: DataMashupLimits,
) -> Result<PackageParts, DataMashupError> {
    let cursor = Cursor::new(bytes);
    let mut archive = ZipArchive::new(cursor).map_err(|_| DataMashupError::FramingInvalid)?;

    if archive.len() > limits.max_inner_entries {
        return Err(DataMashupError::InnerTooManyEntries {
            entries: archive.len(),
            max_entries: limits.max_inner_entries,
        });
    }

    let mut total_read: u64 = 0;
    let mut package_xml: Option<PackageXml> = None;
    let mut main_section: Option<SectionDocument> = None;
    let mut embedded_contents: Vec<EmbeddedContent> = Vec::new();

    for i in 0..archive.len() {
        let mut file = archive
            .by_index(i)
            .map_err(|_| DataMashupError::FramingInvalid)?;
        if file.is_dir() {
            continue;
        }

        let raw_name = file.name().to_string();
        let name = normalize_path(&raw_name);
        if package_xml.is_none() && name == "Config/Package.xml" {
            reserve_inner_read_budget(&mut total_read, name, file.size(), limits)?;
            let text = read_file_to_string(&mut file)?;
            package_xml = Some(PackageXml { raw_xml: text });
            continue;
        }
        if main_section.is_none() && name == "Formulas/Section1.m" {
            reserve_inner_read_budget(&mut total_read, name, file.size(), limits)?;
            let text = strip_leading_bom(read_file_to_string(&mut file)?);
            main_section = Some(SectionDocument { source: text });
            continue;
        }
        if name.starts_with("Content/") {
            reserve_inner_read_budget(&mut total_read, name, file.size(), limits)?;
            let mut content_bytes = Vec::new();
            if file.read_to_end(&mut content_bytes).is_err() {
                continue;
            }

            match extract_embedded_section(&content_bytes, limits, name)? {
                Some(section) => {
                    embedded_contents.push(EmbeddedContent {
                        name: normalize_path(&raw_name).to_string(),
                        section: SectionDocument { source: section },
                    });
                }
                None => {}
            }
        }
    }

    let package_xml = package_xml.ok_or(DataMashupError::FramingInvalid)?;
    let main_section = main_section.ok_or(DataMashupError::FramingInvalid)?;

    Ok(PackageParts {
        package_xml,
        main_section,
        embedded_contents,
    })
}

fn normalize_path(name: &str) -> &str {
    name.trim_start_matches('/')
}

fn read_file_to_string(file: &mut zip::read::ZipFile<'_>) -> Result<String, DataMashupError> {
    let mut buf = Vec::new();
    file.read_to_end(&mut buf)
        .map_err(|_| DataMashupError::FramingInvalid)?;
    String::from_utf8(buf).map_err(|_| DataMashupError::FramingInvalid)
}

fn reserve_inner_read_budget(
    total_read: &mut u64,
    path: &str,
    size: u64,
    limits: DataMashupLimits,
) -> Result<(), DataMashupError> {
    if size > limits.max_inner_part_bytes {
        return Err(DataMashupError::InnerPartTooLarge {
            path: path.to_string(),
            size,
            limit: limits.max_inner_part_bytes,
        });
    }

    let new_total = total_read.saturating_add(size);
    if new_total > limits.max_inner_total_bytes {
        return Err(DataMashupError::InnerTotalTooLarge {
            limit: limits.max_inner_total_bytes,
        });
    }

    *total_read = new_total;
    Ok(())
}

fn extract_embedded_section(
    bytes: &[u8],
    limits: DataMashupLimits,
    outer_name: &str,
) -> Result<Option<String>, DataMashupError> {
    let cursor = Cursor::new(bytes);
    let mut archive = match ZipArchive::new(cursor) {
        Ok(archive) => archive,
        Err(_) => return Ok(None),
    };

    if archive.len() > limits.max_inner_entries {
        return Err(DataMashupError::InnerTooManyEntries {
            entries: archive.len(),
            max_entries: limits.max_inner_entries,
        });
    }

    find_section_document(&mut archive, limits, outer_name)
}

fn find_section_document<R: Read + Seek>(
    archive: &mut ZipArchive<R>,
    limits: DataMashupLimits,
    outer_name: &str,
) -> Result<Option<String>, DataMashupError> {
    let mut total_read: u64 = 0;

    for idx in 0..archive.len() {
        let mut file = match archive.by_index(idx) {
            Ok(file) => file,
            Err(_) => continue,
        };
        if file.is_dir() {
            continue;
        }

        let inner_name = normalize_path(file.name());
        if inner_name == "Formulas/Section1.m" {
            let combined_name = format!("{outer_name}/{inner_name}");
            reserve_inner_read_budget(&mut total_read, &combined_name, file.size(), limits)?;
            let mut buf = Vec::new();
            if file.read_to_end(&mut buf).is_ok() {
                if let Ok(text) = String::from_utf8(buf) {
                    return Ok(Some(strip_leading_bom(text)));
                }
            }
            return Ok(None);
        }
    }
    Ok(None)
}

fn strip_leading_bom(text: String) -> String {
    text.strip_prefix('\u{FEFF}')
        .map(|s| s.to_string())
        .unwrap_or(text)
}

```

---

### File: `core\src\diff.rs`

```rust
//! Diff operations and reports for workbook comparison.
//!
//! This module defines the types used to represent differences between two workbooks:
//! - [`DiffOp`]: Individual operations representing a single change (cell edit, row/column add/remove, etc.)
//! - [`DiffReport`]: A versioned collection of diff operations
//! - [`DiffError`]: Errors that can occur during the diff process

use crate::error_codes;
use crate::string_pool::StringId;
use crate::workbook::{CellAddress, CellSnapshot, ColSignature, RowSignature};
use thiserror::Error;

#[derive(Debug, Clone, Copy, PartialEq, Eq, serde::Serialize, serde::Deserialize)]
pub enum QueryChangeKind {
    /// A semantic change (meaningfully different after canonicalization).
    Semantic,
    /// Only formatting changed (whitespace/comments); meaning is unchanged.
    FormattingOnly,
    /// The query was renamed (definition may be unchanged).
    Renamed,
}

#[derive(Debug, Clone, Copy, PartialEq, Eq, serde::Serialize, serde::Deserialize)]
#[serde(rename_all = "snake_case")]
pub enum FormulaDiffResult {
    /// Unknown or not computed.
    Unknown,
    /// Formula/value is unchanged.
    Unchanged,
    /// Formula/value was added.
    Added,
    /// Formula/value was removed.
    Removed,
    /// Only formatting changed (whitespace/casing), semantics unchanged.
    FormattingOnly,
    /// Filled down/across (shift-equivalent).
    Filled,
    /// Semantic change.
    SemanticChange,
    /// Textual change (different text but semantics not computed/unknown).
    TextChange,
}

impl Default for FormulaDiffResult {
    fn default() -> Self {
        FormulaDiffResult::Unknown
    }
}

#[derive(Debug, Clone, Copy, PartialEq, Eq, serde::Serialize, serde::Deserialize)]
pub enum QueryMetadataField {
    /// Whether the query loads to a sheet.
    LoadToSheet,
    /// Whether the query loads to the data model.
    LoadToModel,
    /// Query group path.
    GroupPath,
    /// Whether the query is connection-only.
    ConnectionOnly,
}

/// Errors produced by diffing APIs.
#[derive(Debug, Error)]
#[non_exhaustive]
pub enum DiffError {
    #[error(
        "[EXDIFF_DIFF_001] alignment limits exceeded for sheet '{sheet}': rows={rows}, cols={cols} (limits: rows={max_rows}, cols={max_cols}). Suggestion: increase `max_align_rows`/`max_align_cols` or change `on_limit_exceeded`."
    )]
    LimitsExceeded {
        sheet: StringId,
        rows: u32,
        cols: u32,
        max_rows: u32,
        max_cols: u32,
    },

    #[error("[EXDIFF_DIFF_002] sink error: {message}. Suggestion: check the output destination and retry.")]
    SinkError { message: String },

    #[error("[EXDIFF_DIFF_003] sheet '{requested}' not found. Available sheets: {}. Suggestion: check the sheet name and casing.", available.join(", "))]
    SheetNotFound {
        requested: String,
        available: Vec<String>,
    },

    #[error("[EXDIFF_DIFF_004] internal error: {message}. Suggestion: report a bug with the input file if possible.")]
    InternalError { message: String },
}

impl DiffError {
    pub fn code(&self) -> &'static str {
        match self {
            DiffError::LimitsExceeded { .. } => error_codes::DIFF_LIMITS_EXCEEDED,
            DiffError::SinkError { .. } => error_codes::DIFF_SINK_ERROR,
            DiffError::SheetNotFound { .. } => error_codes::DIFF_SHEET_NOT_FOUND,
            DiffError::InternalError { .. } => error_codes::DIFF_INTERNAL_ERROR,
        }
    }
}

pub type SheetId = StringId;

/// Summary metadata about a diff run emitted alongside streamed ops.
#[derive(Debug, Clone, PartialEq, Eq)]
pub struct DiffSummary {
    /// Whether the diff completed without early aborts/fallbacks.
    pub complete: bool,
    /// Warnings explaining why results are incomplete (when `complete == false`).
    pub warnings: Vec<String>,
    /// Total number of ops emitted.
    pub op_count: usize,
    #[cfg(feature = "perf-metrics")]
    /// Optional performance metrics when the `perf-metrics` feature is enabled.
    pub metrics: Option<crate::perf::DiffMetrics>,
}

/// A single diff operation representing one logical change between workbooks.
///
/// Operations are emitted by the diff engine and collected into a [`DiffReport`].
/// The enum is marked `#[non_exhaustive]` to allow future additions.
#[derive(Debug, Clone, PartialEq, Eq, serde::Serialize, serde::Deserialize)]
#[serde(tag = "kind")]
#[non_exhaustive]
pub enum DiffOp {
    SheetAdded {
        sheet: SheetId,
    },
    SheetRemoved {
        sheet: SheetId,
    },
    RowAdded {
        sheet: SheetId,
        row_idx: u32,
        #[serde(skip_serializing_if = "Option::is_none")]
        row_signature: Option<RowSignature>,
    },
    RowRemoved {
        sheet: SheetId,
        row_idx: u32,
        #[serde(skip_serializing_if = "Option::is_none")]
        row_signature: Option<RowSignature>,
    },
    ColumnAdded {
        sheet: SheetId,
        col_idx: u32,
        #[serde(skip_serializing_if = "Option::is_none")]
        col_signature: Option<ColSignature>,
    },
    ColumnRemoved {
        sheet: SheetId,
        col_idx: u32,
        #[serde(skip_serializing_if = "Option::is_none")]
        col_signature: Option<ColSignature>,
    },
    BlockMovedRows {
        sheet: SheetId,
        src_start_row: u32,
        row_count: u32,
        dst_start_row: u32,
        #[serde(skip_serializing_if = "Option::is_none")]
        block_hash: Option<u64>,
    },
    BlockMovedColumns {
        sheet: SheetId,
        src_start_col: u32,
        col_count: u32,
        dst_start_col: u32,
        #[serde(skip_serializing_if = "Option::is_none")]
        block_hash: Option<u64>,
    },
    BlockMovedRect {
        sheet: SheetId,
        src_start_row: u32,
        src_row_count: u32,
        src_start_col: u32,
        src_col_count: u32,
        dst_start_row: u32,
        dst_start_col: u32,
        #[serde(skip_serializing_if = "Option::is_none")]
        block_hash: Option<u64>,
    },
    /// Logical change to a single cell.
    ///
    /// Invariants (maintained by producers and tests, not by the type system):
    /// - `addr` is the canonical location for the edit.
    /// - `from.addr` and `to.addr` must both equal `addr`.
    /// - `CellSnapshot` equality intentionally ignores `addr` and compares only
    ///   `(value, formula)`, so `DiffOp::CellEdited` equality does not by itself
    ///   enforce the address invariants; callers must respect them when
    ///   constructing ops.
    CellEdited {
        sheet: SheetId,
        addr: CellAddress,
        from: CellSnapshot,
        to: CellSnapshot,
        #[serde(default)]
        formula_diff: FormulaDiffResult,
    },

    VbaModuleAdded {
        name: StringId,
    },
    VbaModuleRemoved {
        name: StringId,
    },
    VbaModuleChanged {
        name: StringId,
    },

    NamedRangeAdded {
        name: StringId,
    },
    NamedRangeRemoved {
        name: StringId,
    },
    NamedRangeChanged {
        name: StringId,
        old_ref: StringId,
        new_ref: StringId,
    },

    ChartAdded {
        sheet: StringId,
        name: StringId,
    },
    ChartRemoved {
        sheet: StringId,
        name: StringId,
    },
    ChartChanged {
        sheet: StringId,
        name: StringId,
    },

    QueryAdded {
        name: StringId,
    },
    QueryRemoved {
        name: StringId,
    },
    QueryRenamed {
        from: StringId,
        to: StringId,
    },
    QueryDefinitionChanged {
        name: StringId,
        change_kind: QueryChangeKind,
        old_hash: u64,
        new_hash: u64,
    },
    QueryMetadataChanged {
        name: StringId,
        field: QueryMetadataField,
        old: Option<StringId>,
        new: Option<StringId>,
    },
    // Future: DAX operations
    // MeasureAdded { name: StringId }
    // MeasureRemoved { name: StringId }
    // MeasureDefinitionChanged { name: StringId, change_kind: QueryChangeKind }
}

/// A versioned collection of diff operations between two workbooks.
///
/// The `version` field indicates the schema version for forwards compatibility.
///
/// # Incomplete results
///
/// Some safety rails and limit behaviors can produce partial results. In that case:
///
/// - `complete == false`
/// - `warnings` contains at least one human-readable explanation
///
/// The CLI prints warnings to stderr as `Warning: ...`.
#[derive(Debug, Clone, PartialEq, Eq, serde::Serialize, serde::Deserialize)]
pub struct DiffReport {
    /// Schema version (currently "1").
    pub version: String,
    /// Interned string table used by ids referenced in this report.
    #[serde(default)]
    pub strings: Vec<String>,
    /// The list of diff operations.
    pub ops: Vec<DiffOp>,
    /// Whether the diff result is complete. When `false`, some operations may be missing
    /// due to resource limits being exceeded (e.g., row/column limits).
    #[serde(default = "default_complete")]
    pub complete: bool,
    /// Warnings generated during the diff process. Non-empty when limits were exceeded
    /// or other partial-result conditions occurred.
    #[serde(default, skip_serializing_if = "Vec::is_empty")]
    pub warnings: Vec<String>,
    #[cfg(feature = "perf-metrics")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub metrics: Option<crate::perf::DiffMetrics>,
}

fn default_complete() -> bool {
    true
}

impl DiffReport {
    pub const SCHEMA_VERSION: &'static str = "1";

    pub fn new(ops: Vec<DiffOp>) -> DiffReport {
        DiffReport {
            version: Self::SCHEMA_VERSION.to_string(),
            strings: Vec::new(),
            ops,
            complete: true,
            warnings: Vec::new(),
            #[cfg(feature = "perf-metrics")]
            metrics: None,
        }
    }

    pub fn from_ops_and_summary(
        ops: Vec<DiffOp>,
        summary: DiffSummary,
        strings: Vec<String>,
    ) -> DiffReport {
        let mut report = DiffReport::new(ops);
        report.complete = summary.complete;
        report.warnings = summary.warnings;
        #[cfg(feature = "perf-metrics")]
        {
            report.metrics = summary.metrics;
        }
        report.strings = strings;
        report
    }

    pub fn with_partial_result(ops: Vec<DiffOp>, warning: String) -> DiffReport {
        DiffReport {
            version: Self::SCHEMA_VERSION.to_string(),
            strings: Vec::new(),
            ops,
            complete: false,
            warnings: vec![warning],
            #[cfg(feature = "perf-metrics")]
            metrics: None,
        }
    }

    pub fn add_warning(&mut self, warning: String) {
        self.warnings.push(warning);
        self.complete = false;
    }

    /// Resolve an interned [`StringId`] into a string slice using this report's `strings` table.
    ///
    /// Many fields in [`DiffOp`] are `StringId`s (sheet names, query names, etc.). The returned
    /// string is owned by the report.
    ///
    /// ```
    /// # use excel_diff::{DiffReport, StringId};
    /// # fn demo(report: &DiffReport, id: StringId) {
    /// let text = report.resolve(id).unwrap_or("<unknown>");
    /// # let _ = text;
    /// # }
    /// ```
    pub fn resolve(&self, id: StringId) -> Option<&str> {
        self.strings.get(id.0 as usize).map(|s| s.as_str())
    }

    pub fn grid_ops(&self) -> impl Iterator<Item = &DiffOp> {
        self.ops.iter().filter(|op| !op.is_m_op())
    }

    pub fn m_ops(&self) -> impl Iterator<Item = &DiffOp> {
        self.ops.iter().filter(|op| op.is_m_op())
    }
}

impl DiffOp {
    pub fn is_m_op(&self) -> bool {
        matches!(
            self,
            DiffOp::QueryAdded { .. }
                | DiffOp::QueryRemoved { .. }
                | DiffOp::QueryRenamed { .. }
                | DiffOp::QueryDefinitionChanged { .. }
                | DiffOp::QueryMetadataChanged { .. }
        )
    }

    pub fn cell_edited(
        sheet: SheetId,
        addr: CellAddress,
        from: CellSnapshot,
        to: CellSnapshot,
        formula_diff: FormulaDiffResult,
    ) -> DiffOp {
        debug_assert_eq!(from.addr, addr, "from.addr must match canonical addr");
        debug_assert_eq!(to.addr, addr, "to.addr must match canonical addr");
        DiffOp::CellEdited {
            sheet,
            addr,
            from,
            to,
            formula_diff,
        }
    }

    pub fn row_added(sheet: SheetId, row_idx: u32, row_signature: Option<RowSignature>) -> DiffOp {
        DiffOp::RowAdded {
            sheet,
            row_idx,
            row_signature,
        }
    }

    pub fn row_removed(
        sheet: SheetId,
        row_idx: u32,
        row_signature: Option<RowSignature>,
    ) -> DiffOp {
        DiffOp::RowRemoved {
            sheet,
            row_idx,
            row_signature,
        }
    }

    pub fn column_added(
        sheet: SheetId,
        col_idx: u32,
        col_signature: Option<ColSignature>,
    ) -> DiffOp {
        DiffOp::ColumnAdded {
            sheet,
            col_idx,
            col_signature,
        }
    }

    pub fn column_removed(
        sheet: SheetId,
        col_idx: u32,
        col_signature: Option<ColSignature>,
    ) -> DiffOp {
        DiffOp::ColumnRemoved {
            sheet,
            col_idx,
            col_signature,
        }
    }

    pub fn block_moved_rows(
        sheet: SheetId,
        src_start_row: u32,
        row_count: u32,
        dst_start_row: u32,
        block_hash: Option<u64>,
    ) -> DiffOp {
        DiffOp::BlockMovedRows {
            sheet,
            src_start_row,
            row_count,
            dst_start_row,
            block_hash,
        }
    }

    pub fn block_moved_columns(
        sheet: SheetId,
        src_start_col: u32,
        col_count: u32,
        dst_start_col: u32,
        block_hash: Option<u64>,
    ) -> DiffOp {
        DiffOp::BlockMovedColumns {
            sheet,
            src_start_col,
            col_count,
            dst_start_col,
            block_hash,
        }
    }

    #[allow(clippy::too_many_arguments)]
    pub fn block_moved_rect(
        sheet: SheetId,
        src_start_row: u32,
        src_row_count: u32,
        src_start_col: u32,
        src_col_count: u32,
        dst_start_row: u32,
        dst_start_col: u32,
        block_hash: Option<u64>,
    ) -> DiffOp {
        DiffOp::BlockMovedRect {
            sheet,
            src_start_row,
            src_row_count,
            src_start_col,
            src_col_count,
            dst_start_row,
            dst_start_col,
            block_hash,
        }
    }
}

```

---

### File: `core\src\engine\amr.rs`

```rust
use crate::alignment::align_rows_amr_with_signatures_from_views;
use crate::alignment::move_extraction::moves_from_matched_pairs;
use crate::alignment_types::RowAlignment;
use crate::column_alignment::align_single_column_change_from_views;
use crate::config::DiffConfig;
use crate::diff::DiffError;
use crate::grid_view::GridView;
#[cfg(feature = "perf-metrics")]
use crate::perf::{DiffMetrics, Phase};
use crate::sink::DiffSink;
use crate::workbook::{Grid, RowSignature};

use std::collections::{HashMap, HashSet};

use super::context::EmitCtx;
use super::grid_primitives::{
    emit_column_aligned_diffs, emit_row_aligned_diffs, run_positional_diff_with_metrics,
};
use super::move_mask::row_signature_at;

pub(crate) fn row_signature_multiset_equal(a: &Grid, b: &Grid) -> bool {
    if a.nrows != b.nrows {
        return false;
    }

    let mut a_sigs: Vec<RowSignature> = (0..a.nrows)
        .filter_map(|row| row_signature_at(a, row))
        .collect();
    let mut b_sigs: Vec<RowSignature> = (0..b.nrows)
        .filter_map(|row| row_signature_at(b, row))
        .collect();

    a_sigs.sort_unstable_by_key(|s| s.hash);
    b_sigs.sort_unstable_by_key(|s| s.hash);

    a_sigs == b_sigs
}

fn amr_strip_moves_policy(old: &Grid, new: &Grid, alignment: &mut RowAlignment) {
    let mut deleted_from_moves = Vec::new();
    let mut inserted_from_moves = Vec::new();
    for mv in &alignment.moves {
        deleted_from_moves.extend(mv.src_start_row..mv.src_start_row.saturating_add(mv.row_count));
        inserted_from_moves.extend(mv.dst_start_row..mv.dst_start_row.saturating_add(mv.row_count));
    }

    let multiset_equal = row_signature_multiset_equal(old, new);
    if multiset_equal {
        for (a, b) in &alignment.matched {
            if row_signature_at(old, *a) != row_signature_at(new, *b) {
                deleted_from_moves.push(*a);
                inserted_from_moves.push(*b);
            }
        }
    }

    if !deleted_from_moves.is_empty() || !inserted_from_moves.is_empty() {
        let deleted_set: HashSet<u32> = deleted_from_moves.iter().copied().collect();
        let inserted_set: HashSet<u32> = inserted_from_moves.iter().copied().collect();

        alignment
            .matched
            .retain(|(a, b)| !deleted_set.contains(a) && !inserted_set.contains(b));

        alignment.deleted.extend(deleted_set);
        alignment.inserted.extend(inserted_set);
        alignment.deleted.sort_unstable();
        alignment.deleted.dedup();
        alignment.inserted.sort_unstable();
        alignment.inserted.dedup();
    }

    alignment.moves.clear();
}

fn amr_should_fallback_no_matched_rows(alignment: &RowAlignment) -> bool {
    let has_structural = !alignment.inserted.is_empty() || !alignment.deleted.is_empty();
    has_structural && alignment.matched.is_empty()
}

fn amr_should_fallback_row_edits_with_structural(
    old: &Grid,
    new: &Grid,
    alignment: &RowAlignment,
    config: &DiffConfig,
) -> bool {
    let has_structural = !alignment.inserted.is_empty() || !alignment.deleted.is_empty();
    if !has_structural {
        return false;
    }

    let has_row_edits = alignment
        .matched
        .iter()
        .any(|(a, b)| row_signature_at(old, *a) != row_signature_at(new, *b));

    has_row_edits && config.max_move_iterations > 0
}

fn amr_alignment_is_trivial_identity(old: &Grid, new: &Grid, alignment: &RowAlignment) -> bool {
    alignment.moves.is_empty()
        && alignment.inserted.is_empty()
        && alignment.deleted.is_empty()
        && old.nrows == new.nrows
        && alignment.matched.len() as u32 == old.nrows
        && alignment.matched.iter().all(|(a, b)| a == b)
}

fn amr_should_fallback_multiset_reorder(
    old: &Grid,
    new: &Grid,
    alignment: &RowAlignment,
    config: &DiffConfig,
) -> bool {
    let is_trivial = amr_alignment_is_trivial_identity(old, new, alignment);
    !is_trivial
        && alignment.moves.is_empty()
        && row_signature_multiset_equal(old, new)
        && config.max_move_iterations > 0
}

fn amr_can_try_column_alignment(old: &Grid, new: &Grid, alignment: &RowAlignment) -> bool {
    alignment.moves.is_empty()
        && alignment.inserted.is_empty()
        && alignment.deleted.is_empty()
        && old.ncols != new.ncols
}

fn inject_moves_from_insert_delete(
    old: &Grid,
    new: &Grid,
    alignment: &mut RowAlignment,
    row_signatures_old: &[RowSignature],
    row_signatures_new: &[RowSignature],
) {
    if alignment.inserted.is_empty() || alignment.deleted.is_empty() {
        return;
    }

    let mut deleted_by_sig: HashMap<RowSignature, Vec<u32>> = HashMap::new();
    for row in &alignment.deleted {
        let sig = row_signatures_old
            .get(*row as usize)
            .copied()
            .or_else(|| row_signature_at(old, *row));
        if let Some(sig) = sig {
            deleted_by_sig.entry(sig).or_default().push(*row);
        }
    }

    let mut inserted_by_sig: HashMap<RowSignature, Vec<u32>> = HashMap::new();
    for row in &alignment.inserted {
        let sig = row_signatures_new
            .get(*row as usize)
            .copied()
            .or_else(|| row_signature_at(new, *row));
        if let Some(sig) = sig {
            inserted_by_sig.entry(sig).or_default().push(*row);
        }
    }

    let mut matched_pairs = Vec::new();
    for (sig, deleted_rows) in deleted_by_sig.iter() {
        if deleted_rows.len() != 1 {
            continue;
        }
        if let Some(insert_rows) = inserted_by_sig.get(sig) {
            if insert_rows.len() != 1 {
                continue;
            }
            matched_pairs.push((deleted_rows[0], insert_rows[0]));
        }
    }

    if matched_pairs.is_empty() {
        return;
    }

    let new_moves = moves_from_matched_pairs(&matched_pairs);
    if new_moves.is_empty() {
        return;
    }

    let mut moved_src = HashSet::new();
    let mut moved_dst = HashSet::new();
    for mv in &new_moves {
        for r in mv.src_start_row..mv.src_start_row.saturating_add(mv.row_count) {
            moved_src.insert(r);
        }
        for r in mv.dst_start_row..mv.dst_start_row.saturating_add(mv.row_count) {
            moved_dst.insert(r);
        }
    }

    alignment.deleted.retain(|r| !moved_src.contains(r));
    alignment.inserted.retain(|r| !moved_dst.contains(r));
    alignment.moves.extend(new_moves);
    alignment
        .moves
        .sort_by_key(|m| (m.src_start_row, m.dst_start_row, m.row_count));
}

pub(super) fn try_diff_with_amr<S: DiffSink>(
    emit_ctx: &mut EmitCtx<'_, '_, S>,
    old: &Grid,
    new: &Grid,
    old_view: &GridView,
    new_view: &GridView,
    #[cfg(feature = "perf-metrics")] mut metrics: Option<&mut DiffMetrics>,
) -> Result<bool, DiffError> {
    let Some(amr_result) =
        align_rows_amr_with_signatures_from_views(old_view, new_view, emit_ctx.config)
    else {
        return Ok(false);
    };

    let mut alignment = amr_result.alignment;

    if emit_ctx.config.max_move_iterations > 0 {
        inject_moves_from_insert_delete(
            old,
            new,
            &mut alignment,
            &amr_result.row_signatures_a,
            &amr_result.row_signatures_b,
        );
    } else {
        amr_strip_moves_policy(old, new, &mut alignment);
    }

    if amr_should_fallback_no_matched_rows(&alignment) {
        #[cfg(feature = "perf-metrics")]
        run_positional_diff_with_metrics(emit_ctx, old, new, metrics.as_deref_mut())?;
        #[cfg(not(feature = "perf-metrics"))]
        run_positional_diff_with_metrics(emit_ctx, old, new)?;
        return Ok(true);
    }

    if amr_should_fallback_row_edits_with_structural(old, new, &alignment, emit_ctx.config) {
        #[cfg(feature = "perf-metrics")]
        run_positional_diff_with_metrics(emit_ctx, old, new, metrics.as_deref_mut())?;
        #[cfg(not(feature = "perf-metrics"))]
        run_positional_diff_with_metrics(emit_ctx, old, new)?;
        return Ok(true);
    }

    if amr_can_try_column_alignment(old, new, &alignment)
        && let Some(col_alignment) =
            align_single_column_change_from_views(old_view, new_view, emit_ctx.config)
    {
        emit_ctx.hardening.progress("cell_diff", 0.0);
        #[cfg(feature = "perf-metrics")]
        if let Some(m) = metrics.as_mut() {
            m.start_phase(Phase::CellDiff);
        }
        emit_column_aligned_diffs(emit_ctx, old, new, &col_alignment)?;
        emit_ctx.hardening.progress("cell_diff", 1.0);
        #[cfg(feature = "perf-metrics")]
        if let Some(m) = metrics.as_mut() {
            let overlap_rows = old.nrows.min(new.nrows) as u64;
            m.add_cells_compared(overlap_rows.saturating_mul(col_alignment.matched.len() as u64));
            m.end_phase(Phase::CellDiff);
        }
        return Ok(true);
    }

    if amr_should_fallback_multiset_reorder(old, new, &alignment, emit_ctx.config) {
        #[cfg(feature = "perf-metrics")]
        run_positional_diff_with_metrics(emit_ctx, old, new, metrics.as_deref_mut())?;
        #[cfg(not(feature = "perf-metrics"))]
        run_positional_diff_with_metrics(emit_ctx, old, new)?;
        return Ok(true);
    }

    #[cfg(feature = "perf-metrics")]
    if let Some(m) = metrics.as_mut() {
        m.start_phase(Phase::CellDiff);
    }

    emit_ctx.hardening.progress("cell_diff", 0.0);
    let compared = emit_row_aligned_diffs(emit_ctx, old_view, new_view, &alignment)?;
    emit_ctx.hardening.progress("cell_diff", 1.0);
    #[cfg(feature = "perf-metrics")]
    if let Some(m) = metrics.as_mut() {
        m.add_cells_compared(compared);
        m.anchors_found = m
            .anchors_found
            .saturating_add(alignment.matched.len() as u32);
        m.moves_detected = m
            .moves_detected
            .saturating_add(alignment.moves.len() as u32);
        m.end_phase(Phase::CellDiff);
    }
    #[cfg(not(feature = "perf-metrics"))]
    let _ = compared;

    Ok(true)
}

```

---

### File: `core\src\engine\context.rs`

```rust
use crate::config::DiffConfig;
use crate::diff::{DiffError, DiffOp};
use crate::formula_diff::FormulaParseCache;
use crate::sink::DiffSink;
use crate::string_pool::StringPool;

use super::SheetId;
use super::hardening::HardeningController;

#[derive(Debug, Default)]
pub(super) struct DiffContext {
    pub(super) warnings: Vec<String>,
    pub(super) formula_cache: FormulaParseCache,
}

pub(super) fn emit_op<S: DiffSink>(
    sink: &mut S,
    op_count: &mut usize,
    op: DiffOp,
) -> Result<(), DiffError> {
    sink.emit(op)?;
    *op_count = op_count.saturating_add(1);
    Ok(())
}

pub(super) struct EmitCtx<'a, 'p, S: DiffSink> {
    pub(super) sheet_id: SheetId,
    pub(super) pool: &'a StringPool,
    pub(super) config: &'a DiffConfig,
    pub(super) cache: &'a mut FormulaParseCache,
    pub(super) sink: &'a mut S,
    pub(super) op_count: &'a mut usize,
    pub(super) warnings: &'a mut Vec<String>,
    pub(super) hardening: &'a mut HardeningController<'p>,
}

impl<'a, 'p, S: DiffSink> EmitCtx<'a, 'p, S> {
    pub(super) fn new(
        sheet_id: SheetId,
        pool: &'a StringPool,
        config: &'a DiffConfig,
        cache: &'a mut FormulaParseCache,
        sink: &'a mut S,
        op_count: &'a mut usize,
        warnings: &'a mut Vec<String>,
        hardening: &'a mut HardeningController<'p>,
    ) -> Self {
        Self {
            sheet_id,
            pool,
            config,
            cache,
            sink,
            op_count,
            warnings,
            hardening,
        }
    }

    pub(super) fn emit(&mut self, op: DiffOp) -> Result<(), DiffError> {
        emit_op(self.sink, self.op_count, op)
    }
}

```

---

### File: `core\src\engine\grid_diff.rs`

```rust
use crate::config::{DiffConfig, LimitBehavior};
use crate::diff::{DiffError, DiffOp, DiffReport, DiffSummary};
use crate::formula_diff::FormulaParseCache;
use crate::grid_view::GridView;
#[cfg(feature = "perf-metrics")]
use crate::perf::{DiffMetrics, Phase};
use crate::sink::{DiffSink, VecSink};
use crate::string_pool::StringPool;
use crate::workbook::{Grid, RowSignature};
use std::collections::HashSet;

use super::SheetId;
use super::context::{DiffContext, EmitCtx, emit_op};
use super::grid_primitives::{
    cells_content_equal, compute_formula_diff, run_positional_diff_with_metrics, snapshot_with_addr,
};
use super::move_mask::SheetGridDiffer;

use crate::database_alignment::{KeyColumnSpec, diff_table_by_key};

const DATABASE_MODE_SHEET_ID: &str = "<database>";

#[allow(clippy::too_many_arguments)]
pub(super) fn try_diff_grids<'p, S: DiffSink>(
    sheet_id: SheetId,
    old: &Grid,
    new: &Grid,
    config: &DiffConfig,
    pool: &StringPool,
    sink: &mut S,
    op_count: &mut usize,
    ctx: &mut DiffContext,
    hardening: &mut super::hardening::HardeningController<'p>,
    #[cfg(feature = "perf-metrics")] mut metrics: Option<&mut DiffMetrics>,
) -> Result<(), DiffError> {
    if old.nrows == 0 && new.nrows == 0 {
        return Ok(());
    }

    if hardening.check_timeout(&mut ctx.warnings) {
        return Ok(());
    }

    #[cfg(feature = "perf-metrics")]
    if let Some(m) = metrics.as_mut() {
        m.rows_processed = m
            .rows_processed
            .saturating_add(old.nrows as u64)
            .saturating_add(new.nrows as u64);
    }

    let exceeds_limits = old.nrows.max(new.nrows) > config.max_align_rows
        || old.ncols.max(new.ncols) > config.max_align_cols;

    if exceeds_limits {
        let warning = format!(
            "Sheet '{}': alignment limits exceeded (rows={}, cols={}; limits: rows={}, cols={})",
            pool.resolve(sheet_id),
            old.nrows.max(new.nrows),
            old.ncols.max(new.ncols),
            config.max_align_rows,
            config.max_align_cols
        );

        match config.on_limit_exceeded {
            LimitBehavior::ReturnError => {
                return Err(DiffError::LimitsExceeded {
                    sheet: sheet_id,
                    rows: old.nrows.max(new.nrows),
                    cols: old.ncols.max(new.ncols),
                    max_rows: config.max_align_rows,
                    max_cols: config.max_align_cols,
                });
            }
            behavior => {
                if matches!(behavior, LimitBehavior::ReturnPartialResult) {
                    ctx.warnings.push(warning);
                }

                let mut emit_ctx = EmitCtx::new(
                    sheet_id,
                    pool,
                    config,
                    &mut ctx.formula_cache,
                    sink,
                    op_count,
                    &mut ctx.warnings,
                    hardening,
                );

                #[cfg(feature = "perf-metrics")]
                run_positional_diff_with_metrics(&mut emit_ctx, old, new, metrics.as_deref_mut())?;
                #[cfg(not(feature = "perf-metrics"))]
                run_positional_diff_with_metrics(&mut emit_ctx, old, new)?;

                return Ok(());
            }
        }
    }

    diff_grids_core(
        sheet_id,
        old,
        new,
        config,
        pool,
        sink,
        op_count,
        ctx,
        hardening,
        #[cfg(feature = "perf-metrics")]
        metrics,
    )?;

    Ok(())
}

#[allow(clippy::too_many_arguments)]
fn diff_grids_core<'p, S: DiffSink>(
    sheet_id: SheetId,
    old: &Grid,
    new: &Grid,
    config: &DiffConfig,
    pool: &StringPool,
    sink: &mut S,
    op_count: &mut usize,
    ctx: &mut DiffContext,
    hardening: &mut super::hardening::HardeningController<'p>,
    #[cfg(feature = "perf-metrics")] mut metrics: Option<&mut DiffMetrics>,
) -> Result<(), DiffError> {
    if old.nrows == new.nrows && old.ncols == new.ncols && grids_non_blank_cells_equal(old, new) {
        #[cfg(feature = "perf-metrics")]
        if let Some(m) = metrics.as_mut() {
            m.add_cells_compared(cells_in_overlap(old, new));
        }
        return Ok(());
    }

    if hardening.check_timeout(&mut ctx.warnings) {
        return Ok(());
    }

    let sheet_name = pool.resolve(sheet_id);
    let context = format!("sheet '{sheet_name}'");
    if hardening.memory_guard_or_warn(
        super::hardening::estimate_advanced_sheet_diff_peak(old, new),
        &mut ctx.warnings,
        &context,
    ) {
        let mut emit_ctx = EmitCtx::new(
            sheet_id,
            pool,
            config,
            &mut ctx.formula_cache,
            sink,
            op_count,
            &mut ctx.warnings,
            hardening,
        );
        #[cfg(feature = "perf-metrics")]
        run_positional_diff_with_metrics(&mut emit_ctx, old, new, metrics.as_deref_mut())?;
        #[cfg(not(feature = "perf-metrics"))]
        run_positional_diff_with_metrics(&mut emit_ctx, old, new)?;
        return Ok(());
    }

    let old_view = GridView::from_grid_with_config(old, config);
    let new_view = GridView::from_grid_with_config(new, config);

    let preflight = should_short_circuit_to_positional(&old_view, &new_view, config);

    if matches!(
        preflight,
        PreflightDecision::ShortCircuitNearIdentical | PreflightDecision::ShortCircuitDissimilar
    ) {
        let mut emit_ctx = EmitCtx::new(
            sheet_id,
            pool,
            config,
            &mut ctx.formula_cache,
            sink,
            op_count,
            &mut ctx.warnings,
            hardening,
        );
        #[cfg(feature = "perf-metrics")]
        run_positional_diff_with_metrics(&mut emit_ctx, old, new, metrics.as_deref_mut())?;
        #[cfg(not(feature = "perf-metrics"))]
        run_positional_diff_with_metrics(&mut emit_ctx, old, new)?;
        return Ok(());
    }

    let emit_ctx = EmitCtx::new(
        sheet_id,
        pool,
        config,
        &mut ctx.formula_cache,
        sink,
        op_count,
        &mut ctx.warnings,
        hardening,
    );

    let mut differ = SheetGridDiffer::from_views(
        emit_ctx,
        old,
        new,
        old_view,
        new_view,
        #[cfg(feature = "perf-metrics")]
        metrics.as_deref_mut(),
    );

    #[cfg(feature = "perf-metrics")]
    if let Some(m) = differ.metrics.as_mut() {
        m.start_phase(Phase::MoveDetection);
    }

    differ.emit_ctx.hardening.progress("move_detection", 0.0);
    if differ.emit_ctx.hardening.check_timeout(differ.emit_ctx.warnings) {
        return Ok(());
    }
    differ.detect_moves()?;
    differ.emit_ctx.hardening.progress("move_detection", 1.0);

    #[cfg(feature = "perf-metrics")]
    if let Some(m) = differ.metrics.as_mut() {
        m.end_phase(Phase::MoveDetection);
    }

    if differ.emit_ctx.hardening.should_abort() {
        return Ok(());
    }

    if differ.has_mask_exclusions() {
        differ.emit_ctx.hardening.progress("alignment", 1.0);
        #[cfg(feature = "perf-metrics")]
        if let Some(m) = differ.metrics.as_mut() {
            m.start_phase(Phase::CellDiff);
        }
        differ.diff_with_masks()?;
        #[cfg(feature = "perf-metrics")]
        if let Some(m) = differ.metrics.as_mut() {
            m.end_phase(Phase::CellDiff);
        }
        return Ok(());
    }

    #[cfg(feature = "perf-metrics")]
    if let Some(m) = differ.metrics.as_mut() {
        m.start_phase(Phase::Alignment);
    }

    differ.emit_ctx.hardening.progress("alignment", 0.0);
    if differ.emit_ctx.hardening.check_timeout(differ.emit_ctx.warnings) {
        return Ok(());
    }
    if differ.try_amr()? {
        differ.emit_ctx.hardening.progress("alignment", 1.0);
        #[cfg(feature = "perf-metrics")]
        if let Some(m) = differ.metrics.as_mut() {
            m.end_phase(Phase::Alignment);
        }
        return Ok(());
    }

    if differ.try_row_alignment()? {
        differ.emit_ctx.hardening.progress("alignment", 1.0);
        #[cfg(feature = "perf-metrics")]
        if let Some(m) = differ.metrics.as_mut() {
            m.end_phase(Phase::Alignment);
        }
        return Ok(());
    }

    if differ.try_single_column_alignment()? {
        differ.emit_ctx.hardening.progress("alignment", 1.0);
        #[cfg(feature = "perf-metrics")]
        if let Some(m) = differ.metrics.as_mut() {
            m.end_phase(Phase::Alignment);
        }
        return Ok(());
    }

    differ.positional()?;

    differ.emit_ctx.hardening.progress("alignment", 1.0);

    #[cfg(feature = "perf-metrics")]
    if let Some(m) = differ.metrics.as_mut() {
        m.end_phase(Phase::Alignment);
    }

    Ok(())
}

pub fn diff_grids_database_mode(
    old: &Grid,
    new: &Grid,
    key_columns: &[u32],
    pool: &mut StringPool,
    config: &DiffConfig,
) -> DiffReport {
    let sheet_id: SheetId = pool.intern(DATABASE_MODE_SHEET_ID);
    let mut sink = VecSink::new();
    let mut op_count = 0usize;
    match try_diff_grids_database_mode_streaming(
        sheet_id,
        old,
        new,
        key_columns,
        pool,
        config,
        &mut sink,
        &mut op_count,
    ) {
        Ok(summary) => {
            let strings = pool.strings().to_vec();
            DiffReport::from_ops_and_summary(sink.into_ops(), summary, strings)
        }
        Err(e) => {
            let strings = pool.strings().to_vec();
            DiffReport {
                version: DiffReport::SCHEMA_VERSION.to_string(),
                strings,
                ops: sink.into_ops(),
                complete: false,
                warnings: vec![e.to_string()],
                #[cfg(feature = "perf-metrics")]
                metrics: None,
            }
        }
    }
}

pub(crate) fn try_diff_grids_database_mode_streaming<S: DiffSink>(
    sheet_id: SheetId,
    old: &Grid,
    new: &Grid,
    key_columns: &[u32],
    pool: &mut StringPool,
    config: &DiffConfig,
    sink: &mut S,
    op_count: &mut usize,
) -> Result<DiffSummary, DiffError> {
    let mut warnings: Vec<String> = Vec::new();
    let mut hardening = super::hardening::HardeningController::new(config, None);
    let mut formula_cache = FormulaParseCache::default();
    let spec = KeyColumnSpec::new(key_columns.to_vec());

    sink.begin(pool)?;
    if hardening.check_timeout(&mut warnings) {
        sink.finish()?;
        return Ok(DiffSummary {
            complete: false,
            warnings,
            op_count: *op_count,
            #[cfg(feature = "perf-metrics")]
            metrics: None,
        });
    }

    let alignment = match diff_table_by_key(old, new, key_columns) {
        Ok(alignment) => alignment,
        Err(_) => {
            let mut ctx = DiffContext::default();
            warnings.push(
                "database-mode: duplicate keys for requested columns; falling back to spreadsheet mode"
                    .to_string(),
            );
            ctx.warnings = warnings;
            try_diff_grids(
                sheet_id,
                old,
                new,
                config,
                pool,
                sink,
                op_count,
                &mut ctx,
                &mut hardening,
                #[cfg(feature = "perf-metrics")]
                None,
            )?;
            sink.finish()?;
            let complete = ctx.warnings.is_empty();
            return Ok(DiffSummary {
                complete,
                warnings: ctx.warnings,
                op_count: *op_count,
                #[cfg(feature = "perf-metrics")]
                metrics: None,
            });
        }
    };

    let max_cols = old.ncols.max(new.ncols);

    for row_idx in &alignment.left_only_rows {
        if hardening.check_timeout(&mut warnings) {
            break;
        }
        emit_op(
            sink,
            op_count,
            DiffOp::row_removed(sheet_id, *row_idx, None),
        )?;
    }

    for row_idx in &alignment.right_only_rows {
        if hardening.check_timeout(&mut warnings) {
            break;
        }
        emit_op(sink, op_count, DiffOp::row_added(sheet_id, *row_idx, None))?;
    }

    for (row_a, row_b) in &alignment.matched_rows {
        if hardening.check_timeout(&mut warnings) {
            break;
        }
        for col in 0..max_cols {
            if spec.is_key_column(col) {
                continue;
            }

            let old_cell = old.get(*row_a, col);
            let new_cell = new.get(*row_b, col);

            if cells_content_equal(old_cell, new_cell) {
                continue;
            }

            let addr = crate::workbook::CellAddress::from_indices(*row_b, col);
            let from = snapshot_with_addr(old_cell, addr);
            let to = snapshot_with_addr(new_cell, addr);

            let formula_diff = compute_formula_diff(
                pool,
                &mut formula_cache,
                old_cell,
                new_cell,
                *row_b as i32 - *row_a as i32,
                0,
                config,
            );

            emit_op(
                sink,
                op_count,
                DiffOp::cell_edited(sheet_id, addr, from, to, formula_diff),
            )?;
        }
    }

    sink.finish()?;
    Ok(DiffSummary {
        complete: warnings.is_empty(),
        warnings,
        op_count: *op_count,
        #[cfg(feature = "perf-metrics")]
        metrics: None,
    })
}

fn grids_non_blank_cells_equal(old: &Grid, new: &Grid) -> bool {
    if old.cells.len() != new.cells.len() {
        return false;
    }

    for (coord, cell_a) in old.cells.iter() {
        let Some(cell_b) = new.cells.get(coord) else {
            return false;
        };
        if cell_a.value != cell_b.value || cell_a.formula != cell_b.formula {
            return false;
        }
    }

    true
}

#[derive(Debug, Clone, Copy, PartialEq, Eq)]
pub(super) enum PreflightDecision {
    RunFullPipeline,
    ShortCircuitNearIdentical,
    ShortCircuitDissimilar,
}

pub(super) fn should_short_circuit_to_positional(
    old_view: &GridView<'_>,
    new_view: &GridView<'_>,
    config: &DiffConfig,
) -> PreflightDecision {
    let nrows_old = old_view.row_meta.len();
    let nrows_new = new_view.row_meta.len();
    let ncols_old = old_view.col_meta.len();
    let ncols_new = new_view.col_meta.len();

    if nrows_old != nrows_new || ncols_old != ncols_new {
        return PreflightDecision::RunFullPipeline;
    }

    let nrows = nrows_old;
    if nrows < config.preflight_min_rows as usize {
        return PreflightDecision::RunFullPipeline;
    }

    let (in_order_matches, old_sig_set, new_sig_set) =
        compute_row_signature_stats(old_view, new_view);

    let in_order_mismatches = nrows.saturating_sub(in_order_matches);
    let in_order_match_ratio = if nrows > 0 {
        in_order_matches as f64 / nrows as f64
    } else {
        1.0
    };

    let intersection_size = old_sig_set.intersection(&new_sig_set).count();
    let union_size = old_sig_set.union(&new_sig_set).count();
    let jaccard = if union_size > 0 {
        intersection_size as f64 / union_size as f64
    } else {
        1.0
    };

    let multiset_equal = are_multisets_equal(old_view, new_view);

    let near_identical = in_order_mismatches <= config.preflight_in_order_mismatch_max as usize
        && in_order_match_ratio >= config.preflight_in_order_match_ratio_min
        && !multiset_equal;

    if near_identical {
        return PreflightDecision::ShortCircuitNearIdentical;
    }

    if jaccard < config.bailout_similarity_threshold {
        return PreflightDecision::ShortCircuitDissimilar;
    }

    PreflightDecision::RunFullPipeline
}

fn compute_row_signature_stats(
    old_view: &GridView<'_>,
    new_view: &GridView<'_>,
) -> (usize, HashSet<RowSignature>, HashSet<RowSignature>) {
    let mut in_order_matches = 0usize;
    let mut old_sig_set = HashSet::with_capacity(old_view.row_meta.len());
    let mut new_sig_set = HashSet::with_capacity(new_view.row_meta.len());

    for (old_meta, new_meta) in old_view.row_meta.iter().zip(new_view.row_meta.iter()) {
        if old_meta.signature == new_meta.signature {
            in_order_matches += 1;
        }
        old_sig_set.insert(old_meta.signature);
        new_sig_set.insert(new_meta.signature);
    }

    (in_order_matches, old_sig_set, new_sig_set)
}

fn are_multisets_equal(old_view: &GridView<'_>, new_view: &GridView<'_>) -> bool {
    use std::collections::HashMap;

    if old_view.row_meta.len() != new_view.row_meta.len() {
        return false;
    }

    let mut old_freq: HashMap<RowSignature, u32> = HashMap::new();
    for meta in &old_view.row_meta {
        *old_freq.entry(meta.signature).or_insert(0) += 1;
    }

    let mut new_freq: HashMap<RowSignature, u32> = HashMap::new();
    for meta in &new_view.row_meta {
        *new_freq.entry(meta.signature).or_insert(0) += 1;
    }

    old_freq == new_freq
}

#[cfg(feature = "perf-metrics")]
fn cells_in_overlap(old: &Grid, new: &Grid) -> u64 {
    let overlap_rows = old.nrows.min(new.nrows) as u64;
    let overlap_cols = old.ncols.min(new.ncols) as u64;
    overlap_rows.saturating_mul(overlap_cols)
}

#[cfg(test)]
mod tests {
    use super::*;
    use crate::sink::VecSink;
    use crate::string_pool::StringPool;
    use crate::workbook::{Cell, CellValue};

    fn numbered_cell(value: f64) -> Cell {
        Cell {
            value: Some(CellValue::Number(value)),
            formula: None,
        }
    }

    #[test]
    fn grids_non_blank_cells_equal_requires_matching_entries() {
        let base_cell = Cell {
            value: Some(CellValue::Number(1.0)),
            formula: None,
        };

        let mut grid_a = Grid::new(2, 2);
        let mut grid_b = Grid::new(2, 2);
        grid_a.insert_cell(0, 0, base_cell.value.clone(), base_cell.formula);
        grid_b.insert_cell(0, 0, base_cell.value.clone(), base_cell.formula);

        assert!(grids_non_blank_cells_equal(&grid_a, &grid_b));

        let mut grid_b_changed = grid_b.clone();
        let mut changed_cell = base_cell.clone();
        changed_cell.value = Some(CellValue::Number(2.0));
        grid_b_changed.insert_cell(0, 0, changed_cell.value.clone(), changed_cell.formula);

        assert!(!grids_non_blank_cells_equal(&grid_a, &grid_b_changed));

        grid_a.insert_cell(1, 1, None, None);

        assert!(!grids_non_blank_cells_equal(&grid_a, &grid_b));
    }

    #[test]
    fn diff_row_pair_sparse_counts_union_columns_not_sum_lengths() {
        use super::super::grid_primitives::diff_row_pair_sparse;
        use crate::formula_diff::FormulaParseCache;

        let mut pool = StringPool::new();
        let sheet_id: SheetId = pool.intern("Sheet1");
        let config = DiffConfig::default();
        let mut sink = VecSink::new();
        let mut op_count = 0usize;
        let mut cache = FormulaParseCache::default();
        let mut warnings: Vec<String> = Vec::new();
        let mut hardening = super::super::hardening::HardeningController::new(&config, None);

        let old_cells_storage = [numbered_cell(1.0), numbered_cell(2.0), numbered_cell(3.0)];
        let new_cells_storage = [numbered_cell(1.0), numbered_cell(2.0), numbered_cell(4.0)];

        let old_cells: Vec<(u32, &Cell)> = old_cells_storage
            .iter()
            .enumerate()
            .map(|(idx, cell)| (idx as u32, cell))
            .collect();
        let new_cells: Vec<(u32, &Cell)> = new_cells_storage
            .iter()
            .enumerate()
            .map(|(idx, cell)| (idx as u32, cell))
            .collect();

        let mut emit_ctx = EmitCtx::new(
            sheet_id,
            &pool,
            &config,
            &mut cache,
            &mut sink,
            &mut op_count,
            &mut warnings,
            &mut hardening,
        );
        let compared = diff_row_pair_sparse(&mut emit_ctx, 0, 0, 3, &old_cells, &new_cells)
            .expect("diff should succeed");

        assert_eq!(compared, 3);
    }

    #[test]
    fn diff_row_pair_sparse_counts_union_for_sparse_columns() {
        use super::super::grid_primitives::diff_row_pair_sparse;
        use crate::formula_diff::FormulaParseCache;

        let mut pool = StringPool::new();
        let sheet_id: SheetId = pool.intern("Sheet1");
        let config = DiffConfig::default();
        let mut sink = VecSink::new();
        let mut op_count = 0usize;
        let mut cache = FormulaParseCache::default();
        let mut warnings: Vec<String> = Vec::new();
        let mut hardening = super::super::hardening::HardeningController::new(&config, None);

        let old_cells_storage = [numbered_cell(1.0)];
        let new_cells_storage = [numbered_cell(2.0)];

        let old_cells: Vec<(u32, &Cell)> = vec![(0, &old_cells_storage[0])];
        let new_cells: Vec<(u32, &Cell)> = vec![(2, &new_cells_storage[0])];

        let mut emit_ctx = EmitCtx::new(
            sheet_id,
            &pool,
            &config,
            &mut cache,
            &mut sink,
            &mut op_count,
            &mut warnings,
            &mut hardening,
        );
        let compared = diff_row_pair_sparse(&mut emit_ctx, 0, 0, 3, &old_cells, &new_cells)
            .expect("diff should succeed");

        assert_eq!(compared, 2);
    }
}

```

---

### File: `core\src\engine\grid_primitives.rs`

```rust
use crate::alignment_types::{RowAlignment, RowBlockMove};
use crate::column_alignment::{
    ColumnAlignment, ColumnBlockMove, align_single_column_change_from_views,
};
use crate::config::DiffConfig;
use crate::diff::{DiffError, DiffOp, FormulaDiffResult};
use crate::formula_diff::{FormulaParseCache, diff_cell_formulas_ids};
use crate::grid_view::GridView;
#[cfg(feature = "perf-metrics")]
use crate::perf::{DiffMetrics, Phase};
use crate::rect_block_move::RectBlockMove;
use crate::row_alignment::align_row_changes_from_views;
use crate::sink::DiffSink;
use crate::string_pool::StringPool;
use crate::workbook::{Cell, CellAddress, CellSnapshot, Grid};

use super::context::EmitCtx;

pub(super) fn compute_formula_diff(
    pool: &StringPool,
    cache: &mut FormulaParseCache,
    old_cell: Option<&Cell>,
    new_cell: Option<&Cell>,
    row_shift: i32,
    col_shift: i32,
    config: &DiffConfig,
) -> FormulaDiffResult {
    let old_f = old_cell.and_then(|c| c.formula);
    let new_f = new_cell.and_then(|c| c.formula);
    diff_cell_formulas_ids(pool, cache, old_f, new_f, row_shift, col_shift, config)
}

pub(super) fn emit_cell_edit<S: DiffSink>(
    ctx: &mut EmitCtx<'_, '_, S>,
    addr: CellAddress,
    old_cell: Option<&Cell>,
    new_cell: Option<&Cell>,
    row_shift: i32,
    col_shift: i32,
) -> Result<(), DiffError> {
    let from = snapshot_with_addr(old_cell, addr);
    let to = snapshot_with_addr(new_cell, addr);
    let formula_diff = compute_formula_diff(
        ctx.pool, ctx.cache, old_cell, new_cell, row_shift, col_shift, ctx.config,
    );
    ctx.emit(DiffOp::cell_edited(
        ctx.sheet_id,
        addr,
        from,
        to,
        formula_diff,
    ))
}

pub(super) fn cells_content_equal(a: Option<&Cell>, b: Option<&Cell>) -> bool {
    match (a, b) {
        (None, None) => true,
        (Some(cell_a), None) | (None, Some(cell_a)) => {
            cell_a.value.is_none() && cell_a.formula.is_none()
        }
        (Some(cell_a), Some(cell_b)) => {
            cell_a.value == cell_b.value && cell_a.formula == cell_b.formula
        }
    }
}

pub(super) fn snapshot_with_addr(cell: Option<&Cell>, addr: CellAddress) -> CellSnapshot {
    match cell {
        Some(cell) => CellSnapshot {
            addr,
            value: cell.value,
            formula: cell.formula,
        },
        None => CellSnapshot::empty(addr),
    }
}

pub(super) fn emit_row_block_move<S: DiffSink>(
    ctx: &mut EmitCtx<'_, '_, S>,
    mv: RowBlockMove,
) -> Result<(), DiffError> {
    ctx.emit(DiffOp::BlockMovedRows {
        sheet: ctx.sheet_id,
        src_start_row: mv.src_start_row,
        row_count: mv.row_count,
        dst_start_row: mv.dst_start_row,
        block_hash: None,
    })
}

pub(super) fn emit_column_block_move<S: DiffSink>(
    ctx: &mut EmitCtx<'_, '_, S>,
    mv: ColumnBlockMove,
) -> Result<(), DiffError> {
    ctx.emit(DiffOp::BlockMovedColumns {
        sheet: ctx.sheet_id,
        src_start_col: mv.src_start_col,
        col_count: mv.col_count,
        dst_start_col: mv.dst_start_col,
        block_hash: None,
    })
}

pub(super) fn emit_rect_block_move<S: DiffSink>(
    ctx: &mut EmitCtx<'_, '_, S>,
    mv: RectBlockMove,
) -> Result<(), DiffError> {
    ctx.emit(DiffOp::BlockMovedRect {
        sheet: ctx.sheet_id,
        src_start_row: mv.src_start_row,
        src_row_count: mv.src_row_count,
        src_start_col: mv.src_start_col,
        src_col_count: mv.src_col_count,
        dst_start_row: mv.dst_start_row,
        dst_start_col: mv.dst_start_col,
        block_hash: mv.block_hash,
    })
}

pub(super) fn emit_moved_row_block_edits<S: DiffSink>(
    ctx: &mut EmitCtx<'_, '_, S>,
    old_view: &GridView,
    new_view: &GridView,
    mv: RowBlockMove,
) -> Result<(), DiffError> {
    let overlap_cols = old_view.source.ncols.min(new_view.source.ncols);
    for offset in 0..mv.row_count {
        let old_idx = (mv.src_start_row + offset) as usize;
        let new_idx = (mv.dst_start_row + offset) as usize;
        let Some(old_row) = old_view.rows.get(old_idx) else {
            continue;
        };
        let Some(new_row) = new_view.rows.get(new_idx) else {
            continue;
        };

        let _ = diff_row_pair_sparse(
            ctx,
            mv.src_start_row + offset,
            mv.dst_start_row + offset,
            overlap_cols,
            &old_row.cells,
            &new_row.cells,
        )?;
    }
    Ok(())
}

pub(super) fn diff_row_pair_sparse<S: DiffSink>(
    ctx: &mut EmitCtx<'_, '_, S>,
    row_a: u32,
    row_b: u32,
    overlap_cols: u32,
    old_cells: &[(u32, &Cell)],
    new_cells: &[(u32, &Cell)],
) -> Result<u64, DiffError> {
    let mut i = 0usize;
    let mut j = 0usize;
    let mut compared = 0u64;

    let row_shift = row_b as i32 - row_a as i32;

    while i < old_cells.len() || j < new_cells.len() {
        let col_a = old_cells.get(i).map(|(c, _)| *c).unwrap_or(u32::MAX);
        let col_b = new_cells.get(j).map(|(c, _)| *c).unwrap_or(u32::MAX);
        let col = col_a.min(col_b);

        if col >= overlap_cols {
            break;
        }

        compared = compared.saturating_add(1);

        let old_cell = if col_a == col {
            let (_, cell) = old_cells[i];
            i += 1;
            Some(cell)
        } else {
            None
        };

        let new_cell = if col_b == col {
            let (_, cell) = new_cells[j];
            j += 1;
            Some(cell)
        } else {
            None
        };

        let changed = !cells_content_equal(old_cell, new_cell);

        if changed || ctx.config.include_unchanged_cells {
            let addr = CellAddress::from_indices(row_b, col);
            emit_cell_edit(ctx, addr, old_cell, new_cell, row_shift, 0)?;
        }
    }

    Ok(compared)
}

pub(super) fn diff_row_pair<S: DiffSink>(
    ctx: &mut EmitCtx<'_, '_, S>,
    old: &Grid,
    new: &Grid,
    row_a: u32,
    row_b: u32,
    overlap_cols: u32,
) -> Result<(), DiffError> {
    let row_shift = row_b as i32 - row_a as i32;
    for col in 0..overlap_cols {
        let old_cell = old.get(row_a, col);
        let new_cell = new.get(row_b, col);

        if cells_content_equal(old_cell, new_cell) {
            continue;
        }

        let addr = CellAddress::from_indices(row_b, col);
        emit_cell_edit(ctx, addr, old_cell, new_cell, row_shift, 0)?;
    }
    Ok(())
}

pub(super) fn emit_row_aligned_diffs<S: DiffSink>(
    ctx: &mut EmitCtx<'_, '_, S>,
    old_view: &GridView,
    new_view: &GridView,
    alignment: &RowAlignment,
) -> Result<u64, DiffError> {
    let overlap_cols = old_view.source.ncols.min(new_view.source.ncols);
    let mut compared = 0u64;

    for (row_a, row_b) in &alignment.matched {
        if let (Some(old_row), Some(new_row)) = (
            old_view.rows.get(*row_a as usize),
            new_view.rows.get(*row_b as usize),
        ) {
            compared = compared.saturating_add(diff_row_pair_sparse(
                ctx,
                *row_a,
                *row_b,
                overlap_cols,
                &old_row.cells,
                &new_row.cells,
            )?);
        }
    }

    for row_idx in &alignment.inserted {
        ctx.emit(DiffOp::row_added(ctx.sheet_id, *row_idx, None))?;
    }

    for row_idx in &alignment.deleted {
        ctx.emit(DiffOp::row_removed(ctx.sheet_id, *row_idx, None))?;
    }

    for mv in &alignment.moves {
        emit_row_block_move(ctx, *mv)?;
    }

    if new_view.source.ncols > old_view.source.ncols {
        for col_idx in old_view.source.ncols..new_view.source.ncols {
            ctx.emit(DiffOp::column_added(ctx.sheet_id, col_idx, None))?;
        }
    } else if old_view.source.ncols > new_view.source.ncols {
        for col_idx in new_view.source.ncols..old_view.source.ncols {
            ctx.emit(DiffOp::column_removed(ctx.sheet_id, col_idx, None))?;
        }
    }

    Ok(compared)
}

pub(super) fn emit_column_aligned_diffs<S: DiffSink>(
    ctx: &mut EmitCtx<'_, '_, S>,
    old: &Grid,
    new: &Grid,
    alignment: &ColumnAlignment,
) -> Result<(), DiffError> {
    let overlap_rows = old.nrows.min(new.nrows);

    for row in 0..overlap_rows {
        for (col_a, col_b) in &alignment.matched {
            let old_cell = old.get(row, *col_a);
            let new_cell = new.get(row, *col_b);

            if cells_content_equal(old_cell, new_cell) {
                continue;
            }

            let addr = CellAddress::from_indices(row, *col_b);
            let col_shift = *col_b as i32 - *col_a as i32;
            emit_cell_edit(ctx, addr, old_cell, new_cell, 0, col_shift)?;
        }
    }

    for col_idx in &alignment.inserted {
        ctx.emit(DiffOp::column_added(ctx.sheet_id, *col_idx, None))?;
    }

    for col_idx in &alignment.deleted {
        ctx.emit(DiffOp::column_removed(ctx.sheet_id, *col_idx, None))?;
    }

    Ok(())
}

pub(super) fn positional_diff<S: DiffSink>(
    ctx: &mut EmitCtx<'_, '_, S>,
    old: &Grid,
    new: &Grid,
) -> Result<(), DiffError> {
    let overlap_rows = old.nrows.min(new.nrows);
    let overlap_cols = old.ncols.min(new.ncols);

    ctx.hardening.progress("cell_diff", 0.0);

    for row in 0..overlap_rows {
        if ctx.hardening.check_timeout(ctx.warnings) {
            return Ok(());
        }

        if overlap_rows > 0 && row % 256 == 0 {
            ctx.hardening
                .progress("cell_diff", row as f32 / overlap_rows as f32);
        }

        diff_row_pair(ctx, old, new, row, row, overlap_cols)?;
    }

    if overlap_rows > 0 {
        ctx.hardening.progress("cell_diff", 1.0);
    }

    if ctx.hardening.check_timeout(ctx.warnings) {
        return Ok(());
    }

    if new.nrows > old.nrows {
        for row_idx in old.nrows..new.nrows {
            if row_idx % 4096 == 0 && ctx.hardening.check_timeout(ctx.warnings) {
                return Ok(());
            }
            ctx.emit(DiffOp::row_added(ctx.sheet_id, row_idx, None))?;
        }
    } else if old.nrows > new.nrows {
        for row_idx in new.nrows..old.nrows {
            if row_idx % 4096 == 0 && ctx.hardening.check_timeout(ctx.warnings) {
                return Ok(());
            }
            ctx.emit(DiffOp::row_removed(ctx.sheet_id, row_idx, None))?;
        }
    }

    if new.ncols > old.ncols {
        for col_idx in old.ncols..new.ncols {
            if col_idx % 4096 == 0 && ctx.hardening.check_timeout(ctx.warnings) {
                return Ok(());
            }
            ctx.emit(DiffOp::column_added(ctx.sheet_id, col_idx, None))?;
        }
    } else if old.ncols > new.ncols {
        for col_idx in new.ncols..old.ncols {
            if col_idx % 4096 == 0 && ctx.hardening.check_timeout(ctx.warnings) {
                return Ok(());
            }
            ctx.emit(DiffOp::column_removed(ctx.sheet_id, col_idx, None))?;
        }
    }

    Ok(())
}

#[cfg(feature = "perf-metrics")]
pub(super) fn cells_in_overlap(old: &Grid, new: &Grid) -> u64 {
    let overlap_rows = old.nrows.min(new.nrows) as u64;
    let overlap_cols = old.ncols.min(new.ncols) as u64;
    overlap_rows.saturating_mul(overlap_cols)
}

#[cfg(feature = "perf-metrics")]
pub(super) fn run_positional_diff_with_metrics<S: DiffSink>(
    ctx: &mut EmitCtx<'_, '_, S>,
    old: &Grid,
    new: &Grid,
    mut metrics: Option<&mut DiffMetrics>,
) -> Result<(), DiffError> {
    {
        let _phase = metrics
            .as_deref_mut()
            .map(|m| m.phase_guard(Phase::CellDiff));

        positional_diff(ctx, old, new)?;
    }

    if let Some(m) = metrics.as_deref_mut() {
        m.add_cells_compared(cells_in_overlap(old, new));
    }

    Ok(())
}

#[cfg(not(feature = "perf-metrics"))]
pub(super) fn run_positional_diff_with_metrics<S: DiffSink>(
    ctx: &mut EmitCtx<'_, '_, S>,
    old: &Grid,
    new: &Grid,
) -> Result<(), DiffError> {
    positional_diff(ctx, old, new)
}

pub(super) fn try_row_alignment_internal<S: DiffSink>(
    emit_ctx: &mut EmitCtx<'_, '_, S>,
    old_view: &GridView,
    new_view: &GridView,
    #[cfg(feature = "perf-metrics")] metrics: &mut Option<&mut DiffMetrics>,
) -> Result<bool, DiffError> {
    let Some(alignment) = align_row_changes_from_views(old_view, new_view, emit_ctx.config) else {
        return Ok(false);
    };

    emit_ctx.hardening.progress("cell_diff", 0.0);

    #[cfg(feature = "perf-metrics")]
    let compared = {
        let _phase = metrics
            .as_deref_mut()
            .map(|m| m.phase_guard(Phase::CellDiff));
        emit_row_aligned_diffs(emit_ctx, old_view, new_view, &alignment)?
    };
    #[cfg(not(feature = "perf-metrics"))]
    let compared = emit_row_aligned_diffs(emit_ctx, old_view, new_view, &alignment)?;

    emit_ctx.hardening.progress("cell_diff", 1.0);

    #[cfg(feature = "perf-metrics")]
    if let Some(m) = metrics.as_deref_mut() {
        m.add_cells_compared(compared);
    }
    #[cfg(not(feature = "perf-metrics"))]
    let _ = compared;

    Ok(true)
}

pub(super) fn try_single_column_alignment_internal<S: DiffSink>(
    emit_ctx: &mut EmitCtx<'_, '_, S>,
    old: &Grid,
    new: &Grid,
    old_view: &GridView,
    new_view: &GridView,
    #[cfg(feature = "perf-metrics")] metrics: &mut Option<&mut DiffMetrics>,
) -> Result<bool, DiffError> {
    let Some(alignment) =
        align_single_column_change_from_views(old_view, new_view, emit_ctx.config)
    else {
        return Ok(false);
    };

    emit_ctx.hardening.progress("cell_diff", 0.0);

    #[cfg(feature = "perf-metrics")]
    {
        let _phase = metrics
            .as_deref_mut()
            .map(|m| m.phase_guard(Phase::CellDiff));
        emit_column_aligned_diffs(emit_ctx, old, new, &alignment)?;
    }
    #[cfg(not(feature = "perf-metrics"))]
    emit_column_aligned_diffs(emit_ctx, old, new, &alignment)?;

    emit_ctx.hardening.progress("cell_diff", 1.0);

    #[cfg(feature = "perf-metrics")]
    if let Some(m) = metrics.as_deref_mut() {
        let overlap_rows = old.nrows.min(new.nrows) as u64;
        m.add_cells_compared(overlap_rows.saturating_mul(alignment.matched.len() as u64));
    }

    Ok(true)
}

```

---

### File: `core\src\engine\hardening.rs`

```rust
use crate::config::DiffConfig;
use crate::progress::ProgressCallback;
use crate::workbook::{Cell, Grid};
use std::mem::size_of;
use std::time::{Duration, Instant};

const BYTES_PER_MB: u64 = 1024 * 1024;

const PROGRESS_MIN_DELTA: f32 = 0.01;
const TIMEOUT_CHECK_EVERY_TICKS: u64 = 256;

pub(super) struct HardeningController<'a> {
    start: Instant,
    timeout: Option<Duration>,
    max_memory_bytes: Option<u64>,
    aborted: bool,
    warned_timeout: bool,
    warned_memory: bool,
    progress: Option<&'a dyn ProgressCallback>,
    last_progress_phase: Option<&'static str>,
    last_progress_percent: Option<f32>,
    timeout_tick: u64,
}

impl<'a> HardeningController<'a> {
    pub(super) fn new(config: &DiffConfig, progress: Option<&'a dyn ProgressCallback>) -> Self {
        Self {
            start: Instant::now(),
            timeout: config
                .timeout_seconds
                .map(|secs| Duration::from_secs(secs as u64)),
            max_memory_bytes: config
                .max_memory_mb
                .map(|mb| (mb as u64).saturating_mul(BYTES_PER_MB)),
            aborted: false,
            warned_timeout: false,
            warned_memory: false,
            progress,
            last_progress_phase: None,
            last_progress_percent: None,
            timeout_tick: 0,
        }
    }

    pub(super) fn should_abort(&self) -> bool {
        self.aborted
    }

    pub(super) fn check_timeout(&mut self, warnings: &mut Vec<String>) -> bool {
        if self.aborted {
            return true;
        }
        let Some(timeout) = self.timeout else {
            return false;
        };

        self.timeout_tick = self.timeout_tick.saturating_add(1);
        let should_check = self.timeout_tick == 1 || self.timeout_tick % TIMEOUT_CHECK_EVERY_TICKS == 0;
        if !should_check {
            return false;
        }

        if self.start.elapsed() < timeout {
            return false;
        }

        self.aborted = true;
        if !self.warned_timeout {
            self.warned_timeout = true;
            warnings.push(format!(
                "timeout after {} seconds; diff aborted early; results may be incomplete",
                timeout.as_secs()
            ));
        }
        true
    }

    pub(super) fn memory_guard_or_warn(
        &mut self,
        estimated_extra_bytes: u64,
        warnings: &mut Vec<String>,
        context: &str,
    ) -> bool {
        let Some(limit) = self.max_memory_bytes else {
            return false;
        };

        if estimated_extra_bytes <= limit {
            return false;
        }

        if !self.warned_memory {
            self.warned_memory = true;
            warnings.push(format!(
                "memory budget exceeded in {context} (estimated ~{} MB > limit {} MB); falling back to positional diff; results may be incomplete",
                bytes_to_mb_ceil(estimated_extra_bytes),
                bytes_to_mb_ceil(limit),
            ));
        }

        true
    }

    pub(super) fn progress(&mut self, phase: &'static str, percent: f32) {
        let Some(callback) = self.progress else {
            return;
        };

        let mut clamped = if percent.is_finite() { percent } else { 0.0 };
        if clamped < 0.0 {
            clamped = 0.0;
        } else if clamped > 1.0 {
            clamped = 1.0;
        }

        let should_emit = match (self.last_progress_phase, self.last_progress_percent) {
            (Some(last_phase), Some(last_percent)) if last_phase == phase => {
                clamped == 0.0
                    || clamped == 1.0
                    || clamped < last_percent
                    || (clamped - last_percent) >= PROGRESS_MIN_DELTA
            }
            _ => true,
        };

        if !should_emit {
            return;
        }

        self.last_progress_phase = Some(phase);
        self.last_progress_percent = Some(clamped);
        callback.on_progress(phase, clamped);
    }
}

pub(super) fn estimate_gridview_bytes(grid: &Grid) -> u64 {
    let nrows = grid.nrows as u64;
    let ncols = grid.ncols as u64;
    let cell_count = grid.cell_count() as u64;

    let row_view_bytes = nrows.saturating_mul(size_of::<crate::grid_view::RowView<'static>>() as u64);
    let row_meta_bytes = nrows.saturating_mul(size_of::<crate::grid_view::RowMeta>() as u64);
    let col_meta_bytes = ncols.saturating_mul(size_of::<crate::grid_view::ColMeta>() as u64);

    let cell_entry_bytes = cell_count
        .saturating_mul(size_of::<(u32, &'static Cell)>() as u64)
        .saturating_mul(5)
        .saturating_div(4);

    let build_row_counts_bytes = nrows
        .saturating_mul(size_of::<u32>() as u64)
        .saturating_add(nrows.saturating_mul(size_of::<Option<u32>>() as u64));
    let build_col_counts_bytes = ncols
        .saturating_mul(size_of::<u32>() as u64)
        .saturating_add(ncols.saturating_mul(size_of::<Option<u32>>() as u64));
    let build_hashers_bytes =
        ncols.saturating_mul(size_of::<xxhash_rust::xxh3::Xxh3>() as u64);

    row_view_bytes
        .saturating_add(row_meta_bytes)
        .saturating_add(col_meta_bytes)
        .saturating_add(cell_entry_bytes)
        .saturating_add(build_row_counts_bytes)
        .saturating_add(build_col_counts_bytes)
        .saturating_add(build_hashers_bytes)
}

pub(super) fn estimate_advanced_sheet_diff_peak(old: &Grid, new: &Grid) -> u64 {
    let base = estimate_gridview_bytes(old).saturating_add(estimate_gridview_bytes(new));
    let max_rows = old.nrows.max(new.nrows) as u64;
    let max_cols = old.ncols.max(new.ncols) as u64;

    let alignment_overhead = max_rows
        .saturating_add(max_cols)
        .saturating_mul(size_of::<u32>() as u64)
        .saturating_mul(8);

    base.saturating_add(alignment_overhead)
}

fn bytes_to_mb_ceil(bytes: u64) -> u64 {
    bytes
        .saturating_add(BYTES_PER_MB.saturating_sub(1))
        .saturating_div(BYTES_PER_MB)
}


```

---

### File: `core\src\engine\mod.rs`

```rust
//! Core diffing engine for workbook comparison.
//!
//! Provides the main entry point [`diff_workbooks`] for comparing two workbooks
//! and generating a [`DiffReport`] of all changes.
//!
//! ## Module Structure
//!
//! - `workbook_diff`: Workbook-level diff orchestration and sheet enumeration
//! - `grid_diff`: Grid diffing pipeline, cell comparison, and positional diff
//! - `move_mask`: Move detection with region masks and SheetGridDiffer
//! - `amr`: AMR (Adaptive Move Recognition) alignment and decision helpers
//! - `context`: Shared types for diff context and emission

mod amr;
mod context;
mod grid_diff;
mod grid_primitives;
mod hardening;
mod move_mask;
mod workbook_diff;

use crate::diff::SheetId;
use context::emit_op;

pub use grid_diff::diff_grids_database_mode;
pub(crate) use grid_diff::try_diff_grids_database_mode_streaming;
pub use workbook_diff::{
    diff_workbooks, diff_workbooks_streaming, diff_workbooks_streaming_with_progress,
    diff_workbooks_with_progress, try_diff_workbooks, try_diff_workbooks_streaming,
    try_diff_workbooks_streaming_with_progress, try_diff_workbooks_with_progress,
};

```

---

### File: `core\src\engine\move_mask.rs`

```rust
use crate::alignment_types::RowBlockMove;
use crate::column_alignment::{ColumnBlockMove, detect_exact_column_block_move};
use crate::config::DiffConfig;
use crate::diff::DiffError;
use crate::grid_view::GridView;
#[cfg(feature = "perf-metrics")]
use crate::perf::DiffMetrics;
use crate::rect_block_move::{RectBlockMove, detect_exact_rect_block_move};
use crate::region_mask::RegionMask;
use crate::row_alignment::{detect_exact_row_block_move, detect_fuzzy_row_block_move};
use crate::sink::DiffSink;
use crate::workbook::{CellAddress, ColSignature, Grid, RowSignature};

use std::collections::{BTreeMap, HashSet};

use super::amr::try_diff_with_amr;
use super::context::EmitCtx;
use super::grid_primitives::{
    cells_content_equal, emit_cell_edit, emit_column_block_move, emit_moved_row_block_edits,
    emit_rect_block_move, emit_row_block_move, run_positional_diff_with_metrics,
    try_row_alignment_internal, try_single_column_alignment_internal,
};

pub(super) struct SheetGridDiffer<'a, 'p, 'b, S: DiffSink> {
    pub(super) emit_ctx: EmitCtx<'a, 'p, S>,
    pub(super) old: &'b Grid,
    pub(super) new: &'b Grid,
    pub(super) old_view: GridView<'b>,
    pub(super) new_view: GridView<'b>,
    pub(super) old_mask: RegionMask,
    pub(super) new_mask: RegionMask,
    #[cfg(feature = "perf-metrics")]
    pub(super) metrics: Option<&'a mut DiffMetrics>,
}

impl<'a, 'p, 'b, S: DiffSink> SheetGridDiffer<'a, 'p, 'b, S> {
    pub(super) fn from_views(
        emit_ctx: EmitCtx<'a, 'p, S>,
        old: &'b Grid,
        new: &'b Grid,
        old_view: GridView<'b>,
        new_view: GridView<'b>,
        #[cfg(feature = "perf-metrics")] metrics: Option<&'a mut DiffMetrics>,
    ) -> Self {
        let old_mask = RegionMask::all_active(old.nrows, old.ncols);
        let new_mask = RegionMask::all_active(new.nrows, new.ncols);

        Self {
            emit_ctx,
            old,
            new,
            old_view,
            new_view,
            old_mask,
            new_mask,
            #[cfg(feature = "perf-metrics")]
            metrics,
        }
    }

    fn move_detection_enabled(&self) -> bool {
        self.old.nrows.max(self.new.nrows) <= self.emit_ctx.config.max_move_detection_rows
            && self.old.ncols.max(self.new.ncols) <= self.emit_ctx.config.max_move_detection_cols
    }

    pub(super) fn detect_moves(&mut self) -> Result<u32, DiffError> {
        if !self.move_detection_enabled() {
            return Ok(0);
        }

        let mut iteration = 0u32;
        let config = self.emit_ctx.config;

        loop {
            if iteration >= config.max_move_iterations {
                break;
            }

            if !self.old_mask.has_active_cells() || !self.new_mask.has_active_cells() {
                break;
            }

            let mut found_move = false;

            if let Some(mv) = detect_exact_rect_block_move_masked(
                self.old,
                self.new,
                &self.old_mask,
                &self.new_mask,
                config,
            ) {
                emit_rect_block_move(&mut self.emit_ctx, mv)?;
                #[cfg(feature = "perf-metrics")]
                if let Some(m) = self.metrics.as_mut() {
                    m.moves_detected = m.moves_detected.saturating_add(1);
                }
                self.old_mask.exclude_rect_cells(
                    mv.src_start_row,
                    mv.src_row_count,
                    mv.src_start_col,
                    mv.src_col_count,
                );
                self.new_mask.exclude_rect_cells(
                    mv.dst_start_row,
                    mv.src_row_count,
                    mv.dst_start_col,
                    mv.src_col_count,
                );
                self.old_mask.exclude_rect_cells(
                    mv.dst_start_row,
                    mv.src_row_count,
                    mv.dst_start_col,
                    mv.src_col_count,
                );
                self.new_mask.exclude_rect_cells(
                    mv.src_start_row,
                    mv.src_row_count,
                    mv.src_start_col,
                    mv.src_col_count,
                );
                iteration += 1;
                found_move = true;
            }

            if !found_move
                && let Some(mv) = detect_exact_row_block_move_masked(
                    self.old,
                    self.new,
                    &self.old_mask,
                    &self.new_mask,
                    config,
                )
            {
                emit_row_block_move(&mut self.emit_ctx, mv)?;
                #[cfg(feature = "perf-metrics")]
                if let Some(m) = self.metrics.as_mut() {
                    m.moves_detected = m.moves_detected.saturating_add(1);
                }
                self.old_mask.exclude_rows(mv.src_start_row, mv.row_count);
                self.new_mask.exclude_rows(mv.dst_start_row, mv.row_count);
                iteration += 1;
                found_move = true;
            }

            if !found_move
                && let Some(mv) = detect_exact_column_block_move_masked(
                    self.old,
                    self.new,
                    &self.old_mask,
                    &self.new_mask,
                    config,
                )
            {
                emit_column_block_move(&mut self.emit_ctx, mv)?;
                #[cfg(feature = "perf-metrics")]
                if let Some(m) = self.metrics.as_mut() {
                    m.moves_detected = m.moves_detected.saturating_add(1);
                }
                self.old_mask.exclude_cols(mv.src_start_col, mv.col_count);
                self.new_mask.exclude_cols(mv.dst_start_col, mv.col_count);
                iteration += 1;
                found_move = true;
            }

            if !found_move
                && config.enable_fuzzy_moves
                && let Some(mv) = detect_fuzzy_row_block_move_masked(
                    self.old,
                    self.new,
                    &self.old_mask,
                    &self.new_mask,
                    config,
                )
            {
                emit_row_block_move(&mut self.emit_ctx, mv)?;
                emit_moved_row_block_edits(&mut self.emit_ctx, &self.old_view, &self.new_view, mv)?;
                #[cfg(feature = "perf-metrics")]
                if let Some(m) = self.metrics.as_mut() {
                    m.moves_detected = m.moves_detected.saturating_add(1);
                }
                self.old_mask.exclude_rows(mv.src_start_row, mv.row_count);
                self.new_mask.exclude_rows(mv.dst_start_row, mv.row_count);
                iteration += 1;
                found_move = true;
            }

            if !found_move {
                break;
            }

            if self.old.nrows != self.new.nrows || self.old.ncols != self.new.ncols {
                break;
            }
        }

        Ok(iteration)
    }

    pub(super) fn has_mask_exclusions(&self) -> bool {
        self.old_mask.has_exclusions() || self.new_mask.has_exclusions()
    }

    pub(super) fn diff_with_masks(&mut self) -> Result<(), DiffError> {
        if self.old.nrows != self.new.nrows || self.old.ncols != self.new.ncols {
            if diff_aligned_with_masks(
                &mut self.emit_ctx,
                self.old,
                self.new,
                &self.old_mask,
                &self.new_mask,
            )? {
                return Ok(());
            }
            positional_diff_with_masks(
                &mut self.emit_ctx,
                self.old,
                self.new,
                &self.old_mask,
                &self.new_mask,
            )?;
            return Ok(());
        }

        positional_diff_masked_equal_size(
            &mut self.emit_ctx,
            self.old,
            self.new,
            &self.old_mask,
            &self.new_mask,
        )?;

        Ok(())
    }

    pub(super) fn try_amr(&mut self) -> Result<bool, DiffError> {
        #[cfg(feature = "perf-metrics")]
        let handled = try_diff_with_amr(
            &mut self.emit_ctx,
            self.old,
            self.new,
            &self.old_view,
            &self.new_view,
            self.metrics.as_deref_mut(),
        )?;
        #[cfg(not(feature = "perf-metrics"))]
        let handled = try_diff_with_amr(
            &mut self.emit_ctx,
            self.old,
            self.new,
            &self.old_view,
            &self.new_view,
        )?;
        Ok(handled)
    }

    pub(super) fn try_row_alignment(&mut self) -> Result<bool, DiffError> {
        #[cfg(feature = "perf-metrics")]
        return try_row_alignment_internal(
            &mut self.emit_ctx,
            &self.old_view,
            &self.new_view,
            &mut self.metrics,
        );
        #[cfg(not(feature = "perf-metrics"))]
        return try_row_alignment_internal(&mut self.emit_ctx, &self.old_view, &self.new_view);
    }

    pub(super) fn try_single_column_alignment(&mut self) -> Result<bool, DiffError> {
        #[cfg(feature = "perf-metrics")]
        return try_single_column_alignment_internal(
            &mut self.emit_ctx,
            self.old,
            self.new,
            &self.old_view,
            &self.new_view,
            &mut self.metrics,
        );
        #[cfg(not(feature = "perf-metrics"))]
        return try_single_column_alignment_internal(
            &mut self.emit_ctx,
            self.old,
            self.new,
            &self.old_view,
            &self.new_view,
        );
    }

    pub(super) fn positional(&mut self) -> Result<(), DiffError> {
        #[cfg(feature = "perf-metrics")]
        run_positional_diff_with_metrics(
            &mut self.emit_ctx,
            self.old,
            self.new,
            self.metrics.as_deref_mut(),
        )?;
        #[cfg(not(feature = "perf-metrics"))]
        run_positional_diff_with_metrics(&mut self.emit_ctx, self.old, self.new)?;
        Ok(())
    }
}

pub(super) fn row_signature_at(grid: &Grid, row: u32) -> Option<RowSignature> {
    if let Some(sig) = grid
        .row_signatures
        .as_ref()
        .and_then(|rows| rows.get(row as usize))
    {
        return Some(*sig);
    }
    Some(grid.compute_row_signature(row))
}

pub(super) fn col_signature_at(grid: &Grid, col: u32) -> Option<ColSignature> {
    if let Some(sig) = grid
        .col_signatures
        .as_ref()
        .and_then(|cols| cols.get(col as usize))
    {
        return Some(*sig);
    }
    Some(grid.compute_col_signature(col))
}

fn align_indices_by_signature<T: Copy + Eq>(
    idx_a: &[u32],
    idx_b: &[u32],
    sig_a: impl Fn(u32) -> Option<T>,
    sig_b: impl Fn(u32) -> Option<T>,
) -> Option<(Vec<u32>, Vec<u32>)> {
    if idx_a.is_empty() || idx_b.is_empty() {
        return None;
    }

    if idx_a.len() == idx_b.len() {
        return Some((idx_a.to_vec(), idx_b.to_vec()));
    }

    let (short, long, short_is_a) = if idx_a.len() <= idx_b.len() {
        (idx_a, idx_b, true)
    } else {
        (idx_b, idx_a, false)
    };

    let diff = long.len() - short.len();
    let mut best_offset = 0usize;
    let mut best_matches = 0usize;

    for offset in 0..=diff {
        let mut matches = 0usize;
        for (i, &short_idx) in short.iter().enumerate() {
            let long_idx = long[offset + i];
            let (sig_short, sig_long) = if short_is_a {
                (sig_a(short_idx), sig_b(long_idx))
            } else {
                (sig_b(short_idx), sig_a(long_idx))
            };
            if let (Some(sa), Some(sb)) = (sig_short, sig_long)
                && sa == sb
            {
                matches += 1;
            }
        }
        if matches > best_matches {
            best_matches = matches;
            best_offset = offset;
        }
    }

    if short_is_a {
        let aligned_b = long[best_offset..best_offset + short.len()].to_vec();
        Some((idx_a.to_vec(), aligned_b))
    } else {
        let aligned_a = long[best_offset..best_offset + short.len()].to_vec();
        Some((aligned_a, idx_b.to_vec()))
    }
}

fn collect_differences_in_grid(old: &Grid, new: &Grid) -> Vec<(u32, u32)> {
    let mut diffs = Vec::new();

    for row in 0..old.nrows {
        for col in 0..old.ncols {
            if !cells_content_equal(old.get(row, col), new.get(row, col)) {
                diffs.push((row, col));
            }
        }
    }

    diffs
}

fn contiguous_ranges<I>(indices: I) -> Vec<(u32, u32)>
where
    I: IntoIterator<Item = u32>,
{
    let mut values: Vec<u32> = indices.into_iter().collect();
    if values.is_empty() {
        return Vec::new();
    }

    values.sort_unstable();
    values.dedup();

    let mut ranges: Vec<(u32, u32)> = Vec::new();
    let mut start = values[0];
    let mut prev = values[0];

    for &val in values.iter().skip(1) {
        if val == prev + 1 {
            prev = val;
            continue;
        }

        ranges.push((start, prev));
        start = val;
        prev = val;
    }
    ranges.push((start, prev));

    ranges
}

fn group_rows_by_column_patterns(diffs: &[(u32, u32)]) -> Vec<(u32, u32)> {
    if diffs.is_empty() {
        return Vec::new();
    }

    let mut row_to_cols: BTreeMap<u32, Vec<u32>> = BTreeMap::new();
    for (row, col) in diffs {
        row_to_cols.entry(*row).or_default().push(*col);
    }

    for cols in row_to_cols.values_mut() {
        cols.sort_unstable();
        cols.dedup();
    }

    let mut rows: Vec<u32> = row_to_cols.keys().copied().collect();
    rows.sort_unstable();

    let mut groups: Vec<(u32, u32)> = Vec::new();
    if let Some(&first_row) = rows.first() {
        let mut start = first_row;
        let mut prev = first_row;
        let mut current_cols = row_to_cols.get(&first_row).cloned().unwrap_or_default();

        for row in rows.into_iter().skip(1) {
            let cols = row_to_cols.get(&row).cloned().unwrap_or_default();
            if row == prev + 1 && cols == current_cols {
                prev = row;
            } else {
                groups.push((start, prev));
                start = row;
                prev = row;
                current_cols = cols;
            }
        }
        groups.push((start, prev));
    }

    groups
}

fn build_projected_grid_from_maps(
    source: &Grid,
    mask: &RegionMask,
    row_map: &[u32],
    col_map: &[u32],
) -> (Grid, Vec<u32>, Vec<u32>) {
    let nrows = row_map.len() as u32;
    let ncols = col_map.len() as u32;

    let mut row_lookup: Vec<Option<u32>> = vec![None; source.nrows as usize];
    for (new_idx, old_row) in row_map.iter().enumerate() {
        row_lookup[*old_row as usize] = Some(new_idx as u32);
    }

    let mut col_lookup: Vec<Option<u32>> = vec![None; source.ncols as usize];
    for (new_idx, old_col) in col_map.iter().enumerate() {
        col_lookup[*old_col as usize] = Some(new_idx as u32);
    }

    let mut projected = Grid::new(nrows, ncols);

    for ((row, col), cell) in source.iter_cells() {
        if !mask.is_cell_active(row, col) {
            continue;
        }
        let Some(new_row) = row_lookup.get(row as usize).and_then(|v| *v) else {
            continue;
        };
        let Some(new_col) = col_lookup.get(col as usize).and_then(|v| *v) else {
            continue;
        };

        projected.insert_cell(new_row, new_col, cell.value, cell.formula);
    }

    (projected, row_map.to_vec(), col_map.to_vec())
}

fn build_masked_grid(source: &Grid, mask: &RegionMask) -> (Grid, Vec<u32>, Vec<u32>) {
    let row_map: Vec<u32> = mask.active_rows().collect();
    let col_map: Vec<u32> = mask.active_cols().collect();

    let nrows = row_map.len() as u32;
    let ncols = col_map.len() as u32;

    let mut row_lookup: Vec<Option<u32>> = vec![None; source.nrows as usize];
    for (new_idx, old_row) in row_map.iter().enumerate() {
        row_lookup[*old_row as usize] = Some(new_idx as u32);
    }

    let mut col_lookup: Vec<Option<u32>> = vec![None; source.ncols as usize];
    for (new_idx, old_col) in col_map.iter().enumerate() {
        col_lookup[*old_col as usize] = Some(new_idx as u32);
    }

    let mut projected = Grid::new(nrows, ncols);

    for ((row, col), cell) in source.iter_cells() {
        if !mask.is_cell_active(row, col) {
            continue;
        }

        let Some(new_row) = row_lookup.get(row as usize).and_then(|v| *v) else {
            continue;
        };
        let Some(new_col) = col_lookup.get(col as usize).and_then(|v| *v) else {
            continue;
        };

        projected.insert_cell(new_row, new_col, cell.value, cell.formula);
    }

    (projected, row_map, col_map)
}

fn detect_exact_row_block_move_masked(
    old: &Grid,
    new: &Grid,
    old_mask: &RegionMask,
    new_mask: &RegionMask,
    config: &DiffConfig,
) -> Option<RowBlockMove> {
    if !old_mask.has_active_cells() || !new_mask.has_active_cells() {
        return None;
    }

    if !old_mask.has_exclusions() && !new_mask.has_exclusions() {
        return detect_exact_row_block_move(old, new, config);
    }

    let (old_proj, old_rows, _) = build_masked_grid(old, old_mask);
    let (new_proj, new_rows, _) = build_masked_grid(new, new_mask);

    if old_proj.nrows != new_proj.nrows || old_proj.ncols != new_proj.ncols {
        return None;
    }

    let mv_local = detect_exact_row_block_move(&old_proj, &new_proj, config)?;
    let src_start_row = *old_rows.get(mv_local.src_start_row as usize)?;
    let dst_start_row = *new_rows.get(mv_local.dst_start_row as usize)?;

    Some(RowBlockMove {
        src_start_row,
        dst_start_row,
        row_count: mv_local.row_count,
    })
}

fn detect_exact_column_block_move_masked(
    old: &Grid,
    new: &Grid,
    old_mask: &RegionMask,
    new_mask: &RegionMask,
    config: &DiffConfig,
) -> Option<ColumnBlockMove> {
    if !old_mask.has_active_cells() || !new_mask.has_active_cells() {
        return None;
    }

    if !old_mask.has_exclusions() && !new_mask.has_exclusions() {
        return detect_exact_column_block_move(old, new, config);
    }

    let (old_proj, _, old_cols) = build_masked_grid(old, old_mask);
    let (new_proj, _, new_cols) = build_masked_grid(new, new_mask);

    if old_proj.nrows != new_proj.nrows || old_proj.ncols != new_proj.ncols {
        return None;
    }

    let mv_local = detect_exact_column_block_move(&old_proj, &new_proj, config)?;
    let src_start_col = *old_cols.get(mv_local.src_start_col as usize)?;
    let dst_start_col = *new_cols.get(mv_local.dst_start_col as usize)?;

    Some(ColumnBlockMove {
        src_start_col,
        dst_start_col,
        col_count: mv_local.col_count,
    })
}

fn detect_exact_rect_block_move_masked(
    old: &Grid,
    new: &Grid,
    old_mask: &RegionMask,
    new_mask: &RegionMask,
    config: &DiffConfig,
) -> Option<RectBlockMove> {
    if !old_mask.has_active_cells() || !new_mask.has_active_cells() {
        return None;
    }

    if !old_mask.has_exclusions()
        && !new_mask.has_exclusions()
        && old.nrows == new.nrows
        && old.ncols == new.ncols
        && let Some(mv) = detect_exact_rect_block_move(old, new, config)
    {
        return Some(mv);
    }

    let aligned_rows = align_indices_by_signature(
        &old_mask.active_rows().collect::<Vec<_>>(),
        &new_mask.active_rows().collect::<Vec<_>>(),
        |r| row_signature_at(old, r),
        |r| row_signature_at(new, r),
    )?;
    let aligned_cols = align_indices_by_signature(
        &old_mask.active_cols().collect::<Vec<_>>(),
        &new_mask.active_cols().collect::<Vec<_>>(),
        |c| col_signature_at(old, c),
        |c| col_signature_at(new, c),
    )?;
    let (old_proj, old_rows, old_cols) =
        build_projected_grid_from_maps(old, old_mask, &aligned_rows.0, &aligned_cols.0);
    let (new_proj, new_rows, new_cols) =
        build_projected_grid_from_maps(new, new_mask, &aligned_rows.1, &aligned_cols.1);

    let map_move = |mv_local: RectBlockMove,
                    row_map_old: &[u32],
                    row_map_new: &[u32],
                    col_map_old: &[u32],
                    col_map_new: &[u32]|
     -> Option<RectBlockMove> {
        let src_start_row = *row_map_old.get(mv_local.src_start_row as usize)?;
        let dst_start_row = *row_map_new.get(mv_local.dst_start_row as usize)?;
        let src_start_col = *col_map_old.get(mv_local.src_start_col as usize)?;
        let dst_start_col = *col_map_new.get(mv_local.dst_start_col as usize)?;

        Some(RectBlockMove {
            src_start_row,
            dst_start_row,
            src_start_col,
            dst_start_col,
            src_row_count: mv_local.src_row_count,
            src_col_count: mv_local.src_col_count,
            block_hash: mv_local.block_hash,
        })
    };

    if let Some(mv_local) = detect_exact_rect_block_move(&old_proj, &new_proj, config)
        && let Some(mapped) = map_move(mv_local, &old_rows, &new_rows, &old_cols, &new_cols)
    {
        return Some(mapped);
    }

    let diff_positions = collect_differences_in_grid(&old_proj, &new_proj);
    if diff_positions.is_empty() {
        return None;
    }

    let row_ranges = group_rows_by_column_patterns(&diff_positions);
    let col_ranges_full = contiguous_ranges(diff_positions.iter().map(|(_, c)| *c));
    let has_prior_exclusions = old_mask.has_exclusions() || new_mask.has_exclusions();
    if !has_prior_exclusions && row_ranges.len() <= 2 && col_ranges_full.len() <= 2 {
        return None;
    }

    let range_len = |range: (u32, u32)| range.1.saturating_sub(range.0).saturating_add(1);
    let in_range = |idx: u32, range: (u32, u32)| idx >= range.0 && idx <= range.1;
    let rectangles_match = |src_rows: (u32, u32),
                            src_cols: (u32, u32),
                            dst_rows: (u32, u32),
                            dst_cols: (u32, u32)|
     -> bool {
        let row_count = range_len(src_rows);
        let col_count = range_len(src_cols);

        for dr in 0..row_count {
            for dc in 0..col_count {
                let src_row = src_rows.0 + dr;
                let src_col = src_cols.0 + dc;
                let dst_row = dst_rows.0 + dr;
                let dst_col = dst_cols.0 + dc;

                if !cells_content_equal(
                    old_proj.get(src_row, src_col),
                    new_proj.get(dst_row, dst_col),
                ) {
                    return false;
                }
            }
        }

        true
    };

    for (row_idx, &row_a) in row_ranges.iter().enumerate() {
        for &row_b in row_ranges.iter().skip(row_idx + 1) {
            if range_len(row_a) != range_len(row_b) {
                continue;
            }

            let cols_row_a: Vec<u32> = diff_positions
                .iter()
                .filter_map(|(r, c)| if in_range(*r, row_a) { Some(*c) } else { None })
                .collect();
            let cols_row_b: Vec<u32> = diff_positions
                .iter()
                .filter_map(|(r, c)| if in_range(*r, row_b) { Some(*c) } else { None })
                .collect();
            let col_ranges_a = contiguous_ranges(cols_row_a);
            let col_ranges_b = contiguous_ranges(cols_row_b);
            let mut col_pairs: Vec<((u32, u32), (u32, u32))> = Vec::new();

            for &col_a in &col_ranges_a {
                for &col_b in &col_ranges_b {
                    if range_len(col_a) != range_len(col_b) {
                        continue;
                    }
                    col_pairs.push((col_a, col_b));
                }
            }

            if col_pairs.is_empty() {
                continue;
            }

            for (col_a, col_b) in col_pairs {
                let mut scoped_old_mask = RegionMask::all_active(old_proj.nrows, old_proj.ncols);
                let mut scoped_new_mask = RegionMask::all_active(new_proj.nrows, new_proj.ncols);

                for row in 0..old_proj.nrows {
                    if !in_range(row, row_a) && !in_range(row, row_b) {
                        scoped_old_mask.exclude_row(row);
                        scoped_new_mask.exclude_row(row);
                    }
                }

                for col in 0..old_proj.ncols {
                    if !in_range(col, col_a) && !in_range(col, col_b) {
                        scoped_old_mask.exclude_col(col);
                        scoped_new_mask.exclude_col(col);
                    }
                }

                let (old_scoped, scoped_old_rows, scoped_old_cols) =
                    build_masked_grid(&old_proj, &scoped_old_mask);
                let (new_scoped, scoped_new_rows, scoped_new_cols) =
                    build_masked_grid(&new_proj, &scoped_new_mask);

                if old_scoped.nrows != new_scoped.nrows || old_scoped.ncols != new_scoped.ncols {
                    continue;
                }

                if let Some(candidate) =
                    detect_exact_rect_block_move(&old_scoped, &new_scoped, config)
                {
                    let scoped_row_map_old: Option<Vec<u32>> = scoped_old_rows
                        .iter()
                        .map(|idx| old_rows.get(*idx as usize).copied())
                        .collect();
                    let scoped_row_map_new: Option<Vec<u32>> = scoped_new_rows
                        .iter()
                        .map(|idx| new_rows.get(*idx as usize).copied())
                        .collect();
                    let scoped_col_map_old: Option<Vec<u32>> = scoped_old_cols
                        .iter()
                        .map(|idx| old_cols.get(*idx as usize).copied())
                        .collect();
                    let scoped_col_map_new: Option<Vec<u32>> = scoped_new_cols
                        .iter()
                        .map(|idx| new_cols.get(*idx as usize).copied())
                        .collect();

                    if let (
                        Some(row_map_old),
                        Some(row_map_new),
                        Some(col_map_old),
                        Some(col_map_new),
                    ) = (
                        scoped_row_map_old,
                        scoped_row_map_new,
                        scoped_col_map_old,
                        scoped_col_map_new,
                    ) && let Some(mapped) = map_move(
                        candidate,
                        &row_map_old,
                        &row_map_new,
                        &col_map_old,
                        &col_map_new,
                    ) {
                        return Some(mapped);
                    }
                }

                let row_len = range_len(row_a);
                let col_len = range_len(col_a);
                if row_len == 0 || col_len == 0 {
                    continue;
                }

                let candidates = [
                    (row_a, col_a, row_b, col_b),
                    (row_a, col_b, row_b, col_a),
                    (row_b, col_a, row_a, col_b),
                    (row_b, col_b, row_a, col_a),
                ];

                for (src_rows, src_cols, dst_rows, dst_cols) in candidates {
                    if range_len(src_rows) != range_len(dst_rows)
                        || range_len(src_cols) != range_len(dst_cols)
                    {
                        continue;
                    }

                    if rectangles_match(src_rows, src_cols, dst_rows, dst_cols) {
                        let mapped = RectBlockMove {
                            src_start_row: *old_rows.get(src_rows.0 as usize)?,
                            dst_start_row: *new_rows.get(dst_rows.0 as usize)?,
                            src_start_col: *old_cols.get(src_cols.0 as usize)?,
                            dst_start_col: *new_cols.get(dst_cols.0 as usize)?,
                            src_row_count: range_len(src_rows),
                            src_col_count: range_len(src_cols),
                            block_hash: None,
                        };
                        return Some(mapped);
                    }
                }
            }
        }
    }

    None
}

fn detect_fuzzy_row_block_move_masked(
    old: &Grid,
    new: &Grid,
    old_mask: &RegionMask,
    new_mask: &RegionMask,
    config: &DiffConfig,
) -> Option<RowBlockMove> {
    if !old_mask.has_active_cells() || !new_mask.has_active_cells() {
        return None;
    }

    if !old_mask.has_exclusions() && !new_mask.has_exclusions() {
        return detect_fuzzy_row_block_move(old, new, config);
    }

    let (old_proj, old_rows, _) = build_masked_grid(old, old_mask);
    let (new_proj, new_rows, _) = build_masked_grid(new, new_mask);

    if old_proj.nrows != new_proj.nrows || old_proj.ncols != new_proj.ncols {
        return None;
    }

    let mv_local = detect_fuzzy_row_block_move(&old_proj, &new_proj, config)?;
    let src_start_row = *old_rows.get(mv_local.src_start_row as usize)?;
    let dst_start_row = *new_rows.get(mv_local.dst_start_row as usize)?;

    Some(RowBlockMove {
        src_start_row,
        dst_start_row,
        row_count: mv_local.row_count,
    })
}

fn diff_aligned_with_masks<S: DiffSink>(
    ctx: &mut EmitCtx<'_, '_, S>,
    old: &Grid,
    new: &Grid,
    old_mask: &RegionMask,
    new_mask: &RegionMask,
) -> Result<bool, DiffError> {
    let old_rows: Vec<u32> = old_mask.active_rows().collect();
    let new_rows: Vec<u32> = new_mask.active_rows().collect();
    let old_cols: Vec<u32> = old_mask.active_cols().collect();
    let new_cols: Vec<u32> = new_mask.active_cols().collect();

    let Some((rows_a, rows_b)) = align_indices_by_signature(
        &old_rows,
        &new_rows,
        |r| row_signature_at(old, r),
        |r| row_signature_at(new, r),
    ) else {
        return Ok(false);
    };

    let (cols_a, cols_b) = align_indices_by_signature(
        &old_cols,
        &new_cols,
        |c| col_signature_at(old, c),
        |c| col_signature_at(new, c),
    )
    .unwrap_or((old_cols.clone(), new_cols.clone()));

    if rows_a.len() != rows_b.len() || cols_a.len() != cols_b.len() {
        return Ok(false);
    }

    ctx.hardening.progress("cell_diff", 0.0);

    let total_rows = rows_a.len();
    for (idx, (row_a, row_b)) in rows_a.iter().zip(rows_b.iter()).enumerate() {
        if ctx.hardening.check_timeout(ctx.warnings) {
            return Ok(true);
        }

        if total_rows > 0 && idx % 64 == 0 {
            ctx.hardening
                .progress("cell_diff", idx as f32 / total_rows as f32);
        }

        for (col_a, col_b) in cols_a.iter().zip(cols_b.iter()) {
            if !old_mask.is_cell_active(*row_a, *col_a) || !new_mask.is_cell_active(*row_b, *col_b)
            {
                continue;
            }
            let old_cell = old.get(*row_a, *col_a);
            let new_cell = new.get(*row_b, *col_b);

            if cells_content_equal(old_cell, new_cell) {
                continue;
            }

            let addr = CellAddress::from_indices(*row_b, *col_b);
            let row_shift = *row_b as i32 - *row_a as i32;
            let col_shift = *col_b as i32 - *col_a as i32;
            emit_cell_edit(ctx, addr, old_cell, new_cell, row_shift, col_shift)?;
        }
    }

    ctx.hardening.progress("cell_diff", 1.0);

    let rows_a_set: HashSet<u32> = rows_a.iter().copied().collect();
    let rows_b_set: HashSet<u32> = rows_b.iter().copied().collect();

    for row_idx in new_rows.iter().filter(|r| !rows_b_set.contains(r)) {
        if new_mask.is_row_active(*row_idx) {
            ctx.emit(crate::diff::DiffOp::row_added(ctx.sheet_id, *row_idx, None))?;
        }
    }

    for row_idx in old_rows.iter().filter(|r| !rows_a_set.contains(r)) {
        if old_mask.is_row_active(*row_idx) {
            ctx.emit(crate::diff::DiffOp::row_removed(
                ctx.sheet_id,
                *row_idx,
                None,
            ))?;
        }
    }

    let cols_a_set: HashSet<u32> = cols_a.iter().copied().collect();
    let cols_b_set: HashSet<u32> = cols_b.iter().copied().collect();

    for col_idx in new_cols.iter().filter(|c| !cols_b_set.contains(c)) {
        if new_mask.is_col_active(*col_idx) {
            ctx.emit(crate::diff::DiffOp::column_added(
                ctx.sheet_id,
                *col_idx,
                None,
            ))?;
        }
    }

    for col_idx in old_cols.iter().filter(|c| !cols_a_set.contains(c)) {
        if old_mask.is_col_active(*col_idx) {
            ctx.emit(crate::diff::DiffOp::column_removed(
                ctx.sheet_id,
                *col_idx,
                None,
            ))?;
        }
    }

    Ok(true)
}

fn positional_diff_with_masks<S: DiffSink>(
    ctx: &mut EmitCtx<'_, '_, S>,
    old: &Grid,
    new: &Grid,
    old_mask: &RegionMask,
    new_mask: &RegionMask,
) -> Result<(), DiffError> {
    let overlap_rows = old.nrows.min(new.nrows);
    let overlap_cols = old.ncols.min(new.ncols);

    ctx.hardening.progress("cell_diff", 0.0);

    for row in 0..overlap_rows {
        if ctx.hardening.check_timeout(ctx.warnings) {
            return Ok(());
        }
        if overlap_rows > 0 && row % 256 == 0 {
            ctx.hardening
                .progress("cell_diff", row as f32 / overlap_rows as f32);
        }
        for col in 0..overlap_cols {
            if !old_mask.is_cell_active(row, col) || !new_mask.is_cell_active(row, col) {
                continue;
            }
            let old_cell = old.get(row, col);
            let new_cell = new.get(row, col);

            if cells_content_equal(old_cell, new_cell) {
                continue;
            }

            let addr = CellAddress::from_indices(row, col);
            emit_cell_edit(ctx, addr, old_cell, new_cell, 0, 0)?;
        }
    }

    if overlap_rows > 0 {
        ctx.hardening.progress("cell_diff", 1.0);
    }

    if ctx.hardening.check_timeout(ctx.warnings) {
        return Ok(());
    }

    if new.nrows > old.nrows {
        for row_idx in old.nrows..new.nrows {
            if row_idx % 4096 == 0 && ctx.hardening.check_timeout(ctx.warnings) {
                return Ok(());
            }
            if new_mask.is_row_active(row_idx) {
                ctx.emit(crate::diff::DiffOp::row_added(ctx.sheet_id, row_idx, None))?;
            }
        }
    } else if old.nrows > new.nrows {
        for row_idx in new.nrows..old.nrows {
            if row_idx % 4096 == 0 && ctx.hardening.check_timeout(ctx.warnings) {
                return Ok(());
            }
            if old_mask.is_row_active(row_idx) {
                ctx.emit(crate::diff::DiffOp::row_removed(
                    ctx.sheet_id,
                    row_idx,
                    None,
                ))?;
            }
        }
    }

    if new.ncols > old.ncols {
        for col_idx in old.ncols..new.ncols {
            if col_idx % 4096 == 0 && ctx.hardening.check_timeout(ctx.warnings) {
                return Ok(());
            }
            if new_mask.is_col_active(col_idx) {
                ctx.emit(crate::diff::DiffOp::column_added(
                    ctx.sheet_id,
                    col_idx,
                    None,
                ))?;
            }
        }
    } else if old.ncols > new.ncols {
        for col_idx in new.ncols..old.ncols {
            if col_idx % 4096 == 0 && ctx.hardening.check_timeout(ctx.warnings) {
                return Ok(());
            }
            if old_mask.is_col_active(col_idx) {
                ctx.emit(crate::diff::DiffOp::column_removed(
                    ctx.sheet_id,
                    col_idx,
                    None,
                ))?;
            }
        }
    }

    Ok(())
}

fn positional_diff_masked_equal_size<S: DiffSink>(
    ctx: &mut EmitCtx<'_, '_, S>,
    old: &Grid,
    new: &Grid,
    old_mask: &RegionMask,
    new_mask: &RegionMask,
) -> Result<(), DiffError> {
    let row_shift_zone =
        compute_combined_shift_zone(old_mask.row_shift_bounds(), new_mask.row_shift_bounds());
    let col_shift_zone =
        compute_combined_shift_zone(old_mask.col_shift_bounds(), new_mask.col_shift_bounds());

    let stable_rows: Vec<u32> = (0..old.nrows)
        .filter(|&r| !is_in_zone(r, &row_shift_zone))
        .collect();
    let stable_cols: Vec<u32> = (0..old.ncols)
        .filter(|&c| !is_in_zone(c, &col_shift_zone))
        .collect();

    ctx.hardening.progress("cell_diff", 0.0);

    let total_rows = stable_rows.len();
    for (idx, &row) in stable_rows.iter().enumerate() {
        if ctx.hardening.check_timeout(ctx.warnings) {
            return Ok(());
        }
        if total_rows > 0 && idx % 64 == 0 {
            ctx.hardening
                .progress("cell_diff", idx as f32 / total_rows as f32);
        }
        for &col in &stable_cols {
            if !old_mask.is_cell_active(row, col) || !new_mask.is_cell_active(row, col) {
                continue;
            }
            let old_cell = old.get(row, col);
            let new_cell = new.get(row, col);

            if cells_content_equal(old_cell, new_cell) {
                continue;
            }

            let addr = CellAddress::from_indices(row, col);
            emit_cell_edit(ctx, addr, old_cell, new_cell, 0, 0)?;
        }
    }

    ctx.hardening.progress("cell_diff", 1.0);

    Ok(())
}

fn compute_combined_shift_zone(a: Option<(u32, u32)>, b: Option<(u32, u32)>) -> Option<(u32, u32)> {
    match (a, b) {
        (Some((a_min, a_max)), Some((b_min, b_max))) => Some((a_min.min(b_min), a_max.max(b_max))),
        (Some(bounds), None) | (None, Some(bounds)) => Some(bounds),
        (None, None) => None,
    }
}

fn is_in_zone(idx: u32, zone: &Option<(u32, u32)>) -> bool {
    match zone {
        Some((min, max)) => idx >= *min && idx <= *max,
        None => false,
    }
}

#[cfg(test)]
mod tests {
    use super::*;
    use crate::workbook::CellValue;

    fn grid_from_matrix(values: &[Vec<i32>]) -> Grid {
        let nrows = values.len() as u32;
        let ncols = if nrows == 0 {
            0
        } else {
            values[0].len() as u32
        };
        let mut grid = Grid::new(nrows, ncols);
        for (r, row) in values.iter().enumerate() {
            for (c, val) in row.iter().enumerate() {
                grid.insert_cell(
                    r as u32,
                    c as u32,
                    Some(CellValue::Number(*val as f64)),
                    None,
                );
            }
        }
        grid
    }

    #[test]
    fn rect_move_masked_falls_back_when_outside_edit_exists() {
        let rows = 12usize;
        let cols = 12usize;
        let base: Vec<Vec<i32>> = (0..rows)
            .map(|r| {
                (0..cols)
                    .map(|c| 10_000 + (r as i32) * 100 + c as i32)
                    .collect()
            })
            .collect();
        let mut changed = base.clone();

        let src = (2usize, 2usize);
        let dst = (8usize, 6usize);
        let size = (2usize, 3usize);

        for dr in 0..size.0 {
            for dc in 0..size.1 {
                let src_r = src.0 + dr;
                let src_c = src.1 + dc;
                let dst_r = dst.0 + dr;
                let dst_c = dst.1 + dc;

                let src_val = base[src_r][src_c];
                let dst_val = base[dst_r][dst_c];

                changed[dst_r][dst_c] = src_val;
                changed[src_r][src_c] = dst_val;
            }
        }

        changed[0][0] = 77_777;

        let old = grid_from_matrix(&base);
        let new = grid_from_matrix(&changed);
        let old_mask = RegionMask::all_active(old.nrows, old.ncols);
        let new_mask = RegionMask::all_active(new.nrows, new.ncols);

        let mv = detect_exact_rect_block_move_masked(
            &old,
            &new,
            &old_mask,
            &new_mask,
            &DiffConfig::default(),
        )
        .expect("masked detector should fall back and still detect the move");

        assert_eq!(mv.src_start_row, src.0 as u32);
        assert_eq!(mv.src_start_col, src.1 as u32);
        assert_eq!(mv.src_row_count, size.0 as u32);
        assert_eq!(mv.src_col_count, size.1 as u32);
        assert_eq!(mv.dst_start_row, dst.0 as u32);
        assert_eq!(mv.dst_start_col, dst.1 as u32);
    }
}

```

---

### File: `core\src\engine\workbook_diff.rs`

```rust
use crate::config::DiffConfig;
use crate::diff::{DiffError, DiffOp, DiffReport, DiffSummary};
#[cfg(feature = "perf-metrics")]
use crate::perf::{DiffMetrics, Phase};
use crate::sink::{DiffSink, VecSink};
use crate::string_pool::StringPool;
use crate::workbook::{Sheet, SheetKind, Workbook};
use crate::progress::ProgressCallback;

use std::collections::HashMap;

use super::context::DiffContext;
use super::grid_diff::try_diff_grids;
use super::hardening::HardeningController;
use super::{SheetId, emit_op};

#[derive(Debug, Clone, PartialEq, Eq, Hash)]
struct SheetKey {
    name_lower: String,
    kind: SheetKind,
}

fn make_sheet_key(sheet: &Sheet, pool: &StringPool) -> SheetKey {
    SheetKey {
        name_lower: pool.resolve(sheet.name).to_lowercase(),
        kind: sheet.kind.clone(),
    }
}

fn sheet_kind_order(kind: &SheetKind) -> u8 {
    match kind {
        SheetKind::Worksheet => 0,
        SheetKind::Chart => 1,
        SheetKind::Macro => 2,
        SheetKind::Other => 3,
    }
}

pub fn diff_workbooks(
    old: &Workbook,
    new: &Workbook,
    pool: &mut StringPool,
    config: &DiffConfig,
) -> DiffReport {
    match try_diff_workbooks(old, new, pool, config) {
        Ok(report) => report,
        Err(e) => {
            let strings = pool.strings().to_vec();
            DiffReport {
                version: DiffReport::SCHEMA_VERSION.to_string(),
                strings,
                ops: Vec::new(),
                complete: false,
                warnings: vec![e.to_string()],
                #[cfg(feature = "perf-metrics")]
                metrics: None,
            }
        }
    }
}

pub fn diff_workbooks_with_progress(
    old: &Workbook,
    new: &Workbook,
    pool: &mut StringPool,
    config: &DiffConfig,
    progress: &dyn ProgressCallback,
) -> DiffReport {
    match try_diff_workbooks_with_progress(old, new, pool, config, progress) {
        Ok(report) => report,
        Err(e) => {
            let strings = pool.strings().to_vec();
            DiffReport {
                version: DiffReport::SCHEMA_VERSION.to_string(),
                strings,
                ops: Vec::new(),
                complete: false,
                warnings: vec![e.to_string()],
                #[cfg(feature = "perf-metrics")]
                metrics: None,
            }
        }
    }
}

pub fn diff_workbooks_streaming<S: DiffSink>(
    old: &Workbook,
    new: &Workbook,
    pool: &mut StringPool,
    config: &DiffConfig,
    sink: &mut S,
) -> DiffSummary {
    match try_diff_workbooks_streaming(old, new, pool, config, sink) {
        Ok(summary) => summary,
        Err(e) => DiffSummary {
            complete: false,
            warnings: vec![e.to_string()],
            op_count: 0,
            #[cfg(feature = "perf-metrics")]
            metrics: None,
        },
    }
}

pub fn diff_workbooks_streaming_with_progress<S: DiffSink>(
    old: &Workbook,
    new: &Workbook,
    pool: &mut StringPool,
    config: &DiffConfig,
    sink: &mut S,
    progress: &dyn ProgressCallback,
) -> DiffSummary {
    match try_diff_workbooks_streaming_with_progress(old, new, pool, config, sink, progress) {
        Ok(summary) => summary,
        Err(e) => DiffSummary {
            complete: false,
            warnings: vec![e.to_string()],
            op_count: 0,
            #[cfg(feature = "perf-metrics")]
            metrics: None,
        },
    }
}

pub fn try_diff_workbooks(
    old: &Workbook,
    new: &Workbook,
    pool: &mut StringPool,
    config: &DiffConfig,
) -> Result<DiffReport, DiffError> {
    let mut sink = VecSink::new();
    let summary = try_diff_workbooks_streaming(old, new, pool, config, &mut sink)?;
    let strings = pool.strings().to_vec();
    Ok(DiffReport::from_ops_and_summary(
        sink.into_ops(),
        summary,
        strings,
    ))
}

pub fn try_diff_workbooks_with_progress(
    old: &Workbook,
    new: &Workbook,
    pool: &mut StringPool,
    config: &DiffConfig,
    progress: &dyn ProgressCallback,
) -> Result<DiffReport, DiffError> {
    let mut sink = VecSink::new();
    let summary =
        try_diff_workbooks_streaming_with_progress(old, new, pool, config, &mut sink, progress)?;
    let strings = pool.strings().to_vec();
    Ok(DiffReport::from_ops_and_summary(
        sink.into_ops(),
        summary,
        strings,
    ))
}

pub fn try_diff_workbooks_streaming<S: DiffSink>(
    old: &Workbook,
    new: &Workbook,
    pool: &mut StringPool,
    config: &DiffConfig,
    sink: &mut S,
) -> Result<DiffSummary, DiffError> {
    try_diff_workbooks_streaming_impl(old, new, pool, config, sink, None)
}

pub fn try_diff_workbooks_streaming_with_progress<S: DiffSink>(
    old: &Workbook,
    new: &Workbook,
    pool: &mut StringPool,
    config: &DiffConfig,
    sink: &mut S,
    progress: &dyn ProgressCallback,
) -> Result<DiffSummary, DiffError> {
    try_diff_workbooks_streaming_impl(old, new, pool, config, sink, Some(progress))
}

fn try_diff_workbooks_streaming_impl<'p, S: DiffSink>(
    old: &Workbook,
    new: &Workbook,
    pool: &mut StringPool,
    config: &DiffConfig,
    sink: &mut S,
    progress: Option<&'p dyn ProgressCallback>,
) -> Result<DiffSummary, DiffError> {
    let mut hardening = HardeningController::new(config, progress);
    hardening.progress("parse", 0.0);

    sink.begin(pool)?;

    let mut ctx = DiffContext::default();
    let mut op_count = 0usize;
    #[cfg(feature = "perf-metrics")]
    let mut metrics = {
        let mut m = DiffMetrics::default();
        m.start_phase(Phase::Total);
        m
    };

    if hardening.check_timeout(&mut ctx.warnings) {
        sink.finish()?;
        return Ok(DiffSummary {
            complete: false,
            warnings: ctx.warnings,
            op_count,
            #[cfg(feature = "perf-metrics")]
            metrics: Some(metrics),
        });
    }

    let mut old_sheets: HashMap<SheetKey, &Sheet> = HashMap::new();
    for sheet in &old.sheets {
        let key = make_sheet_key(sheet, pool);
        if let Some(previous) = old_sheets.insert(key.clone(), sheet) {
            ctx.warnings.push(format!(
                "duplicate sheet identity in old workbook: '{}' ({:?}); \
                 later definition '{}' overwrites earlier one '{}'. The file may be corrupt.",
                key.name_lower,
                key.kind,
                pool.resolve(sheet.name),
                pool.resolve(previous.name)
            ));
        }
    }

    let mut new_sheets: HashMap<SheetKey, &Sheet> = HashMap::new();
    for sheet in &new.sheets {
        let key = make_sheet_key(sheet, pool);
        if let Some(previous) = new_sheets.insert(key.clone(), sheet) {
            ctx.warnings.push(format!(
                "duplicate sheet identity in new workbook: '{}' ({:?}); \
                 later definition '{}' overwrites earlier one '{}'. The file may be corrupt.",
                key.name_lower,
                key.kind,
                pool.resolve(sheet.name),
                pool.resolve(previous.name)
            ));
        }
    }

    let mut all_keys: Vec<SheetKey> = old_sheets
        .keys()
        .chain(new_sheets.keys())
        .cloned()
        .collect();
    all_keys.sort_by(|a, b| match a.name_lower.cmp(&b.name_lower) {
        std::cmp::Ordering::Equal => sheet_kind_order(&a.kind).cmp(&sheet_kind_order(&b.kind)),
        other => other,
    });
    all_keys.dedup();

    hardening.progress("parse", 1.0);

    for key in all_keys {
        if hardening.check_timeout(&mut ctx.warnings) {
            break;
        }

        match (old_sheets.get(&key), new_sheets.get(&key)) {
            (None, Some(new_sheet)) => {
                emit_op(
                    sink,
                    &mut op_count,
                    DiffOp::SheetAdded {
                        sheet: new_sheet.name,
                    },
                )?;
            }
            (Some(old_sheet), None) => {
                emit_op(
                    sink,
                    &mut op_count,
                    DiffOp::SheetRemoved {
                        sheet: old_sheet.name,
                    },
                )?;
            }
            (Some(old_sheet), Some(new_sheet)) => {
                let sheet_id: SheetId = old_sheet.name;
                try_diff_grids(
                    sheet_id,
                    &old_sheet.grid,
                    &new_sheet.grid,
                    config,
                    pool,
                    sink,
                    &mut op_count,
                    &mut ctx,
                    &mut hardening,
                    #[cfg(feature = "perf-metrics")]
                    Some(&mut metrics),
                )?;
                if hardening.should_abort() {
                    break;
                }
            }
            (None, None) => {
                debug_assert!(false, "sheet key in all_keys but not in either map");
                continue;
            }
        }
    }

    #[cfg(feature = "perf-metrics")]
    {
        metrics.end_phase(Phase::Total);
    }
    sink.finish()?;
    let complete = ctx.warnings.is_empty();
    Ok(DiffSummary {
        complete,
        warnings: ctx.warnings,
        op_count,
        #[cfg(feature = "perf-metrics")]
        metrics: Some(metrics),
    })
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn sheet_kind_order_ranking_includes_macro_and_other() {
        assert!(
            sheet_kind_order(&SheetKind::Worksheet) < sheet_kind_order(&SheetKind::Chart),
            "Worksheet should rank before Chart"
        );
        assert!(
            sheet_kind_order(&SheetKind::Chart) < sheet_kind_order(&SheetKind::Macro),
            "Chart should rank before Macro"
        );
        assert!(
            sheet_kind_order(&SheetKind::Macro) < sheet_kind_order(&SheetKind::Other),
            "Macro should rank before Other"
        );
    }
}

```

---

### File: `core\src\error_codes.rs`

```rust
pub const PKG_NOT_ZIP: &str = "EXDIFF_PKG_001";
pub const PKG_NOT_OPC: &str = "EXDIFF_PKG_002";
pub const PKG_MISSING_PART: &str = "EXDIFF_PKG_003";
pub const PKG_INVALID_XML: &str = "EXDIFF_PKG_004";
pub const PKG_ZIP_PART_TOO_LARGE: &str = "EXDIFF_PKG_005";
pub const PKG_ZIP_TOO_MANY_ENTRIES: &str = "EXDIFF_PKG_006";
pub const PKG_ZIP_TOTAL_TOO_LARGE: &str = "EXDIFF_PKG_007";
pub const PKG_ZIP_READ: &str = "EXDIFF_PKG_008";
pub const PKG_UNSUPPORTED_FORMAT: &str = "EXDIFF_PKG_009";

pub const GRID_XML_ERROR: &str = "EXDIFF_GRID_001";
pub const GRID_INVALID_ADDRESS: &str = "EXDIFF_GRID_002";
pub const GRID_SHARED_STRING_OOB: &str = "EXDIFF_GRID_003";

pub const CONTAINER_IO: &str = "EXDIFF_CTR_001";
pub const CONTAINER_ZIP: &str = "EXDIFF_CTR_002";
pub const CONTAINER_NOT_ZIP: &str = "EXDIFF_CTR_003";
pub const CONTAINER_NOT_OPC: &str = "EXDIFF_CTR_004";
pub const CONTAINER_TOO_MANY_ENTRIES: &str = "EXDIFF_CTR_005";
pub const CONTAINER_PART_TOO_LARGE: &str = "EXDIFF_CTR_006";
pub const CONTAINER_TOTAL_TOO_LARGE: &str = "EXDIFF_CTR_007";

pub const DM_BASE64_INVALID: &str = "EXDIFF_DM_001";
pub const DM_UNSUPPORTED_VERSION: &str = "EXDIFF_DM_002";
pub const DM_FRAMING_INVALID: &str = "EXDIFF_DM_003";
pub const DM_XML_ERROR: &str = "EXDIFF_DM_004";
pub const DM_INNER_PART_TOO_LARGE: &str = "EXDIFF_DM_005";
pub const DM_INVALID_HEADER: &str = "EXDIFF_DM_006";
pub const DM_INNER_TOO_MANY_ENTRIES: &str = "EXDIFF_DM_007";
pub const DM_INNER_TOTAL_TOO_LARGE: &str = "EXDIFF_DM_008";

pub const DIFF_LIMITS_EXCEEDED: &str = "EXDIFF_DIFF_001";
pub const DIFF_SINK_ERROR: &str = "EXDIFF_DIFF_002";
pub const DIFF_SHEET_NOT_FOUND: &str = "EXDIFF_DIFF_003";
pub const DIFF_INTERNAL_ERROR: &str = "EXDIFF_DIFF_004";


```

---

### File: `core\src\excel_open_xml.rs`

```rust
//! Excel Open XML file parsing.
//!
//! Provides functions for opening `.xlsx` files and parsing their contents into
//! the internal representation used for diffing.

use crate::container::{ContainerError, OpcContainer};
use crate::datamashup_framing::{
    DataMashupError, RawDataMashup, decode_datamashup_base64, parse_data_mashup,
    read_datamashup_text,
};
use crate::error_codes;
use crate::grid_parser::{
    GridParseError, parse_defined_names, parse_relationships, parse_relationships_all,
    parse_shared_strings, parse_sheet_xml, parse_workbook_xml, resolve_sheet_target,
};
use crate::package::VbaModule;
#[cfg(feature = "vba")]
use crate::package::VbaModuleType;
use crate::string_pool::StringId;
use crate::string_pool::StringPool;
use crate::workbook::{ChartInfo, ChartObject, Sheet, SheetKind, Workbook};
use std::collections::HashMap;
#[cfg(feature = "std-fs")]
use std::path::Path;
use thiserror::Error;
use xxhash_rust::xxh3::Xxh3;

#[derive(Debug, Error)]
#[non_exhaustive]
pub enum PackageError {
    #[error("{0}")]
    Container(#[from] ContainerError),
    #[error("{0}")]
    GridParse(#[from] GridParseError),
    #[error("{0}")]
    DataMashup(#[from] DataMashupError),
    #[error("[EXDIFF_PKG_003] workbook.xml missing or unreadable. Suggestion: re-save the file in Excel or verify it is a valid .xlsx.")]
    WorkbookXmlMissing,
    #[error("[EXDIFF_PKG_003] worksheet XML missing for sheet {sheet_name}. Suggestion: re-save the file in Excel or verify it is a valid .xlsx.")]
    WorksheetXmlMissing { sheet_name: String },
    #[error("{0}")]
    Diff(#[from] crate::diff::DiffError),
    #[error("[EXDIFF_PKG_009] serialization error: {0}. Suggestion: verify the workbook is a standard .xlsx saved by Excel.")]
    SerializationError(String),

    #[error("[EXDIFF_PKG_001] not a valid ZIP file: {message}. Suggestion: verify the input is a .xlsx workbook.")]
    NotAZip { message: String },

    #[error("[EXDIFF_PKG_003] missing required part: {path}. Suggestion: the workbook may be corrupt; re-save the file in Excel.")]
    MissingPart { path: String },

    #[error("[EXDIFF_PKG_004] invalid XML in '{part}' at line {line}, column {column}: {message}. Suggestion: re-save the file in Excel.")]
    InvalidXml {
        part: String,
        line: usize,
        column: usize,
        message: String,
    },

    #[error("[EXDIFF_PKG_009] unsupported format: {message}. Suggestion: verify the workbook is a standard .xlsx saved by Excel.")]
    UnsupportedFormat { message: String },

    #[error("[EXDIFF_PKG_008] failed to read part '{part}': {message}")]
    ReadPartFailed { part: String, message: String },

    #[error("{source} (in part '{part}')")]
    DataMashupPartError { part: String, source: DataMashupError },

    #[error("[{path}] {source}")]
    WithPath {
        path: String,
        #[source]
        source: Box<PackageError>,
    },
}

impl PackageError {
    pub fn code(&self) -> &'static str {
        match self {
            PackageError::Container(e) => e.code(),
            PackageError::GridParse(e) => e.code(),
            PackageError::DataMashup(e) => e.code(),
            PackageError::WorkbookXmlMissing => error_codes::PKG_MISSING_PART,
            PackageError::WorksheetXmlMissing { .. } => error_codes::PKG_MISSING_PART,
            PackageError::Diff(_) => error_codes::DIFF_INTERNAL_ERROR,
            PackageError::SerializationError(_) => error_codes::PKG_UNSUPPORTED_FORMAT,
            PackageError::NotAZip { .. } => error_codes::PKG_NOT_ZIP,
            PackageError::MissingPart { .. } => error_codes::PKG_MISSING_PART,
            PackageError::InvalidXml { .. } => error_codes::PKG_INVALID_XML,
            PackageError::UnsupportedFormat { .. } => error_codes::PKG_UNSUPPORTED_FORMAT,
            PackageError::ReadPartFailed { .. } => error_codes::PKG_ZIP_READ,
            PackageError::DataMashupPartError { source, .. } => source.code(),
            PackageError::WithPath { source, .. } => source.code(),
        }
    }

    pub fn with_path(self, path: impl Into<String>) -> Self {
        PackageError::WithPath {
            path: path.into(),
            source: Box::new(self),
        }
    }
}

#[deprecated(note = "use PackageError")]
pub type ExcelOpenError = PackageError;

pub(crate) fn open_workbook_from_container(
    container: &mut OpcContainer,
    pool: &mut StringPool,
) -> Result<Workbook, PackageError> {
    let shared_strings = match container.read_file_optional_checked("xl/sharedStrings.xml")? {
        Some(bytes) => parse_shared_strings(&bytes, pool).map_err(|e| {
            wrap_grid_parse_error(e, "xl/sharedStrings.xml")
        })?,
        None => Vec::new(),
    };

    let workbook_bytes = container
        .read_file_checked("xl/workbook.xml")
        .map_err(|e| match e {
            ContainerError::FileNotFound { .. } => PackageError::MissingPart {
                path: "xl/workbook.xml".to_string(),
            },
            other => PackageError::ReadPartFailed {
                part: "xl/workbook.xml".to_string(),
                message: other.to_string(),
            },
        })?;

    let sheets = parse_workbook_xml(&workbook_bytes)
        .map_err(|e| wrap_grid_parse_error(e, "xl/workbook.xml"))?;

    let named_ranges = parse_defined_names(&workbook_bytes, &sheets, pool)
        .map_err(|e| wrap_grid_parse_error(e, "xl/workbook.xml"))?;

    let relationships = match container.read_file_optional_checked("xl/_rels/workbook.xml.rels")? {
        Some(bytes) => parse_relationships(&bytes)
            .map_err(|e| wrap_grid_parse_error(e, "xl/_rels/workbook.xml.rels"))?,
        None => HashMap::new(),
    };

    let mut charts: Vec<ChartObject> = Vec::new();
    let mut chart_parts: HashMap<String, ChartPartCacheEntry> = HashMap::new();

    let mut sheet_ir = Vec::with_capacity(sheets.len());
    for (idx, sheet) in sheets.iter().enumerate() {
        let target = resolve_sheet_target(sheet, &relationships, idx);
        let sheet_bytes = container.read_file_checked(&target).map_err(|e| match e {
            ContainerError::FileNotFound { .. } => PackageError::MissingPart {
                path: target.clone(),
            },
            other => PackageError::ReadPartFailed {
                part: target.clone(),
                message: other.to_string(),
            },
        })?;

        let sheet_name_id = pool.intern(&sheet.name);

        let grid = parse_sheet_xml(&sheet_bytes, &shared_strings, pool)
            .map_err(|e| wrap_grid_parse_error(e, &target))?;
        sheet_ir.push(Sheet {
            name: sheet_name_id,
            kind: SheetKind::Worksheet,
            grid,
        });

        let drawing_rids = match parse_worksheet_drawing_rids(&sheet_bytes) {
            Ok(rids) => rids,
            Err(_) => continue,
        };
        for drawing_rid in drawing_rids {
            let sheet_rels_path = rels_part_path(&target);
            let sheet_rels_bytes = match read_optional_part(container, &sheet_rels_path)? {
                Some(bytes) => bytes,
                None => continue,
            };
            let sheet_rels = parse_relationships_all(&sheet_rels_bytes)
                .map_err(|e| wrap_grid_parse_error(e, &sheet_rels_path))?;
            let Some(drawing_target) = sheet_rels.get(&drawing_rid) else {
                continue;
            };
            let drawing_part_path = resolve_target_against_part(&target, drawing_target);

            let drawing_bytes = match read_optional_part(container, &drawing_part_path)? {
                Some(bytes) => bytes,
                None => continue,
            };
            let drawing_chart_refs = parse_drawing_chart_refs(&drawing_bytes)
                .map_err(|e| wrap_grid_parse_error(e, &drawing_part_path))?;
            if drawing_chart_refs.is_empty() {
                continue;
            }

            let drawing_rels_path = rels_part_path(&drawing_part_path);
            let drawing_rels_bytes = match read_optional_part(container, &drawing_rels_path)? {
                Some(bytes) => bytes,
                None => continue,
            };
            let drawing_rels = parse_relationships_all(&drawing_rels_bytes)
                .map_err(|e| wrap_grid_parse_error(e, &drawing_rels_path))?;

            for chart_ref in drawing_chart_refs {
                let Some(chart_target) = drawing_rels.get(&chart_ref.rel_id) else {
                    continue;
                };
                let chart_part_path = resolve_target_against_part(&drawing_part_path, chart_target);
                let chart_bytes = match read_optional_part(container, &chart_part_path)? {
                    Some(bytes) => bytes,
                    None => continue,
                };

                let entry = match chart_parts.get(&chart_part_path) {
                    Some(entry) => entry.clone(),
                    None => {
                        let xml_hash = hash_xml_part(&chart_bytes);
                        let (chart_type, data_range) =
                            parse_chart_part_metadata(&chart_bytes, pool)
                                .map_err(|e| wrap_grid_parse_error(e, &chart_part_path))?;
                        let entry = ChartPartCacheEntry {
                            xml_hash,
                            chart_type,
                            data_range,
                        };
                        chart_parts.insert(chart_part_path.clone(), entry.clone());
                        entry
                    }
                };

                let name = match chart_ref.name {
                    Some(name) => name,
                    None => fallback_chart_name_from_path(&chart_part_path),
                };

                charts.push(ChartObject {
                    sheet: sheet_name_id,
                    info: ChartInfo {
                        name: pool.intern(&name),
                        chart_type: entry.chart_type,
                        data_range: entry.data_range,
                    },
                    xml_hash: entry.xml_hash,
                });
            }
        }
    }

    Ok(Workbook {
        sheets: sheet_ir,
        named_ranges,
        charts,
    })
}

#[cfg(feature = "vba")]
pub(crate) fn open_vba_modules_from_container(
    container: &mut OpcContainer,
    pool: &mut StringPool,
) -> Result<Option<Vec<VbaModule>>, PackageError> {
    let bytes = match container.read_file_optional_checked("xl/vbaProject.bin")? {
        Some(bytes) => bytes,
        None => return Ok(None),
    };

    let project = ovba::open_project(bytes).map_err(|e| PackageError::UnsupportedFormat {
        message: format!("failed to parse xl/vbaProject.bin: {e}"),
    })?;

    let mut modules = Vec::with_capacity(project.modules.len());
    for module in &project.modules {
        let name = pool.intern(&module.name);
        let module_type = match module.module_type {
            ovba::ModuleType::Procedural => VbaModuleType::Standard,
            ovba::ModuleType::DocClsDesigner => VbaModuleType::Document,
        };

        let code = match project.module_source(&module.name) {
            Ok(code) => code,
            Err(_) => match project.module_source_raw(&module.name) {
                Ok(raw) => String::from_utf8_lossy(&raw).into_owned(),
                Err(_) => String::new(),
            },
        };

        modules.push(VbaModule {
            name,
            module_type,
            code,
        });
    }

    Ok(Some(modules))
}

#[cfg(not(feature = "vba"))]
pub(crate) fn open_vba_modules_from_container(
    _container: &mut OpcContainer,
    _pool: &mut StringPool,
) -> Result<Option<Vec<VbaModule>>, PackageError> {
    Ok(None)
}

#[derive(Debug, Clone)]
struct ChartPartCacheEntry {
    xml_hash: u128,
    chart_type: StringId,
    data_range: Option<StringId>,
}

#[derive(Debug, Clone)]
struct DrawingChartRef {
    rel_id: String,
    name: Option<String>,
}

fn read_optional_part(
    container: &mut OpcContainer,
    path: &str,
) -> Result<Option<Vec<u8>>, PackageError> {
    container
        .read_file_optional_checked(path)
        .map_err(|e| PackageError::ReadPartFailed {
            part: path.to_string(),
            message: e.to_string(),
        })
}

fn rels_part_path(part_path: &str) -> String {
    let part_path = part_path.trim_start_matches('/');
    let (dir, file) = match part_path.rsplit_once('/') {
        Some((dir, file)) => (dir, file),
        None => ("", part_path),
    };

    if dir.is_empty() {
        format!("_rels/{file}.rels")
    } else {
        format!("{dir}/_rels/{file}.rels")
    }
}

fn resolve_target_against_part(base_part: &str, target: &str) -> String {
    let target = target.trim();
    if let Some(rest) = target.strip_prefix('/') {
        return normalize_part_path(rest);
    }
    if target.starts_with("xl/") {
        return normalize_part_path(target);
    }

    let base_part = base_part.trim_start_matches('/');
    let base_dir = base_part.rsplit_once('/').map(|(dir, _)| dir).unwrap_or("");
    if base_dir.is_empty() {
        normalize_part_path(target)
    } else {
        normalize_part_path(&format!("{base_dir}/{target}"))
    }
}

fn normalize_part_path(path: &str) -> String {
    let mut stack: Vec<&str> = Vec::new();
    for seg in path.split('/') {
        match seg {
            "" | "." => {}
            ".." => {
                let _ = stack.pop();
            }
            other => stack.push(other),
        }
    }
    stack.join("/")
}

fn local_name(name: &[u8]) -> &[u8] {
    name.rsplit(|&b| b == b':').next().unwrap_or(name)
}

fn parse_worksheet_drawing_rids(xml: &[u8]) -> Result<Vec<String>, GridParseError> {
    let mut reader = quick_xml::Reader::from_reader(xml);
    reader.config_mut().trim_text(true);
    let mut buf = Vec::new();
    let mut rids = Vec::new();

    loop {
        match reader.read_event_into(&mut buf) {
            Ok(quick_xml::events::Event::Start(e))
            | Ok(quick_xml::events::Event::Empty(e))
                if local_name(e.name().as_ref()) == b"drawing" =>
            {
                for attr in e.attributes() {
                    let attr = attr.map_err(|e| GridParseError::XmlError(e.to_string()))?;
                    if attr.key.as_ref() == b"r:id" {
                        let rid = attr
                            .unescape_value()
                            .map_err(|e| GridParseError::XmlError(e.to_string()))?
                            .into_owned();
                        rids.push(rid);
                    }
                }
            }
            Ok(quick_xml::events::Event::Eof) => break,
            Err(e) => return Err(GridParseError::XmlError(e.to_string())),
            _ => {}
        }
        buf.clear();
    }

    Ok(rids)
}

fn parse_drawing_chart_refs(drawing_xml: &[u8]) -> Result<Vec<DrawingChartRef>, GridParseError> {
    let mut reader = quick_xml::Reader::from_reader(drawing_xml);
    reader.config_mut().trim_text(true);
    let mut buf = Vec::new();
    let mut refs = Vec::new();
    let mut pending_name: Option<String> = None;

    loop {
        match reader.read_event_into(&mut buf) {
            Ok(quick_xml::events::Event::Start(e))
            | Ok(quick_xml::events::Event::Empty(e)) => {
                let name = e.name();
                let tag = local_name(name.as_ref());
                if tag == b"cNvPr" {
                    for attr in e.attributes() {
                        let attr = attr.map_err(|e| GridParseError::XmlError(e.to_string()))?;
                        if attr.key.as_ref() == b"name" {
                            pending_name = Some(
                                attr.unescape_value()
                                    .map_err(|e| GridParseError::XmlError(e.to_string()))?
                                    .into_owned(),
                            );
                        }
                    }
                } else if tag == b"chart" {
                    let mut rel_id = None;
                    for attr in e.attributes() {
                        let attr = attr.map_err(|e| GridParseError::XmlError(e.to_string()))?;
                        if attr.key.as_ref() == b"r:id" {
                            rel_id = Some(
                                attr.unescape_value()
                                    .map_err(|e| GridParseError::XmlError(e.to_string()))?
                                    .into_owned(),
                            );
                        }
                    }
                    if let Some(rel_id) = rel_id {
                        refs.push(DrawingChartRef {
                            rel_id,
                            name: pending_name.take(),
                        });
                    }
                }
            }
            Ok(quick_xml::events::Event::Eof) => break,
            Err(e) => return Err(GridParseError::XmlError(e.to_string())),
            _ => {}
        }
        buf.clear();
    }

    Ok(refs)
}

fn parse_chart_part_metadata(
    chart_xml: &[u8],
    pool: &mut StringPool,
) -> Result<(StringId, Option<StringId>), GridParseError> {
    let mut reader = quick_xml::Reader::from_reader(chart_xml);
    reader.config_mut().trim_text(true);
    let mut buf = Vec::new();

    let mut chart_type: Option<String> = None;
    let mut data_range: Option<String> = None;

    loop {
        match reader.read_event_into(&mut buf) {
            Ok(quick_xml::events::Event::Start(e))
                if local_name(e.name().as_ref()) == b"f" && data_range.is_none() =>
            {
                let text = reader
                    .read_text(e.name())
                    .map_err(|e| GridParseError::XmlError(e.to_string()))?
                    .into_owned();
                let trimmed = text.trim();
                if !trimmed.is_empty() {
                    data_range = Some(trimmed.to_string());
                }
            }
            Ok(quick_xml::events::Event::Start(e)) | Ok(quick_xml::events::Event::Empty(e)) => {
                let name = e.name();
                let tag = local_name(name.as_ref());
                if chart_type.is_none() && tag.ends_with(b"Chart") {
                    chart_type = Some(String::from_utf8_lossy(tag).to_string());
                }
            }
            Ok(quick_xml::events::Event::Eof) => break,
            Err(e) => return Err(GridParseError::XmlError(e.to_string())),
            _ => {}
        }
        buf.clear();
    }

    let chart_type_id = pool.intern(chart_type.as_deref().unwrap_or("unknown"));
    let data_range_id = data_range.as_deref().map(|s| pool.intern(s));
    Ok((chart_type_id, data_range_id))
}

fn fallback_chart_name_from_path(chart_part_path: &str) -> String {
    let file = chart_part_path
        .rsplit('/')
        .next()
        .unwrap_or(chart_part_path);
    file.strip_suffix(".xml").unwrap_or(file).to_string()
}

fn hash_xml_part(xml: &[u8]) -> u128 {
    let mut hasher = Xxh3::new();
    hasher.update(xml);
    hasher.digest128()
}

fn wrap_grid_parse_error(err: GridParseError, part: &str) -> PackageError {
    match err {
        GridParseError::XmlErrorAt { line, column, message } => PackageError::InvalidXml {
            part: part.to_string(),
            line,
            column,
            message,
        },
        GridParseError::XmlError(msg) => PackageError::InvalidXml {
            part: part.to_string(),
            line: 0,
            column: 0,
            message: msg,
        },
        GridParseError::InvalidAddress(addr) => PackageError::UnsupportedFormat {
            message: format!("invalid cell address '{}' in {}", addr, part),
        },
        GridParseError::SharedStringOutOfBounds(idx) => PackageError::UnsupportedFormat {
            message: format!(
                "shared string index {} out of bounds while parsing {}",
                idx, part
            ),
        },
    }
}

#[cfg(feature = "std-fs")]
#[allow(deprecated)]
pub fn open_workbook(
    path: impl AsRef<Path>,
    pool: &mut StringPool,
) -> Result<Workbook, PackageError> {
    let path_str = path.as_ref().display().to_string();
    let mut container = OpcContainer::open_from_path(path.as_ref())
        .map_err(|e| PackageError::from(e).with_path(&path_str))?;
    open_workbook_from_container(&mut container, pool)
        .map_err(|e| e.with_path(&path_str))
}

#[cfg(feature = "std-fs")]
#[allow(deprecated)]
pub fn open_vba_modules(
    path: impl AsRef<Path>,
    pool: &mut StringPool,
) -> Result<Option<Vec<VbaModule>>, PackageError> {
    let path_str = path.as_ref().display().to_string();
    let mut container = OpcContainer::open_from_path(path.as_ref())
        .map_err(|e| PackageError::from(e).with_path(&path_str))?;
    open_vba_modules_from_container(&mut container, pool).map_err(|e| e.with_path(&path_str))
}

pub(crate) fn open_data_mashup_from_container(
    container: &mut OpcContainer,
) -> Result<Option<RawDataMashup>, PackageError> {
    let mut found: Option<RawDataMashup> = None;

    for i in 0..container.len() {
        let name = {
            let file = container.archive.by_index(i).ok();
            file.map(|f| f.name().to_string())
        };

        if let Some(name) = name {
            if !name.starts_with("customXml/") || !name.ends_with(".xml") {
                continue;
            }

            let bytes = container
                .read_file_checked(&name)
                .map_err(|e| PackageError::ReadPartFailed {
                    part: name.clone(),
                    message: e.to_string(),
                })?;

            match read_datamashup_text(&bytes) {
                Ok(Some(text)) => {
                    let decoded = decode_datamashup_base64(&text).map_err(|e| {
                        PackageError::DataMashupPartError {
                            part: name.clone(),
                            source: e,
                        }
                    })?;
                    let parsed = parse_data_mashup(&decoded).map_err(|e| {
                        PackageError::DataMashupPartError {
                            part: name.clone(),
                            source: e,
                        }
                    })?;
                    if found.is_some() {
                        return Err(PackageError::DataMashupPartError {
                            part: name,
                            source: DataMashupError::FramingInvalid,
                        });
                    }
                    found = Some(parsed);
                }
                Ok(None) => {}
                Err(e) => {
                    return Err(PackageError::DataMashupPartError {
                        part: name,
                        source: e,
                    });
                }
            }
        }
    }

    Ok(found)
}

#[cfg(feature = "std-fs")]
#[allow(deprecated)]
pub fn open_data_mashup(path: impl AsRef<Path>) -> Result<Option<RawDataMashup>, PackageError> {
    let path_str = path.as_ref().display().to_string();
    let mut container = OpcContainer::open_from_path(path.as_ref())
        .map_err(|e| PackageError::from(e).with_path(&path_str))?;
    open_data_mashup_from_container(&mut container)
        .map_err(|e| e.with_path(&path_str))
}

```

---

### File: `core\src\formula.rs`

```rust
use std::fmt;

#[derive(Debug, Clone, PartialEq)]
pub enum FormulaExpr {
    Number(f64),
    Text(String),
    Boolean(bool),
    Error(ExcelError),

    CellRef(CellReference),
    RangeRef(RangeReference),

    NamedRef(String),

    FunctionCall {
        name: String,
        args: Vec<FormulaExpr>,
    },

    UnaryOp {
        op: UnaryOperator,
        operand: Box<FormulaExpr>,
    },

    BinaryOp {
        op: BinaryOperator,
        left: Box<FormulaExpr>,
        right: Box<FormulaExpr>,
    },

    Array(Vec<Vec<FormulaExpr>>),
}

#[derive(Debug, Clone, PartialEq, Eq)]
pub enum ExcelError {
    Null,
    Div0,
    Value,
    Ref,
    Name,
    Num,
    NA,
    Spill,
    Calc,
    GettingData,
    Unknown(String),
}

#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
pub enum RowRef {
    Absolute(u32),
    Relative(u32),
    Offset(i32),
}

#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
pub enum ColRef {
    Absolute(u32),
    Relative(u32),
    Offset(i32),
}

#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct CellReference {
    pub sheet: Option<String>,
    pub row: RowRef,
    pub col: ColRef,
    pub spill: bool,
}

#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct RangeReference {
    pub sheet: Option<String>,
    pub start: CellReference,
    pub end: CellReference,
}

#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
pub enum UnaryOperator {
    Plus,
    Minus,
    Percent,
}

#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
pub enum BinaryOperator {
    Add,
    Sub,
    Mul,
    Div,
    Pow,
    Concat,
    Eq,
    Ne,
    Lt,
    Le,
    Gt,
    Ge,
}

#[derive(Debug, Clone, PartialEq, Eq)]
pub struct FormulaParseError {
    pub pos: usize,
    pub message: String,
}

impl fmt::Display for FormulaParseError {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        write!(f, "formula parse error at {}: {}", self.pos, self.message)
    }
}

impl std::error::Error for FormulaParseError {}

pub fn parse_formula(formula: &str) -> Result<FormulaExpr, FormulaParseError> {
    let s = formula.trim();
    let s = s.strip_prefix('=').unwrap_or(s);
    let mut p = Parser::new(s);
    let expr = p.parse_expr(0)?;
    p.skip_ws();
    if !p.eof() {
        return Err(p.err("trailing characters"));
    }
    Ok(expr)
}

#[derive(Clone, Copy)]
pub(crate) enum ShiftMode {
    RelativeOnly,
    #[cfg(any(test, feature = "dev-apis"))]
    All,
}

impl FormulaExpr {
    pub fn canonicalize(&self) -> FormulaExpr {
        let mut e = self.clone();
        e.canonicalize_in_place();
        e
    }

    pub(crate) fn shifted(&self, row_shift: i32, col_shift: i32, mode: ShiftMode) -> FormulaExpr {
        shift_expr(self, row_shift, col_shift, mode)
    }

    fn canonicalize_in_place(&mut self) {
        match self {
            FormulaExpr::FunctionCall { name, args } => {
                *name = name.to_ascii_uppercase();
                for a in args.iter_mut() {
                    a.canonicalize_in_place();
                }
                if is_commutative_function(name) {
                    args.sort_by_key(|a| canonical_sort_key(a));
                }
            }
            FormulaExpr::NamedRef(name) => {
                *name = name.to_ascii_uppercase();
            }
            FormulaExpr::CellRef(r) => {
                if let Some(s) = &mut r.sheet {
                    *s = s.to_ascii_uppercase();
                }
            }
            FormulaExpr::RangeRef(r) => {
                if let Some(s) = &mut r.sheet {
                    *s = s.to_ascii_uppercase();
                }
                if let Some(s) = &mut r.start.sheet {
                    *s = s.to_ascii_uppercase();
                }
                if let Some(s) = &mut r.end.sheet {
                    *s = s.to_ascii_uppercase();
                }
                let a = ref_sort_key(&r.start);
                let b = ref_sort_key(&r.end);
                if b < a {
                    std::mem::swap(&mut r.start, &mut r.end);
                }
            }
            FormulaExpr::UnaryOp { operand, .. } => {
                operand.canonicalize_in_place();
            }
            FormulaExpr::BinaryOp { op, left, right } => {
                left.canonicalize_in_place();
                right.canonicalize_in_place();
                if is_commutative_binary(*op) {
                    let lk = canonical_sort_key(left);
                    let rk = canonical_sort_key(right);
                    if rk < lk {
                        std::mem::swap(left, right);
                    }
                }
            }
            FormulaExpr::Array(rows) => {
                for row in rows.iter_mut() {
                    for cell in row.iter_mut() {
                        cell.canonicalize_in_place();
                    }
                }
            }
            _ => {}
        }
    }
}

fn is_commutative_function(name: &str) -> bool {
    matches!(name, "SUM" | "PRODUCT" | "MIN" | "MAX" | "AND" | "OR")
}

fn is_commutative_binary(op: BinaryOperator) -> bool {
    matches!(
        op,
        BinaryOperator::Add | BinaryOperator::Mul | BinaryOperator::Eq | BinaryOperator::Ne
    )
}

fn canonical_sort_key(e: &FormulaExpr) -> String {
    format!("{:?}", e.canonicalize())
}

fn ref_sort_key(r: &CellReference) -> (i64, i64, u8, u8) {
    (
        row_key(r.row),
        col_key(r.col),
        abs_key_row(r.row),
        abs_key_col(r.col),
    )
}

fn row_key(r: RowRef) -> i64 {
    match r {
        RowRef::Absolute(n) | RowRef::Relative(n) => n as i64,
        RowRef::Offset(n) => n as i64,
    }
}

fn col_key(c: ColRef) -> i64 {
    match c {
        ColRef::Absolute(n) | ColRef::Relative(n) => n as i64,
        ColRef::Offset(n) => n as i64,
    }
}

fn abs_key_row(r: RowRef) -> u8 {
    match r {
        RowRef::Absolute(_) => 0,
        RowRef::Relative(_) => 1,
        RowRef::Offset(_) => 2,
    }
}

fn abs_key_col(c: ColRef) -> u8 {
    match c {
        ColRef::Absolute(_) => 0,
        ColRef::Relative(_) => 1,
        ColRef::Offset(_) => 2,
    }
}

fn shift_expr(e: &FormulaExpr, row_shift: i32, col_shift: i32, mode: ShiftMode) -> FormulaExpr {
    match e {
        FormulaExpr::CellRef(r) => {
            FormulaExpr::CellRef(shift_cell_ref(r, row_shift, col_shift, mode))
        }
        FormulaExpr::RangeRef(r) => {
            let mut rr = r.clone();
            rr.start = shift_cell_ref(&rr.start, row_shift, col_shift, mode);
            rr.end = shift_cell_ref(&rr.end, row_shift, col_shift, mode);
            FormulaExpr::RangeRef(rr)
        }
        FormulaExpr::FunctionCall { name, args } => FormulaExpr::FunctionCall {
            name: name.clone(),
            args: args
                .iter()
                .map(|a| shift_expr(a, row_shift, col_shift, mode))
                .collect(),
        },
        FormulaExpr::UnaryOp { op, operand } => FormulaExpr::UnaryOp {
            op: *op,
            operand: Box::new(shift_expr(operand, row_shift, col_shift, mode)),
        },
        FormulaExpr::BinaryOp { op, left, right } => FormulaExpr::BinaryOp {
            op: *op,
            left: Box::new(shift_expr(left, row_shift, col_shift, mode)),
            right: Box::new(shift_expr(right, row_shift, col_shift, mode)),
        },
        FormulaExpr::Array(rows) => FormulaExpr::Array(
            rows.iter()
                .map(|row| {
                    row.iter()
                        .map(|x| shift_expr(x, row_shift, col_shift, mode))
                        .collect()
                })
                .collect(),
        ),
        _ => e.clone(),
    }
}

fn shift_cell_ref(
    r: &CellReference,
    row_shift: i32,
    col_shift: i32,
    mode: ShiftMode,
) -> CellReference {
    let mut out = r.clone();
    out.row = shift_row_ref(r.row, row_shift, mode);
    out.col = shift_col_ref(r.col, col_shift, mode);
    out
}

fn shift_row_ref(r: RowRef, delta: i32, mode: ShiftMode) -> RowRef {
    match r {
        RowRef::Relative(n) => RowRef::Relative(shift_u32(n, delta)),
        RowRef::Absolute(n) => match mode {
            ShiftMode::RelativeOnly => RowRef::Absolute(n),
            #[cfg(any(test, feature = "dev-apis"))]
            ShiftMode::All => RowRef::Absolute(shift_u32(n, delta)),
        },
        RowRef::Offset(n) => RowRef::Offset(n),
    }
}

fn shift_col_ref(c: ColRef, delta: i32, mode: ShiftMode) -> ColRef {
    match c {
        ColRef::Relative(n) => ColRef::Relative(shift_u32(n, delta)),
        ColRef::Absolute(n) => match mode {
            ShiftMode::RelativeOnly => ColRef::Absolute(n),
            #[cfg(any(test, feature = "dev-apis"))]
            ShiftMode::All => ColRef::Absolute(shift_u32(n, delta)),
        },
        ColRef::Offset(n) => ColRef::Offset(n),
    }
}

fn shift_u32(n: u32, delta: i32) -> u32 {
    let v = n as i64 + delta as i64;
    if v <= 0 {
        0
    } else if v >= u32::MAX as i64 {
        u32::MAX
    } else {
        v as u32
    }
}

pub fn formulas_equivalent_modulo_shift(
    a: &FormulaExpr,
    b: &FormulaExpr,
    row_shift: i32,
    col_shift: i32,
) -> bool {
    let a_shifted = a
        .shifted(row_shift, col_shift, ShiftMode::RelativeOnly)
        .canonicalize();
    let b_canon = b.canonicalize();
    a_shifted == b_canon
}

struct Parser<'a> {
    s: &'a [u8],
    pos: usize,
}

impl<'a> Parser<'a> {
    fn new(input: &'a str) -> Self {
        Self {
            s: input.as_bytes(),
            pos: 0,
        }
    }

    fn eof(&self) -> bool {
        self.pos >= self.s.len()
    }

    fn peek(&self) -> Option<u8> {
        self.s.get(self.pos).copied()
    }

    fn bump(&mut self) -> Option<u8> {
        let b = self.peek()?;
        self.pos += 1;
        Some(b)
    }

    fn skip_ws(&mut self) {
        while matches!(self.peek(), Some(b' ' | b'\t' | b'\r' | b'\n')) {
            self.pos += 1;
        }
    }

    fn err(&self, msg: &str) -> FormulaParseError {
        FormulaParseError {
            pos: self.pos,
            message: msg.to_string(),
        }
    }

    fn parse_expr(&mut self, min_bp: u8) -> Result<FormulaExpr, FormulaParseError> {
        self.skip_ws();

        let mut lhs = if matches!(self.peek(), Some(b'+' | b'-')) {
            let op_byte = self
                .bump()
                .ok_or_else(|| self.err("unexpected EOF after unary op"))?;
            let op = match op_byte {
                b'+' => UnaryOperator::Plus,
                b'-' => UnaryOperator::Minus,
                _ => return Err(self.err("invalid unary op")),
            };
            let rhs = self.parse_expr(90)?;
            FormulaExpr::UnaryOp {
                op,
                operand: Box::new(rhs),
            }
        } else {
            self.parse_primary()?
        };

        loop {
            self.skip_ws();

            while matches!(self.peek(), Some(b'%')) {
                self.bump();
                lhs = FormulaExpr::UnaryOp {
                    op: UnaryOperator::Percent,
                    operand: Box::new(lhs),
                };
                self.skip_ws();
            }

            let (op, l_bp, r_bp) = match self.peek_infix_op() {
                Some(x) => x,
                None => break,
            };

            if l_bp < min_bp {
                break;
            }

            self.consume_infix_op(op)?;
            let rhs = self.parse_expr(r_bp)?;
            lhs = FormulaExpr::BinaryOp {
                op,
                left: Box::new(lhs),
                right: Box::new(rhs),
            };
        }

        Ok(lhs)
    }

    fn peek_infix_op(&self) -> Option<(BinaryOperator, u8, u8)> {
        let b = self.peek()?;
        match b {
            b'+' => Some((BinaryOperator::Add, 50, 51)),
            b'-' => Some((BinaryOperator::Sub, 50, 51)),
            b'*' => Some((BinaryOperator::Mul, 60, 61)),
            b'/' => Some((BinaryOperator::Div, 60, 61)),
            b'^' => Some((BinaryOperator::Pow, 70, 70)),
            b'&' => Some((BinaryOperator::Concat, 40, 41)),
            b'=' => Some((BinaryOperator::Eq, 30, 31)),
            b'<' => {
                if self.s.get(self.pos + 1) == Some(&b'=') {
                    Some((BinaryOperator::Le, 30, 31))
                } else if self.s.get(self.pos + 1) == Some(&b'>') {
                    Some((BinaryOperator::Ne, 30, 31))
                } else {
                    Some((BinaryOperator::Lt, 30, 31))
                }
            }
            b'>' => {
                if self.s.get(self.pos + 1) == Some(&b'=') {
                    Some((BinaryOperator::Ge, 30, 31))
                } else {
                    Some((BinaryOperator::Gt, 30, 31))
                }
            }
            _ => None,
        }
    }

    fn consume_infix_op(&mut self, op: BinaryOperator) -> Result<(), FormulaParseError> {
        match op {
            BinaryOperator::Le | BinaryOperator::Ge => {
                self.bump();
                if self.bump() != Some(b'=') {
                    return Err(self.err("expected '='"));
                }
            }
            BinaryOperator::Ne => {
                self.bump();
                if self.bump() != Some(b'>') {
                    return Err(self.err("expected '>'"));
                }
            }
            BinaryOperator::Lt | BinaryOperator::Gt => {
                self.bump();
            }
            _ => {
                self.bump();
            }
        }
        Ok(())
    }

    fn parse_primary(&mut self) -> Result<FormulaExpr, FormulaParseError> {
        self.skip_ws();
        match self.peek() {
            Some(b'(') => {
                self.bump();
                let e = self.parse_expr(0)?;
                self.skip_ws();
                if self.bump() != Some(b')') {
                    return Err(self.err("expected ')'"));
                }
                Ok(e)
            }
            Some(b'{') => self.parse_array(),
            Some(b'"') => self.parse_string(),
            Some(b'#') => self.parse_error(),
            Some(b'0'..=b'9') => {
                if self.looks_like_row_range() {
                    return self.parse_row_range(None);
                }
                self.parse_number()
            }
            Some(b'\'' | b'[') => self.parse_ref_or_name_with_optional_sheet(),
            Some(b'$' | b'A'..=b'Z' | b'a'..=b'z' | b'_') => {
                self.parse_ref_or_name_with_optional_sheet()
            }
            _ => Err(self.err("unexpected token")),
        }
    }

    fn parse_ref_or_name_with_optional_sheet(&mut self) -> Result<FormulaExpr, FormulaParseError> {
        let start = self.pos;
        if let Some(sheet) = self.try_parse_sheet_prefix()? {
            return self.parse_ref_or_name(Some(sheet));
        }
        self.pos = start;
        self.parse_ref_or_name(None)
    }

    fn try_parse_sheet_prefix(&mut self) -> Result<Option<String>, FormulaParseError> {
        self.skip_ws();
        match self.peek() {
            Some(b'\'') => {
                let sheet = self.parse_quoted_sheet_name()?;
                if self.peek() == Some(b'!') {
                    self.bump();
                    return Ok(Some(sheet));
                }
                Ok(None)
            }
            Some(b'[') => {
                let start = self.pos;
                while let Some(b) = self.peek() {
                    if b == b'!' {
                        let sheet = std::str::from_utf8(&self.s[start..self.pos])
                            .map_err(|_| self.err("invalid utf-8 in sheet name"))?
                            .to_string();
                        self.bump();
                        return Ok(Some(sheet));
                    }
                    self.pos += 1;
                }
                self.pos = start;
                Ok(None)
            }
            _ => {
                let start = self.pos;
                let Some(b) = self.peek() else {
                    return Ok(None);
                };
                if !is_ident_start(b) {
                    return Ok(None);
                }
                let ident = self.parse_identifier()?;
                self.skip_ws();
                if self.peek() == Some(b'!') {
                    self.bump();
                    return Ok(Some(ident));
                }
                self.pos = start;
                Ok(None)
            }
        }
    }

    fn parse_ref_or_name(
        &mut self,
        sheet: Option<String>,
    ) -> Result<FormulaExpr, FormulaParseError> {
        self.skip_ws();

        if matches!(self.peek(), Some(b'0'..=b'9')) && self.looks_like_row_range() {
            return self.parse_row_range(sheet);
        }

        if matches!(self.peek(), Some(b'R' | b'r')) {
            let start = self.pos;
            if let Ok(r) = self.try_parse_r1c1(sheet.clone()) {
                return Ok(r);
            }
            self.pos = start;
        }

        if matches!(self.peek(), Some(b'$' | b'A'..=b'Z' | b'a'..=b'z')) {
            let start = self.pos;
                if let Some(r) = self.try_parse_a1_cell_ref(sheet.clone())? {
                    let start_ref = r.clone();
                    let mut expr = FormulaExpr::CellRef(r);
                    self.skip_ws();
                    if self.peek() == Some(b':') {
                        self.bump();
                        let rhs = self.try_parse_a1_cell_ref(None)?;
                        if let Some(end) = rhs {
                            expr = FormulaExpr::RangeRef(RangeReference {
                                sheet,
                                start: start_ref,
                                end,
                            });
                        }
                    }
                    return Ok(expr);
            }
            self.pos = start;
        }

        let ident = self.parse_identifier()?;
        self.skip_ws();

        if sheet.is_none()
            && ident.eq_ignore_ascii_case("TRUE")
            && !matches!(self.peek(), Some(b'(' | b'['))
        {
            return Ok(FormulaExpr::Boolean(true));
        }
        if sheet.is_none()
            && ident.eq_ignore_ascii_case("FALSE")
            && !matches!(self.peek(), Some(b'(' | b'['))
        {
            return Ok(FormulaExpr::Boolean(false));
        }

        if self.peek() == Some(b'[') {
            let structured = self.parse_bracket_blob()?;
            let full = match sheet {
                Some(s) => format!("{}!{}{}", s, ident, structured),
                None => format!("{}{}", ident, structured),
            };
            return Ok(FormulaExpr::NamedRef(full));
        }

        if self.peek() == Some(b'(') {
            self.bump();
            let mut args = Vec::new();
            loop {
                self.skip_ws();
                if self.peek() == Some(b')') {
                    self.bump();
                    break;
                }
                let arg = self.parse_expr(0)?;
                args.push(arg);
                self.skip_ws();
                match self.peek() {
                    Some(b',' | b';') => {
                        self.bump();
                    }
                    Some(b')') => {
                        self.bump();
                        break;
                    }
                    _ => return Err(self.err("expected ',' or ')'")),
                }
            }

            let name = match sheet {
                Some(s) => format!("{}!{}", s, ident),
                None => ident,
            };

            return Ok(FormulaExpr::FunctionCall { name, args });
        }

        let name = match sheet {
            Some(s) => format!("{}!{}", s, ident),
            None => ident,
        };

        Ok(FormulaExpr::NamedRef(name))
    }

    fn parse_array(&mut self) -> Result<FormulaExpr, FormulaParseError> {
        self.bump();
        let mut rows = Vec::new();
        let mut current_row = Vec::new();
        loop {
            self.skip_ws();
            if self.peek() == Some(b'}') {
                self.bump();
                if !current_row.is_empty() {
                    rows.push(current_row);
                }
                break;
            }
            let elem = self.parse_expr(0)?;
            current_row.push(elem);
            self.skip_ws();
            match self.peek() {
                Some(b',') => {
                    self.bump();
                }
                Some(b';') => {
                    self.bump();
                    rows.push(current_row);
                    current_row = Vec::new();
                }
                Some(b'}') => {
                    self.bump();
                    rows.push(current_row);
                    break;
                }
                _ => return Err(self.err("expected ',', ';', or '}'")),
            }
        }
        Ok(FormulaExpr::Array(rows))
    }

    fn parse_string(&mut self) -> Result<FormulaExpr, FormulaParseError> {
        if self.bump() != Some(b'"') {
            return Err(self.err("expected '\"'"));
        }

        let mut out = Vec::new();
        loop {
            match self.bump() {
                Some(b'"') => {
                    if self.peek() == Some(b'"') {
                        self.bump();
                        out.push(b'"');
                        continue;
                    }
                    break;
                }
                Some(b) => out.push(b),
                None => return Err(self.err("unterminated string literal")),
            }
        }

        let s = String::from_utf8(out).map_err(|_| self.err("invalid utf-8 in string"))?;
        Ok(FormulaExpr::Text(s))
    }

    fn parse_error(&mut self) -> Result<FormulaExpr, FormulaParseError> {
        let start = self.pos;

        if self.bump() != Some(b'#') {
            return Err(self.err("expected '#'"));
        }

        while let Some(b) = self.peek() {
            if b.is_ascii_alphanumeric() || matches!(b, b'/' | b'!' | b'?' | b'_') {
                self.pos += 1;
            } else {
                break;
            }
        }

        let txt = std::str::from_utf8(&self.s[start..self.pos])
            .map_err(|_| self.err("invalid utf-8 in error literal"))?
            .to_string();

        let upper = txt.to_ascii_uppercase();
        let err = match upper.as_str() {
            "#NULL!" => ExcelError::Null,
            "#DIV/0!" => ExcelError::Div0,
            "#VALUE!" => ExcelError::Value,
            "#REF!" => ExcelError::Ref,
            "#NAME?" => ExcelError::Name,
            "#NUM!" => ExcelError::Num,
            "#N/A" => ExcelError::NA,
            "#SPILL!" => ExcelError::Spill,
            "#CALC!" => ExcelError::Calc,
            "#GETTING_DATA" => ExcelError::GettingData,
            _ => ExcelError::Unknown(txt),
        };
        Ok(FormulaExpr::Error(err))
    }

    fn parse_bracket_blob(&mut self) -> Result<String, FormulaParseError> {
        self.skip_ws();
        if self.peek() != Some(b'[') {
            return Err(self.err("expected '['"));
        }

        let start = self.pos;
        let mut depth: i32 = 0;

        while let Some(b) = self.bump() {
            match b {
                b'[' => depth += 1,
                b']' => {
                    depth -= 1;
                    if depth == 0 {
                        break;
                    }
                }
                _ => {}
            }
        }

        if depth != 0 {
            return Err(self.err("unterminated structured reference"));
        }

        let txt = std::str::from_utf8(&self.s[start..self.pos])
            .map_err(|_| self.err("invalid utf-8 in structured reference"))?
            .to_string();

        Ok(txt)
    }

    fn parse_number(&mut self) -> Result<FormulaExpr, FormulaParseError> {
        let start = self.pos;
        while matches!(self.peek(), Some(b'0'..=b'9')) {
            self.pos += 1;
        }
        if self.peek() == Some(b'.') {
            self.pos += 1;
            while matches!(self.peek(), Some(b'0'..=b'9')) {
                self.pos += 1;
            }
        }
        if matches!(self.peek(), Some(b'e' | b'E')) {
            self.pos += 1;
            if matches!(self.peek(), Some(b'+' | b'-')) {
                self.pos += 1;
            }
            while matches!(self.peek(), Some(b'0'..=b'9')) {
                self.pos += 1;
            }
        }
        let txt = std::str::from_utf8(&self.s[start..self.pos])
            .map_err(|_| self.err("invalid utf-8 in number"))?;
        let n: f64 = txt.parse().map_err(|_| self.err("invalid number"))?;
        Ok(FormulaExpr::Number(n))
    }

    fn parse_identifier(&mut self) -> Result<String, FormulaParseError> {
        self.skip_ws();
        let start = self.pos;
        if let Some(b) = self.peek() {
            if !is_ident_start(b) {
                return Err(self.err("expected identifier"));
            }
        } else {
            return Err(self.err("expected identifier"));
        }
        self.pos += 1;
        while let Some(b) = self.peek() {
            if is_ident_continue(b) {
                self.pos += 1;
            } else {
                break;
            }
        }
        let ident = std::str::from_utf8(&self.s[start..self.pos])
            .map_err(|_| self.err("invalid utf-8 in identifier"))?
            .to_string();
        Ok(ident)
    }

    fn parse_quoted_sheet_name(&mut self) -> Result<String, FormulaParseError> {
        debug_assert_eq!(self.peek(), Some(b'\''));
        self.bump();
        let start = self.pos;
        while let Some(b) = self.peek() {
            self.pos += 1;
            if b == b'\'' {
                if self.peek() == Some(b'\'') {
                    self.pos += 1;
                    continue;
                }
                let name = std::str::from_utf8(&self.s[start..self.pos - 1])
                    .map_err(|_| self.err("invalid utf-8 in sheet name"))?
                    .replace("''", "'");
                return Ok(name);
            }
        }
        Err(self.err("unterminated sheet name"))
    }

    fn try_parse_r1c1(&mut self, sheet: Option<String>) -> Result<FormulaExpr, FormulaParseError> {
        let start = self.pos;
        self.skip_ws();
        if !matches!(self.peek(), Some(b'R' | b'r')) {
            self.pos = start;
            return Err(self.err("expected R1C1 ref"));
        }
        self.bump();
        let row = if self.peek() == Some(b'[') {
            self.bump();
            let offset = self.parse_i32()?;
            if self.bump() != Some(b']') {
                return Err(self.err("expected ']'"));
            }
            RowRef::Offset(offset)
        } else if matches!(self.peek(), Some(b'0'..=b'9')) {
            RowRef::Absolute(self.parse_u32()?)
        } else {
            RowRef::Relative(0)
        };

        if !matches!(self.peek(), Some(b'C' | b'c')) {
            self.pos = start;
            return Err(self.err("expected 'C'"));
        }
        self.bump();

        let col = if self.peek() == Some(b'[') {
            self.bump();
            let offset = self.parse_i32()?;
            if self.bump() != Some(b']') {
                return Err(self.err("expected ']'"));
            }
            ColRef::Offset(offset)
        } else if matches!(self.peek(), Some(b'0'..=b'9')) {
            ColRef::Absolute(self.parse_u32()?)
        } else {
            ColRef::Relative(0)
        };

        Ok(FormulaExpr::CellRef(CellReference {
            sheet,
            row,
            col,
            spill: false,
        }))
    }

    fn parse_i32(&mut self) -> Result<i32, FormulaParseError> {
        self.skip_ws();
        let start = self.pos;
        if self.peek() == Some(b'-') || self.peek() == Some(b'+') {
            self.pos += 1;
        }
        while matches!(self.peek(), Some(b'0'..=b'9')) {
            self.pos += 1;
        }
        let txt = std::str::from_utf8(&self.s[start..self.pos])
            .map_err(|_| self.err("invalid utf-8 in signed int"))?;
        txt.parse::<i32>()
            .map_err(|_| self.err("invalid signed int"))
    }

    fn parse_u32(&mut self) -> Result<u32, FormulaParseError> {
        self.skip_ws();
        let start = self.pos;
        while matches!(self.peek(), Some(b'0'..=b'9')) {
            self.pos += 1;
        }
        let txt = std::str::from_utf8(&self.s[start..self.pos])
            .map_err(|_| self.err("invalid utf-8 in number"))?;
        txt.parse::<u32>().map_err(|_| self.err("invalid number"))
    }

    fn try_parse_a1_cell_ref(
        &mut self,
        sheet: Option<String>,
    ) -> Result<Option<CellReference>, FormulaParseError> {
        self.skip_ws();
        let start = self.pos;

        let col_abs = self.consume_if(b'$');
        if matches!(self.peek(), Some(b'R' | b'r')) {
            if self.looks_like_r1c1() {
                self.pos = start;
                return Ok(None);
            }
        }

        let col_start = self.pos;
        while matches!(self.peek(), Some(b'A'..=b'Z' | b'a'..=b'z')) {
            self.pos += 1;
        }
        if self.pos == col_start {
            self.pos = start;
            return Ok(None);
        }

        let col_txt = std::str::from_utf8(&self.s[col_start..self.pos])
            .map_err(|_| self.err("invalid utf-8 in column"))?;
        if col_txt.len() > 3 {
            self.pos = start;
            return Ok(None);
        }

        let col_num = col_letters_to_u32(col_txt).ok_or_else(|| self.err("invalid column"))?;
        let row_abs = self.consume_if(b'$');

        let row_start = self.pos;
        while matches!(self.peek(), Some(b'0'..=b'9')) {
            self.pos += 1;
        }
        if self.pos == row_start {
            self.pos = start;
            return Ok(None);
        }

        let row_txt = std::str::from_utf8(&self.s[row_start..self.pos])
            .map_err(|_| self.err("invalid utf-8 in row"))?;
        let row_num = row_txt
            .parse::<u32>()
            .map_err(|_| self.err("invalid row"))?;

        let mut spill = false;
        if self.peek() == Some(b'#') {
            self.bump();
            spill = true;
        }

        Ok(Some(CellReference {
            sheet,
            row: if row_abs {
                RowRef::Absolute(row_num)
            } else {
                RowRef::Relative(row_num)
            },
            col: if col_abs {
                ColRef::Absolute(col_num)
            } else {
                ColRef::Relative(col_num)
            },
            spill,
        }))
    }

    fn consume_if(&mut self, b: u8) -> bool {
        if self.peek() == Some(b) {
            self.pos += 1;
            true
        } else {
            false
        }
    }

    fn looks_like_r1c1(&self) -> bool {
        let mut i = self.pos;
        if i >= self.s.len() {
            return false;
        }
        let b = self.s[i];
        if b != b'R' && b != b'r' {
            return false;
        }
        i += 1;
        while i < self.s.len() && matches!(self.s[i], b'0'..=b'9') {
            i += 1;
        }
        if i < self.s.len() && self.s[i] == b'[' {
            return true;
        }
        i < self.s.len() && (self.s[i] == b'C' || self.s[i] == b'c')
    }

    fn looks_like_row_range(&self) -> bool {
        let mut i = self.pos;
        while i < self.s.len() && matches!(self.s[i], b'0'..=b'9') {
            i += 1;
        }
        if i == self.pos {
            return false;
        }
        while i < self.s.len() && matches!(self.s[i], b' ' | b'\t') {
            i += 1;
        }
        if i >= self.s.len() || self.s[i] != b':' {
            return false;
        }
        i += 1;
        while i < self.s.len() && matches!(self.s[i], b' ' | b'\t') {
            i += 1;
        }
        let j = i;
        while i < self.s.len() && matches!(self.s[i], b'0'..=b'9') {
            i += 1;
        }
        i > j
    }

    fn parse_row_range(&mut self, sheet: Option<String>) -> Result<FormulaExpr, FormulaParseError> {
        let start_row = self.parse_u32()?;
        self.skip_ws();
        if self.bump() != Some(b':') {
            return Err(self.err("expected ':' in row range"));
        }
        self.skip_ws();
        let end_row = self.parse_u32()?;
        Ok(FormulaExpr::NamedRef(format!(
            "{}{}:{}",
            match sheet {
                Some(s) => format!("{}!", s),
                None => "".to_string(),
            },
            start_row,
            end_row
        )))
    }
}

fn is_ident_start(b: u8) -> bool {
    matches!(b, b'A'..=b'Z' | b'a'..=b'z' | b'_' | b'\\')
}

fn is_ident_continue(b: u8) -> bool {
    is_ident_start(b) || matches!(b, b'0'..=b'9' | b'.')
}

fn col_letters_to_u32(s: &str) -> Option<u32> {
    let mut col: u32 = 0;
    for b in s.bytes() {
        let c = b.to_ascii_uppercase();
        if !(b'A'..=b'Z').contains(&c) {
            return None;
        }
        col = col * 26 + (c - b'A' + 1) as u32;
    }
    Some(col)
}

```

---

### File: `core\src\formula_diff.rs`

```rust
use rustc_hash::FxHashMap;

use crate::config::DiffConfig;
use crate::diff::FormulaDiffResult;
use crate::formula::{FormulaExpr, formulas_equivalent_modulo_shift, parse_formula};
use crate::string_pool::{StringId, StringPool};

#[derive(Debug, Default)]
pub(crate) struct FormulaParseCache {
    parsed: FxHashMap<StringId, Option<FormulaExpr>>,
    canonical: FxHashMap<StringId, Option<FormulaExpr>>,
}

impl FormulaParseCache {
    fn parsed(&mut self, pool: &StringPool, id: StringId) -> Option<&FormulaExpr> {
        if !self.parsed.contains_key(&id) {
            let s = pool.resolve(id);
            self.parsed.insert(id, parse_formula(s).ok());
        }
        self.parsed.get(&id).and_then(|x| x.as_ref())
    }

    fn canonical(&mut self, pool: &StringPool, id: StringId) -> Option<FormulaExpr> {
        if !self.canonical.contains_key(&id) {
            let canon = self.parsed(pool, id).map(|e| e.canonicalize());
            self.canonical.insert(id, canon);
        }
        self.canonical.get(&id).and_then(|x| x.clone())
    }
}

pub(crate) fn diff_cell_formulas_ids(
    pool: &StringPool,
    cache: &mut FormulaParseCache,
    old: Option<StringId>,
    new: Option<StringId>,
    row_shift: i32,
    col_shift: i32,
    config: &DiffConfig,
) -> FormulaDiffResult {
    if old == new {
        return FormulaDiffResult::Unchanged;
    }

    match (old, new) {
        (None, Some(_)) => return FormulaDiffResult::Added,
        (Some(_), None) => return FormulaDiffResult::Removed,
        (None, None) => return FormulaDiffResult::Unchanged,
        _ => {}
    }

    if !config.enable_formula_semantic_diff {
        return FormulaDiffResult::TextChange;
    }

    let (Some(old_id), Some(new_id)) = (old, new) else {
        return FormulaDiffResult::TextChange;
    };

    let old_ast = match cache.parsed(pool, old_id) {
        Some(a) => a.clone(),
        None => return FormulaDiffResult::TextChange,
    };
    let new_ast = match cache.parsed(pool, new_id) {
        Some(a) => a.clone(),
        None => return FormulaDiffResult::TextChange,
    };

    let old_c = old_ast.canonicalize();
    let new_c = match cache.canonical(pool, new_id) {
        Some(c) => c,
        None => new_ast.canonicalize(),
    };

    if old_c == new_c {
        return FormulaDiffResult::FormattingOnly;
    }

    if row_shift != 0 || col_shift != 0 {
        if formulas_equivalent_modulo_shift(&old_ast, &new_ast, row_shift, col_shift) {
            return FormulaDiffResult::Filled;
        }
    }

    FormulaDiffResult::SemanticChange
}

```

---

### File: `core\src\grid_metadata.rs`

```rust
//! Grid row metadata and frequency classification.
//!
//! This module is the canonical home for row metadata shared across the grid view
//! layer and alignment algorithms.

use std::collections::HashMap;

use crate::config::DiffConfig;
use crate::workbook::RowSignature;

#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash)]
pub enum FrequencyClass {
    Unique,
    Rare,
    Common,
    LowInfo,
}

#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash)]
pub struct RowMeta {
    pub row_idx: u32,
    pub signature: RowSignature,
    pub non_blank_count: u16,
    pub first_non_blank_col: u16,
    pub frequency_class: FrequencyClass,
    pub is_low_info: bool,
}

impl RowMeta {
    pub fn is_low_info(&self) -> bool {
        self.is_low_info || matches!(self.frequency_class, FrequencyClass::LowInfo)
    }
}

pub fn frequency_map(row_meta: &[RowMeta]) -> HashMap<RowSignature, u32> {
    let mut map = HashMap::new();
    for meta in row_meta {
        *map.entry(meta.signature).or_insert(0) += 1;
    }
    map
}

pub fn classify_row_frequencies(row_meta: &mut [RowMeta], config: &DiffConfig) {
    let freq_map = frequency_map(row_meta);
    for meta in row_meta.iter_mut() {
        if meta.frequency_class == FrequencyClass::LowInfo {
            continue;
        }

        let count = freq_map.get(&meta.signature).copied().unwrap_or(0);
        let mut class = match count {
            1 => FrequencyClass::Unique,
            0 => FrequencyClass::Common,
            c if c <= config.rare_threshold => FrequencyClass::Rare,
            _ => FrequencyClass::Common,
        };

        if (meta.non_blank_count as u32) < config.low_info_threshold || meta.is_low_info {
            class = FrequencyClass::LowInfo;
            meta.is_low_info = true;
        }

        meta.frequency_class = class;
    }
}

#[cfg(test)]
#[allow(clippy::field_reassign_with_default)]
mod tests {
    use super::*;

    fn make_meta(row_idx: u32, hash: u128, non_blank: u16) -> RowMeta {
        let signature = RowSignature { hash };
        RowMeta {
            row_idx,
            signature,
            non_blank_count: non_blank,
            first_non_blank_col: 0,
            frequency_class: FrequencyClass::Common,
            is_low_info: false,
        }
    }

    #[test]
    fn classifies_unique_and_rare_and_low_info() {
        let mut meta = vec![make_meta(0, 1, 3), make_meta(1, 1, 3), make_meta(2, 2, 1)];

        let mut config = DiffConfig::default();
        config.rare_threshold = 2;
        config.low_info_threshold = 2;

        classify_row_frequencies(&mut meta, &config);

        assert_eq!(meta[0].frequency_class, FrequencyClass::Rare);
        assert_eq!(meta[1].frequency_class, FrequencyClass::Rare);
        assert_eq!(meta[2].frequency_class, FrequencyClass::LowInfo);
    }
}

```

---

### File: `core\src\grid_parser.rs`

```rust
//! XML parsing for Excel worksheet grids.
//!
//! Handles parsing of worksheet XML, shared strings, workbook structure, and
//! relationship files to construct [`Grid`] representations of sheet data.

use crate::addressing::address_to_index;
use crate::error_codes;
use crate::string_pool::{StringId, StringPool};
use crate::workbook::{CellValue, Grid, NamedRange};
use quick_xml::Reader;
use quick_xml::events::{BytesStart, Event};
use std::collections::HashMap;
use thiserror::Error;

#[derive(Debug, Error)]
#[non_exhaustive]
pub enum GridParseError {
    #[error("[EXDIFF_GRID_001] XML parse error: {0}. Suggestion: re-save the file in Excel or verify it is valid XML.")]
    XmlError(String),
    #[error("[EXDIFF_GRID_001] XML parse error at line {line}, column {column}: {message}. Suggestion: re-save the file in Excel or verify it is valid XML.")]
    XmlErrorAt {
        line: usize,
        column: usize,
        message: String,
    },
    #[error("[EXDIFF_GRID_002] invalid cell address: {0}. Suggestion: the workbook may be corrupt.")]
    InvalidAddress(String),
    #[error("[EXDIFF_GRID_003] shared string index {0} out of bounds. Suggestion: the workbook may be corrupt.")]
    SharedStringOutOfBounds(usize),
}

impl GridParseError {
    pub fn code(&self) -> &'static str {
        match self {
            GridParseError::XmlError(_) => error_codes::GRID_XML_ERROR,
            GridParseError::XmlErrorAt { .. } => error_codes::GRID_XML_ERROR,
            GridParseError::InvalidAddress(_) => error_codes::GRID_INVALID_ADDRESS,
            GridParseError::SharedStringOutOfBounds(_) => error_codes::GRID_SHARED_STRING_OOB,
        }
    }
}

pub struct SheetDescriptor {
    pub name: String,
    pub rel_id: Option<String>,
    pub sheet_id: Option<u32>,
}

pub fn parse_shared_strings(
    xml: &[u8],
    pool: &mut StringPool,
) -> Result<Vec<StringId>, GridParseError> {
    let mut reader = Reader::from_reader(xml);
    reader.config_mut().trim_text(false);
    let mut buf = Vec::new();
    let mut strings = Vec::new();
    let mut current = String::new();
    let mut in_si = false;

    loop {
        match reader.read_event_into(&mut buf) {
            Ok(Event::Start(e)) if e.name().as_ref() == b"si" => {
                current.clear();
                in_si = true;
            }
            Ok(Event::Start(e)) if e.name().as_ref() == b"t" && in_si => {
                let text = reader
                    .read_text(e.name())
                    .map_err(|e| xml_err(&reader, xml, e))?
                    .into_owned();
                current.push_str(&text);
            }
            Ok(Event::End(e)) if e.name().as_ref() == b"si" => {
                let id = pool.intern(&current);
                strings.push(id);
                in_si = false;
            }
            Ok(Event::Eof) => break,
            Err(e) => return Err(xml_err(&reader, xml, e)),
            _ => {}
        }
        buf.clear();
    }

    Ok(strings)
}

pub fn parse_workbook_xml(xml: &[u8]) -> Result<Vec<SheetDescriptor>, GridParseError> {
    let mut reader = Reader::from_reader(xml);
    reader.config_mut().trim_text(true);
    let mut buf = Vec::new();
    let mut sheets = Vec::new();

    loop {
        match reader.read_event_into(&mut buf) {
            Ok(Event::Start(e)) | Ok(Event::Empty(e)) if e.name().as_ref() == b"sheet" => {
                let mut name = None;
                let mut rel_id = None;
                let mut sheet_id = None;
                for attr in e.attributes() {
                    let attr = attr.map_err(|e| xml_msg_err(&reader, xml, e.to_string()))?;
                    match attr.key.as_ref() {
                        b"name" => {
                            name = Some(
                                attr.unescape_value()
                                    .map_err(|e| xml_err(&reader, xml, e))?
                                    .into_owned(),
                            )
                        }
                        b"sheetId" => {
                            let parsed = attr
                                .unescape_value()
                                .map_err(|e| xml_err(&reader, xml, e))?;
                            sheet_id = parsed.into_owned().parse::<u32>().ok();
                        }
                        b"r:id" => {
                            rel_id = Some(
                                attr.unescape_value()
                                    .map_err(|e| xml_err(&reader, xml, e))?
                                    .into_owned(),
                            )
                        }
                        _ => {}
                    }
                }
                if let Some(name) = name {
                    sheets.push(SheetDescriptor {
                        name,
                        rel_id,
                        sheet_id,
                    });
                }
            }
            Ok(Event::Eof) => break,
            Err(e) => return Err(xml_err(&reader, xml, e)),
            _ => {}
        }
        buf.clear();
    }

    Ok(sheets)
}

pub fn parse_defined_names(
    workbook_xml: &[u8],
    sheets_in_order: &[SheetDescriptor],
    pool: &mut StringPool,
) -> Result<Vec<NamedRange>, GridParseError> {
    fn local_name(name: &[u8]) -> &[u8] {
        name.rsplit(|&b| b == b':').next().unwrap_or(name)
    }

    fn quote_sheet_name(sheet: &str) -> String {
        let needs_quotes = sheet
            .chars()
            .any(|c| matches!(c, ' ' | '\'' | '!' | ',' | ';' | '[' | ']' | '(' | ')'));
        if !needs_quotes {
            return sheet.to_string();
        }
        let escaped = sheet.replace('\'', "''");
        format!("'{escaped}'")
    }

    let mut reader = Reader::from_reader(workbook_xml);
    reader.config_mut().trim_text(false);
    let mut buf = Vec::new();
    let mut named_ranges = Vec::new();

    loop {
        match reader.read_event_into(&mut buf) {
            Ok(Event::Start(e)) if local_name(e.name().as_ref()) == b"definedName" => {
                let mut name = None;
                let mut local_sheet_id = None;
                for attr in e.attributes() {
                    let attr = attr.map_err(|e| xml_msg_err(&reader, workbook_xml, e.to_string()))?;
                    match attr.key.as_ref() {
                        b"name" => {
                            name = Some(
                                attr.unescape_value()
                                    .map_err(|e| xml_err(&reader, workbook_xml, e))?
                                    .into_owned(),
                            );
                        }
                        b"localSheetId" => {
                            let value = attr
                                .unescape_value()
                                .map_err(|e| xml_err(&reader, workbook_xml, e))?
                                .into_owned();
                            local_sheet_id = value.parse::<usize>().ok();
                        }
                        _ => {}
                    }
                }

                let name = match name {
                    Some(name) => name,
                    None => {
                        return Err(xml_msg_err(
                            &reader,
                            workbook_xml,
                            "definedName missing required 'name' attribute",
                        ));
                    }
                };

                let refers_to = reader
                    .read_text(e.name())
                    .map_err(|e| xml_err(&reader, workbook_xml, e))?
                    .into_owned();
                let refers_to = refers_to.trim();

                let (qualified_name, scope) = match local_sheet_id {
                    None => (name.clone(), None),
                    Some(idx) => {
                        let sheet_name = sheets_in_order.get(idx).map(|s| s.name.as_str());
                        let sheet_name = match sheet_name {
                            Some(sheet_name) => sheet_name,
                            None => {
                                return Err(xml_msg_err(
                                    &reader,
                                    workbook_xml,
                                    format!(
                                        "definedName localSheetId {idx} out of bounds (sheets={})",
                                        sheets_in_order.len()
                                    ),
                                ));
                            }
                        };
                        let sheet_name_id = pool.intern(sheet_name);
                        let qualified = format!("{}!{}", quote_sheet_name(sheet_name), name);
                        (qualified, Some(sheet_name_id))
                    }
                };

                named_ranges.push(NamedRange {
                    name: pool.intern(&qualified_name),
                    refers_to: pool.intern(refers_to),
                    scope,
                });
            }
            Ok(Event::Empty(e)) if local_name(e.name().as_ref()) == b"definedName" => {
                let mut name = None;
                let mut local_sheet_id = None;
                for attr in e.attributes() {
                    let attr = attr.map_err(|e| xml_msg_err(&reader, workbook_xml, e.to_string()))?;
                    match attr.key.as_ref() {
                        b"name" => {
                            name = Some(
                                attr.unescape_value()
                                    .map_err(|e| xml_err(&reader, workbook_xml, e))?
                                    .into_owned(),
                            );
                        }
                        b"localSheetId" => {
                            let value = attr
                                .unescape_value()
                                .map_err(|e| xml_err(&reader, workbook_xml, e))?
                                .into_owned();
                            local_sheet_id = value.parse::<usize>().ok();
                        }
                        _ => {}
                    }
                }

                let name = match name {
                    Some(name) => name,
                    None => {
                        return Err(xml_msg_err(
                            &reader,
                            workbook_xml,
                            "definedName missing required 'name' attribute",
                        ));
                    }
                };

                let (qualified_name, scope) = match local_sheet_id {
                    None => (name.clone(), None),
                    Some(idx) => {
                        let sheet_name = sheets_in_order.get(idx).map(|s| s.name.as_str());
                        let sheet_name = match sheet_name {
                            Some(sheet_name) => sheet_name,
                            None => {
                                return Err(xml_msg_err(
                                    &reader,
                                    workbook_xml,
                                    format!(
                                        "definedName localSheetId {idx} out of bounds (sheets={})",
                                        sheets_in_order.len()
                                    ),
                                ));
                            }
                        };
                        let sheet_name_id = pool.intern(sheet_name);
                        let qualified = format!("{}!{}", quote_sheet_name(sheet_name), name);
                        (qualified, Some(sheet_name_id))
                    }
                };

                named_ranges.push(NamedRange {
                    name: pool.intern(&qualified_name),
                    refers_to: pool.intern(""),
                    scope,
                });
            }
            Ok(Event::Eof) => break,
            Err(e) => return Err(xml_err(&reader, workbook_xml, e)),
            _ => {}
        }
        buf.clear();
    }

    Ok(named_ranges)
}

pub fn parse_relationships(xml: &[u8]) -> Result<HashMap<String, String>, GridParseError> {
    let mut reader = Reader::from_reader(xml);
    reader.config_mut().trim_text(true);
    let mut buf = Vec::new();
    let mut map = HashMap::new();

    loop {
        match reader.read_event_into(&mut buf) {
            Ok(Event::Start(e)) | Ok(Event::Empty(e)) if e.name().as_ref() == b"Relationship" => {
                let mut id = None;
                let mut target = None;
                let mut rel_type = None;
                for attr in e.attributes() {
                    let attr = attr.map_err(|e| xml_msg_err(&reader, xml, e.to_string()))?;
                    match attr.key.as_ref() {
                        b"Id" => {
                            id = Some(
                                attr.unescape_value()
                                    .map_err(|e| xml_err(&reader, xml, e))?
                                    .into_owned(),
                            )
                        }
                        b"Target" => {
                            target = Some(
                                attr.unescape_value()
                                    .map_err(|e| xml_err(&reader, xml, e))?
                                    .into_owned(),
                            )
                        }
                        b"Type" => {
                            rel_type = Some(
                                attr.unescape_value()
                                    .map_err(|e| xml_err(&reader, xml, e))?
                                    .into_owned(),
                            )
                        }
                        _ => {}
                    }
                }

                if let (Some(id), Some(target), Some(rel_type)) = (id, target, rel_type)
                    && rel_type.contains("worksheet")
                {
                    map.insert(id, target);
                }
            }
            Ok(Event::Eof) => break,
            Err(e) => return Err(xml_err(&reader, xml, e)),
            _ => {}
        }
        buf.clear();
    }

    Ok(map)
}

pub fn parse_relationships_all(xml: &[u8]) -> Result<HashMap<String, String>, GridParseError> {
    let mut reader = Reader::from_reader(xml);
    reader.config_mut().trim_text(true);
    let mut buf = Vec::new();
    let mut map = HashMap::new();

    loop {
        match reader.read_event_into(&mut buf) {
            Ok(Event::Start(e)) | Ok(Event::Empty(e)) if e.name().as_ref() == b"Relationship" => {
                let mut id = None;
                let mut target = None;
                for attr in e.attributes() {
                    let attr = attr.map_err(|e| xml_msg_err(&reader, xml, e.to_string()))?;
                    match attr.key.as_ref() {
                        b"Id" => {
                            id = Some(
                                attr.unescape_value()
                                    .map_err(|e| xml_err(&reader, xml, e))?
                                    .into_owned(),
                            )
                        }
                        b"Target" => {
                            target = Some(
                                attr.unescape_value()
                                    .map_err(|e| xml_err(&reader, xml, e))?
                                    .into_owned(),
                            )
                        }
                        _ => {}
                    }
                }

                if let (Some(id), Some(target)) = (id, target) {
                    map.insert(id, target);
                }
            }
            Ok(Event::Eof) => break,
            Err(e) => return Err(xml_err(&reader, xml, e)),
            _ => {}
        }
        buf.clear();
    }

    Ok(map)
}

pub fn resolve_sheet_target(
    sheet: &SheetDescriptor,
    relationships: &HashMap<String, String>,
    index: usize,
) -> String {
    if let Some(rel_id) = &sheet.rel_id
        && let Some(target) = relationships.get(rel_id)
    {
        return normalize_target(target);
    }

    let guessed = sheet
        .sheet_id
        .map(|id| format!("xl/worksheets/sheet{id}.xml"))
        .unwrap_or_else(|| format!("xl/worksheets/sheet{}.xml", index + 1));
    normalize_target(&guessed)
}

fn normalize_target(target: &str) -> String {
    let trimmed = target.trim_start_matches('/');
    if trimmed.starts_with("xl/") {
        trimmed.to_string()
    } else {
        format!("xl/{trimmed}")
    }
}

pub fn parse_sheet_xml(
    xml: &[u8],
    shared_strings: &[StringId],
    pool: &mut StringPool,
) -> Result<Grid, GridParseError> {
    let mut reader = Reader::from_reader(xml);
    reader.config_mut().trim_text(false);
    let mut buf = Vec::new();

    let mut dimension_hint: Option<(u32, u32)> = None;
    let mut parsed_cells: Vec<ParsedCell> = Vec::new();
    let mut max_row: Option<u32> = None;
    let mut max_col: Option<u32> = None;

    loop {
        match reader.read_event_into(&mut buf) {
            Ok(Event::Start(e)) | Ok(Event::Empty(e)) if e.name().as_ref() == b"dimension" => {
                if let Some(r) = get_attr_value(&reader, xml, &e, b"ref")? {
                    dimension_hint = dimension_from_ref(&r);
                }
            }
            Ok(Event::Start(e)) if e.name().as_ref() == b"c" => {
                let cell = parse_cell(&mut reader, xml, e, shared_strings, pool)?;
                max_row = Some(max_row.map_or(cell.row, |r| r.max(cell.row)));
                max_col = Some(max_col.map_or(cell.col, |c| c.max(cell.col)));
                parsed_cells.push(cell);
            }
            Ok(Event::Eof) => break,
            Err(e) => return Err(xml_err(&reader, xml, e)),
            _ => {}
        }
        buf.clear();
    }

    if parsed_cells.is_empty() {
        return Ok(Grid::new(0, 0));
    }

    let mut nrows = dimension_hint.map(|(r, _)| r).unwrap_or(0);
    let mut ncols = dimension_hint.map(|(_, c)| c).unwrap_or(0);

    if let Some(max_r) = max_row {
        nrows = nrows.max(max_r + 1);
    }
    if let Some(max_c) = max_col {
        ncols = ncols.max(max_c + 1);
    }

    build_grid(nrows, ncols, parsed_cells)
}

fn parse_cell(
    reader: &mut Reader<&[u8]>,
    xml: &[u8],
    start: BytesStart,
    shared_strings: &[StringId],
    pool: &mut StringPool,
) -> Result<ParsedCell, GridParseError> {
    let address_raw =
        get_attr_value(reader, xml, &start, b"r")?.ok_or_else(|| {
            xml_msg_err(reader, xml, "cell missing address")
        })?;
    let (row, col) = address_to_index(&address_raw)
        .ok_or_else(|| GridParseError::InvalidAddress(address_raw.clone()))?;

    let cell_type = get_attr_value(reader, xml, &start, b"t")?;

    let mut value_text: Option<String> = None;
    let mut formula_text: Option<String> = None;
    let mut inline_text: Option<String> = None;
    let mut buf = Vec::new();

    loop {
        match reader.read_event_into(&mut buf) {
            Ok(Event::Start(e)) if e.name().as_ref() == b"v" => {
                let text = reader
                    .read_text(e.name())
                    .map_err(|e| xml_err(reader, xml, e))?
                    .into_owned();
                value_text = Some(text);
            }
            Ok(Event::Start(e)) if e.name().as_ref() == b"f" => {
                let text = reader
                    .read_text(e.name())
                    .map_err(|e| xml_err(reader, xml, e))?
                    .into_owned();
                let unescaped = quick_xml::escape::unescape(&text)
                    .map_err(|e| xml_msg_err(reader, xml, e.to_string()))?
                    .into_owned();
                formula_text = Some(unescaped);
            }
            Ok(Event::Start(e)) if e.name().as_ref() == b"is" => {
                inline_text = Some(read_inline_string(reader, xml)?);
            }
            Ok(Event::End(e)) if e.name().as_ref() == start.name().as_ref() => break,
            Ok(Event::Eof) => {
                return Err(xml_msg_err(reader, xml, "unexpected EOF inside cell"));
            }
            Err(e) => return Err(xml_err(reader, xml, e)),
            _ => {}
        }
        buf.clear();
    }

    let value = match inline_text {
        Some(text) => Some(CellValue::Text(pool.intern(&text))),
        None => convert_value(
            value_text.as_deref(),
            cell_type.as_deref(),
            shared_strings,
            pool,
            reader,
            xml,
        )?,
    };

    Ok(ParsedCell {
        row,
        col,
        value,
        formula: formula_text.map(|f| pool.intern(&f)),
    })
}

fn read_inline_string(reader: &mut Reader<&[u8]>, xml: &[u8]) -> Result<String, GridParseError> {
    let mut buf = Vec::new();
    let mut value = String::new();
    loop {
        match reader.read_event_into(&mut buf) {
            Ok(Event::Start(e)) if e.name().as_ref() == b"t" => {
                let text = reader
                    .read_text(e.name())
                    .map_err(|e| xml_err(reader, xml, e))?
                    .into_owned();
                value.push_str(&text);
            }
            Ok(Event::End(e)) if e.name().as_ref() == b"is" => break,
            Ok(Event::Eof) => {
                return Err(xml_msg_err(
                    reader,
                    xml,
                    "unexpected EOF inside inline string",
                ));
            }
            Err(e) => return Err(xml_err(reader, xml, e)),
            _ => {}
        }
        buf.clear();
    }
    Ok(value)
}

fn convert_value(
    value_text: Option<&str>,
    cell_type: Option<&str>,
    shared_strings: &[StringId],
    pool: &mut StringPool,
    reader: &Reader<&[u8]>,
    xml: &[u8],
) -> Result<Option<CellValue>, GridParseError> {
    let raw = match value_text {
        Some(t) => t,
        None => return Ok(None),
    };

    let trimmed = raw.trim();
    if raw.is_empty() || trimmed.is_empty() {
        return Ok(Some(CellValue::Text(pool.intern(""))));
    }

    match cell_type {
        Some("s") => {
            let idx = trimmed
                .parse::<usize>()
                .map_err(|e| xml_msg_err(reader, xml, e.to_string()))?;
            let text_id = *shared_strings
                .get(idx)
                .ok_or(GridParseError::SharedStringOutOfBounds(idx))?;
            Ok(Some(CellValue::Text(text_id)))
        }
        Some("b") => Ok(match trimmed {
            "1" => Some(CellValue::Bool(true)),
            "0" => Some(CellValue::Bool(false)),
            _ => None,
        }),
        Some("e") => Ok(Some(CellValue::Error(pool.intern(trimmed)))),
        Some("str") | Some("inlineStr") => Ok(Some(CellValue::Text(pool.intern(raw)))),
        _ => {
            if let Ok(n) = trimmed.parse::<f64>() {
                Ok(Some(CellValue::Number(n)))
            } else {
                Ok(Some(CellValue::Text(pool.intern(trimmed))))
            }
        }
    }
}

fn dimension_from_ref(reference: &str) -> Option<(u32, u32)> {
    let mut parts = reference.split(':');
    let start = parts.next()?;
    let end = parts.next().unwrap_or(start);
    let (start_row, start_col) = address_to_index(start)?;
    let (end_row, end_col) = address_to_index(end)?;
    let height = end_row.checked_sub(start_row)?.checked_add(1)?;
    let width = end_col.checked_sub(start_col)?.checked_add(1)?;
    Some((height, width))
}

fn build_grid(nrows: u32, ncols: u32, cells: Vec<ParsedCell>) -> Result<Grid, GridParseError> {
    let mut grid = Grid::new(nrows, ncols);

    for parsed in cells {
        grid.insert_cell(parsed.row, parsed.col, parsed.value, parsed.formula);
    }

    Ok(grid)
}

fn get_attr_value(
    reader: &Reader<&[u8]>,
    xml: &[u8],
    element: &BytesStart<'_>,
    key: &[u8],
) -> Result<Option<String>, GridParseError> {
    for attr in element.attributes() {
        let attr = attr.map_err(|e| xml_msg_err(reader, xml, e.to_string()))?;
        if attr.key.as_ref() == key {
            return Ok(Some(
                attr.unescape_value()
                    .map_err(|e| xml_err(reader, xml, e))?
                    .into_owned(),
            ));
        }
    }
    Ok(None)
}

fn xml_err(reader: &Reader<&[u8]>, xml: &[u8], err: quick_xml::Error) -> GridParseError {
    xml_error_with_position(err, xml, reader.buffer_position())
}

fn xml_msg_err(reader: &Reader<&[u8]>, xml: &[u8], message: impl Into<String>) -> GridParseError {
    let (line, column) = compute_line_col(xml, reader.buffer_position());
    GridParseError::XmlErrorAt {
        line,
        column,
        message: message.into(),
    }
}

fn xml_error_with_position(
    err: quick_xml::Error,
    xml: &[u8],
    byte_offset: usize,
) -> GridParseError {
    let (line, column) = compute_line_col(xml, byte_offset);
    GridParseError::XmlErrorAt {
        line,
        column,
        message: err.to_string(),
    }
}

fn compute_line_col(data: &[u8], offset: usize) -> (usize, usize) {
    let safe_offset = offset.min(data.len());
    let slice = &data[..safe_offset];
    let line = slice.iter().filter(|&&b| b == b'\n').count() + 1;
    let last_newline = slice.iter().rposition(|&b| b == b'\n');
    let column = match last_newline {
        Some(pos) => safe_offset - pos,
        None => safe_offset + 1,
    };
    (line, column)
}

struct ParsedCell {
    row: u32,
    col: u32,
    value: Option<CellValue>,
    formula: Option<StringId>,
}

#[cfg(test)]
mod tests {
    use super::{GridParseError, convert_value, parse_shared_strings, read_inline_string};
    use crate::string_pool::StringPool;
    use crate::workbook::CellValue;
    use quick_xml::Reader;

    #[test]
    fn parse_shared_strings_rich_text_flattens_runs() {
        let xml = br#"<?xml version="1.0"?>
<sst>
  <si>
    <r><t>Hello</t></r>
    <r><t xml:space="preserve"> World</t></r>
  </si>
</sst>"#;
        let mut pool = StringPool::new();
        let strings = parse_shared_strings(xml, &mut pool).expect("shared strings should parse");
        let first = strings.first().copied().unwrap();
        assert_eq!(pool.resolve(first), "Hello World");
    }

    #[test]
    fn read_inline_string_preserves_xml_space_preserve() {
        let xml = br#"<is><t xml:space="preserve"> hello</t></is>"#;
        let mut reader = Reader::from_reader(xml.as_ref());
        reader.config_mut().trim_text(false);
        let value = read_inline_string(&mut reader, xml).expect("inline string should parse");
        assert_eq!(value, " hello");

        let mut pool = StringPool::new();
        let dummy_xml: &[u8] = b"";
        let dummy_reader = Reader::from_reader(dummy_xml);
        let converted = convert_value(
            Some(value.as_str()),
            Some("inlineStr"),
            &[],
            &mut pool,
            &dummy_reader,
            dummy_xml,
        )
            .expect("inlineStr conversion should succeed");
        let text_id = converted
            .as_ref()
            .and_then(CellValue::as_text_id)
            .expect("text id");
        assert_eq!(pool.resolve(text_id), " hello");
    }

    #[test]
    fn convert_value_bool_0_1_and_other() {
        let dummy_xml: &[u8] = b"";
        let dummy_reader = Reader::from_reader(dummy_xml);

        let mut pool = StringPool::new();
        let false_val = convert_value(Some("0"), Some("b"), &[], &mut pool, &dummy_reader, dummy_xml)
            .expect("bool cell conversion should succeed");
        assert_eq!(false_val, Some(CellValue::Bool(false)));

        let mut pool = StringPool::new();
        let true_val = convert_value(Some("1"), Some("b"), &[], &mut pool, &dummy_reader, dummy_xml)
            .expect("bool cell conversion should succeed");
        assert_eq!(true_val, Some(CellValue::Bool(true)));

        let none_val = convert_value(Some("2"), Some("b"), &[], &mut pool, &dummy_reader, dummy_xml)
            .expect("unexpected bool tokens should still parse");
        assert!(none_val.is_none());
    }

    #[test]
    fn convert_value_shared_string_index_out_of_bounds_errors() {
        let dummy_xml: &[u8] = b"";
        let dummy_reader = Reader::from_reader(dummy_xml);

        let mut pool = StringPool::new();
        let only_id = pool.intern("only");
        let err = convert_value(Some("5"), Some("s"), &[only_id], &mut pool, &dummy_reader, dummy_xml)
            .expect_err("invalid shared string index should error");
        assert!(matches!(err, GridParseError::SharedStringOutOfBounds(5)));
    }

    #[test]
    fn convert_value_error_cell_as_text() {
        let dummy_xml: &[u8] = b"";
        let dummy_reader = Reader::from_reader(dummy_xml);

        let mut pool = StringPool::new();
        let value = convert_value(Some("#DIV/0!"), Some("e"), &[], &mut pool, &dummy_reader, dummy_xml)
            .expect("error cell should convert");
        let err_id = value
            .and_then(|v| {
                if let CellValue::Error(id) = v {
                    Some(id)
                } else {
                    None
                }
            })
            .expect("error id");
        assert_eq!(pool.resolve(err_id), "#DIV/0!");
    }
}

```

---

### File: `core\src\grid_view.rs`

```rust
use std::collections::HashMap;
use std::hash::Hash;

use crate::config::DiffConfig;
use crate::grid_metadata::classify_row_frequencies;
use crate::hashing::{hash_cell_value, hash_row_content_128};
use crate::workbook::{Cell, CellValue, ColSignature, Grid, RowSignature};
use xxhash_rust::xxh3::Xxh3;

pub use crate::grid_metadata::{FrequencyClass, RowMeta};

pub type RowHash = RowSignature;
pub type ColHash = ColSignature;

#[derive(Debug)]
pub struct RowView<'a> {
    pub cells: Vec<(u32, &'a Cell)>, // sorted by column index
}

#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
pub struct ColMeta {
    pub col_idx: u32,
    pub hash: ColHash,
    pub non_blank_count: u16,
    pub first_non_blank_row: u16,
}

#[derive(Debug)]
pub struct GridView<'a> {
    pub rows: Vec<RowView<'a>>,
    pub row_meta: Vec<RowMeta>,
    pub col_meta: Vec<ColMeta>,
    pub source: &'a Grid,
}

impl<'a> GridView<'a> {
    pub fn from_grid(grid: &'a Grid) -> GridView<'a> {
        let default_config = DiffConfig::default();
        Self::from_grid_with_config(grid, &default_config)
    }

    pub fn from_grid_with_config(grid: &'a Grid, config: &DiffConfig) -> GridView<'a> {
        let nrows = grid.nrows as usize;
        let ncols = grid.ncols as usize;

        let mut rows: Vec<RowView<'a>> =
            (0..nrows).map(|_| RowView { cells: Vec::new() }).collect();

        let mut row_counts = vec![0u32; nrows];
        let mut row_first_non_blank: Vec<Option<u32>> = vec![None; nrows];

        let mut col_counts = vec![0u32; ncols];
        let mut col_first_non_blank: Vec<Option<u32>> = vec![None; ncols];

        for ((row, col), cell) in &grid.cells {
            let r = *row as usize;
            let c = *col as usize;

            debug_assert!(
                r < nrows && c < ncols,
                "cell coordinates must lie within the grid bounds"
            );

            rows[r].cells.push((*col, cell));

            if is_non_blank(cell) {
                row_counts[r] = row_counts[r].saturating_add(1);
                col_counts[c] = col_counts[c].saturating_add(1);

                row_first_non_blank[r] =
                    Some(row_first_non_blank[r].map_or(*col, |cur| cur.min(*col)));
                col_first_non_blank[c] =
                    Some(col_first_non_blank[c].map_or(*row, |cur| cur.min(*row)));
            }
        }

        for row_view in rows.iter_mut() {
            row_view.cells.sort_unstable_by_key(|(col, _)| *col);
        }

        let mut row_meta: Vec<RowMeta> = rows
            .iter()
            .enumerate()
            .map(|(idx, row_view)| {
                let count = row_counts.get(idx).copied().unwrap_or(0);
                let non_blank_count = to_u16(count);
                let first_non_blank_col = row_first_non_blank
                    .get(idx)
                    .and_then(|c| c.map(to_u16))
                    .unwrap_or(0);
                let is_low_info = compute_is_low_info(non_blank_count, row_view);

                let signature = RowSignature {
                    hash: hash_row_content_128(&row_view.cells),
                };

                let frequency_class = if is_low_info {
                    FrequencyClass::LowInfo
                } else {
                    FrequencyClass::Common
                };

                RowMeta {
                    row_idx: idx as u32,
                    signature,
                    non_blank_count,
                    first_non_blank_col,
                    frequency_class,
                    is_low_info,
                }
            })
            .collect();

        classify_row_frequencies(&mut row_meta, config);

        let mut col_hashers: Vec<Xxh3> = (0..ncols).map(|_| Xxh3::new()).collect();

        for row_view in rows.iter() {
            for (col, cell) in row_view.cells.iter() {
                let idx = *col as usize;
                if idx >= col_hashers.len() {
                    continue;
                }
                hash_cell_value(&cell.value, &mut col_hashers[idx]);
                cell.formula.hash(&mut col_hashers[idx]);
            }
        }

        let col_meta: Vec<ColMeta> = (0..ncols)
            .map(|idx| ColMeta {
                col_idx: idx as u32,
                hash: ColSignature {
                    hash: col_hashers[idx].digest128(),
                },
                non_blank_count: to_u16(col_counts.get(idx).copied().unwrap_or(0)),
                first_non_blank_row: col_first_non_blank
                    .get(idx)
                    .and_then(|r| r.map(to_u16))
                    .unwrap_or(0),
            })
            .collect();

        GridView {
            rows,
            row_meta,
            col_meta,
            source: grid,
        }
    }

    pub fn is_low_info_dominated(&self) -> bool {
        if self.row_meta.is_empty() {
            return false;
        }
        let low = self.row_meta.iter().filter(|m| m.is_low_info()).count();
        low * 2 > self.row_meta.len()
    }

    pub fn is_blank_dominated(&self) -> bool {
        if self.col_meta.is_empty() {
            return false;
        }
        let blank = self
            .col_meta
            .iter()
            .filter(|m| m.non_blank_count == 0)
            .count();
        blank * 2 > self.col_meta.len()
    }
}

#[derive(Debug, Default)]
pub struct HashStats<H> {
    pub freq_a: HashMap<H, u32>,
    pub freq_b: HashMap<H, u32>,
    pub hash_to_positions_b: HashMap<H, Vec<u32>>,
}

impl HashStats<RowHash> {
    pub fn from_row_meta(rows_a: &[RowMeta], rows_b: &[RowMeta]) -> HashStats<RowHash> {
        let mut stats = HashStats::default();

        for meta in rows_a {
            *stats.freq_a.entry(meta.signature).or_insert(0) += 1;
        }

        for meta in rows_b {
            *stats.freq_b.entry(meta.signature).or_insert(0) += 1;
            stats
                .hash_to_positions_b
                .entry(meta.signature)
                .or_insert_with(Vec::new)
                .push(meta.row_idx);
        }

        stats
    }
}

impl HashStats<ColHash> {
    pub fn from_col_meta(cols_a: &[ColMeta], cols_b: &[ColMeta]) -> HashStats<ColHash> {
        let mut stats = HashStats::default();

        for meta in cols_a {
            *stats.freq_a.entry(meta.hash).or_insert(0) += 1;
        }

        for meta in cols_b {
            *stats.freq_b.entry(meta.hash).or_insert(0) += 1;
            stats
                .hash_to_positions_b
                .entry(meta.hash)
                .or_insert_with(Vec::new)
                .push(meta.col_idx);
        }

        stats
    }
}

impl<H> HashStats<H>
where
    H: Eq + Hash + Copy,
{
    pub fn is_unique(&self, hash: H) -> bool {
        self.freq_a.get(&hash).copied().unwrap_or(0) == 1
            && self.freq_b.get(&hash).copied().unwrap_or(0) == 1
    }

    pub fn is_unique_to_a(&self, hash: H) -> bool {
        self.freq_a.get(&hash).copied().unwrap_or(0) == 1
            && self.freq_b.get(&hash).copied().unwrap_or(0) == 0
    }

    pub fn is_unique_to_b(&self, hash: H) -> bool {
        self.freq_a.get(&hash).copied().unwrap_or(0) == 0
            && self.freq_b.get(&hash).copied().unwrap_or(0) == 1
    }

    pub fn max_frequency(&self) -> u32 {
        self.freq_a
            .values()
            .chain(self.freq_b.values())
            .copied()
            .max()
            .unwrap_or(0)
    }

    pub fn has_heavy_repetition(&self, max_repeat: u32) -> bool {
        self.max_frequency() > max_repeat
    }

    pub fn is_rare(&self, hash: H, threshold: u32) -> bool {
        let freq_a = self.freq_a.get(&hash).copied().unwrap_or(0);
        let freq_b = self.freq_b.get(&hash).copied().unwrap_or(0);

        if freq_a == 0 || freq_b == 0 || self.is_unique(hash) {
            return false;
        }

        freq_a <= threshold && freq_b <= threshold
    }

    pub fn is_common(&self, hash: H, threshold: u32) -> bool {
        let freq_a = self.freq_a.get(&hash).copied().unwrap_or(0);
        let freq_b = self.freq_b.get(&hash).copied().unwrap_or(0);

        if freq_a == 0 && freq_b == 0 {
            return false;
        }

        freq_a > threshold || freq_b > threshold
    }

    pub fn appears_in_both(&self, hash: H) -> bool {
        self.freq_a.get(&hash).copied().unwrap_or(0) > 0
            && self.freq_b.get(&hash).copied().unwrap_or(0) > 0
    }
}

fn is_non_blank(cell: &Cell) -> bool {
    cell.value.is_some() || cell.formula.is_some()
}

fn compute_is_low_info(non_blank_count: u16, row_view: &RowView<'_>) -> bool {
    if non_blank_count == 0 {
        return true;
    }

    if non_blank_count > 1 {
        return false;
    }

    let cell = row_view
        .cells
        .iter()
        .find_map(|(_, cell)| is_non_blank(cell).then_some(*cell));

    match cell {
        None => true,
        Some(cell) => match (&cell.value, &cell.formula) {
            (_, Some(_)) => false,
            (Some(CellValue::Text(id)), None) => id.0 == 0,
            (Some(CellValue::Number(_)), _) => false,
            (Some(CellValue::Bool(_)), _) => false,
            (Some(CellValue::Error(_)), _) => false,
            (Some(CellValue::Blank), _) => true,
            (None, None) => true,
        },
    }
}

fn to_u16(value: u32) -> u16 {
    u16::try_from(value).unwrap_or(u16::MAX)
}

```

---

### File: `core\src\hashing.rs`

```rust
//! Hash utilities for row/column signature computation.
//!
//! Provides consistent hashing functions used for computing structural
//! signatures that enable efficient alignment during diffing.
//!
//! # Position Independence
//!
//! Row signatures are computed by hashing cell content in column-sorted order
//! *without* including column indices. This ensures that inserting or deleting
//! columns does not invalidate row alignment.
//!
//! Column signatures similarly hash content in row-sorted order without row indices.
//!
//! # Collision Probability
//!
//! Using 128-bit xxHash3 signatures, the collision probability is ~10^-38 per pair.
//! At 50K rows, the birthday-bound collision probability is ~10^-29, which is
//! negligible for practical purposes.

use std::hash::{Hash, Hasher};
use xxhash_rust::xxh3::Xxh3;
#[cfg(any(test, feature = "dev-apis"))]
use xxhash_rust::xxh64::Xxh64;

use crate::workbook::{CellContent, CellValue};
#[cfg(any(test, feature = "dev-apis"))]
use crate::workbook::{ColSignature, RowSignature};

pub(crate) const XXH64_SEED: u64 = 0;
#[cfg(any(test, feature = "dev-apis"))]
const HASH_MIX_CONSTANT: u64 = 0x9e3779b97f4a7c15;
const CANONICAL_NAN_BITS: u64 = 0x7FF8_0000_0000_0000;

pub(crate) fn normalize_float_for_hash(n: f64) -> u64 {
    if n.is_nan() {
        return CANONICAL_NAN_BITS;
    }
    if n == 0.0 {
        return 0u64;
    }
    let magnitude = n.abs().log10().floor() as i32;
    let scale = 10f64.powi(14 - magnitude);
    let normalized = (n * scale).round() / scale;
    normalized.to_bits()
}

pub(crate) fn hash_cell_value<H: Hasher>(value: &Option<CellValue>, state: &mut H) {
    match value {
        None => {
            3u8.hash(state);
        }
        Some(CellValue::Blank) => {
            4u8.hash(state);
        }
        Some(CellValue::Number(n)) => {
            0u8.hash(state);
            normalize_float_for_hash(*n).hash(state);
        }
        Some(CellValue::Text(s)) => {
            1u8.hash(state);
            s.hash(state);
        }
        Some(CellValue::Bool(b)) => {
            2u8.hash(state);
            b.hash(state);
        }
        Some(CellValue::Error(id)) => {
            5u8.hash(state);
            id.hash(state);
        }
    }
}

#[cfg(any(test, feature = "dev-apis"))]
pub(crate) fn hash_cell_content(cell: &CellContent) -> u64 {
    let mut hasher = Xxh64::new(XXH64_SEED);
    hash_cell_value(&cell.value, &mut hasher);
    cell.formula.hash(&mut hasher);
    hasher.finish()
}

#[cfg(any(test, feature = "dev-apis"))]
pub(crate) fn hash_cell_content_128(cell: &CellContent) -> u128 {
    let mut hasher = Xxh3::new();
    hash_cell_value(&cell.value, &mut hasher);
    cell.formula.hash(&mut hasher);
    hasher.digest128()
}

pub(crate) fn hash_row_content_128(cells: &[(u32, &CellContent)]) -> u128 {
    let mut hasher = Xxh3::new();
    for (_, cell) in cells.iter() {
        hash_cell_value(&cell.value, &mut hasher);
        cell.formula.hash(&mut hasher);
    }
    hasher.digest128()
}

#[cfg(any(test, feature = "dev-apis"))]
pub(crate) fn hash_col_content_128(cells: &[&CellContent]) -> u128 {
    let mut hasher = Xxh3::new();
    for cell in cells.iter() {
        hash_cell_value(&cell.value, &mut hasher);
        cell.formula.hash(&mut hasher);
    }
    hasher.digest128()
}

pub(crate) fn hash_col_content_unordered_128(cells: &[&CellContent]) -> u128 {
    if cells.is_empty() {
        return Xxh3::new().digest128();
    }

    let mut cell_hashes: Vec<u128> = cells
        .iter()
        .map(|cell| {
            let mut h = Xxh3::new();
            hash_cell_value(&cell.value, &mut h);
            cell.formula.hash(&mut h);
            h.digest128()
        })
        .collect();

    cell_hashes.sort_unstable();

    let mut combined = Xxh3::new();
    for h in cell_hashes {
        combined.update(&h.to_le_bytes());
    }
    combined.digest128()
}

#[cfg(any(test, feature = "dev-apis"))]
pub(crate) fn mix_hash(hash: u64) -> u64 {
    hash.rotate_left(13) ^ HASH_MIX_CONSTANT
}

#[cfg(any(test, feature = "dev-apis"))]
pub(crate) fn mix_hash_128(hash: u128) -> u128 {
    hash.rotate_left(47) ^ (HASH_MIX_CONSTANT as u128)
}

#[cfg(any(test, feature = "dev-apis"))]
pub(crate) fn combine_hashes(current: u64, contribution: u64) -> u64 {
    current.wrapping_add(mix_hash(contribution))
}

#[cfg(any(test, feature = "dev-apis"))]
pub(crate) fn combine_hashes_128(current: u128, contribution: u128) -> u128 {
    current.wrapping_add(mix_hash_128(contribution))
}

#[cfg(any(test, feature = "dev-apis"))]
pub(crate) fn compute_row_signature<'a>(
    cells: impl Iterator<Item = ((u32, u32), &'a CellContent)>,
    row: u32,
) -> RowSignature {
    let mut row_cells: Vec<(u32, &CellContent)> = cells
        .filter_map(|((r, c), cell)| (r == row).then_some((c, cell)))
        .collect();
    row_cells.sort_by_key(|(col, _)| *col);

    let hash = hash_row_content_128(&row_cells);
    RowSignature { hash }
}

#[cfg(any(test, feature = "dev-apis"))]
pub(crate) fn compute_col_signature<'a>(
    cells: impl Iterator<Item = ((u32, u32), &'a CellContent)>,
    col: u32,
) -> ColSignature {
    let mut col_cells: Vec<(u32, &CellContent)> = cells
        .filter_map(|((r, c), cell)| (c == col).then_some((r, cell)))
        .collect();
    col_cells.sort_by_key(|(r, _)| *r);
    let ordered: Vec<&CellContent> = col_cells.into_iter().map(|(_, cell)| cell).collect();
    let hash = hash_col_content_128(&ordered);
    ColSignature { hash }
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn normalize_zero_values() {
        assert_eq!(
            normalize_float_for_hash(0.0),
            normalize_float_for_hash(-0.0)
        );
        assert_eq!(normalize_float_for_hash(0.0), 0u64);
    }

    #[test]
    fn normalize_nan_values() {
        let nan1 = f64::NAN;
        let nan2 = f64::from_bits(0x7FF8_0000_0000_0001);
        assert_eq!(
            normalize_float_for_hash(nan1),
            normalize_float_for_hash(nan2)
        );
        assert_eq!(normalize_float_for_hash(nan1), CANONICAL_NAN_BITS);
    }

    #[test]
    fn normalize_ulp_drift() {
        let a = 1.0;
        let b = 1.0000000000000002;
        assert_eq!(normalize_float_for_hash(a), normalize_float_for_hash(b));
    }

    #[test]
    fn normalize_meaningful_difference() {
        let a = 1.0;
        let b = 1.0001;
        assert_ne!(normalize_float_for_hash(a), normalize_float_for_hash(b));
    }

    #[test]
    fn normalize_preserves_large_numbers() {
        let a = 1e15;
        let b = 1e15 + 1.0;
        assert_eq!(normalize_float_for_hash(a), normalize_float_for_hash(b));
    }

    #[test]
    fn normalize_distinguishes_different_magnitudes() {
        let a = 1.0;
        let b = 2.0;
        assert_ne!(normalize_float_for_hash(a), normalize_float_for_hash(b));
    }
}

```

---

### File: `core\src\lib.rs`

```rust
//! Excel Diff: a library for comparing Excel workbooks.
//!
//! The main entry point is [`WorkbookPackage`], which can parse a workbook (when the
//! `excel-open-xml` feature is enabled) and then diff it against another workbook.
//!
//! The diff includes:
//! - sheet/grid ops (cell edits, row/column adds/removes, block moves)
//! - object ops (named ranges, charts, VBA modules)
//! - Power Query ops (M query add/remove/rename and definition/metadata changes)
//!
//! # Quick start
//!
//! ```no_run
//! use excel_diff::{DiffConfig, WorkbookPackage};
//! use std::fs::File;
//!
//! # fn main() -> Result<(), Box<dyn std::error::Error>> {
//! let old_pkg = WorkbookPackage::open(File::open("old.xlsx")?)?;
//! let new_pkg = WorkbookPackage::open(File::open("new.xlsx")?)?;
//!
//! let report = old_pkg.diff(&new_pkg, &DiffConfig::default());
//! println!("ops={}", report.ops.len());
//! # Ok(())
//! # }
//! ```
//!
//! # Streaming (JSON Lines)
//!
//! ```no_run
//! use excel_diff::{DiffConfig, JsonLinesSink, WorkbookPackage};
//! use std::fs::File;
//! use std::io::{self, BufWriter};
//!
//! # fn main() -> Result<(), Box<dyn std::error::Error>> {
//! let old_pkg = WorkbookPackage::open(File::open("old.xlsx")?)?;
//! let new_pkg = WorkbookPackage::open(File::open("new.xlsx")?)?;
//!
//! let stdout = io::stdout();
//! let mut sink = JsonLinesSink::new(BufWriter::new(stdout.lock()));
//! let summary = old_pkg.diff_streaming(&new_pkg, &DiffConfig::default(), &mut sink)?;
//! eprintln!("complete={} ops={}", summary.complete, summary.op_count);
//! # Ok(())
//! # }
//! ```
//!
//! # Database mode (key-based diff)
//!
//! ```no_run
//! use excel_diff::{DiffConfig, WorkbookPackage};
//! use std::fs::File;
//!
//! # fn main() -> Result<(), Box<dyn std::error::Error>> {
//! let old_pkg = WorkbookPackage::open(File::open("old.xlsx")?)?;
//! let new_pkg = WorkbookPackage::open(File::open("new.xlsx")?)?;
//!
//! // Key columns are 0-based indices (A=0, B=1, ...).
//! let keys: Vec<u32> = vec![0, 2]; // A,C
//! let report = old_pkg.diff_database_mode(&new_pkg, "Data", &keys, &DiffConfig::default())?;
//! println!("ops={}", report.ops.len());
//! # Ok(())
//! # }
//! ```

#![cfg_attr(not(test), deny(clippy::unwrap_used))]
#![cfg_attr(not(test), deny(clippy::expect_used))]

use std::cell::RefCell;

mod addressing;
pub(crate) mod alignment;
mod alignment_types;
pub(crate) mod column_alignment;
mod config;
mod container;
mod database_alignment;
mod datamashup;
mod datamashup_framing;
mod datamashup_package;
pub mod error_codes;
mod diff;
mod engine;
#[cfg(feature = "excel-open-xml")]
mod excel_open_xml;
mod formula;
mod formula_diff;
mod grid_metadata;
mod grid_parser;
mod grid_view;
pub(crate) mod hashing;
mod m_ast;
mod m_diff;
mod m_section;
mod object_diff;
mod output;
mod package;
mod progress;
#[cfg(feature = "perf-metrics")]
#[doc(hidden)]
pub mod perf;
pub(crate) mod rect_block_move;
pub(crate) mod region_mask;
pub(crate) mod row_alignment;
mod session;
mod sink;
mod string_pool;
mod workbook;

thread_local! {
    static DEFAULT_SESSION: RefCell<DiffSession> = RefCell::new(DiffSession::new());
}

#[doc(hidden)]
pub fn with_default_session<T>(f: impl FnOnce(&mut DiffSession) -> T) -> T {
    DEFAULT_SESSION.with(|session| {
        let mut session = session.borrow_mut();
        f(&mut session)
    })
}

#[deprecated(note = "use WorkbookPackage::diff")]
#[doc(hidden)]
pub fn diff_workbooks(old: &Workbook, new: &Workbook, config: &DiffConfig) -> DiffReport {
    DEFAULT_SESSION.with(|session| {
        let mut session = session.borrow_mut();
        engine::diff_workbooks(old, new, &mut session.strings, config)
    })
}

#[deprecated(note = "use WorkbookPackage::diff")]
#[doc(hidden)]
pub fn try_diff_workbooks(
    old: &Workbook,
    new: &Workbook,
    config: &DiffConfig,
) -> Result<DiffReport, DiffError> {
    DEFAULT_SESSION.with(|session| {
        let mut session = session.borrow_mut();
        engine::try_diff_workbooks(old, new, &mut session.strings, config)
    })
}

#[cfg(all(feature = "excel-open-xml", feature = "std-fs"))]
#[deprecated(note = "use WorkbookPackage::open")]
#[allow(deprecated)]
#[doc(hidden)]
pub fn open_workbook(path: impl AsRef<std::path::Path>) -> Result<Workbook, ExcelOpenError> {
    DEFAULT_SESSION.with(|session| {
        let mut session = session.borrow_mut();
        excel_open_xml::open_workbook(path, &mut session.strings)
    })
}

/// Advanced APIs for power users.
///
/// The recommended entry point for most callers is [`WorkbookPackage`]. This module exposes
/// lower-level functions and types for callers who want to manage their own sessions/pools or
/// stream ops directly.
pub mod advanced {
    pub use crate::engine::{
        diff_grids_database_mode, diff_workbooks as diff_workbooks_with_pool,
        diff_workbooks_streaming, diff_workbooks_streaming_with_progress, diff_workbooks_with_progress,
        try_diff_workbooks as try_diff_workbooks_with_pool, try_diff_workbooks_streaming,
        try_diff_workbooks_streaming_with_progress, try_diff_workbooks_with_progress,
    };
    pub use crate::session::DiffSession;
    pub use crate::sink::{CallbackSink, DiffSink, VecSink};
    pub use crate::string_pool::{StringId, StringPool};
}

pub use addressing::{AddressParseError, address_to_index, index_to_address};
pub use config::{DiffConfig, DiffConfigBuilder, LimitBehavior};
pub use container::{ContainerError, ContainerLimits, OpcContainer};
#[doc(hidden)]
pub use datamashup::parse_metadata;
pub use datamashup::{
    DataMashup, Metadata, Permissions, Query, QueryMetadata, build_data_mashup, build_queries,
};
pub use datamashup_framing::{DataMashupError, RawDataMashup, parse_data_mashup};
pub use datamashup_package::{
    DataMashupLimits, EmbeddedContent, PackageParts, PackageXml, SectionDocument,
    parse_package_parts, parse_package_parts_with_limits,
};
pub use diff::{
    DiffError, DiffOp, DiffReport, DiffSummary, FormulaDiffResult, QueryChangeKind,
    QueryMetadataField, SheetId,
};
#[doc(hidden)]
pub use engine::{
    diff_grids_database_mode, diff_workbooks as diff_workbooks_with_pool, diff_workbooks_streaming,
    diff_workbooks_streaming_with_progress, diff_workbooks_with_progress,
    try_diff_workbooks as try_diff_workbooks_with_pool, try_diff_workbooks_streaming,
    try_diff_workbooks_streaming_with_progress, try_diff_workbooks_with_progress,
};
#[cfg(feature = "excel-open-xml")]
#[allow(deprecated)]
#[doc(hidden)]
pub use excel_open_xml::{ExcelOpenError, PackageError};
#[cfg(all(feature = "excel-open-xml", feature = "std-fs"))]
#[allow(deprecated)]
#[doc(hidden)]
pub use excel_open_xml::{open_data_mashup, open_workbook as open_workbook_with_pool};
pub use formula::{
    BinaryOperator, CellReference, ColRef, ExcelError, FormulaExpr, FormulaParseError,
    RangeReference, RowRef, UnaryOperator, formulas_equivalent_modulo_shift, parse_formula,
};
pub use grid_parser::{GridParseError, SheetDescriptor};
pub use grid_view::{
    ColHash, ColMeta, FrequencyClass, GridView, HashStats, RowHash, RowMeta, RowView,
};
#[doc(hidden)]
pub use m_ast::{MAstKind, MTokenDebug, tokenize_for_testing};
pub use m_ast::{
    MModuleAst, MParseError, ast_semantically_equal, canonicalize_m_ast, parse_m_expression,
};
pub use m_section::{SectionMember, SectionParseError, parse_section_members};
#[doc(hidden)]
pub use output::json::diff_report_to_cell_diffs;
#[cfg(all(feature = "excel-open-xml", feature = "std-fs"))]
#[doc(hidden)]
pub use output::json::diff_workbooks_to_json;
pub use output::json::{CellDiff, serialize_cell_diffs, serialize_diff_report};
pub use output::json_lines::JsonLinesSink;
pub use package::{VbaModule, VbaModuleType, WorkbookPackage};
pub use progress::{NoProgress, ProgressCallback};
pub use session::DiffSession;
pub use sink::{CallbackSink, DiffSink, VecSink};
pub use string_pool::{StringId, StringPool};
pub use workbook::{
    Cell, CellAddress, CellSnapshot, CellValue, ChartInfo, ChartObject, ColSignature, Grid,
    NamedRange, RowSignature, Sheet, SheetKind, Workbook,
};
pub use database_alignment::suggest_key_columns;

```

---

### File: `core\src\m_ast.rs`

```rust
use std::iter::Peekable;
use std::str::Chars;

use thiserror::Error;

#[derive(Clone, Debug, PartialEq, Eq, Hash)]
pub struct MModuleAst {
    root: MExpr,
}

#[derive(Clone, Debug, PartialEq, Eq)]
pub enum MAstKind {
    Let { binding_count: usize },
    Record { field_count: usize },
    List { item_count: usize },
    FunctionCall { name: String, arg_count: usize },
    Primitive,
    Opaque { token_count: usize },
}

#[derive(Clone, Debug, PartialEq, Eq, Hash)]
enum MExpr {
    Let {
        bindings: Vec<LetBinding>,
        body: Box<MExpr>,
    },
    Record {
        fields: Vec<RecordField>,
    },
    List {
        items: Vec<MExpr>,
    },
    FunctionCall {
        name: String,
        args: Vec<MExpr>,
    },
    Primitive(MPrimitive),
    Opaque(Vec<MToken>),
}

#[derive(Clone, Debug, PartialEq, Eq, Hash)]
struct LetBinding {
    name: String,
    value: Box<MExpr>,
}

#[derive(Clone, Debug, PartialEq, Eq, Hash)]
struct RecordField {
    name: String,
    value: Box<MExpr>,
}

#[derive(Clone, Debug, PartialEq, Eq, Hash)]
enum MPrimitive {
    String(String),
    Number(String),
    Boolean(bool),
    Null,
}

#[derive(Clone, Debug, PartialEq, Eq, Hash)]
enum MToken {
    KeywordLet,
    KeywordIn,
    Identifier(String),
    StringLiteral(String),
    Number(String),
    Symbol(char),
}

#[derive(Clone, Debug, PartialEq, Eq)]
pub enum MTokenDebug {
    KeywordLet,
    KeywordIn,
    Identifier(String),
    StringLiteral(String),
    Number(String),
    Symbol(char),
}

#[derive(Debug, Error, PartialEq, Eq)]
pub enum MParseError {
    #[error("expression is empty")]
    Empty,
    #[error("unterminated string literal")]
    UnterminatedString,
    #[error("unterminated block comment")]
    UnterminatedBlockComment,
    #[error("unbalanced delimiter")]
    UnbalancedDelimiter,
    #[error("invalid let binding syntax")]
    InvalidLetBinding,
    #[error("missing 'in' clause in let expression")]
    MissingInClause,
}

impl From<&MToken> for MTokenDebug {
    fn from(token: &MToken) -> Self {
        match token {
            MToken::KeywordLet => MTokenDebug::KeywordLet,
            MToken::KeywordIn => MTokenDebug::KeywordIn,
            MToken::Identifier(v) => MTokenDebug::Identifier(v.clone()),
            MToken::StringLiteral(v) => MTokenDebug::StringLiteral(v.clone()),
            MToken::Number(v) => MTokenDebug::Number(v.clone()),
            MToken::Symbol(v) => MTokenDebug::Symbol(*v),
        }
    }
}

impl MModuleAst {
    /// Returns a minimal view of the root expression kind for tests and debugging.
    ///
    /// This keeps the AST opaque for production consumers while allowing
    /// tests to assert the expected structure.
    pub fn root_kind_for_testing(&self) -> MAstKind {
        match &self.root {
            MExpr::Let { bindings, .. } => MAstKind::Let {
                binding_count: bindings.len(),
            },
            MExpr::Record { fields } => MAstKind::Record {
                field_count: fields.len(),
            },
            MExpr::List { items } => MAstKind::List {
                item_count: items.len(),
            },
            MExpr::FunctionCall { name, args } => MAstKind::FunctionCall {
                name: name.clone(),
                arg_count: args.len(),
            },
            MExpr::Primitive(_) => MAstKind::Primitive,
            MExpr::Opaque(tokens) => MAstKind::Opaque {
                token_count: tokens.len(),
            },
        }
    }
}

/// Tokenize an M expression for testing and diagnostics.
///
/// The returned tokens are a debug-friendly mirror of the internal lexer output
/// and are not part of the stable public API.
pub fn tokenize_for_testing(source: &str) -> Result<Vec<MTokenDebug>, MParseError> {
    tokenize(source).map(|tokens| tokens.iter().map(MTokenDebug::from).collect())
}

/// Parse a Power Query M expression into a minimal AST.
///
/// Supports top-level `let ... in ...` expressions, record and list literals,
/// qualified function calls, and primitive literals. Inputs that do not match
/// those forms are preserved as opaque token sequences. The lexer recognizes
/// `let`/`in`, quoted identifiers (`#"Foo"`), and hash-prefixed literals like
/// `#date`/`#datetime` as single identifiers; other M constructs are parsed
/// best-effort and may be treated as generic tokens.
pub fn parse_m_expression(source: &str) -> Result<MModuleAst, MParseError> {
    let tokens = tokenize(source)?;
    if tokens.is_empty() {
        return Err(MParseError::Empty);
    }

    let root = parse_expression(&tokens)?;
    Ok(MModuleAst { root })
}

pub fn canonicalize_m_ast(ast: &mut MModuleAst) {
    canonicalize_expr(&mut ast.root);
}

pub fn ast_semantically_equal(a: &MModuleAst, b: &MModuleAst) -> bool {
    a == b
}

fn canonicalize_expr(expr: &mut MExpr) {
    match expr {
        MExpr::Let { bindings, body } => {
            for binding in bindings {
                canonicalize_expr(&mut binding.value);
            }
            canonicalize_expr(body);
        }
        MExpr::Record { fields } => {
            for field in fields.iter_mut() {
                canonicalize_expr(&mut field.value);
            }
            fields.sort_by(|a, b| a.name.cmp(&b.name));
        }
        MExpr::List { items } => {
            for item in items {
                canonicalize_expr(item);
            }
        }
        MExpr::FunctionCall { args, .. } => {
            for arg in args {
                canonicalize_expr(arg);
            }
        }
        MExpr::Primitive(_) => {}
        MExpr::Opaque(tokens) => canonicalize_tokens(tokens),
    }
}

fn canonicalize_tokens(tokens: &mut Vec<MToken>) {
    for token in tokens.iter_mut() {
        let MToken::Identifier(ident) = token else {
            continue;
        };

        if ident.eq_ignore_ascii_case("true") {
            *ident = "true".to_string();
        } else if ident.eq_ignore_ascii_case("false") {
            *ident = "false".to_string();
        } else if ident.eq_ignore_ascii_case("null") {
            *ident = "null".to_string();
        }
    }
}

fn parse_expression(tokens: &[MToken]) -> Result<MExpr, MParseError> {
    if tokens.is_empty() {
        return Err(MParseError::Empty);
    }

    if let Some(let_ast) = parse_let(tokens)? {
        return Ok(let_ast);
    }

    if let Some(inner) = strip_wrapping_parens(tokens) {
        if !inner.is_empty() {
            return parse_expression(inner);
        }
    }

    if let Some(rec) = parse_record_literal(tokens)? {
        return Ok(rec);
    }
    if let Some(list) = parse_list_literal(tokens)? {
        return Ok(list);
    }
    if let Some(call) = parse_function_call(tokens)? {
        return Ok(call);
    }
    if let Some(prim) = parse_primitive(tokens) {
        return Ok(prim);
    }

    Ok(MExpr::Opaque(tokens.to_vec()))
}

fn strip_wrapping_parens(tokens: &[MToken]) -> Option<&[MToken]> {
    if tokens.len() < 2 {
        return None;
    }
    if !matches!(tokens.first(), Some(MToken::Symbol('('))) {
        return None;
    }
    if !matches!(tokens.last(), Some(MToken::Symbol(')'))) {
        return None;
    }

    let mut depth = 0i32;
    for (i, tok) in tokens.iter().enumerate() {
        match tok {
            MToken::Symbol('(') => depth += 1,
            MToken::Symbol(')') => {
                depth -= 1;
                if depth == 0 && i != tokens.len() - 1 {
                    return None;
                }
            }
            _ => {}
        }
    }

    if depth != 0 {
        return None;
    }

    Some(&tokens[1..tokens.len() - 1])
}

fn split_top_level(tokens: &[MToken], delimiter: char) -> Vec<&[MToken]> {
    let mut out = Vec::new();
    let mut start = 0usize;
    let mut depth = 0i32;
    let mut let_depth = 0i32;

    for (i, tok) in tokens.iter().enumerate() {
        match tok {
            MToken::Symbol('(') | MToken::Symbol('[') | MToken::Symbol('{') => depth += 1,
            MToken::Symbol(')') | MToken::Symbol(']') | MToken::Symbol('}') => {
                if depth > 0 {
                    depth -= 1;
                }
            }
            MToken::KeywordLet => let_depth += 1,
            MToken::KeywordIn => {
                if let_depth > 0 {
                    let_depth -= 1;
                }
            }
            MToken::Symbol(c) if *c == delimiter && depth == 0 && let_depth == 0 => {
                out.push(&tokens[start..i]);
                start = i + 1;
            }
            _ => {}
        }
    }

    out.push(&tokens[start..]);
    out
}

fn parse_record_literal(tokens: &[MToken]) -> Result<Option<MExpr>, MParseError> {
    if tokens.len() < 2 {
        return Ok(None);
    }
    if !matches!(tokens.first(), Some(MToken::Symbol('['))) {
        return Ok(None);
    }
    if !matches!(tokens.last(), Some(MToken::Symbol(']'))) {
        return Ok(None);
    }

    let inner = &tokens[1..tokens.len() - 1];
    if inner.is_empty() {
        return Ok(Some(MExpr::Record { fields: Vec::new() }));
    }

    let parts = split_top_level(inner, ',');
    let mut fields = Vec::with_capacity(parts.len());

    for part in parts {
        if part.len() < 3 {
            return Ok(None);
        }

        let name = match &part[0] {
            MToken::Identifier(v) => v.clone(),
            MToken::StringLiteral(v) => v.clone(),
            _ => return Ok(None),
        };

        if !matches!(part[1], MToken::Symbol('=')) {
            return Ok(None);
        }

        let value_tokens = &part[2..];
        if value_tokens.is_empty() {
            return Ok(None);
        }

        let value_expr = parse_expression(value_tokens)?;
        fields.push(RecordField {
            name,
            value: Box::new(value_expr),
        });
    }

    Ok(Some(MExpr::Record { fields }))
}

fn parse_list_literal(tokens: &[MToken]) -> Result<Option<MExpr>, MParseError> {
    if tokens.len() < 2 {
        return Ok(None);
    }
    if !matches!(tokens.first(), Some(MToken::Symbol('{'))) {
        return Ok(None);
    }
    if !matches!(tokens.last(), Some(MToken::Symbol('}'))) {
        return Ok(None);
    }

    let inner = &tokens[1..tokens.len() - 1];
    if inner.is_empty() {
        return Ok(Some(MExpr::List { items: Vec::new() }));
    }

    let parts = split_top_level(inner, ',');
    let mut items = Vec::with_capacity(parts.len());
    for part in parts {
        if part.is_empty() {
            return Ok(None);
        }
        items.push(parse_expression(part)?);
    }

    Ok(Some(MExpr::List { items }))
}

fn parse_function_call(tokens: &[MToken]) -> Result<Option<MExpr>, MParseError> {
    if tokens.len() < 3 {
        return Ok(None);
    }
    if matches!(tokens.first(), Some(MToken::Symbol('('))) {
        return Ok(None);
    }

    let mut open_idx = None;
    let mut depth = 0i32;
    let mut let_depth = 0i32;

    for (i, tok) in tokens.iter().enumerate() {
        match tok {
            MToken::Symbol('(') => {
                if depth == 0 && let_depth == 0 {
                    open_idx = Some(i);
                    break;
                }
                depth += 1;
            }
            MToken::Symbol('[') | MToken::Symbol('{') => depth += 1,
            MToken::Symbol(')') | MToken::Symbol(']') | MToken::Symbol('}') => {
                if depth > 0 {
                    depth -= 1;
                }
            }
            MToken::KeywordLet => let_depth += 1,
            MToken::KeywordIn => {
                if let_depth > 0 {
                    let_depth -= 1;
                }
            }
            _ => {}
        }
    }

    let open_idx = match open_idx {
        Some(i) if i > 0 => i,
        _ => return Ok(None),
    };

    if !matches!(tokens.last(), Some(MToken::Symbol(')'))) {
        return Ok(None);
    }

    let mut suffix_depth = 0i32;
    for (i, tok) in tokens[open_idx..].iter().enumerate() {
        match tok {
            MToken::Symbol('(') | MToken::Symbol('[') | MToken::Symbol('{') => suffix_depth += 1,
            MToken::Symbol(')') | MToken::Symbol(']') | MToken::Symbol('}') => {
                if suffix_depth > 0 {
                    suffix_depth -= 1;
                }
                if suffix_depth == 0 && i != tokens.len() - open_idx - 1 {
                    return Ok(None);
                }
            }
            _ => {}
        }
    }

    if suffix_depth != 0 {
        return Ok(None);
    }

    let name = match parse_qualified_name(&tokens[..open_idx]) {
        Some(v) => v,
        None => return Ok(None),
    };

    let arg_tokens = &tokens[open_idx + 1..tokens.len() - 1];
    let args = if arg_tokens.is_empty() {
        Vec::new()
    } else {
        let parts = split_top_level(arg_tokens, ',');
        let mut args = Vec::with_capacity(parts.len());
        for part in parts {
            if part.is_empty() {
                return Ok(None);
            }
            args.push(parse_expression(part)?);
        }
        args
    };

    Ok(Some(MExpr::FunctionCall { name, args }))
}

fn parse_qualified_name(tokens: &[MToken]) -> Option<String> {
    if tokens.is_empty() {
        return None;
    }

    let mut parts = Vec::new();
    let mut i = 0usize;

    match &tokens[i] {
        MToken::Identifier(v) => parts.push(v.clone()),
        _ => return None,
    }
    i += 1;

    while i < tokens.len() {
        match (&tokens[i], tokens.get(i + 1)) {
            (MToken::Symbol('.'), Some(MToken::Identifier(v))) => {
                parts.push(v.clone());
                i += 2;
            }
            _ => return None,
        }
    }

    Some(parts.join("."))
}

fn parse_primitive(tokens: &[MToken]) -> Option<MExpr> {
    if tokens.len() == 1 {
        match &tokens[0] {
            MToken::StringLiteral(v) => {
                return Some(MExpr::Primitive(MPrimitive::String(v.clone())));
            }
            MToken::Number(v) => {
                return Some(MExpr::Primitive(MPrimitive::Number(v.clone())));
            }
            MToken::Identifier(v) => {
                if v.eq_ignore_ascii_case("true") {
                    return Some(MExpr::Primitive(MPrimitive::Boolean(true)));
                }
                if v.eq_ignore_ascii_case("false") {
                    return Some(MExpr::Primitive(MPrimitive::Boolean(false)));
                }
                if v.eq_ignore_ascii_case("null") {
                    return Some(MExpr::Primitive(MPrimitive::Null));
                }
            }
            _ => {}
        }
    }

    if tokens.len() == 2 {
        if matches!(tokens[0], MToken::Symbol('-')) {
            if let MToken::Number(v) = &tokens[1] {
                return Some(MExpr::Primitive(MPrimitive::Number(format!("-{}", v))));
            }
        }
    }

    None
}

fn parse_let(tokens: &[MToken]) -> Result<Option<MExpr>, MParseError> {
    if tokens.is_empty() {
        return Err(MParseError::Empty);
    }
    if !matches!(tokens.first(), Some(MToken::KeywordLet)) {
        return Ok(None);
    }

    let mut idx = 1usize;
    let mut bindings = Vec::new();
    let mut found_in = false;

    while idx < tokens.len() {
        if matches!(tokens.get(idx), Some(MToken::KeywordIn)) {
            found_in = true;
            idx += 1;
            break;
        }

        let name = match tokens.get(idx) {
            Some(MToken::Identifier(name)) => name.clone(),
            _ => return Err(MParseError::InvalidLetBinding),
        };
        idx += 1;

        if !matches!(tokens.get(idx), Some(MToken::Symbol('='))) {
            return Err(MParseError::InvalidLetBinding);
        }
        idx += 1;

        let value_start = idx;
        let mut value_end = None;
        let mut depth = 0i32;
        let mut let_depth_in_value = 0i32;

        while idx < tokens.len() {
            match tokens.get(idx) {
                Some(MToken::KeywordLet) => {
                    let_depth_in_value += 1;
                }
                Some(MToken::KeywordIn) => {
                    if let_depth_in_value > 0 {
                        let_depth_in_value -= 1;
                    } else if depth == 0 {
                        value_end = Some(idx);
                        break;
                    }
                }
                Some(MToken::Symbol(c)) if is_open_delimiter(*c) => depth += 1,
                Some(MToken::Symbol(c)) if is_close_delimiter(*c) => {
                    if depth > 0 {
                        depth -= 1;
                    }
                }
                Some(MToken::Symbol(',')) if depth == 0 && let_depth_in_value == 0 => {
                    value_end = Some(idx);
                    break;
                }
                _ => {}
            }
            idx += 1;
        }

        let value_end = value_end.unwrap_or(idx);
        if value_end <= value_start {
            return Err(MParseError::InvalidLetBinding);
        }

        let value_tokens = &tokens[value_start..value_end];
        let value_expr = parse_expression(value_tokens)?;

        bindings.push(LetBinding {
            name,
            value: Box::new(value_expr),
        });

        idx = value_end;
        if matches!(tokens.get(idx), Some(MToken::Symbol(','))) {
            idx += 1;
        }
    }

    if !found_in {
        return Err(MParseError::MissingInClause);
    }
    if idx >= tokens.len() {
        return Err(MParseError::InvalidLetBinding);
    }

    let body_expr = parse_expression(&tokens[idx..])?;
    Ok(Some(MExpr::Let {
        bindings,
        body: Box::new(body_expr),
    }))
}

fn tokenize(source: &str) -> Result<Vec<MToken>, MParseError> {
    let mut tokens = Vec::new();
    let mut chars = source.chars().peekable();
    let mut delimiters: Vec<char> = Vec::new();

    while let Some(ch) = chars.next() {
        if ch.is_whitespace() {
            continue;
        }

        if ch == '/' {
            if matches!(chars.peek(), Some('/')) {
                skip_line_comment(&mut chars);
                continue;
            }
            if matches!(chars.peek(), Some('*')) {
                chars.next();
                skip_block_comment(&mut chars)?;
                continue;
            }
        }

        if ch == '"' {
            let literal = parse_string(&mut chars)?;
            tokens.push(MToken::StringLiteral(literal));
            continue;
        }

        if ch == '#' {
            if matches!(chars.peek(), Some('"')) {
                chars.next();
                let ident = parse_string(&mut chars)?;
                tokens.push(MToken::Identifier(ident));
                continue;
            }
            if let Some(next) = chars.peek().copied()
                && is_identifier_start(next)
            {
                chars.next();
                let ident = parse_identifier(next, &mut chars);
                tokens.push(MToken::Identifier(format!("#{ident}")));
                continue;
            }
            tokens.push(MToken::Symbol('#'));
            continue;
        }

        if is_identifier_start(ch) {
            let ident = parse_identifier(ch, &mut chars);
            if ident.eq_ignore_ascii_case("let") {
                tokens.push(MToken::KeywordLet);
            } else if ident.eq_ignore_ascii_case("in") {
                tokens.push(MToken::KeywordIn);
            } else {
                tokens.push(MToken::Identifier(ident));
            }
            continue;
        }

        if ch.is_ascii_digit() {
            let number = parse_number(ch, &mut chars);
            tokens.push(MToken::Number(number));
            continue;
        }

        if is_open_delimiter(ch) {
            delimiters.push(ch);
        } else if is_close_delimiter(ch) {
            let Some(open) = delimiters.pop() else {
                return Err(MParseError::UnbalancedDelimiter);
            };
            if !delimiters_match(open, ch) {
                return Err(MParseError::UnbalancedDelimiter);
            }
        }

        tokens.push(MToken::Symbol(ch));
    }

    if !delimiters.is_empty() {
        return Err(MParseError::UnbalancedDelimiter);
    }

    Ok(tokens)
}

#[allow(clippy::while_let_on_iterator)]
fn skip_line_comment(chars: &mut Peekable<Chars<'_>>) {
    while let Some(ch) = chars.next() {
        if ch == '\n' {
            break;
        }
    }
}

#[allow(clippy::while_let_on_iterator)]
fn skip_block_comment(chars: &mut Peekable<Chars<'_>>) -> Result<(), MParseError> {
    while let Some(ch) = chars.next() {
        if ch == '*' && matches!(chars.peek(), Some('/')) {
            chars.next();
            return Ok(());
        }
    }

    Err(MParseError::UnterminatedBlockComment)
}

fn parse_string(chars: &mut Peekable<Chars<'_>>) -> Result<String, MParseError> {
    let mut buf = String::new();

    while let Some(ch) = chars.next() {
        if ch == '"' {
            if matches!(chars.peek(), Some('"')) {
                buf.push('"');
                chars.next();
                continue;
            }
            return Ok(buf);
        }

        buf.push(ch);
    }

    Err(MParseError::UnterminatedString)
}

fn parse_identifier(first: char, chars: &mut Peekable<Chars<'_>>) -> String {
    let mut ident = String::new();
    ident.push(first);

    while let Some(&next) = chars.peek() {
        if is_identifier_continue(next) {
            ident.push(next);
            chars.next();
        } else {
            break;
        }
    }

    ident
}

fn parse_number(first: char, chars: &mut Peekable<Chars<'_>>) -> String {
    let mut number = String::new();
    number.push(first);

    while let Some(&next) = chars.peek() {
        if next.is_ascii_digit() || next == '.' {
            number.push(next);
            chars.next();
        } else {
            break;
        }
    }

    number
}

fn is_identifier_start(ch: char) -> bool {
    ch.is_ascii_alphabetic() || ch == '_'
}

fn is_identifier_continue(ch: char) -> bool {
    ch.is_ascii_alphanumeric() || ch == '_'
}

fn is_open_delimiter(ch: char) -> bool {
    matches!(ch, '(' | '[' | '{')
}

fn is_close_delimiter(ch: char) -> bool {
    matches!(ch, ')' | ']' | '}')
}

fn delimiters_match(open: char, close: char) -> bool {
    matches!((open, close), ('(', ')') | ('[', ']') | ('{', '}'))
}

```

---

### File: `core\src\m_diff.rs`

```rust
use std::collections::{BTreeMap, BTreeSet};
use std::hash::{Hash, Hasher};

use crate::config::DiffConfig;
use crate::datamashup::{DataMashup, Query, build_queries};
use crate::diff::{DiffOp, QueryChangeKind as DiffQueryChangeKind, QueryMetadataField};
use crate::hashing::XXH64_SEED;
use crate::m_ast::{MModuleAst, canonicalize_m_ast, parse_m_expression};
use crate::string_pool::{StringId, StringPool};

#[deprecated(note = "use WorkbookPackage::diff instead")]
#[cfg(any(test, feature = "dev-apis"))]
pub fn diff_m_queries(
    old_queries: &[Query],
    new_queries: &[Query],
    config: &DiffConfig,
) -> Vec<DiffOp> {
    crate::with_default_session(|session| {
        diff_queries_to_ops(old_queries, new_queries, &mut session.strings, config)
    })
}

fn hash64<T: Hash>(value: &T) -> u64 {
    let mut h = xxhash_rust::xxh64::Xxh64::new(XXH64_SEED);
    value.hash(&mut h);
    h.finish()
}

fn intern_bool(pool: &mut StringPool, v: bool) -> StringId {
    if v {
        pool.intern("true")
    } else {
        pool.intern("false")
    }
}

fn canonical_ast_and_hash(expr: &str) -> Option<(MModuleAst, u64)> {
    let mut ast = parse_m_expression(expr).ok()?;
    canonicalize_m_ast(&mut ast);
    let h = hash64(&ast);
    Some((ast, h))
}

fn definition_change(
    old_expr: &str,
    new_expr: &str,
    enable_semantic: bool,
) -> Option<(DiffQueryChangeKind, u64, u64)> {
    if old_expr == new_expr {
        return None;
    }

    if enable_semantic {
        if let (Some((_, old_h)), Some((_, new_h))) = (
            canonical_ast_and_hash(old_expr),
            canonical_ast_and_hash(new_expr),
        ) {
            let kind = if old_h == new_h {
                DiffQueryChangeKind::FormattingOnly
            } else {
                DiffQueryChangeKind::Semantic
            };
            return Some((kind, old_h, new_h));
        }
    }

    let old_h = hash64(&old_expr);
    let new_h = hash64(&new_expr);
    Some((DiffQueryChangeKind::Semantic, old_h, new_h))
}

fn emit_metadata_diffs(
    pool: &mut StringPool,
    out: &mut Vec<DiffOp>,
    name: StringId,
    old_q: &Query,
    new_q: &Query,
) {
    if old_q.metadata.load_to_sheet != new_q.metadata.load_to_sheet {
        out.push(DiffOp::QueryMetadataChanged {
            name,
            field: QueryMetadataField::LoadToSheet,
            old: Some(intern_bool(pool, old_q.metadata.load_to_sheet)),
            new: Some(intern_bool(pool, new_q.metadata.load_to_sheet)),
        });
    }

    if old_q.metadata.load_to_model != new_q.metadata.load_to_model {
        out.push(DiffOp::QueryMetadataChanged {
            name,
            field: QueryMetadataField::LoadToModel,
            old: Some(intern_bool(pool, old_q.metadata.load_to_model)),
            new: Some(intern_bool(pool, new_q.metadata.load_to_model)),
        });
    }

    if old_q.metadata.is_connection_only != new_q.metadata.is_connection_only {
        out.push(DiffOp::QueryMetadataChanged {
            name,
            field: QueryMetadataField::ConnectionOnly,
            old: Some(intern_bool(pool, old_q.metadata.is_connection_only)),
            new: Some(intern_bool(pool, new_q.metadata.is_connection_only)),
        });
    }

    if old_q.metadata.group_path != new_q.metadata.group_path {
        let old = old_q.metadata.group_path.as_deref().map(|s| pool.intern(s));
        let new = new_q.metadata.group_path.as_deref().map(|s| pool.intern(s));
        out.push(DiffOp::QueryMetadataChanged {
            name,
            field: QueryMetadataField::GroupPath,
            old,
            new,
        });
    }
}

fn diff_queries_to_ops(
    old_queries: &[Query],
    new_queries: &[Query],
    pool: &mut StringPool,
    config: &DiffConfig,
) -> Vec<DiffOp> {
    let mut old_by_name: BTreeMap<&str, &Query> = BTreeMap::new();
    let mut new_by_name: BTreeMap<&str, &Query> = BTreeMap::new();

    for q in old_queries {
        old_by_name.insert(q.name.as_str(), q);
    }
    for q in new_queries {
        new_by_name.insert(q.name.as_str(), q);
    }

    let old_only: Vec<&Query> = old_by_name
        .iter()
        .filter_map(|(name, q)| {
            if new_by_name.contains_key(*name) {
                None
            } else {
                Some(*q)
            }
        })
        .collect();

    let new_only: Vec<&Query> = new_by_name
        .iter()
        .filter_map(|(name, q)| {
            if old_by_name.contains_key(*name) {
                None
            } else {
                Some(*q)
            }
        })
        .collect();

    let mut renamed_old: BTreeSet<&str> = BTreeSet::new();
    let mut renamed_new: BTreeSet<&str> = BTreeSet::new();
    let mut rename_ops: Vec<(StringId, StringId, &Query, &Query)> = Vec::new();

    let mut old_hash_map: BTreeMap<u64, Vec<&Query>> = BTreeMap::new();
    let mut new_hash_map: BTreeMap<u64, Vec<&Query>> = BTreeMap::new();

    for q in &old_only {
        let h = if config.enable_m_semantic_diff {
            canonical_ast_and_hash(&q.expression_m)
                .map(|(_, h)| h)
                .unwrap_or_else(|| hash64(&q.expression_m))
        } else {
            hash64(&q.expression_m)
        };
        old_hash_map.entry(h).or_default().push(*q);
    }

    for q in &new_only {
        let h = if config.enable_m_semantic_diff {
            canonical_ast_and_hash(&q.expression_m)
                .map(|(_, h)| h)
                .unwrap_or_else(|| hash64(&q.expression_m))
        } else {
            hash64(&q.expression_m)
        };
        new_hash_map.entry(h).or_default().push(*q);
    }

    for (h, olds) in &old_hash_map {
        if let Some(news) = new_hash_map.get(h) {
            if olds.len() == 1 && news.len() == 1 {
                let old_q = olds[0];
                let new_q = news[0];
                let from = pool.intern(old_q.name.as_str());
                let to = pool.intern(new_q.name.as_str());
                renamed_old.insert(old_q.name.as_str());
                renamed_new.insert(new_q.name.as_str());
                rename_ops.push((from, to, old_q, new_q));
            }
        }
    }

    rename_ops.sort_by(|a, b| {
        let from_a = pool.resolve(a.0);
        let from_b = pool.resolve(b.0);
        from_a.cmp(from_b)
    });

    let mut ops: Vec<DiffOp> = Vec::new();

    for (from, to, old_q, new_q) in rename_ops {
        ops.push(DiffOp::QueryRenamed { from, to });
        emit_metadata_diffs(pool, &mut ops, to, old_q, new_q);
    }

    let mut all_names: Vec<&str> = old_by_name
        .keys()
        .copied()
        .chain(new_by_name.keys().copied())
        .collect();
    all_names.sort();
    all_names.dedup();

    for name in all_names {
        if renamed_old.contains(name) || renamed_new.contains(name) {
            continue;
        }

        match (old_by_name.get(name), new_by_name.get(name)) {
            (None, Some(_new_q)) => {
                ops.push(DiffOp::QueryAdded {
                    name: pool.intern(name),
                });
            }
            (Some(_old_q), None) => {
                ops.push(DiffOp::QueryRemoved {
                    name: pool.intern(name),
                });
            }
            (Some(old_q), Some(new_q)) => {
                let name_id = pool.intern(name);

                if let Some((kind, old_h, new_h)) = definition_change(
                    &old_q.expression_m,
                    &new_q.expression_m,
                    config.enable_m_semantic_diff,
                ) {
                    ops.push(DiffOp::QueryDefinitionChanged {
                        name: name_id,
                        change_kind: kind,
                        old_hash: old_h,
                        new_hash: new_h,
                    });
                }

                emit_metadata_diffs(pool, &mut ops, name_id, old_q, new_q);
            }
            (None, None) => {}
        }
    }

    ops
}

pub(crate) fn diff_m_ops_for_packages(
    old_dm: &Option<DataMashup>,
    new_dm: &Option<DataMashup>,
    pool: &mut StringPool,
    config: &DiffConfig,
) -> Vec<DiffOp> {
    match (old_dm.as_ref(), new_dm.as_ref()) {
        (None, None) => Vec::new(),
        (Some(old_dm), None) => {
            let old_q = match build_queries(old_dm) {
                Ok(v) => v,
                Err(_) => return Vec::new(),
            };
            let mut ops = Vec::new();
            for q in old_q {
                ops.push(DiffOp::QueryRemoved {
                    name: pool.intern(&q.name),
                });
            }
            ops
        }
        (None, Some(new_dm)) => {
            let new_q = match build_queries(new_dm) {
                Ok(v) => v,
                Err(_) => return Vec::new(),
            };
            let mut ops = Vec::new();
            for q in new_q {
                ops.push(DiffOp::QueryAdded {
                    name: pool.intern(&q.name),
                });
            }
            ops
        }
        (Some(old_dm), Some(new_dm)) => {
            let old_q = match build_queries(old_dm) {
                Ok(v) => v,
                Err(_) => return Vec::new(),
            };
            let new_q = match build_queries(new_dm) {
                Ok(v) => v,
                Err(_) => return Vec::new(),
            };
            diff_queries_to_ops(&old_q, &new_q, pool, config)
        }
    }
}

```

---

### File: `core\src\m_section.rs`

```rust
use std::str::Lines;

#[derive(Debug, thiserror::Error, PartialEq, Eq)]
pub enum SectionParseError {
    #[error("missing section header")]
    MissingSectionHeader,
    #[error("invalid section header")]
    InvalidHeader,
    #[error("invalid member syntax")]
    InvalidMemberSyntax,
}

#[derive(Debug, Clone, PartialEq, Eq)]
pub struct SectionMember {
    pub section_name: String,
    pub member_name: String,
    pub expression_m: String,
    pub is_shared: bool,
}

pub fn parse_section_members(source: &str) -> Result<Vec<SectionMember>, SectionParseError> {
    let source = strip_leading_bom(source);
    let mut lines = source.lines();
    let section_name = find_section_name(&mut lines)?;

    let mut members = Vec::new();
    while let Some(line) = lines.next() {
        let trimmed = line.trim();
        if trimmed.is_empty() || trimmed.starts_with("//") {
            continue;
        }

        if !trimmed.starts_with("shared") {
            continue;
        }

        let member = parse_shared_member(trimmed, &mut lines, &section_name)
            .ok_or(SectionParseError::InvalidMemberSyntax)?;
        members.push(member);
    }

    Ok(members)
}

fn find_section_name(lines: &mut Lines<'_>) -> Result<String, SectionParseError> {
    for line in lines.by_ref() {
        let trimmed = line.trim();
        if trimmed.is_empty() || trimmed.starts_with("//") {
            continue;
        }

        match try_parse_section_header(trimmed) {
            Ok(Some(name)) => return Ok(name),
            Ok(None) => continue,
            Err(err) => return Err(err),
        }
    }

    Err(SectionParseError::MissingSectionHeader)
}

fn try_parse_section_header(line: &str) -> Result<Option<String>, SectionParseError> {
    let Some(rest) = line.strip_prefix("section") else {
        return Ok(None);
    };

    if !rest.starts_with(char::is_whitespace) && !rest.is_empty() {
        return Err(SectionParseError::InvalidHeader);
    }

    let header_body = rest.trim_start();
    if !header_body.ends_with(';') {
        return Err(SectionParseError::InvalidHeader);
    }

    let without_semicolon = &header_body[..header_body.len() - 1];
    let name_candidate = without_semicolon.trim();
    if name_candidate.is_empty() {
        return Err(SectionParseError::InvalidHeader);
    }

    let mut parts = name_candidate.split_whitespace();
    let name = parts.next().ok_or(SectionParseError::InvalidHeader)?;
    if parts.next().is_some() {
        return Err(SectionParseError::InvalidHeader);
    }

    if !is_valid_identifier(name) {
        return Err(SectionParseError::InvalidHeader);
    }

    Ok(Some(name.to_string()))
}

fn parse_shared_member(
    line: &str,
    remaining_lines: &mut Lines<'_>,
    section_name: &str,
) -> Option<SectionMember> {
    let rest = line.strip_prefix("shared")?;
    if !rest.starts_with(char::is_whitespace) && !rest.is_empty() {
        return None;
    }

    let body = rest.trim_start();
    if body.is_empty() {
        return None;
    }

    let (member_name, after_name) = parse_identifier(body)?;

    let mut expression_source = after_name;
    let eq_index = expression_source.find('=')?;
    if !expression_source[..eq_index].trim().is_empty() {
        return None;
    }
    expression_source = &expression_source[eq_index + 1..];

    let mut expression = expression_source.to_string();
    if let Some(idx) = expression_source.find(';') {
        expression.truncate(idx);
    } else {
        let mut terminator_index = None;
        while terminator_index.is_none() {
            let Some(next_line) = remaining_lines.next() else {
                break;
            };

            expression.push('\n');
            let offset = expression.len();
            expression.push_str(next_line);
            if let Some(idx) = next_line.find(';') {
                terminator_index = Some(offset + idx);
            }
        }

        if let Some(idx) = terminator_index {
            expression.truncate(idx);
        } else {
            return None;
        }
    }

    let expression_m = expression.trim().to_string();

    Some(SectionMember {
        section_name: section_name.to_string(),
        member_name: member_name.to_string(),
        expression_m,
        is_shared: true,
    })
}

fn parse_identifier(text: &str) -> Option<(String, &str)> {
    let trimmed = text.trim_start();
    if trimmed.is_empty() {
        return None;
    }

    if trimmed.starts_with("#\"") {
        return parse_quoted_identifier(trimmed);
    }

    parse_unquoted_identifier(trimmed)
}

fn parse_unquoted_identifier(text: &str) -> Option<(String, &str)> {
    if text.is_empty() {
        return None;
    }

    let mut end = 0;
    for ch in text.chars() {
        if ch.is_whitespace() || ch == '=' {
            break;
        }
        end += ch.len_utf8();
    }

    if end == 0 {
        return None;
    }

    let (name, rest) = text.split_at(end);
    if !is_valid_identifier(name) {
        return None;
    }

    Some((name.to_string(), rest))
}

fn parse_quoted_identifier(text: &str) -> Option<(String, &str)> {
    let mut chars = text.char_indices();
    let (_, hash) = chars.next()?;
    if hash != '#' {
        return None;
    }
    if !matches!(chars.next(), Some((_, '"'))) {
        return None;
    }

    let mut name = String::new();
    while let Some((idx, ch)) = chars.next() {
        if ch == '"' {
            if let Some((_, next_ch)) = chars.clone().next()
                && next_ch == '"'
            {
                name.push('"');
                chars.next();
                continue;
            }
            let rest_start = idx + 1;
            let rest = &text[rest_start..];
            return Some((name, rest));
        }

        name.push(ch);
    }

    None
}

fn is_valid_identifier(name: &str) -> bool {
    !name.is_empty() && name.chars().all(|c| c.is_ascii_alphanumeric() || c == '_')
}

fn strip_leading_bom(text: &str) -> &str {
    text.strip_prefix('\u{FEFF}').unwrap_or(text)
}

```

---

### File: `core\src\object_diff.rs`

```rust
use crate::diff::DiffOp;
use crate::package::VbaModule;
use crate::string_pool::StringPool;
use crate::workbook::{ChartObject, NamedRange, Workbook};
use std::collections::{BTreeMap, BTreeSet};

pub(crate) fn diff_named_ranges(old: &Workbook, new: &Workbook, pool: &StringPool) -> Vec<DiffOp> {
    fn key(range: &NamedRange, pool: &StringPool) -> String {
        pool.resolve(range.name).to_lowercase()
    }

    let mut old_map: BTreeMap<String, &NamedRange> = BTreeMap::new();
    for range in &old.named_ranges {
        old_map.insert(key(range, pool), range);
    }

    let mut new_map: BTreeMap<String, &NamedRange> = BTreeMap::new();
    for range in &new.named_ranges {
        new_map.insert(key(range, pool), range);
    }

    let mut keys: BTreeSet<String> = BTreeSet::new();
    keys.extend(old_map.keys().cloned());
    keys.extend(new_map.keys().cloned());

    let mut ops = Vec::new();
    for k in keys {
        match (old_map.get(&k), new_map.get(&k)) {
            (None, Some(new_range)) => ops.push(DiffOp::NamedRangeAdded {
                name: new_range.name,
            }),
            (Some(old_range), None) => ops.push(DiffOp::NamedRangeRemoved {
                name: old_range.name,
            }),
            (Some(old_range), Some(new_range)) => {
                if old_range.refers_to != new_range.refers_to {
                    ops.push(DiffOp::NamedRangeChanged {
                        name: new_range.name,
                        old_ref: old_range.refers_to,
                        new_ref: new_range.refers_to,
                    });
                }
            }
            (None, None) => {}
        }
    }

    ops
}

pub(crate) fn diff_charts(old: &Workbook, new: &Workbook, pool: &StringPool) -> Vec<DiffOp> {
    fn key(chart: &ChartObject, pool: &StringPool) -> (String, String) {
        (
            pool.resolve(chart.sheet).to_lowercase(),
            pool.resolve(chart.info.name).to_lowercase(),
        )
    }

    let mut old_map: BTreeMap<(String, String), &ChartObject> = BTreeMap::new();
    for chart in &old.charts {
        old_map.insert(key(chart, pool), chart);
    }

    let mut new_map: BTreeMap<(String, String), &ChartObject> = BTreeMap::new();
    for chart in &new.charts {
        new_map.insert(key(chart, pool), chart);
    }

    let mut keys: BTreeSet<(String, String)> = BTreeSet::new();
    keys.extend(old_map.keys().cloned());
    keys.extend(new_map.keys().cloned());

    let mut ops = Vec::new();
    for k in keys {
        match (old_map.get(&k), new_map.get(&k)) {
            (None, Some(new_chart)) => ops.push(DiffOp::ChartAdded {
                sheet: new_chart.sheet,
                name: new_chart.info.name,
            }),
            (Some(old_chart), None) => ops.push(DiffOp::ChartRemoved {
                sheet: old_chart.sheet,
                name: old_chart.info.name,
            }),
            (Some(old_chart), Some(new_chart)) => {
                if old_chart.xml_hash != new_chart.xml_hash {
                    ops.push(DiffOp::ChartChanged {
                        sheet: new_chart.sheet,
                        name: new_chart.info.name,
                    });
                }
            }
            (None, None) => {}
        }
    }

    ops
}

pub(crate) fn diff_vba_modules(
    old: Option<&[VbaModule]>,
    new: Option<&[VbaModule]>,
    pool: &StringPool,
) -> Vec<DiffOp> {
    fn key(module: &VbaModule, pool: &StringPool) -> String {
        pool.resolve(module.name).to_lowercase()
    }

    fn normalize(code: &str) -> String {
        code.replace("\r\n", "\n").replace('\r', "\n")
    }

    let old = old.unwrap_or_default();
    let new = new.unwrap_or_default();

    let mut old_map: BTreeMap<String, &VbaModule> = BTreeMap::new();
    for module in old {
        old_map.insert(key(module, pool), module);
    }

    let mut new_map: BTreeMap<String, &VbaModule> = BTreeMap::new();
    for module in new {
        new_map.insert(key(module, pool), module);
    }

    let mut keys: BTreeSet<String> = BTreeSet::new();
    keys.extend(old_map.keys().cloned());
    keys.extend(new_map.keys().cloned());

    let mut ops = Vec::new();
    for k in keys {
        match (old_map.get(&k), new_map.get(&k)) {
            (None, Some(new_module)) => ops.push(DiffOp::VbaModuleAdded {
                name: new_module.name,
            }),
            (Some(old_module), None) => ops.push(DiffOp::VbaModuleRemoved {
                name: old_module.name,
            }),
            (Some(old_module), Some(new_module)) => {
                if normalize(&old_module.code) != normalize(&new_module.code) {
                    ops.push(DiffOp::VbaModuleChanged {
                        name: new_module.name,
                    });
                }
            }
            (None, None) => {}
        }
    }

    ops
}


```

---

### File: `core\src\output\json.rs`

```rust
#[cfg(all(feature = "excel-open-xml", feature = "std-fs"))]
use crate::config::DiffConfig;
#[cfg(all(feature = "excel-open-xml", feature = "std-fs"))]
use crate::datamashup::build_data_mashup;
use crate::diff::DiffReport;
#[cfg(all(feature = "excel-open-xml", feature = "std-fs"))]
use crate::excel_open_xml::{PackageError, open_data_mashup, open_vba_modules, open_workbook};
#[allow(unused_imports)]
use crate::session::DiffSession;
#[cfg(all(feature = "excel-open-xml", feature = "std-fs"))]
use crate::sink::VecSink;
use serde::Serialize;
use serde::ser::Error as SerdeError;
#[cfg(all(feature = "excel-open-xml", feature = "std-fs"))]
use std::path::Path;

#[derive(Debug, Clone, PartialEq, Serialize)]
pub struct CellDiff {
    #[serde(rename = "coords")]
    pub coords: String,
    #[serde(rename = "value_file1")]
    pub value_file1: Option<String>,
    #[serde(rename = "value_file2")]
    pub value_file2: Option<String>,
}

pub fn serialize_cell_diffs(diffs: &[CellDiff]) -> serde_json::Result<String> {
    serde_json::to_string(diffs)
}

pub fn serialize_diff_report(report: &DiffReport) -> serde_json::Result<String> {
    if contains_non_finite_numbers(report) {
        return Err(SerdeError::custom(
            "non-finite numbers (NaN or infinity) are not supported in DiffReport JSON output",
        ));
    }
    serde_json::to_string(report)
}

#[cfg(all(feature = "excel-open-xml", feature = "std-fs"))]
pub fn diff_workbooks(
    path_a: impl AsRef<Path>,
    path_b: impl AsRef<Path>,
    config: &DiffConfig,
) -> Result<DiffReport, PackageError> {
    let path_a = path_a.as_ref();
    let path_b = path_b.as_ref();

    let mut session = DiffSession::new();

    let wb_a = open_workbook(path_a, session.strings_mut())?;
    let wb_b = open_workbook(path_b, session.strings_mut())?;

    let dm_a = open_data_mashup(path_a)?
        .map(|raw| build_data_mashup(&raw))
        .transpose()?;
    let dm_b = open_data_mashup(path_b)?
        .map(|raw| build_data_mashup(&raw))
        .transpose()?;

    let vba_a = open_vba_modules(path_a, session.strings_mut())?;
    let vba_b = open_vba_modules(path_b, session.strings_mut())?;

    let mut sink = VecSink::new();
    let summary = crate::engine::try_diff_workbooks_streaming(
        &wb_a,
        &wb_b,
        session.strings_mut(),
        config,
        &mut sink,
    )?;

    let mut ops = sink.into_ops();

    let mut object_ops = crate::object_diff::diff_named_ranges(&wb_a, &wb_b, session.strings());
    object_ops.extend(crate::object_diff::diff_charts(
        &wb_a,
        &wb_b,
        session.strings(),
    ));
    object_ops.extend(crate::object_diff::diff_vba_modules(
        vba_a.as_deref(),
        vba_b.as_deref(),
        session.strings(),
    ));
    ops.extend(object_ops);

    let m_ops = crate::m_diff::diff_m_ops_for_packages(&dm_a, &dm_b, session.strings_mut(), config);

    ops.extend(m_ops);

    let strings = session.strings.into_strings();
    Ok(DiffReport::from_ops_and_summary(ops, summary, strings))
}

#[cfg(all(feature = "excel-open-xml", feature = "std-fs"))]
pub fn diff_workbooks_to_json(
    path_a: impl AsRef<Path>,
    path_b: impl AsRef<Path>,
    config: &DiffConfig,
) -> Result<String, PackageError> {
    let report = diff_workbooks(path_a, path_b, config)?;
    serialize_diff_report(&report).map_err(|e| PackageError::SerializationError(e.to_string()))
}

pub fn diff_report_to_cell_diffs(report: &DiffReport) -> Vec<CellDiff> {
    use crate::diff::DiffOp;
    use crate::workbook::CellValue;

    fn render_value(report: &DiffReport, value: &Option<CellValue>) -> Option<String> {
        match value {
            Some(CellValue::Number(n)) => Some(n.to_string()),
            Some(CellValue::Text(id)) => report.resolve(*id).map(|s| s.to_string()),
            Some(CellValue::Bool(b)) => Some(b.to_string()),
            Some(CellValue::Error(id)) => report.resolve(*id).map(|s| s.to_string()),
            Some(CellValue::Blank) => Some(String::new()),
            None => None,
        }
    }

    report
        .ops
        .iter()
        .filter_map(|op| {
            if let DiffOp::CellEdited { addr, from, to, .. } = op {
                if from == to {
                    return None;
                }
                Some(CellDiff {
                    coords: addr.to_a1(),
                    value_file1: render_value(report, &from.value),
                    value_file2: render_value(report, &to.value),
                })
            } else {
                None
            }
        })
        .collect()
}

fn contains_non_finite_numbers(report: &DiffReport) -> bool {
    use crate::diff::DiffOp;
    use crate::workbook::CellValue;

    report.ops.iter().any(|op| match op {
        DiffOp::CellEdited { from, to, .. } => {
            matches!(from.value, Some(CellValue::Number(n)) if !n.is_finite())
                || matches!(to.value, Some(CellValue::Number(n)) if !n.is_finite())
        }
        _ => false,
    })
}

```

---

### File: `core\src\output\json_lines.rs`

```rust
use crate::diff::{DiffError, DiffOp};
use crate::sink::DiffSink;
use crate::string_pool::StringPool;
use serde::Serialize;
use std::io::Write;

#[derive(Serialize)]
struct JsonLinesHeader<'a> {
    kind: &'static str,
    version: &'a str,
    strings: &'a [String],
}

/// A [`DiffSink`] that writes a JSON Lines stream.
///
/// The first line is a header containing the schema version and the string table. Each
/// subsequent line is a JSON-serialized [`DiffOp`].
pub struct JsonLinesSink<W: Write> {
    w: W,
    wrote_header: bool,
    version: &'static str,
}

impl<W: Write> JsonLinesSink<W> {
    /// Create a JSON Lines sink that writes to `w`.
    ///
    /// The output format is:
    ///
    /// 1. A header line: `{ "kind": "Header", "version": "...", "strings": [...] }`
    /// 2. One JSON-serialized [`DiffOp`] per line
    ///
    /// Ops contain interned [`crate::StringId`] values that index into the header's `strings` table.
    pub fn new(w: W) -> Self {
        Self {
            w,
            wrote_header: false,
            version: crate::diff::DiffReport::SCHEMA_VERSION,
        }
    }

    /// Write the header line (idempotent).
    pub fn begin(&mut self, pool: &StringPool) -> Result<(), DiffError> {
        if self.wrote_header {
            return Ok(());
        }

        let header = JsonLinesHeader {
            kind: "Header",
            version: self.version,
            strings: pool.strings(),
        };

        serde_json::to_writer(&mut self.w, &header).map_err(|e| DiffError::SinkError {
            message: e.to_string(),
        })?;
        self.w.write_all(b"\n").map_err(|e| DiffError::SinkError {
            message: e.to_string(),
        })?;

        self.wrote_header = true;
        Ok(())
    }
}

impl<W: Write> DiffSink for JsonLinesSink<W> {
    fn begin(&mut self, pool: &StringPool) -> Result<(), DiffError> {
        JsonLinesSink::begin(self, pool)
    }

    fn emit(&mut self, op: DiffOp) -> Result<(), DiffError> {
        serde_json::to_writer(&mut self.w, &op).map_err(|e| DiffError::SinkError {
            message: e.to_string(),
        })?;
        self.w.write_all(b"\n").map_err(|e| DiffError::SinkError {
            message: e.to_string(),
        })?;
        Ok(())
    }

    fn finish(&mut self) -> Result<(), DiffError> {
        self.w.flush().map_err(|e| DiffError::SinkError {
            message: e.to_string(),
        })
    }
}

```

---

### File: `core\src\output\mod.rs`

```rust
pub mod json;
pub mod json_lines;

```

---

### File: `core\src\package.rs`

```rust
use crate::config::DiffConfig;
use crate::datamashup::DataMashup;
use crate::diff::{DiffError, DiffReport, DiffSummary, SheetId};
use crate::progress::ProgressCallback;
use crate::sink::{DiffSink, NoFinishSink, VecSink};
use crate::string_pool::StringId;
use crate::string_pool::StringPool;
use crate::workbook::{Sheet, Workbook};

/// The kind of VBA module contained in an `.xlsm` workbook.
#[derive(Debug, Clone, Copy, PartialEq, Eq)]
pub enum VbaModuleType {
    /// A standard module (e.g., `Module1`).
    Standard,
    /// A class module.
    Class,
    /// A form module.
    Form,
    /// A document module (e.g., `ThisWorkbook`, sheet modules).
    Document,
}

/// A VBA module extracted from a workbook.
#[derive(Debug, Clone, PartialEq, Eq)]
pub struct VbaModule {
    /// Module name (interned in the associated string pool).
    pub name: StringId,
    /// Module type (standard/class/form/document).
    pub module_type: VbaModuleType,
    /// Raw module source code.
    pub code: String,
}

/// A parsed workbook plus optional associated content (Power Query and VBA).
///
/// This is the recommended high-level entry point for most callers. It wraps the workbook IR
/// (`Workbook`, `Sheet`, `Grid`) together with:
/// - optional DataMashup content (Power Query / M)
/// - optional extracted VBA modules (for `.xlsm`)
///
/// Diffs produced via [`WorkbookPackage::diff`] and related APIs include grid ops, object ops
/// (named ranges, charts, VBA), and M ops when present.
#[derive(Debug, Clone)]
pub struct WorkbookPackage {
    /// Parsed workbook IR (sheets, grids, named ranges, charts).
    pub workbook: Workbook,
    /// Parsed DataMashup content (Power Query), if present.
    pub data_mashup: Option<DataMashup>,
    /// Extracted VBA modules, if present and the `vba` feature is enabled.
    pub vba_modules: Option<Vec<VbaModule>>,
}

impl From<Workbook> for WorkbookPackage {
    fn from(workbook: Workbook) -> Self {
        Self {
            workbook,
            data_mashup: None,
            vba_modules: None,
        }
    }
}

impl WorkbookPackage {
    #[cfg(feature = "excel-open-xml")]
    /// Parse a workbook from any `Read + Seek` source.
    ///
    /// This is available when the `excel-open-xml` feature is enabled (enabled by default).
    ///
    /// # Examples
    ///
    /// ```no_run
    /// use excel_diff::WorkbookPackage;
    /// use std::fs::File;
    ///
    /// # fn main() -> Result<(), Box<dyn std::error::Error>> {
    /// let _pkg = WorkbookPackage::open(File::open("workbook.xlsx")?)?;
    /// # Ok(())
    /// # }
    /// ```
    pub fn open<R: std::io::Read + std::io::Seek + 'static>(
        reader: R,
    ) -> Result<Self, crate::excel_open_xml::PackageError> {
        crate::with_default_session(|session| {
            let mut container = crate::container::OpcContainer::open_from_reader(reader)?;
            let workbook = crate::excel_open_xml::open_workbook_from_container(
                &mut container,
                &mut session.strings,
            )?;
            let raw = crate::excel_open_xml::open_data_mashup_from_container(&mut container)?;
            let data_mashup = match raw {
                Some(raw) => Some(crate::datamashup::build_data_mashup(&raw)?),
                None => None,
            };
            let vba_modules =
                crate::excel_open_xml::open_vba_modules_from_container(&mut container, &mut session.strings)?;
            Ok(Self {
                workbook,
                data_mashup,
                vba_modules,
            })
        })
    }

    /// Diff this package against `other`, returning an in-memory [`DiffReport`].
    ///
    /// This collects all ops into memory and returns a report containing both the ops and the
    /// string table required to resolve [`StringId`] values referenced by ops.
    ///
    /// For very large workbooks, consider [`WorkbookPackage::diff_streaming`] instead.
    pub fn diff(&self, other: &Self, config: &DiffConfig) -> DiffReport {
        crate::with_default_session(|session| {
            self.diff_with_pool(other, &mut session.strings, config)
        })
    }

    /// Like [`WorkbookPackage::diff`], but reports best-effort progress via `progress`.
    pub fn diff_with_progress(
        &self,
        other: &Self,
        config: &DiffConfig,
        progress: &dyn ProgressCallback,
    ) -> DiffReport {
        crate::with_default_session(|session| {
            self.diff_with_progress_with_pool(other, &mut session.strings, config, progress)
        })
    }

    pub fn diff_with_pool(
        &self,
        other: &Self,
        pool: &mut crate::string_pool::StringPool,
        config: &DiffConfig,
    ) -> DiffReport {
        let mut report =
            crate::engine::diff_workbooks(&self.workbook, &other.workbook, pool, config);

        let mut object_ops =
            crate::object_diff::diff_named_ranges(&self.workbook, &other.workbook, pool);
        object_ops.extend(crate::object_diff::diff_charts(
            &self.workbook,
            &other.workbook,
            pool,
        ));
        object_ops.extend(crate::object_diff::diff_vba_modules(
            self.vba_modules.as_deref(),
            other.vba_modules.as_deref(),
            pool,
        ));
        report.ops.extend(object_ops);

        let m_ops = crate::m_diff::diff_m_ops_for_packages(
            &self.data_mashup,
            &other.data_mashup,
            pool,
            config,
        );

        report.ops.extend(m_ops);
        report.strings = pool.strings().to_vec();
        report
    }

    pub fn diff_with_progress_with_pool(
        &self,
        other: &Self,
        pool: &mut crate::string_pool::StringPool,
        config: &DiffConfig,
        progress: &dyn ProgressCallback,
    ) -> DiffReport {
        let mut report = crate::engine::diff_workbooks_with_progress(
            &self.workbook,
            &other.workbook,
            pool,
            config,
            progress,
        );

        let mut object_ops =
            crate::object_diff::diff_named_ranges(&self.workbook, &other.workbook, pool);
        object_ops.extend(crate::object_diff::diff_charts(
            &self.workbook,
            &other.workbook,
            pool,
        ));
        object_ops.extend(crate::object_diff::diff_vba_modules(
            self.vba_modules.as_deref(),
            other.vba_modules.as_deref(),
            pool,
        ));
        report.ops.extend(object_ops);

        let m_ops = crate::m_diff::diff_m_ops_for_packages(
            &self.data_mashup,
            &other.data_mashup,
            pool,
            config,
        );

        report.ops.extend(m_ops);
        report.strings = pool.strings().to_vec();
        report
    }

    /// Diff this package against `other`, streaming ops into `sink`.
    ///
    /// This is the preferred API for very large workbooks because it does not require holding
    /// the entire op list in memory. Instead, ops are emitted incrementally and a [`DiffSummary`]
    /// is returned at the end.
    ///
    /// # Examples
    ///
    /// ```no_run
    /// use excel_diff::{DiffConfig, JsonLinesSink, WorkbookPackage};
    /// use std::fs::File;
    /// use std::io::{self, BufWriter};
    ///
    /// # fn main() -> Result<(), Box<dyn std::error::Error>> {
    /// let old_pkg = WorkbookPackage::open(File::open("old.xlsx")?)?;
    /// let new_pkg = WorkbookPackage::open(File::open("new.xlsx")?)?;
    ///
    /// let stdout = io::stdout();
    /// let mut sink = JsonLinesSink::new(BufWriter::new(stdout.lock()));
    /// let summary = old_pkg.diff_streaming(&new_pkg, &DiffConfig::default(), &mut sink)?;
    /// eprintln!("complete={} ops={}", summary.complete, summary.op_count);
    /// # Ok(())
    /// # }
    /// ```
    pub fn diff_streaming<S: DiffSink>(
        &self,
        other: &Self,
        config: &DiffConfig,
        sink: &mut S,
    ) -> Result<DiffSummary, DiffError> {
        crate::with_default_session(|session| {
            self.diff_streaming_with_pool(other, &mut session.strings, config, sink)
        })
    }

    /// Like [`WorkbookPackage::diff_streaming`], but reports best-effort progress via `progress`.
    pub fn diff_streaming_with_progress<S: DiffSink>(
        &self,
        other: &Self,
        config: &DiffConfig,
        sink: &mut S,
        progress: &dyn ProgressCallback,
    ) -> Result<DiffSummary, DiffError> {
        crate::with_default_session(|session| {
            self.diff_streaming_with_progress_with_pool(
                other,
                &mut session.strings,
                config,
                sink,
                progress,
            )
        })
    }

    /// Streaming variant of [`WorkbookPackage::diff`], using a caller-provided string pool.
    ///
    /// Most callers should prefer [`WorkbookPackage::diff_streaming`], which uses the default
    /// session string pool internally.
    pub fn diff_streaming_with_pool<S: DiffSink>(
        &self,
        other: &Self,
        pool: &mut crate::string_pool::StringPool,
        config: &DiffConfig,
        sink: &mut S,
    ) -> Result<DiffSummary, DiffError> {
        let mut object_ops =
            crate::object_diff::diff_named_ranges(&self.workbook, &other.workbook, pool);
        object_ops.extend(crate::object_diff::diff_charts(
            &self.workbook,
            &other.workbook,
            pool,
        ));
        object_ops.extend(crate::object_diff::diff_vba_modules(
            self.vba_modules.as_deref(),
            other.vba_modules.as_deref(),
            pool,
        ));

        let m_ops = crate::m_diff::diff_m_ops_for_packages(
            &self.data_mashup,
            &other.data_mashup,
            pool,
            config,
        );

        let grid_result = {
            let mut no_finish = NoFinishSink::new(sink);
            crate::engine::try_diff_workbooks_streaming(
                &self.workbook,
                &other.workbook,
                pool,
                config,
                &mut no_finish,
            )
        };

        let mut summary = match grid_result {
            Ok(summary) => summary,
            Err(e) => {
                let _ = sink.finish();
                return Err(e);
            }
        };

        for op in object_ops {
            if let Err(e) = sink.emit(op) {
                let _ = sink.finish();
                return Err(e);
            }
            summary.op_count = summary.op_count.saturating_add(1);
        }

        for op in m_ops {
            if let Err(e) = sink.emit(op) {
                let _ = sink.finish();
                return Err(e);
            }
            summary.op_count = summary.op_count.saturating_add(1);
        }

        sink.finish()?;

        Ok(summary)
    }

    pub fn diff_streaming_with_progress_with_pool<S: DiffSink>(
        &self,
        other: &Self,
        pool: &mut crate::string_pool::StringPool,
        config: &DiffConfig,
        sink: &mut S,
        progress: &dyn ProgressCallback,
    ) -> Result<DiffSummary, DiffError> {
        let mut object_ops =
            crate::object_diff::diff_named_ranges(&self.workbook, &other.workbook, pool);
        object_ops.extend(crate::object_diff::diff_charts(
            &self.workbook,
            &other.workbook,
            pool,
        ));
        object_ops.extend(crate::object_diff::diff_vba_modules(
            self.vba_modules.as_deref(),
            other.vba_modules.as_deref(),
            pool,
        ));

        let m_ops = crate::m_diff::diff_m_ops_for_packages(
            &self.data_mashup,
            &other.data_mashup,
            pool,
            config,
        );

        let grid_result = {
            let mut no_finish = NoFinishSink::new(sink);
            crate::engine::try_diff_workbooks_streaming_with_progress(
                &self.workbook,
                &other.workbook,
                pool,
                config,
                &mut no_finish,
                progress,
            )
        };

        let mut summary = match grid_result {
            Ok(summary) => summary,
            Err(e) => {
                let _ = sink.finish();
                return Err(e);
            }
        };

        for op in object_ops {
            if let Err(e) = sink.emit(op) {
                let _ = sink.finish();
                return Err(e);
            }
            summary.op_count = summary.op_count.saturating_add(1);
        }

        for op in m_ops {
            if let Err(e) = sink.emit(op) {
                let _ = sink.finish();
                return Err(e);
            }
            summary.op_count = summary.op_count.saturating_add(1);
        }

        sink.finish()?;

        Ok(summary)
    }

    /// Diff a single sheet using key-based row alignment ("database mode").
    ///
    /// `sheet_name` must exist in both workbooks (matching is case-insensitive). `key_columns`
    /// are 0-based column indices (A=0, B=1, ...).
    ///
    /// # Examples
    ///
    /// ```no_run
    /// use excel_diff::{DiffConfig, WorkbookPackage};
    /// use std::fs::File;
    ///
    /// # fn main() -> Result<(), Box<dyn std::error::Error>> {
    /// let old_pkg = WorkbookPackage::open(File::open("old.xlsx")?)?;
    /// let new_pkg = WorkbookPackage::open(File::open("new.xlsx")?)?;
    ///
    /// let keys = vec![0u32, 2u32]; // A,C
    /// let report = old_pkg.diff_database_mode(&new_pkg, "Data", &keys, &DiffConfig::default())?;
    /// println!("complete={} ops={}", report.complete, report.ops.len());
    /// # Ok(())
    /// # }
    /// ```
    pub fn diff_database_mode(
        &self,
        other: &Self,
        sheet_name: &str,
        key_columns: &[u32],
        config: &DiffConfig,
    ) -> Result<DiffReport, DiffError> {
        crate::with_default_session(|session| {
            self.diff_database_mode_with_pool(
                other,
                sheet_name,
                key_columns,
                &mut session.strings,
                config,
            )
        })
    }

    /// Like [`WorkbookPackage::diff_database_mode`], but uses a caller-provided string pool.
    pub fn diff_database_mode_with_pool(
        &self,
        other: &Self,
        sheet_name: &str,
        key_columns: &[u32],
        pool: &mut StringPool,
        config: &DiffConfig,
    ) -> Result<DiffReport, DiffError> {
        let (old_sheet, new_sheet, sheet_id) =
            find_sheets_case_insensitive(&self.workbook, &other.workbook, sheet_name, pool)?;

        let mut sink = VecSink::new();
        let mut op_count = 0usize;

        let summary = crate::engine::try_diff_grids_database_mode_streaming(
            sheet_id,
            &old_sheet.grid,
            &new_sheet.grid,
            key_columns,
            pool,
            config,
            &mut sink,
            &mut op_count,
        )?;

        let mut object_ops =
            crate::object_diff::diff_named_ranges(&self.workbook, &other.workbook, pool);
        object_ops.extend(crate::object_diff::diff_charts(
            &self.workbook,
            &other.workbook,
            pool,
        ));
        object_ops.extend(crate::object_diff::diff_vba_modules(
            self.vba_modules.as_deref(),
            other.vba_modules.as_deref(),
            pool,
        ));

        let m_ops = crate::m_diff::diff_m_ops_for_packages(
            &self.data_mashup,
            &other.data_mashup,
            pool,
            config,
        );

        let mut ops = sink.into_ops();
        ops.extend(object_ops);
        ops.extend(m_ops);

        let strings = pool.strings().to_vec();
        Ok(DiffReport::from_ops_and_summary(ops, summary, strings))
    }

    /// Streaming database mode diff. Emits ops into `sink` and returns a [`DiffSummary`].
    pub fn diff_database_mode_streaming<S: DiffSink>(
        &self,
        other: &Self,
        sheet_name: &str,
        key_columns: &[u32],
        config: &DiffConfig,
        sink: &mut S,
    ) -> Result<DiffSummary, DiffError> {
        crate::with_default_session(|session| {
            self.diff_database_mode_streaming_with_pool(
                other,
                sheet_name,
                key_columns,
                &mut session.strings,
                config,
                sink,
            )
        })
    }

    /// Like [`WorkbookPackage::diff_database_mode_streaming`], but uses a caller-provided string pool.
    pub fn diff_database_mode_streaming_with_pool<S: DiffSink>(
        &self,
        other: &Self,
        sheet_name: &str,
        key_columns: &[u32],
        pool: &mut StringPool,
        config: &DiffConfig,
        sink: &mut S,
    ) -> Result<DiffSummary, DiffError> {
        let mut object_ops =
            crate::object_diff::diff_named_ranges(&self.workbook, &other.workbook, pool);
        object_ops.extend(crate::object_diff::diff_charts(
            &self.workbook,
            &other.workbook,
            pool,
        ));
        object_ops.extend(crate::object_diff::diff_vba_modules(
            self.vba_modules.as_deref(),
            other.vba_modules.as_deref(),
            pool,
        ));

        let m_ops = crate::m_diff::diff_m_ops_for_packages(
            &self.data_mashup,
            &other.data_mashup,
            pool,
            config,
        );

        let (old_sheet, new_sheet, sheet_id) =
            find_sheets_case_insensitive(&self.workbook, &other.workbook, sheet_name, pool)?;

        let grid_result = {
            let mut no_finish = NoFinishSink::new(sink);
            crate::engine::try_diff_grids_database_mode_streaming(
                sheet_id,
                &old_sheet.grid,
                &new_sheet.grid,
                key_columns,
                pool,
                config,
                &mut no_finish,
                &mut 0usize,
            )
        };

        let mut summary = match grid_result {
            Ok(summary) => summary,
            Err(e) => {
                let _ = sink.finish();
                return Err(e);
            }
        };

        for op in object_ops {
            if let Err(e) = sink.emit(op) {
                let _ = sink.finish();
                return Err(e);
            }
            summary.op_count = summary.op_count.saturating_add(1);
        }

        for op in m_ops {
            if let Err(e) = sink.emit(op) {
                let _ = sink.finish();
                return Err(e);
            }
            summary.op_count = summary.op_count.saturating_add(1);
        }

        sink.finish()?;

        Ok(summary)
    }
}

fn find_sheets_case_insensitive<'a>(
    old_wb: &'a Workbook,
    new_wb: &'a Workbook,
    sheet_name: &str,
    pool: &StringPool,
) -> Result<(&'a Sheet, &'a Sheet, SheetId), DiffError> {
    let sheet_name_lower = sheet_name.to_lowercase();

    let old_sheet = old_wb.sheets.iter().find(|s| {
        let name = pool.resolve(s.name);
        name.to_lowercase() == sheet_name_lower
    });

    let new_sheet = new_wb.sheets.iter().find(|s| {
        let name = pool.resolve(s.name);
        name.to_lowercase() == sheet_name_lower
    });

    match (old_sheet, new_sheet) {
        (Some(old), Some(new)) => {
            let sheet_id = old.name;
            Ok((old, new, sheet_id))
        }
        _ => {
            let mut available: Vec<String> = old_wb
                .sheets
                .iter()
                .map(|s| pool.resolve(s.name).to_string())
                .collect();
            for s in &new_wb.sheets {
                let name = pool.resolve(s.name).to_string();
                if !available.iter().any(|n| n.to_lowercase() == name.to_lowercase()) {
                    available.push(name);
                }
            }
            available.sort();
            Err(DiffError::SheetNotFound {
                requested: sheet_name.to_string(),
                available,
            })
        }
    }
}

```

---

### File: `core\src\perf.rs`

```rust
use std::collections::HashMap;
use std::time::Instant;

#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
pub enum Phase {
    Total,
    Parse,
    MoveDetection,
    Alignment,
    CellDiff,
}

#[derive(Debug, Clone, Default, PartialEq, Eq, serde::Serialize, serde::Deserialize)]
pub struct DiffMetrics {
    pub move_detection_time_ms: u64,
    pub alignment_time_ms: u64,
    pub cell_diff_time_ms: u64,
    pub total_time_ms: u64,
    pub rows_processed: u64,
    pub cells_compared: u64,
    pub anchors_found: u32,
    pub moves_detected: u32,
    #[serde(skip)]
    phase_start: HashMap<Phase, Instant>,
}

impl DiffMetrics {
    pub fn start_phase(&mut self, phase: Phase) {
        self.phase_start.insert(phase, Instant::now());
    }

    pub fn end_phase(&mut self, phase: Phase) {
        if let Some(start) = self.phase_start.remove(&phase) {
            let elapsed = start.elapsed().as_millis() as u64;
            match phase {
                Phase::Parse => {}
                Phase::MoveDetection => self.move_detection_time_ms += elapsed,
                Phase::Alignment => self.alignment_time_ms += elapsed,
                Phase::CellDiff => self.cell_diff_time_ms += elapsed,
                Phase::Total => self.total_time_ms += elapsed,
            }
        }
    }

    pub fn add_cells_compared(&mut self, count: u64) {
        self.cells_compared = self.cells_compared.saturating_add(count);
    }

    pub fn phase_guard(&mut self, phase: Phase) -> PhaseGuard<'_> {
        PhaseGuard::new(self, phase)
    }
}

pub struct PhaseGuard<'a> {
    metrics: &'a mut DiffMetrics,
    phase: Phase,
}

impl<'a> PhaseGuard<'a> {
    pub fn new(metrics: &'a mut DiffMetrics, phase: Phase) -> Self {
        metrics.start_phase(phase);
        Self { metrics, phase }
    }
}

impl Drop for PhaseGuard<'_> {
    fn drop(&mut self) {
        self.metrics.end_phase(self.phase);
    }
}

```

---

### File: `core\src\progress.rs`

```rust
/// Progress reporting for long-running diffs.
///
/// The diff engine may call the callback at throttled intervals with a best-effort percentage in
/// the range `[0.0, 1.0]`. Callers should treat progress as advisory and not assume monotonicity
/// across phases.

pub trait ProgressCallback: Send {
    fn on_progress(&self, phase: &str, percent: f32);
}

#[derive(Debug, Default, Clone, Copy)]
pub struct NoProgress;

impl ProgressCallback for NoProgress {
    fn on_progress(&self, _phase: &str, _percent: f32) {}
}


```

---

### File: `core\src\rect_block_move.rs`

```rust
//! Rectangular block move detection.
//!
//! This module implements detection of rectangular regions that have moved
//! between two grids. A rect block move is when a 2D region (rows  cols)
//! moves from one position to another without internal edits.
//!
//! This is used by the engine's masked move detection loop to identify
//! structural changes that preserve content but change position.

use crate::config::DiffConfig;
use crate::grid_view::{ColHash, GridView, HashStats, RowHash};
use crate::workbook::{Cell, Grid};

#[derive(Debug, Clone, Copy, PartialEq, Eq)]
pub(crate) struct RectBlockMove {
    pub src_start_row: u32,
    pub src_row_count: u32,
    pub src_start_col: u32,
    pub src_col_count: u32,
    pub dst_start_row: u32,
    pub dst_start_col: u32,
    pub block_hash: Option<u64>,
}

pub(crate) fn detect_exact_rect_block_move(
    old: &Grid,
    new: &Grid,
    config: &DiffConfig,
) -> Option<RectBlockMove> {
    if old.nrows != new.nrows || old.ncols != new.ncols {
        return None;
    }

    if old.nrows == 0 || old.ncols == 0 {
        return None;
    }

    if !is_within_size_bounds(old, new, config) {
        return None;
    }

    let view_a = GridView::from_grid_with_config(old, config);
    let view_b = GridView::from_grid_with_config(new, config);

    if view_a.is_low_info_dominated() || view_b.is_low_info_dominated() {
        return None;
    }

    if view_a.is_blank_dominated() || view_b.is_blank_dominated() {
        return None;
    }

    let row_stats = HashStats::from_row_meta(&view_a.row_meta, &view_b.row_meta);
    let col_stats = HashStats::from_col_meta(&view_a.col_meta, &view_b.col_meta);

    if row_stats.has_heavy_repetition(config.max_hash_repeat)
        || col_stats.has_heavy_repetition(config.max_hash_repeat)
    {
        return None;
    }

    let shared_rows = row_stats
        .freq_a
        .keys()
        .filter(|h| row_stats.freq_b.contains_key(*h))
        .count();
    let shared_cols = col_stats
        .freq_a
        .keys()
        .filter(|h| col_stats.freq_b.contains_key(*h))
        .count();
    if shared_rows == 0 && shared_cols == 0 {
        return None;
    }

    let diff_positions = collect_differences(old, new);
    if diff_positions.is_empty() {
        return None;
    }

    let row_ranges = find_two_equal_ranges(diff_positions.iter().map(|(r, _)| *r))?;
    let col_ranges = find_two_equal_ranges(diff_positions.iter().map(|(_, c)| *c))?;

    let row_count = range_len(row_ranges.0);
    let col_count = range_len(col_ranges.0);

    let expected_mismatches = row_count.checked_mul(col_count)?.checked_mul(2)?;
    if diff_positions.len() as u32 != expected_mismatches {
        return None;
    }

    let mismatches = count_rect_mismatches(old, new, row_ranges.0, col_ranges.0)
        + count_rect_mismatches(old, new, row_ranges.1, col_ranges.1);
    if mismatches != diff_positions.len() as u32 {
        return None;
    }

    if !has_unique_meta(
        &view_a, &view_b, &row_stats, &col_stats, row_ranges, col_ranges,
    ) {
        return None;
    }

    let primary = validate_orientation(old, new, row_ranges, col_ranges);
    let swapped_ranges = ((row_ranges.1, row_ranges.0), (col_ranges.1, col_ranges.0));
    let alternate = validate_orientation(old, new, swapped_ranges.0, swapped_ranges.1);

    match (primary, alternate) {
        (Some(mv), None) => Some(mv),
        (None, Some(mv)) => Some(mv),
        _ => None,
    }
}

fn validate_orientation(
    old: &Grid,
    new: &Grid,
    row_ranges: ((u32, u32), (u32, u32)),
    col_ranges: ((u32, u32), (u32, u32)),
) -> Option<RectBlockMove> {
    if ranges_overlap(row_ranges.0, row_ranges.1) && ranges_overlap(col_ranges.0, col_ranges.1) {
        return None;
    }

    let row_count = range_len(row_ranges.0);
    let col_count = range_len(col_ranges.0);

    if rectangles_correspond(
        old,
        new,
        row_ranges.0,
        col_ranges.0,
        row_ranges.1,
        col_ranges.1,
    ) {
        return Some(RectBlockMove {
            src_start_row: row_ranges.0.0,
            src_row_count: row_count,
            src_start_col: col_ranges.0.0,
            src_col_count: col_count,
            dst_start_row: row_ranges.1.0,
            dst_start_col: col_ranges.1.0,
            block_hash: None,
        });
    }

    None
}

fn rectangles_correspond(
    old: &Grid,
    new: &Grid,
    src_rows: (u32, u32),
    src_cols: (u32, u32),
    dst_rows: (u32, u32),
    dst_cols: (u32, u32),
) -> bool {
    let row_count = range_len(src_rows);
    let col_count = range_len(src_cols);

    if row_count != range_len(dst_rows) || col_count != range_len(dst_cols) {
        return false;
    }

    for dr in 0..row_count {
        for dc in 0..col_count {
            let src_r = src_rows.0 + dr;
            let src_c = src_cols.0 + dc;
            let dst_r = dst_rows.0 + dr;
            let dst_c = dst_cols.0 + dc;

            if !cell_content_equal(old.get(src_r, src_c), new.get(dst_r, dst_c)) {
                return false;
            }
        }
    }

    true
}

fn collect_differences(old: &Grid, new: &Grid) -> Vec<(u32, u32)> {
    let mut diffs = Vec::new();

    for row in 0..old.nrows {
        for col in 0..old.ncols {
            if !cell_content_equal(old.get(row, col), new.get(row, col)) {
                diffs.push((row, col));
            }
        }
    }

    diffs
}

fn cell_content_equal(a: Option<&Cell>, b: Option<&Cell>) -> bool {
    match (a, b) {
        (None, None) => true,
        (Some(cell_a), Some(cell_b)) => {
            cell_a.value == cell_b.value && cell_a.formula == cell_b.formula
        }
        (Some(cell_a), None) => cell_a.value.is_none() && cell_a.formula.is_none(),
        (None, Some(cell_b)) => cell_b.value.is_none() && cell_b.formula.is_none(),
    }
}

fn count_rect_mismatches(old: &Grid, new: &Grid, rows: (u32, u32), cols: (u32, u32)) -> u32 {
    let mut mismatches = 0u32;
    for row in rows.0..=rows.1 {
        for col in cols.0..=cols.1 {
            if !cell_content_equal(old.get(row, col), new.get(row, col)) {
                mismatches = mismatches.saturating_add(1);
            }
        }
    }
    mismatches
}

fn has_unique_meta(
    view_a: &GridView<'_>,
    view_b: &GridView<'_>,
    row_stats: &HashStats<RowHash>,
    col_stats: &HashStats<ColHash>,
    row_ranges: ((u32, u32), (u32, u32)),
    col_ranges: ((u32, u32), (u32, u32)),
) -> bool {
    for range in [row_ranges.0, row_ranges.1] {
        for idx in range.0..=range.1 {
            if !is_unique_row_in_a(idx, view_a, row_stats)
                || !is_unique_row_in_b(idx, view_b, row_stats)
            {
                return false;
            }
        }
    }

    for range in [col_ranges.0, col_ranges.1] {
        for idx in range.0..=range.1 {
            if !is_unique_col_in_a(idx, view_a, col_stats)
                || !is_unique_col_in_b(idx, view_b, col_stats)
            {
                return false;
            }
        }
    }

    true
}

fn is_unique_row_in_a(idx: u32, view: &GridView<'_>, stats: &HashStats<RowHash>) -> bool {
    view.row_meta
        .get(idx as usize)
        .map(|meta| unique_in_a(meta.signature, stats))
        .unwrap_or(false)
}

fn is_unique_row_in_b(idx: u32, view: &GridView<'_>, stats: &HashStats<RowHash>) -> bool {
    view.row_meta
        .get(idx as usize)
        .map(|meta| unique_in_b(meta.signature, stats))
        .unwrap_or(false)
}

fn is_unique_col_in_a(idx: u32, view: &GridView<'_>, stats: &HashStats<ColHash>) -> bool {
    view.col_meta
        .get(idx as usize)
        .map(|meta| unique_in_a(meta.hash, stats))
        .unwrap_or(false)
}

fn is_unique_col_in_b(idx: u32, view: &GridView<'_>, stats: &HashStats<ColHash>) -> bool {
    view.col_meta
        .get(idx as usize)
        .map(|meta| unique_in_b(meta.hash, stats))
        .unwrap_or(false)
}

fn find_two_equal_ranges<I>(indices: I) -> Option<((u32, u32), (u32, u32))>
where
    I: IntoIterator<Item = u32>,
{
    let mut values: Vec<u32> = indices.into_iter().collect();
    if values.is_empty() {
        return None;
    }

    values.sort_unstable();
    values.dedup();

    let mut ranges: Vec<(u32, u32)> = Vec::new();
    let mut start = values[0];
    let mut prev = values[0];

    for &val in values.iter().skip(1) {
        if val == prev + 1 {
            prev = val;
            continue;
        }

        ranges.push((start, prev));
        start = val;
        prev = val;
    }
    ranges.push((start, prev));

    match ranges.len() {
        1 => Some((ranges[0], ranges[0])),
        2 => {
            let len0 = range_len(ranges[0]);
            let len1 = range_len(ranges[1]);
            if len0 != len1 {
                return None;
            }
            Some((ranges[0], ranges[1]))
        }
        _ => None,
    }
}

fn range_len(range: (u32, u32)) -> u32 {
    range.1.saturating_sub(range.0).saturating_add(1)
}

fn ranges_overlap(a: (u32, u32), b: (u32, u32)) -> bool {
    !(a.1 < b.0 || b.1 < a.0)
}

fn is_within_size_bounds(old: &Grid, new: &Grid, config: &DiffConfig) -> bool {
    let rows = old.nrows.max(new.nrows);
    let cols = old.ncols.max(new.ncols);
    rows <= config.max_align_rows && cols <= config.max_align_cols
}

fn unique_in_a<H>(hash: H, stats: &HashStats<H>) -> bool
where
    H: Eq + std::hash::Hash + Copy,
{
    stats.freq_a.get(&hash).copied().unwrap_or(0) == 1
        && stats.freq_b.get(&hash).copied().unwrap_or(0) <= 1
}

fn unique_in_b<H>(hash: H, stats: &HashStats<H>) -> bool
where
    H: Eq + std::hash::Hash + Copy,
{
    stats.freq_b.get(&hash).copied().unwrap_or(0) == 1
        && stats.freq_a.get(&hash).copied().unwrap_or(0) <= 1
}

#[cfg(test)]
mod tests {
    use super::*;
    use crate::workbook::CellValue;

    fn grid_from_numbers(values: &[&[i32]]) -> Grid {
        let nrows = values.len() as u32;
        let ncols = if nrows == 0 {
            0
        } else {
            values[0].len() as u32
        };

        let mut grid = Grid::new(nrows, ncols);
        for (r, row_vals) in values.iter().enumerate() {
            for (c, v) in row_vals.iter().enumerate() {
                grid.insert_cell(r as u32, c as u32, Some(CellValue::Number(*v as f64)), None);
            }
        }

        grid
    }

    fn base_background(rows: usize, cols: usize) -> Vec<Vec<i32>> {
        (0..rows)
            .map(|r| (0..cols).map(|c| (r as i32) * 1_000 + c as i32).collect())
            .collect()
    }

    fn place_block(target: &mut [Vec<i32>], top: usize, left: usize, block: &[Vec<i32>]) {
        for (r_offset, row_vals) in block.iter().enumerate() {
            for (c_offset, value) in row_vals.iter().enumerate() {
                let row = top + r_offset;
                let col = left + c_offset;
                if let Some(row_slice) = target.get_mut(row)
                    && let Some(cell) = row_slice.get_mut(col)
                {
                    *cell = *value;
                }
            }
        }
    }

    fn grid_from_matrix(matrix: Vec<Vec<i32>>) -> Grid {
        let refs: Vec<&[i32]> = matrix.iter().map(|row| row.as_slice()).collect();
        grid_from_numbers(&refs)
    }

    #[test]
    fn detect_simple_rect_block_move_success() {
        let mut grid_a = base_background(12, 12);
        let mut grid_b = base_background(12, 12);

        let block = vec![vec![11, 12, 13], vec![21, 22, 23], vec![31, 32, 33]];

        place_block(&mut grid_a, 1, 1, &block);
        place_block(&mut grid_b, 7, 6, &block);

        let old = grid_from_matrix(grid_a);
        let new = grid_from_matrix(grid_b);

        let result = detect_exact_rect_block_move(&old, &new, &DiffConfig::default());
        assert!(
            result.is_some(),
            "should detect exact rectangular block move"
        );

        let mv = result.unwrap();
        assert_eq!(mv.src_start_row, 1);
        assert_eq!(mv.src_row_count, 3);
        assert_eq!(mv.src_start_col, 1);
        assert_eq!(mv.src_col_count, 3);
        assert_eq!(mv.dst_start_row, 7);
        assert_eq!(mv.dst_start_col, 6);
    }

    #[test]
    fn detect_rect_block_move_with_shared_columns() {
        let mut grid_a = base_background(10, 10);
        let mut grid_b = base_background(10, 10);

        let block = vec![vec![11, 12], vec![21, 22]];

        place_block(&mut grid_a, 1, 2, &block);
        place_block(&mut grid_b, 6, 2, &block);

        let old = grid_from_matrix(grid_a);
        let new = grid_from_matrix(grid_b);

        let result = detect_exact_rect_block_move(&old, &new, &DiffConfig::default());
        assert!(
            result.is_some(),
            "should detect a vertical rect move when columns overlap"
        );

        let mv = result.unwrap();
        assert_eq!(mv.src_start_row, 1);
        assert_eq!(mv.dst_start_row, 6);
        assert_eq!(mv.src_start_col, 2);
        assert_eq!(mv.dst_start_col, 2);
        assert_eq!(mv.src_row_count, 2);
        assert_eq!(mv.src_col_count, 2);
    }

    #[test]
    fn detect_bails_on_different_grid_dimensions() {
        let old = grid_from_numbers(&[&[1, 2], &[3, 4]]);
        let new = grid_from_numbers(&[&[1, 2, 5], &[3, 4, 6]]);

        let result = detect_exact_rect_block_move(&old, &new, &DiffConfig::default());
        assert!(result.is_none(), "different dimensions should bail");
    }

    #[test]
    fn detect_bails_on_empty_grid() {
        let old = Grid::new(0, 0);
        let new = Grid::new(0, 0);

        let result = detect_exact_rect_block_move(&old, &new, &DiffConfig::default());
        assert!(result.is_none(), "empty grid should bail");
    }

    #[test]
    fn detect_bails_on_identical_grids() {
        let old = grid_from_numbers(&[&[1, 2], &[3, 4]]);
        let new = grid_from_numbers(&[&[1, 2], &[3, 4]]);

        let result = detect_exact_rect_block_move(&old, &new, &DiffConfig::default());
        assert!(
            result.is_none(),
            "identical grids should bail (no differences)"
        );
    }

    #[test]
    fn detect_bails_on_internal_cell_edit() {
        let mut grid_a = base_background(10, 10);
        let mut grid_b = base_background(10, 10);

        let block = vec![vec![11, 12, 13], vec![21, 22, 23], vec![31, 32, 33]];

        place_block(&mut grid_a, 1, 1, &block);
        place_block(&mut grid_b, 6, 4, &block);
        grid_b[7][5] = 9_999;

        let old = grid_from_matrix(grid_a);
        let new = grid_from_matrix(grid_b);

        let result = detect_exact_rect_block_move(&old, &new, &DiffConfig::default());
        assert!(
            result.is_none(),
            "move with internal edit should not be detected as exact rectangular move"
        );
    }

    #[test]
    fn detect_bails_on_ambiguous_block_swap() {
        let base: Vec<Vec<i32>> = (0..6)
            .map(|r| (0..6).map(|c| 100 * r + c).collect())
            .collect();
        let mut grid_a = base.clone();
        let mut grid_b = base.clone();

        let block_one = vec![vec![900, 901], vec![902, 903]];
        let block_two = vec![vec![700, 701], vec![702, 703]];

        place_block(&mut grid_a, 0, 0, &block_one);
        place_block(&mut grid_a, 3, 3, &block_two);

        place_block(&mut grid_b, 0, 0, &block_two);
        place_block(&mut grid_b, 3, 3, &block_one);

        let old = grid_from_matrix(grid_a);
        let new = grid_from_matrix(grid_b);

        let result = detect_exact_rect_block_move(&old, &new, &DiffConfig::default());
        assert!(
            result.is_none(),
            "ambiguous block swap should not emit a rectangular move"
        );
    }

    #[allow(clippy::field_reassign_with_default)]
    #[test]
    fn detect_bails_on_oversized_row_count() {
        let mut config = DiffConfig::default();
        config.max_align_rows = 10;
        let old = Grid::new(config.max_align_rows + 1, 10);
        let new = Grid::new(config.max_align_rows + 1, 10);

        let result = detect_exact_rect_block_move(&old, &new, &config);
        assert!(
            result.is_none(),
            "grids exceeding configured max_align_rows should bail"
        );
    }

    #[allow(clippy::field_reassign_with_default)]
    #[test]
    fn detect_bails_on_oversized_col_count() {
        let mut config = DiffConfig::default();
        config.max_align_cols = 8;
        let old = Grid::new(10, config.max_align_cols + 1);
        let new = Grid::new(10, config.max_align_cols + 1);

        let result = detect_exact_rect_block_move(&old, &new, &config);
        assert!(
            result.is_none(),
            "grids exceeding configured max_align_cols should bail"
        );
    }

    #[test]
    fn detect_bails_on_single_cell_edit() {
        let old = grid_from_numbers(&[&[1, 2, 3], &[4, 5, 6], &[7, 8, 9]]);
        let new = grid_from_numbers(&[&[1, 2, 3], &[4, 99, 6], &[7, 8, 9]]);

        let result = detect_exact_rect_block_move(&old, &new, &DiffConfig::default());
        assert!(
            result.is_none(),
            "single cell edit is not a rectangular block move"
        );
    }

    #[test]
    fn detect_bails_on_pure_row_move_pattern() {
        let old = grid_from_numbers(&[&[1, 2, 3], &[4, 5, 6], &[7, 8, 9], &[10, 11, 12]]);
        let new = grid_from_numbers(&[&[7, 8, 9], &[4, 5, 6], &[1, 2, 3], &[10, 11, 12]]);

        let result = detect_exact_rect_block_move(&old, &new, &DiffConfig::default());
        assert!(
            result.is_none(),
            "pure row swap without column displacement is not a rectangular block move"
        );
    }

    #[test]
    fn detect_bails_on_non_contiguous_differences() {
        let mut grid_a = base_background(8, 8);
        let mut grid_b = base_background(8, 8);

        grid_a[1][1] = 111;
        grid_a[5][5] = 555;
        grid_a[1][5] = 115;
        grid_b[1][1] = 555;
        grid_b[5][5] = 111;
        grid_b[1][5] = 999;

        let old = grid_from_matrix(grid_a);
        let new = grid_from_matrix(grid_b);

        let result = detect_exact_rect_block_move(&old, &new, &DiffConfig::default());
        assert!(
            result.is_none(),
            "non-contiguous differences should not form a rectangular block move"
        );
    }
}

```

---

### File: `core\src\region_mask.rs`

```rust
//! Region mask for tracking which cells have been accounted for during diff.
//!
//! The `RegionMask` tracks which rows and columns are "active" (still to be processed)
//! versus "excluded" (already accounted for by a move or other operation).

use std::collections::HashSet;

#[derive(Debug, Clone, Copy)]
struct RectMask {
    row_start: u32,
    row_count: u32,
    col_start: u32,
    col_count: u32,
}

#[derive(Debug, Clone)]
pub struct RegionMask {
    excluded_rows: HashSet<u32>,
    excluded_cols: HashSet<u32>,
    excluded_rects: Vec<RectMask>,
    nrows: u32,
    ncols: u32,
    row_shift_min: Option<u32>,
    row_shift_max: Option<u32>,
    col_shift_min: Option<u32>,
    col_shift_max: Option<u32>,
}

impl RegionMask {
    pub fn all_active(nrows: u32, ncols: u32) -> Self {
        Self {
            excluded_rows: HashSet::new(),
            excluded_cols: HashSet::new(),
            excluded_rects: Vec::new(),
            nrows,
            ncols,
            row_shift_min: None,
            row_shift_max: None,
            col_shift_min: None,
            col_shift_max: None,
        }
    }

    pub fn exclude_row(&mut self, row: u32) {
        self.excluded_rows.insert(row);
    }

    pub fn exclude_rows(&mut self, start: u32, count: u32) {
        let end = start.saturating_add(count).saturating_sub(1);
        for row in start..=end {
            self.excluded_rows.insert(row);
        }
        self.row_shift_min = Some(self.row_shift_min.map_or(start, |m| m.min(start)));
        self.row_shift_max = Some(self.row_shift_max.map_or(end, |m| m.max(end)));
    }

    pub fn exclude_col(&mut self, col: u32) {
        self.excluded_cols.insert(col);
    }

    pub fn exclude_cols(&mut self, start: u32, count: u32) {
        let end = start.saturating_add(count).saturating_sub(1);
        for col in start..=end {
            self.excluded_cols.insert(col);
        }
        self.col_shift_min = Some(self.col_shift_min.map_or(start, |m| m.min(start)));
        self.col_shift_max = Some(self.col_shift_max.map_or(end, |m| m.max(end)));
    }

    #[cfg(any(test, feature = "dev-apis"))]
    pub fn exclude_rect(&mut self, row_start: u32, row_count: u32, col_start: u32, col_count: u32) {
        self.exclude_rows(row_start, row_count);
        self.exclude_cols(col_start, col_count);
    }

    pub fn exclude_rect_cells(
        &mut self,
        row_start: u32,
        row_count: u32,
        col_start: u32,
        col_count: u32,
    ) {
        self.excluded_rects.push(RectMask {
            row_start,
            row_count,
            col_start,
            col_count,
        });
    }

    pub fn is_row_active(&self, row: u32) -> bool {
        !self.excluded_rows.contains(&row)
    }

    pub fn is_col_active(&self, col: u32) -> bool {
        !self.excluded_cols.contains(&col)
    }

    fn is_cell_excluded_by_rects(&self, row: u32, col: u32) -> bool {
        self.excluded_rects.iter().any(|rect| {
            row >= rect.row_start
                && row < rect.row_start.saturating_add(rect.row_count)
                && col >= rect.col_start
                && col < rect.col_start.saturating_add(rect.col_count)
        })
    }

    pub fn is_cell_active(&self, row: u32, col: u32) -> bool {
        self.is_row_active(row)
            && self.is_col_active(col)
            && !self.is_cell_excluded_by_rects(row, col)
    }

    pub fn active_row_count(&self) -> u32 {
        self.nrows.saturating_sub(self.excluded_rows.len() as u32)
    }

    pub fn active_col_count(&self) -> u32 {
        self.ncols.saturating_sub(self.excluded_cols.len() as u32)
    }

    pub fn active_rows(&self) -> impl Iterator<Item = u32> + '_ {
        (0..self.nrows).filter(|r| self.is_row_active(*r))
    }

    pub fn active_cols(&self) -> impl Iterator<Item = u32> + '_ {
        (0..self.ncols).filter(|c| self.is_col_active(*c))
    }

    pub fn has_excluded_rows(&self) -> bool {
        !self.excluded_rows.is_empty()
    }

    pub fn has_excluded_cols(&self) -> bool {
        !self.excluded_cols.is_empty()
    }

    pub fn has_excluded_rects(&self) -> bool {
        !self.excluded_rects.is_empty()
    }

    pub fn has_exclusions(&self) -> bool {
        self.has_excluded_rows() || self.has_excluded_cols() || self.has_excluded_rects()
    }

    pub fn has_active_cells(&self) -> bool {
        self.active_row_count() > 0 && self.active_col_count() > 0
    }

    #[cfg(any(test, feature = "dev-apis"))]
    pub fn rows_overlap_excluded(&self, start: u32, count: u32) -> bool {
        for row in start..start.saturating_add(count) {
            if self.excluded_rows.contains(&row) {
                return true;
            }
        }
        false
    }

    #[cfg(any(test, feature = "dev-apis"))]
    pub fn cols_overlap_excluded(&self, start: u32, count: u32) -> bool {
        for col in start..start.saturating_add(count) {
            if self.excluded_cols.contains(&col) {
                return true;
            }
        }
        false
    }

    #[cfg(any(test, feature = "dev-apis"))]
    pub fn rect_overlaps_excluded(
        &self,
        row_start: u32,
        row_count: u32,
        col_start: u32,
        col_count: u32,
    ) -> bool {
        self.rows_overlap_excluded(row_start, row_count)
            || self.cols_overlap_excluded(col_start, col_count)
    }

    #[cfg(any(test, feature = "dev-apis"))]
    pub fn is_row_in_shift_zone(&self, row: u32) -> bool {
        match (self.row_shift_min, self.row_shift_max) {
            (Some(min), Some(max)) => row >= min && row <= max,
            _ => false,
        }
    }

    #[cfg(any(test, feature = "dev-apis"))]
    pub fn is_col_in_shift_zone(&self, col: u32) -> bool {
        match (self.col_shift_min, self.col_shift_max) {
            (Some(min), Some(max)) => col >= min && col <= max,
            _ => false,
        }
    }

    pub fn row_shift_bounds(&self) -> Option<(u32, u32)> {
        match (self.row_shift_min, self.row_shift_max) {
            (Some(min), Some(max)) => Some((min, max)),
            _ => None,
        }
    }

    pub fn col_shift_bounds(&self) -> Option<(u32, u32)> {
        match (self.col_shift_min, self.col_shift_max) {
            (Some(min), Some(max)) => Some((min, max)),
            _ => None,
        }
    }
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn all_active_initially() {
        let mask = RegionMask::all_active(10, 5);
        assert!(mask.is_row_active(0));
        assert!(mask.is_row_active(9));
        assert!(mask.is_col_active(0));
        assert!(mask.is_col_active(4));
        assert_eq!(mask.active_row_count(), 10);
        assert_eq!(mask.active_col_count(), 5);
    }

    #[test]
    fn exclude_single_row() {
        let mut mask = RegionMask::all_active(10, 5);
        mask.exclude_row(3);
        assert!(!mask.is_row_active(3));
        assert!(mask.is_row_active(2));
        assert!(mask.is_row_active(4));
        assert_eq!(mask.active_row_count(), 9);
    }

    #[test]
    fn exclude_row_range() {
        let mut mask = RegionMask::all_active(10, 5);
        mask.exclude_rows(2, 4);
        assert!(!mask.is_row_active(2));
        assert!(!mask.is_row_active(5));
        assert!(mask.is_row_active(1));
        assert!(mask.is_row_active(6));
        assert_eq!(mask.active_row_count(), 6);
    }

    #[test]
    fn exclude_rect() {
        let mut mask = RegionMask::all_active(10, 8);
        mask.exclude_rect(2, 3, 4, 2);
        assert!(!mask.is_row_active(2));
        assert!(!mask.is_row_active(4));
        assert!(mask.is_row_active(1));
        assert!(mask.is_row_active(5));
        assert!(!mask.is_col_active(4));
        assert!(!mask.is_col_active(5));
        assert!(mask.is_col_active(3));
        assert!(mask.is_col_active(6));
    }

    #[test]
    fn cell_active_based_on_row_and_col() {
        let mut mask = RegionMask::all_active(10, 10);
        mask.exclude_row(3);
        mask.exclude_col(5);
        assert!(!mask.is_cell_active(3, 5));
        assert!(!mask.is_cell_active(3, 0));
        assert!(!mask.is_cell_active(0, 5));
        assert!(mask.is_cell_active(0, 0));
        assert!(mask.is_cell_active(4, 6));
    }

    #[test]
    fn active_rows_iterator() {
        let mut mask = RegionMask::all_active(5, 3);
        mask.exclude_row(1);
        mask.exclude_row(3);
        let active: Vec<u32> = mask.active_rows().collect();
        assert_eq!(active, vec![0, 2, 4]);
    }

    #[test]
    fn rows_overlap_excluded_detects_overlap() {
        let mut mask = RegionMask::all_active(10, 5);
        mask.exclude_rows(3, 2);
        assert!(mask.rows_overlap_excluded(2, 3));
        assert!(mask.rows_overlap_excluded(4, 2));
        assert!(!mask.rows_overlap_excluded(0, 2));
        assert!(!mask.rows_overlap_excluded(5, 3));
    }

    #[test]
    fn cols_overlap_excluded_detects_overlap() {
        let mut mask = RegionMask::all_active(5, 10);
        mask.exclude_cols(4, 3);
        assert!(mask.cols_overlap_excluded(3, 2));
        assert!(mask.cols_overlap_excluded(6, 2));
        assert!(!mask.cols_overlap_excluded(0, 3));
        assert!(!mask.cols_overlap_excluded(7, 3));
    }

    #[test]
    fn rect_overlaps_excluded_detects_any_overlap() {
        let mut mask = RegionMask::all_active(10, 10);
        mask.exclude_rect(2, 3, 4, 2);
        assert!(mask.rect_overlaps_excluded(1, 2, 0, 3));
        assert!(mask.rect_overlaps_excluded(0, 2, 3, 2));
        assert!(!mask.rect_overlaps_excluded(6, 2, 7, 2));
    }

    #[test]
    fn exclude_rect_cells_masks_only_that_region() {
        let mut mask = RegionMask::all_active(6, 6);
        mask.exclude_rect_cells(2, 2, 2, 2);

        assert!(!mask.is_cell_active(2, 2));
        assert!(!mask.is_cell_active(3, 3));

        assert!(mask.is_cell_active(1, 2));
        assert!(mask.is_cell_active(2, 1));
        assert!(mask.is_cell_active(4, 4));

        assert!(mask.has_exclusions());
        assert!(mask.has_excluded_rects());
    }
}

```

---

### File: `core\src\row_alignment.rs`

```rust
//! Legacy row alignment algorithms (pre-AMR).
//!
//! This module contains the original row alignment implementation that predates
//! the Anchor-Move-Refine (AMR) algorithm in `alignment/`. These functions are
//! retained for:
//!
//! 1. **Fallback scenarios**: The engine may use these when AMR cannot produce
//!    a useful alignment (e.g., heavily repetitive data).
//!
//! 2. **Move detection helpers**: Some functions (`detect_exact_row_block_move`,
//!    `detect_fuzzy_row_block_move`) are still used by the engine's
//!    masked move detection logic.
//!
//! 3. **Test coverage**: Unit tests validate these algorithms work correctly.
//!
//! ## Migration Status
//!
//! The primary alignment path now uses `alignment::align_rows_amr`. The legacy
//! functions are invoked only when:
//! - AMR returns `None` (fallback to `align_row_changes`)
//! - Explicit move detection in masked regions
//!
//! Functions marked `#[cfg(any(test, feature = "dev-apis"))]` are retained for
//! testing but not called from production code paths.

use std::collections::HashSet;

use crate::config::DiffConfig;
use crate::grid_view::{GridView, HashStats, RowHash, RowMeta};
use crate::workbook::Grid;

pub(crate) use crate::alignment_types::{RowAlignment, RowBlockMove};

const _HASH_COLLISION_NOTE: &str = "128-bit xxHash3 collision probability ~10^-29 at 50K rows (birthday bound); \
     secondary verification not required; see hashing.rs for detailed rationale.";

pub(crate) fn detect_exact_row_block_move(
    old: &Grid,
    new: &Grid,
    config: &DiffConfig,
) -> Option<RowBlockMove> {
    if old.nrows != new.nrows || old.ncols != new.ncols {
        return None;
    }

    if old.nrows == 0 {
        return None;
    }

    if !is_within_size_bounds(old, new, config) {
        return None;
    }

    let view_a = GridView::from_grid_with_config(old, config);
    let view_b = GridView::from_grid_with_config(new, config);

    if view_a.is_low_info_dominated() || view_b.is_low_info_dominated() {
        return None;
    }

    let stats = HashStats::from_row_meta(&view_a.row_meta, &view_b.row_meta);
    if stats.has_heavy_repetition(config.max_hash_repeat) {
        return None;
    }

    let meta_a = &view_a.row_meta;
    let meta_b = &view_b.row_meta;
    let n = meta_a.len();

    if meta_a
        .iter()
        .zip(meta_b.iter())
        .all(|(a, b)| a.signature == b.signature)
    {
        return None;
    }

    let prefix = (0..n).find(|&idx| meta_a[idx].signature != meta_b[idx].signature)?;

    let mut suffix_len = 0usize;
    while suffix_len < n.saturating_sub(prefix) {
        let idx_a = n - 1 - suffix_len;
        let idx_b = n - 1 - suffix_len;
        if meta_a[idx_a].signature == meta_b[idx_b].signature {
            suffix_len += 1;
        } else {
            break;
        }
    }
    let tail_start = n - suffix_len;

    let try_candidate = |src_start: usize, dst_start: usize| -> Option<RowBlockMove> {
        if src_start >= tail_start || dst_start >= tail_start {
            return None;
        }

        let mut len = 0usize;
        while src_start + len < tail_start && dst_start + len < tail_start {
            if meta_a[src_start + len].signature != meta_b[dst_start + len].signature {
                break;
            }
            len += 1;
        }

        if len == 0 {
            return None;
        }

        let src_end = src_start + len;
        let dst_end = dst_start + len;

        if !(src_end <= dst_start || dst_end <= src_start) {
            return None;
        }

        let mut idx_a = 0usize;
        let mut idx_b = 0usize;

        loop {
            if idx_a == src_start {
                idx_a = src_end;
            }
            if idx_b == dst_start {
                idx_b = dst_end;
            }

            if idx_a >= n && idx_b >= n {
                break;
            }

            if idx_a >= n || idx_b >= n {
                return None;
            }

            if meta_a[idx_a].signature != meta_b[idx_b].signature {
                return None;
            }

            idx_a += 1;
            idx_b += 1;
        }

        for meta in &meta_a[src_start..src_end] {
            if stats.freq_a.get(&meta.signature).copied().unwrap_or(0) != 1
                || stats.freq_b.get(&meta.signature).copied().unwrap_or(0) != 1
            {
                return None;
            }
        }

        Some(RowBlockMove {
            src_start_row: meta_a[src_start].row_idx,
            dst_start_row: meta_b[dst_start].row_idx,
            row_count: len as u32,
        })
    };

    if let Some(src_start) =
        (prefix..tail_start).find(|&idx| meta_a[idx].signature == meta_b[prefix].signature)
        && let Some(mv) = try_candidate(src_start, prefix)
    {
        return Some(mv);
    }

    if let Some(dst_start) =
        (prefix..tail_start).find(|&idx| meta_b[idx].signature == meta_a[prefix].signature)
        && let Some(mv) = try_candidate(prefix, dst_start)
    {
        return Some(mv);
    }

    None
}

pub(crate) fn detect_fuzzy_row_block_move(
    old: &Grid,
    new: &Grid,
    config: &DiffConfig,
) -> Option<RowBlockMove> {
    if old.nrows != new.nrows || old.ncols != new.ncols {
        return None;
    }

    if old.nrows == 0 {
        return None;
    }

    if !is_within_size_bounds(old, new, config) {
        return None;
    }

    let view_a = GridView::from_grid_with_config(old, config);
    let view_b = GridView::from_grid_with_config(new, config);

    if view_a.is_low_info_dominated() || view_b.is_low_info_dominated() {
        return None;
    }

    let stats = HashStats::from_row_meta(&view_a.row_meta, &view_b.row_meta);
    if stats.has_heavy_repetition(config.max_hash_repeat) {
        return None;
    }

    let meta_a = &view_a.row_meta;
    let meta_b = &view_b.row_meta;

    if meta_a
        .iter()
        .zip(meta_b.iter())
        .all(|(a, b)| a.signature == b.signature)
    {
        return None;
    }

    let n = meta_a.len();
    let mut prefix = 0usize;
    while prefix < n && meta_a[prefix].signature == meta_b[prefix].signature {
        prefix += 1;
    }
    if prefix == n {
        return None;
    }

    let mut suffix_len = 0usize;
    while suffix_len < n.saturating_sub(prefix) {
        let idx_a = n - 1 - suffix_len;
        let idx_b = idx_a;
        if meta_a[idx_a].signature == meta_b[idx_b].signature {
            suffix_len += 1;
        } else {
            break;
        }
    }

    let mismatch_end = n - suffix_len;
    if mismatch_end <= prefix {
        return None;
    }

    let mid_len = mismatch_end - prefix;
    if mid_len <= 1 {
        return None;
    }

    let max_block_len = mid_len
        .saturating_sub(1)
        .min(config.max_fuzzy_block_rows as usize);
    if max_block_len == 0 {
        return None;
    }

    let mut candidate: Option<RowBlockMove> = None;

    for block_len in 1..=max_block_len {
        let remaining = mid_len - block_len;

        // Block moved upward: [middle][block] -> [block'][middle]
        if hashes_match(
            &meta_a[prefix..prefix + remaining],
            &meta_b[prefix + block_len..mismatch_end],
        ) {
            let src_block = &meta_a[prefix + remaining..mismatch_end];
            let dst_block = &meta_b[prefix..prefix + block_len];

            if block_similarity(src_block, dst_block) >= config.fuzzy_similarity_threshold {
                let mv = RowBlockMove {
                    src_start_row: src_block[0].row_idx,
                    dst_start_row: dst_block[0].row_idx,
                    row_count: block_len as u32,
                };
                if mv.src_start_row != mv.dst_start_row {
                    if candidate.is_some() {
                        return None;
                    }
                    candidate = Some(mv);
                }
            }
        }

        // Block moved downward: [block][middle] -> [middle][block']
        if hashes_match(
            &meta_a[prefix + block_len..mismatch_end],
            &meta_b[prefix..prefix + remaining],
        ) {
            let src_block = &meta_a[prefix..prefix + block_len];
            let dst_block = &meta_b[prefix + remaining..mismatch_end];

            if block_similarity(src_block, dst_block) >= config.fuzzy_similarity_threshold {
                let mv = RowBlockMove {
                    src_start_row: src_block[0].row_idx,
                    dst_start_row: dst_block[0].row_idx,
                    row_count: block_len as u32,
                };
                if mv.src_start_row != mv.dst_start_row {
                    if candidate.is_some() {
                        return None;
                    }
                    candidate = Some(mv);
                }
            }
        }
    }

    candidate
}

#[cfg(test)]
pub(crate) fn align_row_changes(
    old: &Grid,
    new: &Grid,
    config: &DiffConfig,
) -> Option<RowAlignment> {
    let view_a = GridView::from_grid_with_config(old, config);
    let view_b = GridView::from_grid_with_config(new, config);
    align_row_changes_from_views(&view_a, &view_b, config)
}

pub(crate) fn align_row_changes_from_views(
    old_view: &GridView,
    new_view: &GridView,
    config: &DiffConfig,
) -> Option<RowAlignment> {
    let row_diff = new_view.source.nrows as i64 - old_view.source.nrows as i64;
    if row_diff.abs() == 1 {
        return align_single_row_change_from_views(old_view, new_view, config);
    }

    align_rows_internal(old_view, new_view, true, config)
}

#[cfg(any(test, feature = "dev-apis"))]
pub(crate) fn align_single_row_change(
    old: &Grid,
    new: &Grid,
    config: &DiffConfig,
) -> Option<RowAlignment> {
    let view_a = GridView::from_grid_with_config(old, config);
    let view_b = GridView::from_grid_with_config(new, config);
    align_single_row_change_from_views(&view_a, &view_b, config)
}

pub(crate) fn align_single_row_change_from_views(
    old_view: &GridView,
    new_view: &GridView,
    config: &DiffConfig,
) -> Option<RowAlignment> {
    align_rows_internal(old_view, new_view, false, config)
}

fn align_rows_internal(
    old_view: &GridView,
    new_view: &GridView,
    allow_blocks: bool,
    config: &DiffConfig,
) -> Option<RowAlignment> {
    if !is_within_size_bounds(old_view.source, new_view.source, config) {
        return None;
    }

    if old_view.source.ncols != new_view.source.ncols {
        return None;
    }

    let row_diff = new_view.source.nrows as i64 - old_view.source.nrows as i64;
    if row_diff == 0 {
        return None;
    }

    let abs_diff = row_diff.unsigned_abs() as u32;

    if !allow_blocks && abs_diff != 1 {
        return None;
    }

    if abs_diff != 1 && (!allow_blocks || abs_diff > config.max_block_gap) {
        return None;
    }

    if old_view.is_low_info_dominated() || new_view.is_low_info_dominated() {
        return None;
    }

    let stats = HashStats::from_row_meta(&old_view.row_meta, &new_view.row_meta);
    if stats.has_heavy_repetition(config.max_hash_repeat) {
        return None;
    }

    if row_diff == 1 {
        find_single_gap_alignment(
            &old_view.row_meta,
            &new_view.row_meta,
            &stats,
            RowChange::Insert,
        )
    } else if row_diff == -1 {
        find_single_gap_alignment(
            &old_view.row_meta,
            &new_view.row_meta,
            &stats,
            RowChange::Delete,
        )
    } else if !allow_blocks {
        None
    } else if row_diff > 0 {
        find_block_gap_alignment(
            &old_view.row_meta,
            &new_view.row_meta,
            &stats,
            RowChange::Insert,
            abs_diff,
        )
    } else {
        find_block_gap_alignment(
            &old_view.row_meta,
            &new_view.row_meta,
            &stats,
            RowChange::Delete,
            abs_diff,
        )
    }
}

enum RowChange {
    Insert,
    Delete,
}

fn find_single_gap_alignment(
    rows_a: &[crate::grid_view::RowMeta],
    rows_b: &[crate::grid_view::RowMeta],
    stats: &HashStats<RowHash>,
    change: RowChange,
) -> Option<RowAlignment> {
    let mut matched = Vec::new();
    let mut inserted = Vec::new();
    let mut deleted = Vec::new();
    let mut skipped = false;

    let mut idx_a = 0usize;
    let mut idx_b = 0usize;

    while idx_a < rows_a.len() && idx_b < rows_b.len() {
        let meta_a = rows_a[idx_a];
        let meta_b = rows_b[idx_b];

        if meta_a.signature == meta_b.signature {
            matched.push((meta_a.row_idx, meta_b.row_idx));
            idx_a += 1;
            idx_b += 1;
            continue;
        }

        if skipped {
            return None;
        }

        match change {
            RowChange::Insert => {
                if !stats.is_unique_to_b(meta_b.signature) {
                    return None;
                }
                inserted.push(meta_b.row_idx);
                idx_b += 1;
            }
            RowChange::Delete => {
                if !stats.is_unique_to_a(meta_a.signature) {
                    return None;
                }
                deleted.push(meta_a.row_idx);
                idx_a += 1;
            }
        }

        skipped = true;
    }

    if idx_a < rows_a.len() || idx_b < rows_b.len() {
        if skipped {
            return None;
        }

        match change {
            RowChange::Insert if idx_a == rows_a.len() && rows_b.len() == idx_b + 1 => {
                let meta_b = rows_b[idx_b];
                if !stats.is_unique_to_b(meta_b.signature) {
                    return None;
                }
                inserted.push(meta_b.row_idx);
            }
            RowChange::Delete if idx_b == rows_b.len() && rows_a.len() == idx_a + 1 => {
                let meta_a = rows_a[idx_a];
                if !stats.is_unique_to_a(meta_a.signature) {
                    return None;
                }
                deleted.push(meta_a.row_idx);
            }
            _ => return None,
        }
    }

    if inserted.len() + deleted.len() != 1 {
        return None;
    }

    let alignment = RowAlignment {
        matched,
        inserted,
        deleted,
        moves: Vec::new(),
    };

    debug_assert!(
        is_monotonic(&alignment.matched),
        "matched pairs must be strictly increasing in both dimensions"
    );

    Some(alignment)
}

fn find_block_gap_alignment(
    rows_a: &[crate::grid_view::RowMeta],
    rows_b: &[crate::grid_view::RowMeta],
    stats: &HashStats<RowHash>,
    change: RowChange,
    gap: u32,
) -> Option<RowAlignment> {
    let gap = gap as usize;
    if gap == 0 {
        return None;
    }

    let (shorter_len, longer_len) = match change {
        RowChange::Insert => (rows_a.len(), rows_b.len()),
        RowChange::Delete => (rows_b.len(), rows_a.len()),
    };

    if longer_len.saturating_sub(shorter_len) != gap {
        return None;
    }

    let mut prefix = 0usize;
    while prefix < rows_a.len()
        && prefix < rows_b.len()
        && rows_a[prefix].signature == rows_b[prefix].signature
    {
        prefix += 1;
    }

    let mut suffix = 0usize;
    while suffix < shorter_len.saturating_sub(prefix) {
        let idx_a = rows_a.len() - 1 - suffix;
        let idx_b = rows_b.len() - 1 - suffix;
        if rows_a[idx_a].signature == rows_b[idx_b].signature {
            suffix += 1;
        } else {
            break;
        }
    }

    if prefix + suffix != shorter_len {
        return None;
    }

    let mut matched = Vec::with_capacity(shorter_len);
    let mut inserted = Vec::new();
    let mut deleted = Vec::new();

    match change {
        RowChange::Insert => {
            let block_start = prefix;
            let block_end = block_start + gap;
            if block_end > rows_b.len() {
                return None;
            }

            for meta in &rows_b[block_start..block_end] {
                if !stats.is_unique_to_b(meta.signature) {
                    return None;
                }
                inserted.push(meta.row_idx);
            }

            for (idx, meta_a) in rows_a.iter().enumerate() {
                let b_idx = if idx < block_start { idx } else { idx + gap };
                matched.push((meta_a.row_idx, rows_b[b_idx].row_idx));
            }
        }
        RowChange::Delete => {
            let block_start = prefix;
            let block_end = block_start + gap;
            if block_end > rows_a.len() {
                return None;
            }

            for meta in &rows_a[block_start..block_end] {
                if !stats.is_unique_to_a(meta.signature) {
                    return None;
                }
                deleted.push(meta.row_idx);
            }

            for (idx_b, meta_b) in rows_b.iter().enumerate() {
                let a_idx = if idx_b < block_start {
                    idx_b
                } else {
                    idx_b + gap
                };
                matched.push((rows_a[a_idx].row_idx, meta_b.row_idx));
            }
        }
    }

    let alignment = RowAlignment {
        matched,
        inserted,
        deleted,
        moves: Vec::new(),
    };

    debug_assert!(
        is_monotonic(&alignment.matched),
        "matched pairs must be strictly increasing in both dimensions"
    );

    Some(alignment)
}

fn is_monotonic(pairs: &[(u32, u32)]) -> bool {
    pairs.windows(2).all(|w| w[0].0 < w[1].0 && w[0].1 < w[1].1)
}

fn is_within_size_bounds(old: &Grid, new: &Grid, config: &DiffConfig) -> bool {
    let rows = old.nrows.max(new.nrows);
    let cols = old.ncols.max(new.ncols);
    rows <= config.max_align_rows && cols <= config.max_align_cols
}

fn hashes_match(slice_a: &[RowMeta], slice_b: &[RowMeta]) -> bool {
    slice_a.len() == slice_b.len()
        && slice_a
            .iter()
            .zip(slice_b.iter())
            .all(|(a, b)| a.signature == b.signature)
}

fn block_similarity(slice_a: &[RowMeta], slice_b: &[RowMeta]) -> f64 {
    let tokens_a: HashSet<RowHash> = slice_a.iter().map(|m| m.signature).collect();
    let tokens_b: HashSet<RowHash> = slice_b.iter().map(|m| m.signature).collect();

    let intersection = tokens_a.intersection(&tokens_b).count();
    let union = tokens_a.union(&tokens_b).count();
    let jaccard = if union == 0 {
        0.0
    } else {
        intersection as f64 / union as f64
    };

    let positional_matches = slice_a
        .iter()
        .zip(slice_b.iter())
        .filter(|(a, b)| a.signature == b.signature)
        .count();
    let positional_ratio = (positional_matches as f64 + 1.0) / (slice_a.len() as f64 + 1.0);

    jaccard.max(positional_ratio)
}

#[cfg(test)]
mod tests {
    use super::*;
    use crate::workbook::CellValue;

    fn grid_from_rows(rows: &[&[i32]]) -> Grid {
        let nrows = rows.len() as u32;
        let ncols = if nrows == 0 { 0 } else { rows[0].len() as u32 };
        let mut grid = Grid::new(nrows, ncols);

        for (r_idx, row_vals) in rows.iter().enumerate() {
            for (c_idx, value) in row_vals.iter().enumerate() {
                grid.insert_cell(
                    r_idx as u32,
                    c_idx as u32,
                    Some(CellValue::Number(*value as f64)),
                    None,
                );
            }
        }

        grid
    }

    #[test]
    fn detects_exact_row_block_move() {
        let base: Vec<Vec<i32>> = (1..=20)
            .map(|r| (1..=3).map(|c| r * 10 + c).collect())
            .collect();
        let base_refs: Vec<&[i32]> = base.iter().map(|row| row.as_slice()).collect();
        let grid_a = grid_from_rows(&base_refs);

        let mut rows_b = base.clone();
        let moved_block: Vec<Vec<i32>> = rows_b.drain(4..8).collect();
        rows_b.splice(12..12, moved_block);
        let rows_b_refs: Vec<&[i32]> = rows_b.iter().map(|row| row.as_slice()).collect();
        let grid_b = grid_from_rows(&rows_b_refs);

        let mv = detect_exact_row_block_move(&grid_a, &grid_b, &DiffConfig::default())
            .expect("expected block move to be found");
        assert_eq!(
            mv,
            RowBlockMove {
                src_start_row: 4,
                dst_start_row: 12,
                row_count: 4
            }
        );
    }

    #[test]
    fn block_move_detection_rejects_internal_edits() {
        let base: Vec<Vec<i32>> = (1..=12)
            .map(|r| (1..=2).map(|c| r * 10 + c).collect())
            .collect();
        let base_refs: Vec<&[i32]> = base.iter().map(|row| row.as_slice()).collect();
        let grid_a = grid_from_rows(&base_refs);

        let mut rows_b = base.clone();
        let mut moved_block: Vec<Vec<i32>> = rows_b.drain(2..5).collect();
        moved_block[1][0] = 9_999;
        rows_b.splice(6..6, moved_block);
        let rows_b_refs: Vec<&[i32]> = rows_b.iter().map(|row| row.as_slice()).collect();
        let grid_b = grid_from_rows(&rows_b_refs);

        assert!(detect_exact_row_block_move(&grid_a, &grid_b, &DiffConfig::default()).is_none());
    }

    #[test]
    fn detects_fuzzy_row_block_move_with_single_internal_edit() {
        let base: Vec<Vec<i32>> = (1..=18)
            .map(|r| (1..=3).map(|c| r * 10 + c).collect())
            .collect();
        let base_refs: Vec<&[i32]> = base.iter().map(|row| row.as_slice()).collect();
        let grid_a = grid_from_rows(&base_refs);

        let mut rows_b = base.clone();
        let mut moved_block: Vec<Vec<i32>> = rows_b.drain(4..8).collect();
        moved_block[1][1] = 9_999;
        rows_b.splice(12..12, moved_block);
        let rows_b_refs: Vec<&[i32]> = rows_b.iter().map(|row| row.as_slice()).collect();
        let grid_b = grid_from_rows(&rows_b_refs);

        assert!(
            detect_exact_row_block_move(&grid_a, &grid_b, &DiffConfig::default()).is_none(),
            "internal edits should prevent exact move detection"
        );

        let mv = detect_fuzzy_row_block_move(&grid_a, &grid_b, &DiffConfig::default())
            .expect("expected fuzzy row block move to be detected");
        assert_eq!(
            mv,
            RowBlockMove {
                src_start_row: 4,
                dst_start_row: 12,
                row_count: 4
            }
        );
    }

    #[test]
    fn fuzzy_move_rejects_low_similarity_block() {
        let base: Vec<Vec<i32>> = (1..=16)
            .map(|r| (1..=3).map(|c| r * 10 + c).collect())
            .collect();
        let base_refs: Vec<&[i32]> = base.iter().map(|row| row.as_slice()).collect();
        let grid_a = grid_from_rows(&base_refs);

        let mut rows_b = base.clone();
        let mut moved_block: Vec<Vec<i32>> = rows_b.drain(3..7).collect();
        for row in &mut moved_block {
            for value in row.iter_mut() {
                *value += 50_000;
            }
        }
        rows_b.splice(10..10, moved_block);
        let rows_b_refs: Vec<&[i32]> = rows_b.iter().map(|row| row.as_slice()).collect();
        let grid_b = grid_from_rows(&rows_b_refs);

        assert!(detect_exact_row_block_move(&grid_a, &grid_b, &DiffConfig::default()).is_none());
        assert!(
            detect_fuzzy_row_block_move(&grid_a, &grid_b, &DiffConfig::default()).is_none(),
            "similarity below threshold should bail out"
        );
    }

    #[test]
    fn fuzzy_move_bails_on_heavy_repetition_or_ambiguous_candidates() {
        let repeated_row = [1, 2];
        let rows_a: Vec<Vec<i32>> = (0..10).map(|_| repeated_row.to_vec()).collect();
        let mut rows_b = rows_a.clone();

        let block: Vec<Vec<i32>> = rows_b.drain(0..3).collect();
        rows_b.splice(5..5, block);

        let rows_a_refs: Vec<&[i32]> = rows_a.iter().map(|row| row.as_slice()).collect();
        let rows_b_refs: Vec<&[i32]> = rows_b.iter().map(|row| row.as_slice()).collect();
        let grid_a = grid_from_rows(&rows_a_refs);
        let grid_b = grid_from_rows(&rows_b_refs);

        assert!(
            detect_fuzzy_row_block_move(&grid_a, &grid_b, &DiffConfig::default()).is_none(),
            "heavy repetition or ambiguous candidates should not emit a move"
        );
    }

    #[test]
    fn fuzzy_move_noop_when_grids_identical() {
        let base: Vec<Vec<i32>> = (1..=6)
            .map(|r| (1..=2).map(|c| r * 10 + c).collect())
            .collect();
        let base_refs: Vec<&[i32]> = base.iter().map(|row| row.as_slice()).collect();
        let grid_a = grid_from_rows(&base_refs);
        let grid_b = grid_from_rows(&base_refs);

        assert!(detect_exact_row_block_move(&grid_a, &grid_b, &DiffConfig::default()).is_none());
        assert!(detect_fuzzy_row_block_move(&grid_a, &grid_b, &DiffConfig::default()).is_none());
    }

    #[test]
    fn detects_fuzzy_row_block_move_upward_with_single_internal_edit() {
        let base: Vec<Vec<i32>> = (1..=18)
            .map(|r| (1..=3).map(|c| r * 10 + c).collect())
            .collect();
        let base_refs: Vec<&[i32]> = base.iter().map(|row| row.as_slice()).collect();
        let grid_a = grid_from_rows(&base_refs);

        let mut rows_b = base.clone();
        let mut moved_block: Vec<Vec<i32>> = rows_b.drain(12..16).collect();
        moved_block[1][1] = 9_999;
        rows_b.splice(4..4, moved_block);
        let rows_b_refs: Vec<&[i32]> = rows_b.iter().map(|row| row.as_slice()).collect();
        let grid_b = grid_from_rows(&rows_b_refs);

        assert!(
            detect_exact_row_block_move(&grid_a, &grid_b, &DiffConfig::default()).is_none(),
            "internal edits should prevent exact move detection"
        );

        let mv = detect_fuzzy_row_block_move(&grid_a, &grid_b, &DiffConfig::default())
            .expect("expected fuzzy row block move upward to be detected");
        assert_eq!(
            mv,
            RowBlockMove {
                src_start_row: 12,
                dst_start_row: 4,
                row_count: 4
            }
        );
    }

    #[test]
    fn fuzzy_move_bails_on_ambiguous_candidates_below_repetition_threshold() {
        let base: Vec<Vec<i32>> = (1..=16)
            .map(|r| (1..=3).map(|c| r * 10 + c).collect())
            .collect();
        let base_refs: Vec<&[i32]> = base.iter().map(|row| row.as_slice()).collect();
        let grid_baseline_a = grid_from_rows(&base_refs);

        let mut rows_baseline_b = base.clone();
        let mut moved: Vec<Vec<i32>> = rows_baseline_b.drain(3..7).collect();
        moved[1][1] = 9999;
        rows_baseline_b.splice(10..10, moved);
        let refs_baseline_b: Vec<&[i32]> =
            rows_baseline_b.iter().map(|row| row.as_slice()).collect();
        let grid_baseline_b = grid_from_rows(&refs_baseline_b);

        assert!(
            detect_fuzzy_row_block_move(&grid_baseline_a, &grid_baseline_b, &DiffConfig::default())
                .is_some(),
            "baseline: non-ambiguous fuzzy move should be detected"
        );

        let rows_a: Vec<Vec<i32>> = vec![
            vec![1, 2, 3],
            vec![4, 5, 6],
            vec![100, 200, 300],
            vec![101, 201, 301],
            vec![102, 202, 302],
            vec![103, 203, 303],
            vec![100, 200, 300],
            vec![101, 201, 301],
            vec![102, 202, 302],
            vec![103, 203, 999],
            vec![31, 32, 33],
            vec![34, 35, 36],
        ];

        let mut rows_b = rows_a.clone();
        let block1: Vec<Vec<i32>> = rows_b.drain(2..6).collect();
        rows_b.splice(6..6, block1);

        let refs_a: Vec<&[i32]> = rows_a.iter().map(|r| r.as_slice()).collect();
        let refs_b: Vec<&[i32]> = rows_b.iter().map(|r| r.as_slice()).collect();
        let grid_a = grid_from_rows(&refs_a);
        let grid_b = grid_from_rows(&refs_b);

        assert!(
            detect_fuzzy_row_block_move(&grid_a, &grid_b, &DiffConfig::default()).is_none(),
            "ambiguous candidates: two similar blocks swapped should trigger ambiguity bail-out"
        );
    }

    #[test]
    fn fuzzy_move_at_max_block_rows_threshold() {
        let config = DiffConfig::default();
        let base: Vec<Vec<i32>> = (1..=70)
            .map(|r| (1..=3).map(|c| r * 10 + c).collect())
            .collect();
        let base_refs: Vec<&[i32]> = base.iter().map(|row| row.as_slice()).collect();
        let grid_a = grid_from_rows(&base_refs);

        let mut rows_b = base.clone();
        let mut moved_block: Vec<Vec<i32>> = rows_b.drain(4..36).collect();
        moved_block[15][1] = 9_999;
        rows_b.splice(36..36, moved_block);
        let rows_b_refs: Vec<&[i32]> = rows_b.iter().map(|row| row.as_slice()).collect();
        let grid_b = grid_from_rows(&rows_b_refs);

        assert!(
            detect_exact_row_block_move(&grid_a, &grid_b, &config).is_none(),
            "internal edits should prevent exact move detection"
        );

        let mv = detect_fuzzy_row_block_move(&grid_a, &grid_b, &config)
            .expect("expected fuzzy move at configured max_fuzzy_block_rows to be detected");
        assert_eq!(
            mv,
            RowBlockMove {
                src_start_row: 4,
                dst_start_row: 36,
                row_count: config.max_fuzzy_block_rows
            }
        );
    }

    #[test]
    fn fuzzy_move_at_max_hash_repeat_boundary() {
        let base: Vec<Vec<i32>> = (1..=18)
            .map(|r| (1..=3).map(|c| r * 10 + c).collect())
            .collect();
        let base_refs: Vec<&[i32]> = base.iter().map(|row| row.as_slice()).collect();
        let grid_base = grid_from_rows(&base_refs);

        let mut rows_moved = base.clone();
        let mut moved_block: Vec<Vec<i32>> = rows_moved.drain(4..8).collect();
        moved_block[1][1] = 9_999;
        rows_moved.splice(12..12, moved_block);
        let moved_refs: Vec<&[i32]> = rows_moved.iter().map(|row| row.as_slice()).collect();
        let grid_moved = grid_from_rows(&moved_refs);

        assert!(
            detect_fuzzy_row_block_move(&grid_base, &grid_moved, &DiffConfig::default()).is_some(),
            "baseline: fuzzy move should work with unique rows"
        );

        let mut base_9_repeat: Vec<Vec<i32>> = (1..=18)
            .map(|r| (1..=3).map(|c| r * 10 + c).collect())
            .collect();
        for row in base_9_repeat.iter_mut().take(9) {
            *row = vec![999, 888, 777];
        }
        let refs_9a: Vec<&[i32]> = base_9_repeat.iter().map(|r| r.as_slice()).collect();
        let grid_9a = grid_from_rows(&refs_9a);

        let mut rows_9b = base_9_repeat.clone();
        let mut moved_9: Vec<Vec<i32>> = rows_9b.drain(10..14).collect();
        moved_9[1][1] = 8_888;
        rows_9b.splice(14..14, moved_9);
        let refs_9b: Vec<&[i32]> = rows_9b.iter().map(|r| r.as_slice()).collect();
        let grid_9b = grid_from_rows(&refs_9b);

        assert!(
            detect_fuzzy_row_block_move(&grid_9a, &grid_9b, &DiffConfig::default()).is_none(),
            "repetition guard should trigger when repeat count exceeds max_hash_repeat"
        );

        let mut base_8_repeat: Vec<Vec<i32>> = (1..=18)
            .map(|r| (1..=3).map(|c| r * 10 + c).collect())
            .collect();
        for row in base_8_repeat.iter_mut().take(8) {
            *row = vec![999, 888, 777];
        }
        let refs_8a: Vec<&[i32]> = base_8_repeat.iter().map(|r| r.as_slice()).collect();
        let grid_8a = grid_from_rows(&refs_8a);

        let mut rows_8b = base_8_repeat.clone();
        let mut moved_8: Vec<Vec<i32>> = rows_8b.drain(9..13).collect();
        moved_8[1][1] = 8_888;
        rows_8b.splice(14..14, moved_8);
        let refs_8b: Vec<&[i32]> = rows_8b.iter().map(|r| r.as_slice()).collect();
        let grid_8b = grid_from_rows(&refs_8b);

        assert!(
            detect_fuzzy_row_block_move(&grid_8a, &grid_8b, &DiffConfig::default()).is_some(),
            "repeat count equal to max_hash_repeat should not trigger heavy repetition guard"
        );
    }

    #[test]
    fn aligns_contiguous_block_insert_middle() {
        let base: Vec<Vec<i32>> = (1..=10)
            .map(|r| (1..=4).map(|c| r * 10 + c).collect())
            .collect();
        let base_refs: Vec<&[i32]> = base.iter().map(|row| row.as_slice()).collect();
        let grid_a = grid_from_rows(&base_refs);

        let inserted_block: Vec<Vec<i32>> = (0..4)
            .map(|idx| vec![1_000 + idx, 2_000 + idx, 3_000 + idx, 4_000 + idx])
            .collect();
        let mut rows_b = base.clone();
        rows_b.splice(3..3, inserted_block);
        let rows_b_refs: Vec<&[i32]> = rows_b.iter().map(|row| row.as_slice()).collect();
        let grid_b = grid_from_rows(&rows_b_refs);

        let alignment = align_row_changes(&grid_a, &grid_b, &DiffConfig::default())
            .expect("alignment should succeed");
        assert_eq!(alignment.inserted, vec![3, 4, 5, 6]);
        assert!(alignment.deleted.is_empty());
        assert_eq!(alignment.matched.len(), 10);
        assert_eq!(alignment.matched[0], (0, 0));
        assert_eq!(alignment.matched[2], (2, 2));
        assert_eq!(alignment.matched[3], (3, 7));
        assert_eq!(alignment.matched.last(), Some(&(9, 13)));
        assert!(is_monotonic(&alignment.matched));
    }

    #[test]
    fn aligns_contiguous_block_delete_middle() {
        let base: Vec<Vec<i32>> = (1..=10)
            .map(|r| (1..=4).map(|c| r * 10 + c).collect())
            .collect();
        let base_refs: Vec<&[i32]> = base.iter().map(|row| row.as_slice()).collect();
        let grid_a = grid_from_rows(&base_refs);

        let mut rows_b = base.clone();
        rows_b.drain(3..7);
        let rows_b_refs: Vec<&[i32]> = rows_b.iter().map(|row| row.as_slice()).collect();
        let grid_b = grid_from_rows(&rows_b_refs);

        let alignment = align_row_changes(&grid_a, &grid_b, &DiffConfig::default())
            .expect("alignment should succeed");
        assert_eq!(alignment.deleted, vec![3, 4, 5, 6]);
        assert!(alignment.inserted.is_empty());
        assert_eq!(alignment.matched.len(), 6);
        assert_eq!(alignment.matched[0], (0, 0));
        assert_eq!(alignment.matched[2], (2, 2));
        assert_eq!(alignment.matched[3], (7, 3));
        assert_eq!(alignment.matched.last(), Some(&(9, 5)));
        assert!(is_monotonic(&alignment.matched));
    }

    #[test]
    fn block_alignment_bails_on_noncontiguous_changes() {
        let base: Vec<Vec<i32>> = (1..=8)
            .map(|r| (1..=3).map(|c| r * 10 + c).collect())
            .collect();
        let base_refs: Vec<&[i32]> = base.iter().map(|row| row.as_slice()).collect();
        let grid_a = grid_from_rows(&base_refs);

        let mut rows_b = base.clone();
        rows_b.insert(1, vec![999, 1_000, 1_001]);
        rows_b.insert(5, vec![2_000, 2_001, 2_002]);
        let rows_b_refs: Vec<&[i32]> = rows_b.iter().map(|row| row.as_slice()).collect();
        let grid_b = grid_from_rows(&rows_b_refs);

        assert!(align_row_changes(&grid_a, &grid_b, &DiffConfig::default()).is_none());
    }

    #[test]
    fn align_row_changes_rejects_column_insert_mismatch() {
        let grid_a = grid_from_rows(&[&[10, 11, 12], &[20, 21, 22]]);
        let grid_b = grid_from_rows(&[&[0, 10, 11, 12], &[0, 20, 21, 22], &[0, 30, 31, 32]]);

        assert!(
            align_row_changes(&grid_a, &grid_b, &DiffConfig::default()).is_none(),
            "column insertion changing column count should skip row alignment"
        );
    }

    #[test]
    fn align_row_changes_rejects_column_delete_mismatch() {
        let grid_a = grid_from_rows(&[&[10, 11, 12, 13], &[20, 21, 22, 23], &[30, 31, 32, 33]]);
        let grid_b = grid_from_rows(&[&[10, 12, 13], &[30, 32, 33]]);

        assert!(
            align_row_changes(&grid_a, &grid_b, &DiffConfig::default()).is_none(),
            "column deletion changing column count should skip row alignment"
        );
    }

    #[test]
    fn aligns_single_insert_with_unique_row() {
        let base = (1..=10)
            .map(|r| (1..=3).map(|c| r * 10 + c).collect::<Vec<_>>())
            .collect::<Vec<_>>();
        let base_refs: Vec<&[i32]> = base.iter().map(|row| row.as_slice()).collect();
        let grid_a = grid_from_rows(&base_refs);

        let mut rows_b = base_refs.clone();
        rows_b.insert(
            5,
            &[999, 1000, 1001], // inserted at position 6 (1-based)
        );
        let grid_b = grid_from_rows(&rows_b);

        let alignment = align_single_row_change(&grid_a, &grid_b, &DiffConfig::default())
            .expect("alignment should succeed");
        assert_eq!(alignment.inserted, vec![5]);
        assert!(alignment.deleted.is_empty());
        assert_eq!(alignment.matched.len(), 10);
        assert_eq!(alignment.matched[0], (0, 0));
        assert_eq!(alignment.matched[4], (4, 4));
        assert_eq!(alignment.matched[5], (5, 6));
        assert_eq!(alignment.matched.last(), Some(&(9, 10)));
    }

    #[test]
    fn rejects_non_monotonic_alignment_with_extra_mismatch() {
        let base_rows = [[11, 12, 13], [21, 22, 23], [31, 32, 33], [41, 42, 43]];
        let base_refs: Vec<&[i32]> = base_rows.iter().map(|row| row.as_slice()).collect();
        let grid_a = grid_from_rows(&base_refs);

        let rows_b: Vec<&[i32]> = vec![
            base_refs[0],       // same
            &[999, 1000, 1001], // inserted unique row
            base_refs[2],       // move row 3 before row 2 to break monotonicity
            base_refs[1],
            base_refs[3],
        ];
        let grid_b = grid_from_rows(&rows_b);

        assert!(align_single_row_change(&grid_a, &grid_b, &DiffConfig::default()).is_none());
    }

    #[test]
    fn aligns_insert_at_row_zero() {
        let base_rows: Vec<Vec<i32>> = (1..=5)
            .map(|r| (1..=3).map(|c| r * 10 + c).collect())
            .collect();
        let base_refs: Vec<&[i32]> = base_rows.iter().map(|row| row.as_slice()).collect();
        let grid_a = grid_from_rows(&base_refs);

        let new_first_row = [999, 1000, 1001];
        let mut rows_b = vec![new_first_row.as_slice()];
        rows_b.extend(base_refs.iter().copied());
        let grid_b = grid_from_rows(&rows_b);

        let alignment = align_single_row_change(&grid_a, &grid_b, &DiffConfig::default())
            .expect("alignment should succeed");
        assert_eq!(alignment.inserted, vec![0]);
        assert!(alignment.deleted.is_empty());
        assert_eq!(alignment.matched.len(), 5);
        assert_eq!(alignment.matched[0], (0, 1));
        assert_eq!(alignment.matched[4], (4, 5));
    }

    #[test]
    fn aligns_insert_at_last_row() {
        let base_rows: Vec<Vec<i32>> = (1..=5)
            .map(|r| (1..=3).map(|c| r * 10 + c).collect())
            .collect();
        let base_refs: Vec<&[i32]> = base_rows.iter().map(|row| row.as_slice()).collect();
        let grid_a = grid_from_rows(&base_refs);

        let new_last_row = [999, 1000, 1001];
        let mut rows_b: Vec<&[i32]> = base_refs.clone();
        rows_b.push(new_last_row.as_slice());
        let grid_b = grid_from_rows(&rows_b);

        let alignment = align_single_row_change(&grid_a, &grid_b, &DiffConfig::default())
            .expect("alignment should succeed");
        assert_eq!(alignment.inserted, vec![5]);
        assert!(alignment.deleted.is_empty());
        assert_eq!(alignment.matched.len(), 5);
        assert_eq!(alignment.matched[0], (0, 0));
        assert_eq!(alignment.matched[4], (4, 4));
    }

    #[test]
    fn aligns_delete_at_row_zero() {
        let base_rows: Vec<Vec<i32>> = (1..=5)
            .map(|r| (1..=3).map(|c| r * 10 + c).collect())
            .collect();
        let base_refs: Vec<&[i32]> = base_rows.iter().map(|row| row.as_slice()).collect();
        let grid_a = grid_from_rows(&base_refs);

        let rows_b: Vec<&[i32]> = base_refs[1..].to_vec();
        let grid_b = grid_from_rows(&rows_b);

        let alignment = align_single_row_change(&grid_a, &grid_b, &DiffConfig::default())
            .expect("alignment should succeed");
        assert!(alignment.inserted.is_empty());
        assert_eq!(alignment.deleted, vec![0]);
        assert_eq!(alignment.matched.len(), 4);
        assert_eq!(alignment.matched[0], (1, 0));
        assert_eq!(alignment.matched[3], (4, 3));
    }

    #[test]
    fn aligns_delete_at_last_row() {
        let base_rows: Vec<Vec<i32>> = (1..=5)
            .map(|r| (1..=3).map(|c| r * 10 + c).collect())
            .collect();
        let base_refs: Vec<&[i32]> = base_rows.iter().map(|row| row.as_slice()).collect();
        let grid_a = grid_from_rows(&base_refs);

        let rows_b: Vec<&[i32]> = base_refs[..4].to_vec();
        let grid_b = grid_from_rows(&rows_b);

        let alignment = align_single_row_change(&grid_a, &grid_b, &DiffConfig::default())
            .expect("alignment should succeed");
        assert!(alignment.inserted.is_empty());
        assert_eq!(alignment.deleted, vec![4]);
        assert_eq!(alignment.matched.len(), 4);
        assert_eq!(alignment.matched[0], (0, 0));
        assert_eq!(alignment.matched[3], (3, 3));
    }

    #[test]
    fn aligns_single_row_to_two_rows_via_insert() {
        let single_row = [[42, 43, 44]];
        let single_refs: Vec<&[i32]> = single_row.iter().map(|row| row.as_slice()).collect();
        let grid_a = grid_from_rows(&single_refs);

        let new_row = [999, 1000, 1001];
        let rows_b: Vec<&[i32]> = vec![single_refs[0], new_row.as_slice()];
        let grid_b = grid_from_rows(&rows_b);

        let alignment = align_single_row_change(&grid_a, &grid_b, &DiffConfig::default())
            .expect("alignment should succeed");
        assert_eq!(alignment.inserted, vec![1]);
        assert!(alignment.deleted.is_empty());
        assert_eq!(alignment.matched.len(), 1);
        assert_eq!(alignment.matched[0], (0, 0));
    }

    #[test]
    fn aligns_two_rows_to_single_row_via_delete() {
        let two_rows = [[42, 43, 44], [99, 100, 101]];
        let two_refs: Vec<&[i32]> = two_rows.iter().map(|row| row.as_slice()).collect();
        let grid_a = grid_from_rows(&two_refs);

        let single_refs: Vec<&[i32]> = vec![two_refs[0]];
        let grid_b = grid_from_rows(&single_refs);

        let alignment = align_single_row_change(&grid_a, &grid_b, &DiffConfig::default())
            .expect("alignment should succeed");
        assert!(alignment.inserted.is_empty());
        assert_eq!(alignment.deleted, vec![1]);
        assert_eq!(alignment.matched.len(), 1);
        assert_eq!(alignment.matched[0], (0, 0));
    }

    #[test]
    fn monotonicity_helper_accepts_valid_sequence() {
        let valid: Vec<(u32, u32)> = vec![(0, 0), (1, 2), (3, 4), (5, 7)];
        assert!(super::is_monotonic(&valid));
    }

    #[test]
    fn monotonicity_helper_rejects_non_increasing_a() {
        let invalid: Vec<(u32, u32)> = vec![(0, 0), (2, 2), (1, 4)];
        assert!(!super::is_monotonic(&invalid));
    }

    #[test]
    fn monotonicity_helper_rejects_non_increasing_b() {
        let invalid: Vec<(u32, u32)> = vec![(0, 3), (1, 2), (2, 4)];
        assert!(!super::is_monotonic(&invalid));
    }

    #[test]
    fn monotonicity_helper_accepts_empty_and_single() {
        assert!(super::is_monotonic(&[]));
        assert!(super::is_monotonic(&[(5, 10)]));
    }
}

```

---

### File: `core\src\session.rs`

```rust
use crate::string_pool::StringPool;

/// Holds shared diffing state such as the string pool.
pub struct DiffSession {
    pub strings: StringPool,
}

impl DiffSession {
    pub fn new() -> Self {
        Self {
            strings: StringPool::new(),
        }
    }

    pub fn strings(&self) -> &StringPool {
        &self.strings
    }

    pub fn strings_mut(&mut self) -> &mut StringPool {
        &mut self.strings
    }
}

```

---

### File: `core\src\sink.rs`

```rust
use crate::diff::{DiffError, DiffOp};
use crate::string_pool::StringPool;

/// Trait for streaming diff operations to a consumer.
///
/// Streaming entry points call sinks in this order:
///
/// 1. `begin(pool)` once (before any ops)
/// 2. `emit(op)` zero or more times
/// 3. `finish()` once (even on most error paths)
///
/// Sinks can use `begin` to access the string table (via `pool.strings()`), e.g. to write a
/// header before streaming ops.
pub trait DiffSink {
    /// Called once before any ops are emitted.
    ///
    /// Default is a no-op so sinks that don't need setup can ignore it.
    fn begin(&mut self, _pool: &StringPool) -> Result<(), DiffError> {
        Ok(())
    }

    /// Emit one diff operation.
    fn emit(&mut self, op: DiffOp) -> Result<(), DiffError>;

    /// Finish the stream (flush/close output destinations).
    fn finish(&mut self) -> Result<(), DiffError> {
        Ok(())
    }
}

pub(crate) struct NoFinishSink<'a, S: DiffSink> {
    inner: &'a mut S,
}

impl<'a, S: DiffSink> NoFinishSink<'a, S> {
    pub(crate) fn new(inner: &'a mut S) -> Self {
        Self { inner }
    }
}

impl<S: DiffSink> DiffSink for NoFinishSink<'_, S> {
    fn begin(&mut self, pool: &StringPool) -> Result<(), DiffError> {
        self.inner.begin(pool)
    }

    fn emit(&mut self, op: DiffOp) -> Result<(), DiffError> {
        self.inner.emit(op)
    }

    fn finish(&mut self) -> Result<(), DiffError> {
        Ok(())
    }
}

/// A sink that collects ops into a Vec for compatibility.
pub struct VecSink {
    ops: Vec<DiffOp>,
}

impl VecSink {
    pub fn new() -> Self {
        Self { ops: Vec::new() }
    }

    pub fn into_ops(self) -> Vec<DiffOp> {
        self.ops
    }
}

impl DiffSink for VecSink {
    fn emit(&mut self, op: DiffOp) -> Result<(), DiffError> {
        self.ops.push(op);
        Ok(())
    }
}

/// A sink that forwards ops to a callback.
pub struct CallbackSink<F: FnMut(DiffOp)> {
    f: F,
}

impl<F: FnMut(DiffOp)> CallbackSink<F> {
    pub fn new(f: F) -> Self {
        Self { f }
    }
}

impl<F: FnMut(DiffOp)> DiffSink for CallbackSink<F> {
    fn emit(&mut self, op: DiffOp) -> Result<(), DiffError> {
        (self.f)(op);
        Ok(())
    }
}

```

---

### File: `core\src\string_pool.rs`

```rust
use rustc_hash::FxHashMap;
use serde::{Deserialize, Serialize};

#[repr(transparent)]
#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash, PartialOrd, Ord, Serialize, Deserialize)]
pub struct StringId(pub u32);

impl std::fmt::Display for StringId {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "{}", self.0)
    }
}

#[derive(Debug, Default)]
pub struct StringPool {
    strings: Vec<String>,
    index: FxHashMap<String, StringId>,
}

impl StringPool {
    pub fn new() -> Self {
        let mut pool = Self::default();
        pool.intern("");
        pool
    }

    pub fn intern(&mut self, s: &str) -> StringId {
        if let Some(&id) = self.index.get(s) {
            return id;
        }

        let id = StringId(self.strings.len() as u32);
        let owned = s.to_owned();
        self.strings.push(owned.clone());
        self.index.insert(owned, id);
        id
    }

    pub fn resolve(&self, id: StringId) -> &str {
        &self.strings[id.0 as usize]
    }

    pub fn strings(&self) -> &[String] {
        &self.strings
    }

    pub fn into_strings(self) -> Vec<String> {
        self.strings
    }

    pub fn len(&self) -> usize {
        self.strings.len()
    }
}

```

---

### File: `core\src\workbook.rs`

```rust
//! Workbook, sheet, and grid data structures.
//!
//! This module defines the core intermediate representation (IR) for Excel workbooks:
//! - [`Workbook`]: A collection of sheets
//! - [`Sheet`]: A named sheet with a grid of cells
//! - [`Grid`]: A sparse 2D grid of cell content with optional row/column signatures
//! - [`CellContent`]: Value + formula for a single cell (coordinates stored in the grid key)

use crate::addressing::{AddressParseError, address_to_index, index_to_address};
use crate::hashing::normalize_float_for_hash;
use crate::string_pool::{StringId, StringPool};
use rustc_hash::FxHashMap;
use serde::de::Error as DeError;
use serde::{Deserialize, Deserializer, Serialize, Serializer};
use std::hash::{Hash, Hasher};
use std::str::FromStr;

/// A snapshot of a cell's logical content for comparison purposes.
///
/// Used in [`crate::diff::DiffOp::CellEdited`] to represent the "before" and "after" states.
/// Equality comparison intentionally ignores `addr` and compares only `(value, formula)`.
#[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
pub struct CellSnapshot {
    pub addr: CellAddress,
    pub value: Option<CellValue>,
    pub formula: Option<StringId>,
}

impl CellSnapshot {
    pub fn from_cell(row: u32, col: u32, cell: &CellContent) -> CellSnapshot {
        CellSnapshot {
            addr: CellAddress::from_indices(row, col),
            value: cell.value.clone(),
            formula: cell.formula,
        }
    }

    pub fn empty(addr: CellAddress) -> CellSnapshot {
        CellSnapshot {
            addr,
            value: None,
            formula: None,
        }
    }
}

/// An Excel workbook containing one or more sheets.
#[derive(Debug, Clone, PartialEq, Default)]
pub struct Workbook {
    pub sheets: Vec<Sheet>,
    pub named_ranges: Vec<NamedRange>,
    pub charts: Vec<ChartObject>,
}

#[derive(Debug, Clone, PartialEq, Eq)]
pub struct NamedRange {
    pub name: StringId,
    pub refers_to: StringId,
    pub scope: Option<StringId>,
}

#[derive(Debug, Clone, PartialEq, Eq)]
pub struct ChartInfo {
    pub name: StringId,
    pub chart_type: StringId,
    pub data_range: Option<StringId>,
}

#[derive(Debug, Clone, PartialEq, Eq)]
pub struct ChartObject {
    pub sheet: StringId,
    pub info: ChartInfo,
    pub xml_hash: u128,
}

/// A single sheet within a workbook.
#[derive(Debug, Clone, PartialEq)]
pub struct Sheet {
    /// The display name of the sheet (e.g., "Sheet1", "Data").
    pub name: StringId,
    /// The type of sheet (worksheet, chart, macro, etc.).
    pub kind: SheetKind,
    /// The grid of cell data.
    pub grid: Grid,
}

/// The type of an Excel sheet.
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub enum SheetKind {
    Worksheet,
    Chart,
    Macro,
    Other,
}

/// A sparse 2D grid of cells representing sheet data.
///
/// # Invariants
///
/// All cells stored in `cells` must satisfy `row < nrows` and `col < ncols`.
#[derive(Debug, Clone, PartialEq)]
pub struct Grid {
    /// Number of rows in the grid's bounding rectangle.
    pub nrows: u32,
    /// Number of columns in the grid's bounding rectangle.
    pub ncols: u32,
    /// Sparse storage of non-empty cells, keyed by (row, col).
    pub cells: FxHashMap<(u32, u32), CellContent>,
    /// Optional precomputed row signatures for alignment.
    pub row_signatures: Option<Vec<RowSignature>>,
    /// Optional precomputed column signatures for alignment.
    pub col_signatures: Option<Vec<ColSignature>>,
}

/// A single cell's logical content (coordinates live in the `Grid` key).
#[derive(Debug, Clone, PartialEq)]
pub struct CellContent {
    /// The cell's value, if any.
    pub value: Option<CellValue>,
    /// The cell's formula text (without leading '='), if any.
    pub formula: Option<StringId>,
}

pub type Cell = CellContent;

/// A view of a cell's content together with its coordinates.
#[derive(Debug, Clone, Copy)]
pub struct CellRef<'a> {
    pub row: u32,
    pub col: u32,
    pub address: CellAddress,
    pub value: &'a Option<CellValue>,
    pub formula: &'a Option<StringId>,
}

/// A cell address representing a position in a grid.
///
/// Can be parsed from A1-style strings (e.g., "B2", "AA10") and converted back.
#[derive(Debug, Clone, Copy, PartialEq, Eq)]
pub struct CellAddress {
    /// Zero-based row index.
    pub row: u32,
    /// Zero-based column index.
    pub col: u32,
}

impl CellAddress {
    pub fn from_indices(row: u32, col: u32) -> CellAddress {
        CellAddress { row, col }
    }

    pub fn from_coords(row: u32, col: u32) -> CellAddress {
        Self::from_indices(row, col)
    }

    pub fn to_a1(&self) -> String {
        index_to_address(self.row, self.col)
    }
}

impl std::str::FromStr for CellAddress {
    type Err = AddressParseError;

    fn from_str(s: &str) -> Result<Self, Self::Err> {
        let (row, col) = address_to_index(s).ok_or_else(|| AddressParseError {
            input: s.to_string(),
        })?;
        Ok(CellAddress { row, col })
    }
}

impl std::fmt::Display for CellAddress {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "{}", self.to_a1())
    }
}

impl Serialize for CellAddress {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        serializer.serialize_str(&self.to_a1())
    }
}

impl<'de> Deserialize<'de> for CellAddress {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: Deserializer<'de>,
    {
        let a1 = String::deserialize(deserializer)?;
        CellAddress::from_str(&a1).map_err(|e| DeError::custom(e.to_string()))
    }
}

#[derive(Debug, Clone, Copy, serde::Serialize, serde::Deserialize)]
pub enum CellValue {
    Blank,
    Number(f64),
    Text(StringId),
    Bool(bool),
    Error(StringId),
}

impl PartialEq for CellValue {
    fn eq(&self, other: &Self) -> bool {
        match (self, other) {
            (CellValue::Blank, CellValue::Blank) => true,
            (CellValue::Number(a), CellValue::Number(b)) => {
                normalize_float_for_hash(*a) == normalize_float_for_hash(*b)
            }
            (CellValue::Text(a), CellValue::Text(b)) => a == b,
            (CellValue::Bool(a), CellValue::Bool(b)) => a == b,
            (CellValue::Error(a), CellValue::Error(b)) => a == b,
            _ => false,
        }
    }
}

impl Eq for CellValue {}

impl Hash for CellValue {
    fn hash<H: Hasher>(&self, state: &mut H) {
        match self {
            CellValue::Blank => {
                3u8.hash(state);
            }
            CellValue::Number(n) => {
                0u8.hash(state);
                normalize_float_for_hash(*n).hash(state);
            }
            CellValue::Text(id) => {
                1u8.hash(state);
                id.hash(state);
            }
            CellValue::Bool(b) => {
                2u8.hash(state);
                b.hash(state);
            }
            CellValue::Error(id) => {
                4u8.hash(state);
                id.hash(state);
            }
        }
    }
}

#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash, Default, Serialize, Deserialize)]
pub struct RowSignature {
    #[serde(with = "signature_hex")]
    pub hash: u128,
}

#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash, Default, Serialize, Deserialize)]
pub struct ColSignature {
    #[serde(with = "signature_hex")]
    pub hash: u128,
}

mod signature_hex {
    use serde::de::Error as DeError;
    use serde::{Deserialize, Deserializer, Serializer};

    pub fn serialize<S>(val: &u128, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        let s = format!("{:032x}", val);
        serializer.serialize_str(&s)
    }

    pub fn deserialize<'de, D>(deserializer: D) -> Result<u128, D::Error>
    where
        D: Deserializer<'de>,
    {
        let s = String::deserialize(deserializer)?;
        u128::from_str_radix(&s, 16)
            .map_err(|e| DeError::custom(format!("invalid hex hash: {}", e)))
    }
}

impl Grid {
    pub fn new(nrows: u32, ncols: u32) -> Grid {
        Grid {
            nrows,
            ncols,
            cells: FxHashMap::default(),
            row_signatures: None,
            col_signatures: None,
        }
    }

    pub fn get(&self, row: u32, col: u32) -> Option<&CellContent> {
        self.cells.get(&(row, col))
    }

    pub fn get_ref(&self, row: u32, col: u32) -> Option<CellRef<'_>> {
        self.get(row, col).map(|cell| CellRef {
            row,
            col,
            address: CellAddress::from_indices(row, col),
            value: &cell.value,
            formula: &cell.formula,
        })
    }

    pub fn get_mut(&mut self, row: u32, col: u32) -> Option<&mut CellContent> {
        self.row_signatures = None;
        self.col_signatures = None;
        self.cells.get_mut(&(row, col))
    }

    pub fn insert_cell(
        &mut self,
        row: u32,
        col: u32,
        value: Option<CellValue>,
        formula: Option<StringId>,
    ) {
        debug_assert!(
            row < self.nrows && col < self.ncols,
            "cell coordinates must lie within the grid bounds"
        );
        self.row_signatures = None;
        self.col_signatures = None;
        self.cells
            .insert((row, col), CellContent { value, formula });
    }

    pub fn cell_count(&self) -> usize {
        self.cells.len()
    }

    pub fn is_empty(&self) -> bool {
        self.cells.is_empty()
    }

    pub fn iter_cells(&self) -> impl Iterator<Item = ((u32, u32), &CellContent)> {
        self.cells.iter().map(|(coords, cell)| (*coords, cell))
    }

    pub fn iter_cell_refs(&self) -> impl Iterator<Item = CellRef<'_>> {
        self.cells.iter().map(|((row, col), cell)| CellRef {
            row: *row,
            col: *col,
            address: CellAddress::from_indices(*row, *col),
            value: &cell.value,
            formula: &cell.formula,
        })
    }

    pub fn rows_iter(&self) -> impl Iterator<Item = u32> + '_ {
        0..self.nrows
    }

    pub fn cols_iter(&self) -> impl Iterator<Item = u32> + '_ {
        0..self.ncols
    }

    pub fn compute_row_signature(&self, row: u32) -> RowSignature {
        use crate::hashing::hash_cell_value;
        use std::hash::Hash;
        use xxhash_rust::xxh3::Xxh3;

        let mut hasher = Xxh3::new();

        if (self.ncols as usize) <= self.cells.len() {
            for col in 0..self.ncols {
                if let Some(cell) = self.cells.get(&(row, col)) {
                    if cell.value.is_none() && cell.formula.is_none() {
                        continue;
                    }
                    hash_cell_value(&cell.value, &mut hasher);
                    cell.formula.hash(&mut hasher);
                }
            }
        } else {
            let mut row_cells: Vec<(u32, &CellContent)> = self
                .cells
                .iter()
                .filter(|((r, _), _)| *r == row)
                .map(|((_, c), cell)| (*c, cell))
                .collect();
            row_cells.sort_by_key(|(c, _)| *c);
            for (_, cell) in row_cells {
                if cell.value.is_none() && cell.formula.is_none() {
                    continue;
                }
                hash_cell_value(&cell.value, &mut hasher);
                cell.formula.hash(&mut hasher);
            }
        }

        RowSignature {
            hash: hasher.digest128(),
        }
    }

    pub fn compute_col_signature(&self, col: u32) -> ColSignature {
        use crate::hashing::hash_cell_value;
        use std::hash::Hash;
        use xxhash_rust::xxh3::Xxh3;

        let mut hasher = Xxh3::new();

        if (self.nrows as usize) <= self.cells.len() {
            for row in 0..self.nrows {
                if let Some(cell) = self.cells.get(&(row, col)) {
                    if cell.value.is_none() && cell.formula.is_none() {
                        continue;
                    }
                    hash_cell_value(&cell.value, &mut hasher);
                    cell.formula.hash(&mut hasher);
                }
            }
        } else {
            let mut col_cells: Vec<(u32, &CellContent)> = self
                .cells
                .iter()
                .filter(|((_, c), _)| *c == col)
                .map(|((r, _), cell)| (*r, cell))
                .collect();
            col_cells.sort_by_key(|(r, _)| *r);
            for (_, cell) in col_cells {
                if cell.value.is_none() && cell.formula.is_none() {
                    continue;
                }
                hash_cell_value(&cell.value, &mut hasher);
                cell.formula.hash(&mut hasher);
            }
        }

        ColSignature {
            hash: hasher.digest128(),
        }
    }

    pub fn compute_all_signatures(&mut self) {
        use crate::hashing::{hash_cell_value, hash_row_content_128};
        use xxhash_rust::xxh3::Xxh3;

        let mut row_cells: Vec<Vec<(u32, &CellContent)>> = vec![Vec::new(); self.nrows as usize];

        for ((row, col), cell) in self.cells.iter() {
            let row_idx = *row as usize;
            if row_idx >= row_cells.len() || *col >= self.ncols {
                continue;
            }
            row_cells[row_idx].push((*col, cell));
        }

        for row in row_cells.iter_mut() {
            row.sort_by_key(|(col, _)| *col);
        }

        let row_signatures: Vec<RowSignature> = row_cells
            .iter()
            .map(|row| RowSignature {
                hash: hash_row_content_128(row),
            })
            .collect();

        let mut col_hashers: Vec<Xxh3> = (0..self.ncols).map(|_| Xxh3::new()).collect();
        for row in row_cells.iter() {
            for (col, cell) in row.iter() {
                let idx = *col as usize;
                if idx >= col_hashers.len() {
                    continue;
                }
                hash_cell_value(&cell.value, &mut col_hashers[idx]);
                cell.formula.hash(&mut col_hashers[idx]);
            }
        }

        let col_signatures: Vec<ColSignature> = col_hashers
            .into_iter()
            .map(|hasher| ColSignature {
                hash: hasher.digest128(),
            })
            .collect();

        self.row_signatures = Some(row_signatures);
        self.col_signatures = Some(col_signatures);
    }
}

impl PartialEq for CellSnapshot {
    fn eq(&self, other: &Self) -> bool {
        self.value == other.value && self.formula == other.formula
    }
}

impl Eq for CellSnapshot {}

impl CellValue {
    pub fn as_text_id(&self) -> Option<StringId> {
        if let CellValue::Text(id) = self {
            Some(*id)
        } else {
            None
        }
    }

    pub fn as_text<'a>(&self, pool: &'a StringPool) -> Option<&'a str> {
        self.as_text_id().map(|id| pool.resolve(id))
    }

    pub fn as_number(&self) -> Option<f64> {
        if let CellValue::Number(n) = self {
            Some(*n)
        } else {
            None
        }
    }

    pub fn as_bool(&self) -> Option<bool> {
        if let CellValue::Bool(b) = self {
            Some(*b)
        } else {
            None
        }
    }
}

#[cfg(test)]
mod tests {
    use super::*;
    use crate::string_pool::StringPool;
    use std::collections::hash_map::DefaultHasher;
    use std::hash::{Hash, Hasher};

    fn addr(a1: &str) -> CellAddress {
        a1.parse().expect("address should parse")
    }

    fn make_cell(
        pool: &mut StringPool,
        address: &str,
        value: Option<CellValue>,
        formula: Option<&str>,
    ) -> ((u32, u32), CellContent) {
        let (row, col) = address_to_index(address).expect("address should parse");
        let formula_id = formula.map(|s| pool.intern(s));
        (
            (row, col),
            CellContent {
                value,
                formula: formula_id,
            },
        )
    }

    #[test]
    fn snapshot_from_number_cell() {
        let mut pool = StringPool::new();
        let ((row, col), cell) = make_cell(&mut pool, "A1", Some(CellValue::Number(42.0)), None);
        let snap = CellSnapshot::from_cell(row, col, &cell);
        assert_eq!(snap.addr.to_string(), "A1");
        assert_eq!(snap.value, Some(CellValue::Number(42.0)));
        assert!(snap.formula.is_none());
    }

    #[test]
    fn snapshot_from_text_cell() {
        let mut pool = StringPool::new();
        let text_id = pool.intern("hello");
        let ((row, col), cell) = make_cell(&mut pool, "B2", Some(CellValue::Text(text_id)), None);
        let snap = CellSnapshot::from_cell(row, col, &cell);
        assert_eq!(snap.addr.to_string(), "B2");
        assert_eq!(snap.value, Some(CellValue::Text(text_id)));
        assert!(snap.formula.is_none());
    }

    #[test]
    fn snapshot_from_bool_cell() {
        let mut pool = StringPool::new();
        let ((row, col), cell) = make_cell(&mut pool, "C3", Some(CellValue::Bool(true)), None);
        let snap = CellSnapshot::from_cell(row, col, &cell);
        assert_eq!(snap.addr.to_string(), "C3");
        assert_eq!(snap.value, Some(CellValue::Bool(true)));
        assert!(snap.formula.is_none());
    }

    #[test]
    fn snapshot_from_empty_cell() {
        let mut pool = StringPool::new();
        let ((row, col), cell) = make_cell(&mut pool, "D4", None, None);
        let snap = CellSnapshot::from_cell(row, col, &cell);
        assert_eq!(snap.addr.to_string(), "D4");
        assert!(snap.value.is_none());
        assert!(snap.formula.is_none());
    }

    #[test]
    fn snapshot_equality_same_value_and_formula() {
        let mut pool = StringPool::new();
        let formula_id = pool.intern("A1+1");
        let snap1 = CellSnapshot {
            addr: addr("A1"),
            value: Some(CellValue::Number(1.0)),
            formula: Some(formula_id),
        };
        let snap2 = CellSnapshot {
            addr: addr("B2"),
            value: Some(CellValue::Number(1.0)),
            formula: Some(formula_id),
        };
        assert_eq!(snap1, snap2);
    }

    #[test]
    fn snapshot_inequality_different_value_same_formula() {
        let mut pool = StringPool::new();
        let formula_id = pool.intern("A1+1");
        let snap1 = CellSnapshot {
            addr: addr("A1"),
            value: Some(CellValue::Number(43.0)),
            formula: Some(formula_id),
        };
        let snap2 = CellSnapshot {
            addr: addr("A1"),
            value: Some(CellValue::Number(44.0)),
            formula: Some(formula_id),
        };
        assert_ne!(snap1, snap2);
    }

    #[test]
    fn snapshot_inequality_value_vs_formula() {
        let snap1 = CellSnapshot {
            addr: addr("A1"),
            value: Some(CellValue::Number(42.0)),
            formula: None,
        };
        let mut pool = StringPool::new();
        let formula_id = pool.intern("A1+1");
        let snap2 = CellSnapshot {
            addr: addr("A1"),
            value: Some(CellValue::Number(42.0)),
            formula: Some(formula_id),
        };
        assert_ne!(snap1, snap2);
    }

    #[test]
    fn snapshot_equality_ignores_address() {
        let mut pool = StringPool::new();
        let text_id = pool.intern("hello");
        let snap1 = CellSnapshot {
            addr: addr("A1"),
            value: Some(CellValue::Text(text_id)),
            formula: None,
        };
        let snap2 = CellSnapshot {
            addr: addr("Z9"),
            value: Some(CellValue::Text(text_id)),
            formula: None,
        };
        assert_eq!(snap1, snap2);
    }

    #[test]
    fn cellvalue_as_text_number_bool_match_variants() {
        let mut pool = StringPool::new();
        let text_id = pool.intern("abc");
        let text = CellValue::Text(text_id);
        let number = CellValue::Number(5.0);
        let boolean = CellValue::Bool(true);

        assert_eq!(text.as_text(&pool), Some("abc"));
        assert_eq!(text.as_number(), None);
        assert_eq!(text.as_bool(), None);

        assert_eq!(number.as_text(&pool), None);
        assert_eq!(number.as_number(), Some(5.0));
        assert_eq!(number.as_bool(), None);

        assert_eq!(boolean.as_text(&pool), None);
        assert_eq!(boolean.as_number(), None);
        assert_eq!(boolean.as_bool(), Some(true));
    }

    fn hash_cell_value(value: &CellValue) -> u64 {
        let mut hasher = DefaultHasher::new();
        value.hash(&mut hasher);
        hasher.finish()
    }

    #[test]
    fn cellvalue_number_hashes_normalize_zero_sign() {
        let h_pos = hash_cell_value(&CellValue::Number(0.0));
        let h_neg = hash_cell_value(&CellValue::Number(-0.0));
        assert_eq!(h_pos, h_neg, "hash should ignore sign of zero");
    }

    #[test]
    fn cellvalue_number_hashes_ignore_ulp_drift() {
        let h_a = hash_cell_value(&CellValue::Number(1.0));
        let h_b = hash_cell_value(&CellValue::Number(1.0000000000000002));
        assert_eq!(h_a, h_b, "minor ULP drift should hash identically");
    }

    #[test]
    fn cellvalue_number_hashes_meaningful_difference() {
        let h_a = hash_cell_value(&CellValue::Number(1.0));
        let h_b = hash_cell_value(&CellValue::Number(1.0001));
        assert_ne!(h_a, h_b, "meaningful numeric changes must alter the hash");
    }

    #[test]
    fn get_mut_clears_cached_signatures() {
        let mut pool = StringPool::new();
        let mut grid = Grid::new(2, 2);
        let id1 = pool.intern("1");
        grid.insert_cell(0, 0, Some(CellValue::Text(id1)), None);
        grid.insert_cell(1, 1, Some(CellValue::Number(2.0)), None);

        grid.compute_all_signatures();
        assert!(grid.row_signatures.is_some());
        assert!(grid.col_signatures.is_some());

        let _ = grid.get_mut(0, 0);

        assert!(grid.row_signatures.is_none());
        assert!(grid.col_signatures.is_none());
    }

    #[test]
    fn insert_clears_cached_signatures() {
        let mut pool = StringPool::new();
        let mut grid = Grid::new(3, 3);
        let id1 = pool.intern("1");
        grid.insert_cell(0, 0, Some(CellValue::Text(id1)), None);

        grid.compute_all_signatures();
        assert!(grid.row_signatures.is_some());
        assert!(grid.col_signatures.is_some());

        let id2 = pool.intern("x");
        grid.insert_cell(1, 1, Some(CellValue::Text(id2)), None);

        assert!(grid.row_signatures.is_none());
        assert!(grid.col_signatures.is_none());
    }

    #[test]
    fn compute_row_signature_matches_cached_for_dense_and_sparse_paths() {
        let mut dense = Grid::new(1, 3);
        dense.insert_cell(0, 0, Some(CellValue::Number(1.0)), None);
        dense.insert_cell(0, 1, Some(CellValue::Number(2.0)), None);
        dense.insert_cell(0, 2, Some(CellValue::Number(3.0)), None);
        dense.compute_all_signatures();
        let cached_dense = dense.row_signatures.as_ref().unwrap()[0];
        assert_eq!(dense.compute_row_signature(0), cached_dense);

        let mut sparse = Grid::new(1, 10);
        sparse.insert_cell(0, 0, Some(CellValue::Number(1.0)), None);
        sparse.insert_cell(0, 9, Some(CellValue::Number(10.0)), None);
        sparse.compute_all_signatures();
        let cached_sparse = sparse.row_signatures.as_ref().unwrap()[0];
        assert_eq!(sparse.compute_row_signature(0), cached_sparse);
    }

    #[test]
    fn compute_col_signature_matches_cached_for_dense_and_sparse_paths() {
        let mut dense = Grid::new(3, 1);
        dense.insert_cell(0, 0, Some(CellValue::Number(1.0)), None);
        dense.insert_cell(1, 0, Some(CellValue::Number(2.0)), None);
        dense.insert_cell(2, 0, Some(CellValue::Number(3.0)), None);
        dense.compute_all_signatures();
        let cached_dense = dense.col_signatures.as_ref().unwrap()[0];
        assert_eq!(dense.compute_col_signature(0), cached_dense);

        let mut sparse = Grid::new(10, 2);
        sparse.insert_cell(0, 1, Some(CellValue::Number(1.0)), None);
        sparse.insert_cell(2, 1, Some(CellValue::Number(3.0)), None);
        sparse.compute_all_signatures();
        let cached_sparse = sparse.col_signatures.as_ref().unwrap()[1];
        assert_eq!(sparse.compute_col_signature(1), cached_sparse);
    }
}

```

---

### File: `core\tests\addressing_pg2_tests.rs`

```rust
mod common;

use common::{open_fixture_workbook, sid};
use excel_diff::{CellValue, address_to_index, index_to_address, with_default_session};

#[test]
fn pg2_addressing_matrix_consistency() {
    let workbook = open_fixture_workbook("pg2_addressing_matrix.xlsx");
    let sheet_names: Vec<String> = with_default_session(|session| {
        workbook
            .sheets
            .iter()
            .map(|s| session.strings.resolve(s.name).to_string())
            .collect()
    });
    let addresses_id = sid("Addresses");
    let sheet = workbook
        .sheets
        .iter()
        .find(|s| s.name == addresses_id)
        .unwrap_or_else(|| panic!("Addresses sheet present; found {:?}", sheet_names));

    for cell in sheet.grid.iter_cell_refs() {
        if let Some(CellValue::Text(text_id)) = cell.value {
            let text =
                with_default_session(|session| session.strings.resolve(*text_id).to_string());
            assert_eq!(cell.address.to_a1(), text.as_str());
            let (r, c) = address_to_index(&text).expect("address strings should parse to indices");
            assert_eq!((r, c), (cell.row, cell.col));
            assert_eq!(index_to_address(cell.row, cell.col), cell.address.to_a1());
        }
    }
}

```

---

### File: `core\tests\amr_multi_gap_tests.rs`

```rust
mod common;

use common::{grid_from_numbers, single_sheet_workbook};
use excel_diff::{DiffConfig, DiffOp, DiffReport, Workbook, WorkbookPackage};

fn diff_workbooks(old: &Workbook, new: &Workbook, config: &DiffConfig) -> DiffReport {
    WorkbookPackage::from(old.clone()).diff(&WorkbookPackage::from(new.clone()), config)
}

fn count_ops(ops: &[DiffOp], predicate: impl Fn(&DiffOp) -> bool) -> usize {
    ops.iter().filter(|op| predicate(op)).count()
}

fn count_row_added(ops: &[DiffOp]) -> usize {
    count_ops(ops, |op| matches!(op, DiffOp::RowAdded { .. }))
}

fn count_row_removed(ops: &[DiffOp]) -> usize {
    count_ops(ops, |op| matches!(op, DiffOp::RowRemoved { .. }))
}

fn count_block_moved_rows(ops: &[DiffOp]) -> usize {
    count_ops(ops, |op| matches!(op, DiffOp::BlockMovedRows { .. }))
}

#[test]
fn amr_two_disjoint_insertion_regions() {
    let grid_a = grid_from_numbers(&[
        &[10, 11, 12],
        &[20, 21, 22],
        &[30, 31, 32],
        &[40, 41, 42],
        &[50, 51, 52],
    ]);

    let grid_b = grid_from_numbers(&[
        &[10, 11, 12],
        &[100, 101, 102],
        &[20, 21, 22],
        &[30, 31, 32],
        &[40, 41, 42],
        &[200, 201, 202],
        &[201, 202, 203],
        &[50, 51, 52],
    ]);

    let wb_a = single_sheet_workbook("Sheet1", grid_a);
    let wb_b = single_sheet_workbook("Sheet1", grid_b);
    let config = DiffConfig::default();

    let report = diff_workbooks(&wb_a, &wb_b, &config);

    assert!(
        report.complete,
        "diff should be complete without hitting limits"
    );
    assert_eq!(
        count_row_added(&report.ops),
        3,
        "should detect 3 inserted rows across 2 disjoint regions"
    );
    assert_eq!(
        count_row_removed(&report.ops),
        0,
        "should not detect any removed rows"
    );
}

#[test]
fn amr_insertion_and_deletion_in_different_regions() {
    let grid_a = grid_from_numbers(&[
        &[10, 11, 12],
        &[20, 21, 22],
        &[90, 91, 92],
        &[30, 31, 32],
        &[40, 41, 42],
        &[50, 51, 52],
    ]);

    let grid_b = grid_from_numbers(&[
        &[10, 11, 12],
        &[20, 21, 22],
        &[30, 31, 32],
        &[40, 41, 42],
        &[100, 101, 102],
        &[50, 51, 52],
    ]);

    let wb_a = single_sheet_workbook("Sheet1", grid_a);
    let wb_b = single_sheet_workbook("Sheet1", grid_b);
    let config = DiffConfig::default();

    let report = diff_workbooks(&wb_a, &wb_b, &config);

    assert!(
        report.complete,
        "diff should be complete without hitting limits"
    );
    assert_eq!(
        count_row_added(&report.ops),
        1,
        "should detect 1 inserted row near the tail"
    );
    assert_eq!(
        count_row_removed(&report.ops),
        1,
        "should detect 1 deleted row in the middle"
    );
}

#[test]
fn amr_gap_contains_moved_block_scenario() {
    let grid_a = grid_from_numbers(&[
        &[10, 11, 12],
        &[20, 21, 22],
        &[30, 31, 32],
        &[40, 41, 42],
        &[50, 51, 52],
        &[60, 61, 62],
        &[70, 71, 72],
        &[80, 81, 82],
    ]);

    let grid_b = grid_from_numbers(&[
        &[10, 11, 12],
        &[60, 61, 62],
        &[70, 71, 72],
        &[20, 21, 22],
        &[30, 31, 32],
        &[40, 41, 42],
        &[50, 51, 52],
        &[80, 81, 82],
    ]);

    let wb_a = single_sheet_workbook("Sheet1", grid_a);
    let wb_b = single_sheet_workbook("Sheet1", grid_b);
    let config = DiffConfig::default();

    let report = diff_workbooks(&wb_a, &wb_b, &config);

    assert!(
        report.complete,
        "diff should be complete without hitting limits"
    );
    let moves = count_block_moved_rows(&report.ops);
    assert!(
        moves >= 1,
        "should detect at least one block move (rows 60-70 moved up)"
    );
    assert_eq!(
        count_row_added(&report.ops),
        0,
        "should not report spurious insertions when move is detected"
    );
    assert_eq!(
        count_row_removed(&report.ops),
        0,
        "should not report spurious deletions when move is detected"
    );
}

#[test]
fn amr_multiple_anchors_with_gaps() {
    let grid_a = grid_from_numbers(&[
        &[1, 2, 3],
        &[10, 11, 12],
        &[20, 21, 22],
        &[30, 31, 32],
        &[40, 41, 42],
        &[50, 51, 52],
        &[60, 61, 62],
        &[70, 71, 72],
    ]);

    let grid_b = grid_from_numbers(&[
        &[1, 2, 3],
        &[10, 11, 12],
        &[100, 101, 102],
        &[20, 21, 22],
        &[30, 31, 32],
        &[40, 41, 42],
        &[200, 201, 202],
        &[50, 51, 52],
        &[60, 61, 62],
        &[70, 71, 72],
    ]);

    let wb_a = single_sheet_workbook("Sheet1", grid_a);
    let wb_b = single_sheet_workbook("Sheet1", grid_b);
    let config = DiffConfig::default();

    let report = diff_workbooks(&wb_a, &wb_b, &config);

    assert!(
        report.complete,
        "diff should be complete without hitting limits"
    );
    assert_eq!(
        count_row_added(&report.ops),
        2,
        "should detect both inserted rows in separate gaps between anchors"
    );
}

#[test]
fn amr_recursive_gap_alignment() {
    let values_a: Vec<&[i32]> = (1..=50i32)
        .map(|i| {
            let row: &[i32] = match i {
                1 => &[10, 11, 12],
                2 => &[20, 21, 22],
                3 => &[30, 31, 32],
                4 => &[40, 41, 42],
                5 => &[50, 51, 52],
                6 => &[60, 61, 62],
                7 => &[70, 71, 72],
                8 => &[80, 81, 82],
                9 => &[90, 91, 92],
                10 => &[100, 101, 102],
                11 => &[110, 111, 112],
                12 => &[120, 121, 122],
                13 => &[130, 131, 132],
                14 => &[140, 141, 142],
                15 => &[150, 151, 152],
                16 => &[160, 161, 162],
                17 => &[170, 171, 172],
                18 => &[180, 181, 182],
                19 => &[190, 191, 192],
                20 => &[200, 201, 202],
                21 => &[210, 211, 212],
                22 => &[220, 221, 222],
                23 => &[230, 231, 232],
                24 => &[240, 241, 242],
                25 => &[250, 251, 252],
                26 => &[260, 261, 262],
                27 => &[270, 271, 272],
                28 => &[280, 281, 282],
                29 => &[290, 291, 292],
                30 => &[300, 301, 302],
                31 => &[310, 311, 312],
                32 => &[320, 321, 322],
                33 => &[330, 331, 332],
                34 => &[340, 341, 342],
                35 => &[350, 351, 352],
                36 => &[360, 361, 362],
                37 => &[370, 371, 372],
                38 => &[380, 381, 382],
                39 => &[390, 391, 392],
                40 => &[400, 401, 402],
                41 => &[410, 411, 412],
                42 => &[420, 421, 422],
                43 => &[430, 431, 432],
                44 => &[440, 441, 442],
                45 => &[450, 451, 452],
                46 => &[460, 461, 462],
                47 => &[470, 471, 472],
                48 => &[480, 481, 482],
                49 => &[490, 491, 492],
                50 => &[500, 501, 502],
                _ => &[0, 0, 0],
            };
            row
        })
        .collect();
    let grid_a = grid_from_numbers(&values_a);

    let mut values_b: Vec<&[i32]> = values_a.clone();
    values_b.insert(10, &[1000, 1001, 1002]);
    values_b.insert(25, &[2000, 2001, 2002]);
    values_b.insert(40, &[3000, 3001, 3002]);

    let grid_b = grid_from_numbers(&values_b);

    let wb_a = single_sheet_workbook("Sheet1", grid_a);
    let wb_b = single_sheet_workbook("Sheet1", grid_b);
    let config = DiffConfig::default();

    let report = diff_workbooks(&wb_a, &wb_b, &config);

    assert!(
        report.complete,
        "diff should be complete without hitting limits"
    );
    assert_eq!(
        count_row_added(&report.ops),
        3,
        "should detect all 3 inserted rows distributed across the grid"
    );
}

```

---

### File: `core\tests\branch4_object_diff_tests.rs`

```rust
mod common;

use common::open_fixture_pkg;
use excel_diff::{DiffConfig, DiffOp, DiffReport, StringId};

fn resolve<'a>(report: &'a DiffReport, id: StringId) -> &'a str {
    report.strings[id.0 as usize].as_str()
}

#[test]
fn branch4_named_ranges_emit_add_remove_change() {
    let pkg_a = open_fixture_pkg("named_ranges_a.xlsx");
    let pkg_b = open_fixture_pkg("named_ranges_b.xlsx");

    let report = pkg_a.diff(&pkg_b, &DiffConfig::default());

    let mut saw_added = false;
    let mut saw_removed = false;
    let mut saw_changed = false;

    for op in &report.ops {
        match op {
            DiffOp::NamedRangeAdded { name } => {
                assert_eq!(resolve(&report, *name), "GlobalAdd");
                saw_added = true;
            }
            DiffOp::NamedRangeRemoved { name } => {
                assert_eq!(resolve(&report, *name), "GlobalRemove");
                saw_removed = true;
            }
            DiffOp::NamedRangeChanged {
                name,
                old_ref,
                new_ref,
            } => {
                assert_eq!(resolve(&report, *name), "Sheet1!LocalChange");
                assert_eq!(resolve(&report, *old_ref), "Sheet1!$C$1");
                assert_eq!(resolve(&report, *new_ref), "Sheet1!$C$2");
                saw_changed = true;
            }
            _ => {}
        }
    }

    assert!(saw_added, "expected NamedRangeAdded(GlobalAdd)");
    assert!(saw_removed, "expected NamedRangeRemoved(GlobalRemove)");
    assert!(saw_changed, "expected NamedRangeChanged(Sheet1!LocalChange)");
}

#[test]
fn branch4_charts_emit_added_removed_changed() {
    let pkg_a = open_fixture_pkg("charts_a.xlsx");
    let pkg_b = open_fixture_pkg("charts_b.xlsx");

    let report_ab = pkg_a.diff(&pkg_b, &DiffConfig::default());

    let mut saw_changed_chart1 = false;
    let mut saw_added_chart2 = false;

    for op in &report_ab.ops {
        match op {
            DiffOp::ChartChanged { sheet, name } => {
                assert_eq!(resolve(&report_ab, *sheet), "Sheet1");
                assert_eq!(resolve(&report_ab, *name), "Chart 1");
                saw_changed_chart1 = true;
            }
            DiffOp::ChartAdded { sheet, name } => {
                assert_eq!(resolve(&report_ab, *sheet), "Sheet1");
                assert_eq!(resolve(&report_ab, *name), "Chart 2");
                saw_added_chart2 = true;
            }
            _ => {}
        }
    }

    assert!(saw_changed_chart1, "expected ChartChanged(Sheet1, Chart 1)");
    assert!(saw_added_chart2, "expected ChartAdded(Sheet1, Chart 2)");

    let report_ba = pkg_b.diff(&pkg_a, &DiffConfig::default());
    let mut saw_removed_chart2 = false;
    for op in &report_ba.ops {
        if let DiffOp::ChartRemoved { sheet, name } = op {
            assert_eq!(resolve(&report_ba, *sheet), "Sheet1");
            assert_eq!(resolve(&report_ba, *name), "Chart 2");
            saw_removed_chart2 = true;
        }
    }
    assert!(saw_removed_chart2, "expected ChartRemoved(Sheet1, Chart 2)");
}

#[test]
fn branch4_vba_modules_emit_added_removed_changed() {
    let pkg_base = open_fixture_pkg("vba_base.xlsm");
    let pkg_added = open_fixture_pkg("vba_added.xlsm");
    let pkg_changed = open_fixture_pkg("vba_changed.xlsm");

    let report_added = pkg_base.diff(&pkg_added, &DiffConfig::default());
    let mut saw_module2_added = false;
    for op in &report_added.ops {
        if let DiffOp::VbaModuleAdded { name } = op {
            if resolve(&report_added, *name) == "Module2" {
                saw_module2_added = true;
            }
        }
    }
    assert!(saw_module2_added, "expected VbaModuleAdded(Module2)");

    let report_removed = pkg_added.diff(&pkg_base, &DiffConfig::default());
    let mut saw_module2_removed = false;
    for op in &report_removed.ops {
        if let DiffOp::VbaModuleRemoved { name } = op {
            if resolve(&report_removed, *name) == "Module2" {
                saw_module2_removed = true;
            }
        }
    }
    assert!(saw_module2_removed, "expected VbaModuleRemoved(Module2)");

    let report_changed = pkg_base.diff(&pkg_changed, &DiffConfig::default());
    let mut saw_module1_changed = false;
    for op in &report_changed.ops {
        if let DiffOp::VbaModuleChanged { name } = op {
            if resolve(&report_changed, *name) == "Module1" {
                saw_module1_changed = true;
            }
        }
    }
    assert!(saw_module1_changed, "expected VbaModuleChanged(Module1)");
}

```

---

### File: `core\tests\common\mod.rs`

```rust
//! Common test utilities shared across integration tests.

#![allow(dead_code)]

use excel_diff::{
    CellValue, DiffConfig, DiffReport, Grid, Sheet, SheetKind, StringId, Workbook, WorkbookPackage,
    with_default_session,
};
use std::fs::File;
use std::path::PathBuf;

pub fn fixture_path(filename: &str) -> PathBuf {
    let mut path = PathBuf::from(env!("CARGO_MANIFEST_DIR"));
    path.push("../fixtures/generated");
    path.push(filename);
    path
}

pub fn open_fixture_pkg(name: &str) -> WorkbookPackage {
    let path = fixture_path(name);
    let file = File::open(&path).unwrap_or_else(|e| {
        panic!("failed to open fixture {}: {e}", path.display());
    });
    WorkbookPackage::open(file).unwrap_or_else(|e| {
        panic!("failed to parse fixture {}: {e}", path.display());
    })
}

pub fn open_fixture_workbook(name: &str) -> Workbook {
    open_fixture_pkg(name).workbook
}

pub fn diff_fixture_pkgs(a: &str, b: &str, config: &DiffConfig) -> DiffReport {
    let pkg_a = open_fixture_pkg(a);
    let pkg_b = open_fixture_pkg(b);
    pkg_a.diff(&pkg_b, config)
}

pub fn grid_from_numbers(values: &[&[i32]]) -> Grid {
    let nrows = values.len() as u32;
    let ncols = if nrows == 0 {
        0
    } else {
        values[0].len() as u32
    };

    let mut grid = Grid::new(nrows, ncols);
    for (r, row_vals) in values.iter().enumerate() {
        for (c, v) in row_vals.iter().enumerate() {
            grid.insert_cell(r as u32, c as u32, Some(CellValue::Number(*v as f64)), None);
        }
    }

    grid
}

pub fn sid(s: &str) -> StringId {
    with_default_session(|session| session.strings.intern(s))
}

pub fn single_sheet_workbook(name: &str, grid: Grid) -> Workbook {
    with_default_session(|session| Workbook {
        sheets: vec![Sheet {
            name: session.strings.intern(name),
            kind: SheetKind::Worksheet,
            grid,
        }],
        ..Default::default()
    })
}

```

---

### File: `core\tests\d1_database_mode_tests.rs`

```rust
mod common;

use common::{grid_from_numbers, open_fixture_workbook, sid};
use excel_diff::{
    CellValue, DiffConfig, DiffOp, DiffReport, Grid, Workbook, WorkbookPackage,
    diff_grids_database_mode, with_default_session,
};

fn diff_workbooks(old: &Workbook, new: &Workbook, config: &DiffConfig) -> DiffReport {
    WorkbookPackage::from(old.clone()).diff(&WorkbookPackage::from(new.clone()), config)
}

fn diff_db(grid_a: &Grid, grid_b: &Grid, keys: &[u32]) -> DiffReport {
    with_default_session(|session| {
        diff_grids_database_mode(
            grid_a,
            grid_b,
            keys,
            &mut session.strings,
            &DiffConfig::default(),
        )
    })
}

fn data_grid(workbook: &Workbook) -> &Grid {
    let data_id = sid("Data");
    workbook
        .sheets
        .iter()
        .find(|s| s.name == data_id)
        .map(|s| &s.grid)
        .expect("Data sheet present")
}

fn grid_from_float_rows(rows: &[&[f64]]) -> Grid {
    let nrows = rows.len() as u32;
    let ncols = if nrows == 0 { 0 } else { rows[0].len() as u32 };
    let mut grid = Grid::new(nrows, ncols);

    for (r_idx, row_vals) in rows.iter().enumerate() {
        for (c_idx, value) in row_vals.iter().enumerate() {
            grid.insert_cell(
                r_idx as u32,
                c_idx as u32,
                Some(CellValue::Number(*value)),
                None,
            );
        }
    }

    grid
}

#[test]
fn d1_equal_ordered_database_mode_empty_diff() {
    let workbook = open_fixture_workbook("db_equal_ordered_a.xlsx");
    let grid = data_grid(&workbook);

    let report = diff_db(grid, grid, &[0]);
    assert!(
        report.ops.is_empty(),
        "database mode should ignore row order when keyed rows are identical"
    );
}

#[test]
fn d1_equal_reordered_database_mode_empty_diff() {
    let wb_a = open_fixture_workbook("db_equal_ordered_a.xlsx");
    let wb_b = open_fixture_workbook("db_equal_ordered_b.xlsx");

    let grid_a = data_grid(&wb_a);
    let grid_b = data_grid(&wb_b);

    let report = diff_db(grid_a, grid_b, &[0]);
    assert!(
        report.ops.is_empty(),
        "keyed alignment should match rows by key and ignore reordering"
    );
}

#[test]
fn d1_spreadsheet_mode_sees_reorder_as_changes() {
    let wb_a = open_fixture_workbook("db_equal_ordered_a.xlsx");
    let wb_b = open_fixture_workbook("db_equal_ordered_b.xlsx");

    let report = diff_workbooks(&wb_a, &wb_b, &DiffConfig::default());

    assert!(
        !report.ops.is_empty(),
        "Spreadsheet Mode should see structural changes when rows are reordered, \
         demonstrating the semantic difference from Database Mode"
    );
}

#[test]
fn d1_duplicate_keys_fallback_to_spreadsheet_mode() {
    let grid_a = grid_from_numbers(&[&[1, 10], &[1, 99]]);
    let grid_b = grid_from_numbers(&[&[1, 10]]);

    let report = diff_db(&grid_a, &grid_b, &[0]);

    assert!(
        !report.ops.is_empty(),
        "duplicate keys cause fallback to spreadsheet mode which should detect differences"
    );

    let has_row_removed = report
        .ops
        .iter()
        .any(|op| matches!(op, DiffOp::RowRemoved { .. }));
    assert!(
        has_row_removed,
        "spreadsheet mode fallback should emit RowRemoved for the missing row"
    );
}

#[test]
fn d1_database_mode_row_added() {
    let grid_a = grid_from_numbers(&[&[1, 10], &[2, 20]]);
    let grid_b = grid_from_numbers(&[&[1, 10], &[2, 20], &[3, 30]]);

    let report = diff_db(&grid_a, &grid_b, &[0]);

    let row_added_count = report
        .ops
        .iter()
        .filter(|op| matches!(op, DiffOp::RowAdded { .. }))
        .count();
    assert_eq!(
        row_added_count, 1,
        "database mode should emit one RowAdded for key 3"
    );
}

#[test]
fn d1_database_mode_row_removed() {
    let grid_a = grid_from_numbers(&[&[1, 10], &[2, 20], &[3, 30]]);
    let grid_b = grid_from_numbers(&[&[1, 10], &[2, 20]]);

    let report = diff_db(&grid_a, &grid_b, &[0]);

    let row_removed_count = report
        .ops
        .iter()
        .filter(|op| matches!(op, DiffOp::RowRemoved { .. }))
        .count();
    assert_eq!(
        row_removed_count, 1,
        "database mode should emit one RowRemoved for key 3"
    );
}

#[test]
fn d1_database_mode_cell_edited() {
    let grid_a = grid_from_numbers(&[&[1, 10], &[2, 20]]);
    let grid_b = grid_from_numbers(&[&[1, 99], &[2, 20]]);

    let report = diff_db(&grid_a, &grid_b, &[0]);

    let cell_edited_count = report
        .ops
        .iter()
        .filter(|op| matches!(op, DiffOp::CellEdited { .. }))
        .count();
    assert_eq!(
        cell_edited_count, 1,
        "database mode should emit one CellEdited for the changed non-key cell"
    );
}

#[test]
fn d1_database_mode_cell_edited_with_reorder() {
    let grid_a = grid_from_numbers(&[&[1, 10], &[2, 20], &[3, 30]]);
    let grid_b = grid_from_numbers(&[&[3, 30], &[2, 99], &[1, 10]]);

    let report = diff_db(&grid_a, &grid_b, &[0]);

    let cell_edited_count = report
        .ops
        .iter()
        .filter(|op| matches!(op, DiffOp::CellEdited { .. }))
        .count();
    assert_eq!(
        cell_edited_count, 1,
        "database mode should ignore reordering and find only the cell edit for key 2"
    );
}

#[test]
fn d1_database_mode_treats_small_float_key_noise_as_equal() {
    let grid_a = grid_from_float_rows(&[&[1.0, 10.0], &[2.0, 20.0], &[3.0, 30.0]]);
    let grid_b = grid_from_float_rows(&[&[1.0000000000000002, 10.0], &[2.0, 20.0], &[3.0, 30.0]]);

    let report = diff_db(&grid_a, &grid_b, &[0]);
    assert!(
        report.ops.is_empty(),
        "ULP-level noise in key column should not break row alignment"
    );
}

#[test]
fn d1_database_mode_detects_meaningful_float_key_change() {
    let grid_a = grid_from_float_rows(&[&[1.0, 10.0], &[2.0, 20.0], &[3.0, 30.0]]);
    let grid_b = grid_from_float_rows(&[&[1.0001, 10.0], &[2.0, 20.0], &[3.0, 30.0]]);

    let report = diff_db(&grid_a, &grid_b, &[0]);

    let row_removed = report
        .ops
        .iter()
        .filter(|op| matches!(op, DiffOp::RowRemoved { .. }))
        .count();
    let row_added = report
        .ops
        .iter()
        .filter(|op| matches!(op, DiffOp::RowAdded { .. }))
        .count();

    assert_eq!(
        row_removed, 1,
        "meaningful key drift should remove the original keyed row"
    );
    assert_eq!(
        row_added, 1,
        "meaningful key drift should add the new keyed row"
    );
}

#[test]
fn d5_composite_key_equal_reordered_database_mode_empty_diff() {
    let grid_a = grid_from_numbers(&[&[1, 10, 100], &[1, 20, 200], &[2, 10, 300]]);
    let grid_b = grid_from_numbers(&[&[2, 10, 300], &[1, 10, 100], &[1, 20, 200]]);

    let report = diff_db(&grid_a, &grid_b, &[0, 1]);
    assert!(
        report.ops.is_empty(),
        "composite keyed alignment should ignore row order differences"
    );
}

#[test]
fn d5_composite_key_row_added_and_cell_edited() {
    let grid_a = grid_from_numbers(&[&[1, 10, 100], &[1, 20, 200]]);
    let grid_b = grid_from_numbers(&[&[1, 10, 150], &[1, 20, 200], &[2, 30, 300]]);

    let report = diff_db(&grid_a, &grid_b, &[0, 1]);

    let row_added_count = report
        .ops
        .iter()
        .filter(|op| matches!(op, DiffOp::RowAdded { .. }))
        .count();
    assert_eq!(
        row_added_count, 1,
        "new composite key should produce exactly one RowAdded"
    );

    let row_removed_count = report
        .ops
        .iter()
        .filter(|op| matches!(op, DiffOp::RowRemoved { .. }))
        .count();
    assert_eq!(
        row_removed_count, 0,
        "no rows should be removed when only a new composite key is introduced"
    );

    let mut cell_edited_iter = report.ops.iter().filter_map(|op| {
        if let DiffOp::CellEdited { addr, .. } = op {
            Some(addr)
        } else {
            None
        }
    });

    let edited_addr = cell_edited_iter
        .next()
        .expect("one cell edit for changed non-key value");
    assert!(
        cell_edited_iter.next().is_none(),
        "only one CellEdited should be present"
    );
    assert_eq!(edited_addr.col, 2, "only non-key column should be edited");
    assert_eq!(
        edited_addr.row, 0,
        "cell edit should reference the row of key (1,10) in the new grid"
    );
}

#[test]
fn d5_composite_key_partial_key_mismatch_yields_add_and_remove() {
    let grid_a = grid_from_numbers(&[&[1, 10, 100]]);
    let grid_b = grid_from_numbers(&[&[1, 20, 100]]);

    let report = diff_db(&grid_a, &grid_b, &[0, 1]);

    let row_removed_count = report
        .ops
        .iter()
        .filter(|op| matches!(op, DiffOp::RowRemoved { .. }))
        .count();
    assert_eq!(
        row_removed_count, 1,
        "changed composite key should remove the old tuple"
    );

    let row_added_count = report
        .ops
        .iter()
        .filter(|op| matches!(op, DiffOp::RowAdded { .. }))
        .count();
    assert_eq!(
        row_added_count, 1,
        "changed composite key should add the new tuple"
    );

    let cell_edited_count = report
        .ops
        .iter()
        .filter(|op| matches!(op, DiffOp::CellEdited { .. }))
        .count();
    assert_eq!(
        cell_edited_count, 0,
        "partial key match must not be treated as a cell edit"
    );
}

#[test]
fn d5_composite_key_duplicate_keys_fallback_to_spreadsheet_mode() {
    let grid_a = grid_from_numbers(&[&[1, 10, 100], &[1, 10, 200]]);
    let grid_b = grid_from_numbers(&[&[1, 10, 100]]);

    let report = diff_db(&grid_a, &grid_b, &[0, 1]);

    assert!(
        !report.ops.is_empty(),
        "duplicate composite keys should trigger spreadsheet-mode fallback"
    );

    let has_row_removed = report
        .ops
        .iter()
        .any(|op| matches!(op, DiffOp::RowRemoved { .. }));
    assert!(
        has_row_removed,
        "fallback should emit a RowRemoved reflecting duplicate handling"
    );
}

#[test]
fn d5_non_contiguous_key_columns_equal_reordered_empty_diff() {
    let grid_a = grid_from_numbers(&[&[1, 999, 10, 100], &[1, 888, 20, 200], &[2, 777, 10, 300]]);
    let grid_b = grid_from_numbers(&[&[2, 777, 10, 300], &[1, 999, 10, 100], &[1, 888, 20, 200]]);

    let report = diff_db(&grid_a, &grid_b, &[0, 2]);
    assert!(
        report.ops.is_empty(),
        "non-contiguous key columns [0,2] should align correctly ignoring row order"
    );
}

#[test]
fn d5_non_contiguous_key_columns_detects_edits_in_skipped_column() {
    let grid_a = grid_from_numbers(&[&[1, 999, 10, 100], &[1, 888, 20, 200], &[2, 777, 10, 300]]);
    let grid_b = grid_from_numbers(&[&[2, 111, 10, 300], &[1, 222, 10, 100], &[1, 333, 20, 200]]);

    let report = diff_db(&grid_a, &grid_b, &[0, 2]);

    let cell_edited_ops: Vec<_> = report
        .ops
        .iter()
        .filter_map(|op| {
            if let DiffOp::CellEdited { addr, .. } = op {
                Some(addr)
            } else {
                None
            }
        })
        .collect();

    assert_eq!(
        cell_edited_ops.len(),
        3,
        "should detect 3 edits in skipped non-key column 1"
    );

    for addr in &cell_edited_ops {
        assert_eq!(
            addr.col, 1,
            "all edits should be in the skipped column 1, not key columns 0 or 2"
        );
    }

    let row_added_count = report
        .ops
        .iter()
        .filter(|op| matches!(op, DiffOp::RowAdded { .. }))
        .count();
    assert_eq!(row_added_count, 0, "no rows should be added");

    let row_removed_count = report
        .ops
        .iter()
        .filter(|op| matches!(op, DiffOp::RowRemoved { .. }))
        .count();
    assert_eq!(row_removed_count, 0, "no rows should be removed");
}

#[test]
fn d5_non_contiguous_key_columns_row_added_and_cell_edited() {
    let grid_a = grid_from_numbers(&[&[1, 999, 10, 100], &[1, 888, 20, 200]]);
    let grid_b = grid_from_numbers(&[&[1, 999, 10, 150], &[1, 888, 20, 200], &[2, 777, 30, 300]]);

    let report = diff_db(&grid_a, &grid_b, &[0, 2]);

    let row_added_count = report
        .ops
        .iter()
        .filter(|op| matches!(op, DiffOp::RowAdded { .. }))
        .count();
    assert_eq!(
        row_added_count, 1,
        "new non-contiguous composite key should produce exactly one RowAdded"
    );

    let row_removed_count = report
        .ops
        .iter()
        .filter(|op| matches!(op, DiffOp::RowRemoved { .. }))
        .count();
    assert_eq!(row_removed_count, 0, "no rows should be removed");

    let cell_edited_count = report
        .ops
        .iter()
        .filter(|op| matches!(op, DiffOp::CellEdited { .. }))
        .count();
    assert_eq!(
        cell_edited_count, 1,
        "changed non-key column should produce exactly one CellEdited"
    );
}

#[test]
fn d5_three_column_composite_key_equal_reordered_empty_diff() {
    let grid_a = grid_from_numbers(&[
        &[1, 10, 100, 1000],
        &[1, 10, 200, 2000],
        &[1, 20, 100, 3000],
        &[2, 10, 100, 4000],
    ]);
    let grid_b = grid_from_numbers(&[
        &[2, 10, 100, 4000],
        &[1, 20, 100, 3000],
        &[1, 10, 200, 2000],
        &[1, 10, 100, 1000],
    ]);

    let report = diff_db(&grid_a, &grid_b, &[0, 1, 2]);
    assert!(
        report.ops.is_empty(),
        "three-column composite key should align correctly ignoring row order"
    );
}

#[test]
fn d5_three_column_composite_key_partial_match_yields_add_and_remove() {
    let grid_a = grid_from_numbers(&[&[1, 10, 100, 1000]]);
    let grid_b = grid_from_numbers(&[&[1, 10, 200, 1000]]);

    let report = diff_db(&grid_a, &grid_b, &[0, 1, 2]);

    let row_removed_count = report
        .ops
        .iter()
        .filter(|op| matches!(op, DiffOp::RowRemoved { .. }))
        .count();
    assert_eq!(
        row_removed_count, 1,
        "changed third key column should remove the old tuple"
    );

    let row_added_count = report
        .ops
        .iter()
        .filter(|op| matches!(op, DiffOp::RowAdded { .. }))
        .count();
    assert_eq!(
        row_added_count, 1,
        "changed third key column should add the new tuple"
    );

    let cell_edited_count = report
        .ops
        .iter()
        .filter(|op| matches!(op, DiffOp::CellEdited { .. }))
        .count();
    assert_eq!(
        cell_edited_count, 0,
        "partial three-column key match must not be treated as a cell edit"
    );
}

```

---

### File: `core\tests\d2_d4_database_mode_workbook_tests.rs`

```rust
mod common;

use common::{open_fixture_workbook, sid};
use excel_diff::{
    CellValue, DiffConfig, DiffOp, DiffReport, Grid, Workbook, diff_grids_database_mode,
    with_default_session,
};

fn diff_db(grid_a: &Grid, grid_b: &Grid, keys: &[u32]) -> DiffReport {
    with_default_session(|session| {
        diff_grids_database_mode(
            grid_a,
            grid_b,
            keys,
            &mut session.strings,
            &DiffConfig::default(),
        )
    })
}

fn data_grid(workbook: &Workbook) -> &Grid {
    let data_id = sid("Data");
    workbook
        .sheets
        .iter()
        .find(|s| s.name == data_id)
        .map(|s| &s.grid)
        .expect("Data sheet present")
}

fn find_row_by_id(grid: &Grid, target_id: i64) -> Option<u32> {
    for row in 0..grid.nrows {
        if let Some(cell) = grid.get(row, 0) {
            if let Some(CellValue::Number(n)) = cell.value {
                if (n as i64) == target_id {
                    return Some(row);
                }
            }
        }
    }
    None
}

fn count_ops(report: &DiffReport) -> (usize, usize, usize) {
    let row_added = report
        .ops
        .iter()
        .filter(|op| matches!(op, DiffOp::RowAdded { .. }))
        .count();
    let row_removed = report
        .ops
        .iter()
        .filter(|op| matches!(op, DiffOp::RowRemoved { .. }))
        .count();
    let cell_edited = report
        .ops
        .iter()
        .filter(|op| matches!(op, DiffOp::CellEdited { .. }))
        .count();
    (row_added, row_removed, cell_edited)
}

#[test]
fn d2_row_added_emits_row_added_only() {
    let wb_a = open_fixture_workbook("db_equal_ordered_a.xlsx");
    let wb_b = open_fixture_workbook("db_row_added_b.xlsx");

    let grid_a = data_grid(&wb_a);
    let grid_b = data_grid(&wb_b);

    let report = diff_db(grid_a, grid_b, &[0]);
    let (row_added, row_removed, cell_edited) = count_ops(&report);

    assert_eq!(row_added, 1, "should emit exactly 1 RowAdded");
    assert_eq!(row_removed, 0, "should emit 0 RowRemoved");
    assert_eq!(cell_edited, 0, "should emit 0 CellEdited");

    let row_b = find_row_by_id(grid_b, 1001).expect("new row with ID 1001 should exist in B");

    let added_row_idx = report
        .ops
        .iter()
        .find_map(|op| {
            if let DiffOp::RowAdded { row_idx, .. } = op {
                Some(*row_idx)
            } else {
                None
            }
        })
        .expect("RowAdded op should exist");

    assert_eq!(
        added_row_idx, row_b,
        "RowAdded row_idx should match the row of ID 1001 in grid B"
    );
}

#[test]
fn d2_row_removed_emits_row_removed_only() {
    let wb_a = open_fixture_workbook("db_row_added_b.xlsx");
    let wb_b = open_fixture_workbook("db_equal_ordered_a.xlsx");

    let grid_a = data_grid(&wb_a);
    let grid_b = data_grid(&wb_b);

    let report = diff_db(grid_a, grid_b, &[0]);
    let (row_added, row_removed, cell_edited) = count_ops(&report);

    assert_eq!(row_removed, 1, "should emit exactly 1 RowRemoved");
    assert_eq!(row_added, 0, "should emit 0 RowAdded");
    assert_eq!(cell_edited, 0, "should emit 0 CellEdited");

    let row_a = find_row_by_id(grid_a, 1001).expect("removed row with ID 1001 should exist in A");

    let removed_row_idx = report
        .ops
        .iter()
        .find_map(|op| {
            if let DiffOp::RowRemoved { row_idx, .. } = op {
                Some(*row_idx)
            } else {
                None
            }
        })
        .expect("RowRemoved op should exist");

    assert_eq!(
        removed_row_idx, row_a,
        "RowRemoved row_idx should match the row of ID 1001 in grid A"
    );
}

#[test]
fn d3_row_update_emits_cell_edited_only() {
    let wb_a = open_fixture_workbook("db_equal_ordered_a.xlsx");
    let wb_b = open_fixture_workbook("db_row_update_b.xlsx");

    let grid_a = data_grid(&wb_a);
    let grid_b = data_grid(&wb_b);

    let report = diff_db(grid_a, grid_b, &[0]);
    let (row_added, row_removed, cell_edited) = count_ops(&report);

    assert_eq!(cell_edited, 1, "should emit exactly 1 CellEdited");
    assert_eq!(row_added, 0, "should emit 0 RowAdded");
    assert_eq!(row_removed, 0, "should emit 0 RowRemoved");

    let row_b = find_row_by_id(grid_b, 7).expect("row with ID 7 should exist in B");

    let edit = report
        .ops
        .iter()
        .find_map(|op| {
            if let DiffOp::CellEdited { addr, from, to, .. } = op {
                Some((addr, from, to))
            } else {
                None
            }
        })
        .expect("CellEdited op should exist");

    let (addr, from, to) = edit;
    assert_eq!(addr.row, row_b, "CellEdited should target row of ID 7 in B");
    assert_eq!(
        addr.col, 2,
        "CellEdited should target Amount column (col 2)"
    );

    let baseline_amount = 7.0 * 10.5;
    match &from.value {
        Some(CellValue::Number(n)) => {
            assert!(
                (*n - baseline_amount).abs() < 0.001,
                "from.value should be baseline Amount for ID 7 ({baseline_amount}), got {n}"
            );
        }
        other => panic!("from.value should be Number, got {:?}", other),
    }

    match &to.value {
        Some(CellValue::Number(n)) => {
            assert!(
                (*n - 120.0).abs() < 0.001,
                "to.value should be 120.0, got {n}"
            );
        }
        other => panic!("to.value should be Number, got {:?}", other),
    }

    assert!(from.formula.is_none(), "from.formula should be None");
    assert!(to.formula.is_none(), "to.formula should be None");
}

#[test]
fn d4_reorder_and_change_emits_cell_edited_only() {
    let wb_a = open_fixture_workbook("db_equal_ordered_a.xlsx");
    let wb_b = open_fixture_workbook("db_reorder_and_change_b.xlsx");

    let grid_a = data_grid(&wb_a);
    let grid_b = data_grid(&wb_b);

    let report = diff_db(grid_a, grid_b, &[0]);
    let (row_added, row_removed, cell_edited) = count_ops(&report);

    assert_eq!(cell_edited, 1, "should emit exactly 1 CellEdited");
    assert_eq!(row_added, 0, "should emit 0 RowAdded (reorder is ignored)");
    assert_eq!(
        row_removed, 0,
        "should emit 0 RowRemoved (reorder is ignored)"
    );

    let row_b = find_row_by_id(grid_b, 7).expect("row with ID 7 should exist in shuffled B");

    let edit = report
        .ops
        .iter()
        .find_map(|op| {
            if let DiffOp::CellEdited { addr, from, to, .. } = op {
                Some((addr, from, to))
            } else {
                None
            }
        })
        .expect("CellEdited op should exist");

    let (addr, from, to) = edit;
    assert_eq!(
        addr.row, row_b,
        "CellEdited should target row of ID 7 in shuffled B"
    );
    assert_eq!(
        addr.col, 2,
        "CellEdited should target Amount column (col 2)"
    );

    let baseline_amount = 7.0 * 10.5;
    match &from.value {
        Some(CellValue::Number(n)) => {
            assert!(
                (*n - baseline_amount).abs() < 0.001,
                "from.value should be baseline Amount for ID 7 ({baseline_amount}), got {n}"
            );
        }
        other => panic!("from.value should be Number, got {:?}", other),
    }

    match &to.value {
        Some(CellValue::Number(n)) => {
            assert!(
                (*n - 120.0).abs() < 0.001,
                "to.value should be 120.0, got {n}"
            );
        }
        other => panic!("to.value should be Number, got {:?}", other),
    }
}

```

---

### File: `core\tests\data_mashup_tests.rs`

```rust
use std::fs::File;
use std::io::{ErrorKind, Read};

use base64::Engine;
use base64::engine::general_purpose::STANDARD;
use excel_diff::{
    ContainerError, DataMashupError, PackageError, RawDataMashup, build_data_mashup,
    open_data_mashup,
};
use quick_xml::{Reader, events::Event};
use zip::ZipArchive;

mod common;
use common::fixture_path;

fn unwrap_path_error(err: PackageError) -> PackageError {
    match err {
        PackageError::WithPath { source, .. } => *source,
        other => other,
    }
}

fn unwrap_datamashup_part_error(err: PackageError) -> PackageError {
    match err {
        PackageError::DataMashupPartError { source, .. } => PackageError::DataMashup(source),
        other => other,
    }
}

fn unwrap_all(err: PackageError) -> PackageError {
    let err = unwrap_path_error(err);
    unwrap_datamashup_part_error(err)
}

#[test]
fn workbook_without_datamashup_returns_none() {
    let path = fixture_path("minimal.xlsx");
    let result = open_data_mashup(&path).expect("minimal workbook should load");
    assert!(result.is_none());
}

#[test]
fn workbook_with_valid_datamashup_parses() {
    let path = fixture_path("m_change_literal_b.xlsx");
    let raw = open_data_mashup(&path)
        .expect("valid mashup should load")
        .expect("mashup should be present");

    assert_eq!(raw.version, 0);
    assert!(!raw.package_parts.is_empty());
    assert!(!raw.metadata.is_empty());

    let assembled = assemble_top_level_bytes(&raw);
    let expected = datamashup_bytes_from_fixture(&path);
    assert_eq!(assembled, expected);
}

#[test]
fn datamashup_with_base64_whitespace_parses() {
    let path = fixture_path("mashup_base64_whitespace.xlsx");
    let raw = open_data_mashup(&path)
        .expect("whitespace in base64 payload should be tolerated")
        .expect("mashup should be present");
    assert_eq!(raw.version, 0);
    assert!(!raw.package_parts.is_empty());
}

#[test]
fn utf16_le_datamashup_parses() {
    let path = fixture_path("mashup_utf16_le.xlsx");
    let raw = open_data_mashup(&path)
        .expect("UTF-16LE mashup should load")
        .expect("mashup should be present");
    assert_eq!(raw.version, 0);
    assert!(!raw.package_parts.is_empty());
}

#[test]
fn utf16_be_datamashup_parses() {
    let path = fixture_path("mashup_utf16_be.xlsx");
    let raw = open_data_mashup(&path)
        .expect("UTF-16BE mashup should load")
        .expect("mashup should be present");
    assert_eq!(raw.version, 0);
    assert!(!raw.package_parts.is_empty());
}

#[test]
fn corrupt_base64_returns_error() {
    let path = fixture_path("corrupt_base64.xlsx");
    let err = open_data_mashup(&path).expect_err("corrupt base64 should fail");
    let err = unwrap_all(err);
    assert!(
        matches!(err, PackageError::DataMashup(DataMashupError::Base64Invalid)),
        "expected Base64Invalid, got {err:?}"
    );
}

#[test]
fn duplicate_datamashup_parts_are_rejected() {
    let path = fixture_path("duplicate_datamashup_parts.xlsx");
    let err = open_data_mashup(&path).expect_err("duplicate DataMashup parts should be rejected");
    let err = unwrap_all(err);
    assert!(
        matches!(err, PackageError::DataMashup(DataMashupError::FramingInvalid)),
        "expected FramingInvalid, got {err:?}"
    );
}

#[test]
fn duplicate_datamashup_elements_are_rejected() {
    let path = fixture_path("duplicate_datamashup_elements.xlsx");
    let err =
        open_data_mashup(&path).expect_err("duplicate DataMashup elements should be rejected");
    let err = unwrap_all(err);
    assert!(
        matches!(err, PackageError::DataMashup(DataMashupError::FramingInvalid)),
        "expected FramingInvalid, got {err:?}"
    );
}

#[test]
fn nonexistent_file_returns_io() {
    let path = fixture_path("missing_mashup.xlsx");
    let err = open_data_mashup(&path).expect_err("missing file should error");
    let err = unwrap_path_error(err);
    match err {
        PackageError::Container(ContainerError::Io(e)) => {
            assert_eq!(e.kind(), ErrorKind::NotFound)
        }
        other => panic!("expected Io error, got {other:?}"),
    }
}

#[test]
fn non_excel_container_returns_not_excel_error() {
    let path = fixture_path("random_zip.zip");
    let err = open_data_mashup(&path).expect_err("random zip should not parse");
    let err = unwrap_path_error(err);
    assert!(
        matches!(err, PackageError::Container(ContainerError::NotOpcPackage)),
        "expected NotOpcPackage, got {err:?}"
    );
}

#[test]
fn missing_content_types_is_not_excel_error() {
    let path = fixture_path("no_content_types.xlsx");
    let err = open_data_mashup(&path).expect_err("missing [Content_Types].xml should fail");
    let err = unwrap_path_error(err);
    assert!(
        matches!(err, PackageError::Container(ContainerError::NotOpcPackage)),
        "expected NotOpcPackage, got {err:?}"
    );
}

#[test]
fn non_zip_file_returns_not_zip_error() {
    let path = fixture_path("not_a_zip.txt");
    let err = open_data_mashup(&path).expect_err("non-zip input should not parse as Excel");
    let err = unwrap_path_error(err);
    assert!(
        matches!(err, PackageError::Container(ContainerError::NotZipContainer)),
        "expected NotZipContainer, got {err:?}"
    );
}

#[test]
fn build_data_mashup_smoke_from_fixture() {
    let raw = open_data_mashup(fixture_path("one_query.xlsx"))
        .expect("fixture should load")
        .expect("DataMashup should be present");
    let dm = build_data_mashup(&raw).expect("build_data_mashup should succeed");

    assert_eq!(dm.version, 0);
    assert!(
        dm.package_parts
            .main_section
            .source
            .contains("section Section1;")
    );
    assert!(!dm.metadata.formulas.is_empty());

    let non_connection: Vec<_> = dm
        .metadata
        .formulas
        .iter()
        .filter(|m| m.section_name == "Section1" && !m.is_connection_only)
        .collect();
    assert_eq!(non_connection.len(), 1);
    let meta = non_connection[0];
    assert_eq!(
        meta.item_path,
        format!("{}/{}", meta.section_name, meta.formula_name)
    );
    assert_eq!(meta.item_path, "Section1/Query1");
    assert_eq!(meta.section_name, "Section1");
    assert_eq!(meta.formula_name, "Query1");
    assert!(meta.load_to_sheet || meta.load_to_model);
}

fn datamashup_bytes_from_fixture(path: &std::path::Path) -> Vec<u8> {
    let file = File::open(path).expect("fixture should be readable");
    let mut archive = ZipArchive::new(file).expect("fixture should be a zip container");
    for i in 0..archive.len() {
        let mut file = archive.by_index(i).expect("zip entry should be readable");
        let name = file.name().to_string();
        if !name.starts_with("customXml/") || !name.ends_with(".xml") {
            continue;
        }

        let mut buf = Vec::new();
        file.read_to_end(&mut buf).expect("XML part should read");
        if let Some(text) = extract_datamashup_base64(&buf) {
            let cleaned: String = text.split_whitespace().collect();
            return STANDARD
                .decode(cleaned.as_bytes())
                .expect("DataMashup base64 should decode");
        }
    }

    panic!("DataMashup element not found in {}", path.display());
}

fn extract_datamashup_base64(xml: &[u8]) -> Option<String> {
    let mut reader = Reader::from_reader(xml);
    reader.config_mut().trim_text(false);
    let mut buf = Vec::new();
    let mut in_datamashup = false;
    let mut content = String::new();

    loop {
        match reader.read_event_into(&mut buf) {
            Ok(Event::Start(e)) if is_datamashup_element(e.name().as_ref()) => {
                if in_datamashup {
                    return None;
                }
                in_datamashup = true;
                content.clear();
            }
            Ok(Event::Text(t)) if in_datamashup => {
                let text = t.unescape().ok()?.into_owned();
                content.push_str(&text);
            }
            Ok(Event::CData(t)) if in_datamashup => {
                content.push_str(&String::from_utf8_lossy(&t.into_inner()));
            }
            Ok(Event::End(e)) if is_datamashup_element(e.name().as_ref()) => {
                if !in_datamashup {
                    return None;
                }
                return Some(content.clone());
            }
            Ok(Event::Eof) => return None,
            Err(_) => return None,
            _ => {}
        }
        buf.clear();
    }
}

fn is_datamashup_element(name: &[u8]) -> bool {
    match name.iter().rposition(|&b| b == b':') {
        Some(idx) => name.get(idx + 1..) == Some(b"DataMashup".as_slice()),
        None => name == b"DataMashup",
    }
}

fn assemble_top_level_bytes(raw: &RawDataMashup) -> Vec<u8> {
    let mut bytes = Vec::new();
    bytes.extend_from_slice(&raw.version.to_le_bytes());
    bytes.extend_from_slice(&(raw.package_parts.len() as u32).to_le_bytes());
    bytes.extend_from_slice(&raw.package_parts);
    bytes.extend_from_slice(&(raw.permissions.len() as u32).to_le_bytes());
    bytes.extend_from_slice(&raw.permissions);
    bytes.extend_from_slice(&(raw.metadata.len() as u32).to_le_bytes());
    bytes.extend_from_slice(&raw.metadata);
    bytes.extend_from_slice(&(raw.permission_bindings.len() as u32).to_le_bytes());
    bytes.extend_from_slice(&raw.permission_bindings);
    bytes
}

```

---

### File: `core\tests\database_mode_wrapper_tests.rs`

```rust
use excel_diff::{
    CellValue, DiffConfig, Grid, LimitBehavior, diff_grids_database_mode, with_default_session,
};

#[test]
fn database_mode_wrapper_limits_exceeded_returns_incomplete_report() {
    let mut grid_a = Grid::new(2, 1);
    grid_a.insert_cell(0, 0, Some(CellValue::Number(1.0)), None);
    grid_a.insert_cell(1, 0, Some(CellValue::Number(1.0)), None);

    let mut grid_b = Grid::new(2, 1);
    grid_b.insert_cell(0, 0, Some(CellValue::Number(1.0)), None);
    grid_b.insert_cell(1, 0, Some(CellValue::Number(1.0)), None);

    let config = DiffConfig {
        max_align_rows: 1,
        on_limit_exceeded: LimitBehavior::ReturnError,
        ..Default::default()
    };

    let result = std::panic::catch_unwind(|| {
        with_default_session(|session| {
            diff_grids_database_mode(&grid_a, &grid_b, &[0], &mut session.strings, &config)
        })
    });
    assert!(result.is_ok(), "database mode wrapper should not panic");
    let report = result.unwrap();

    assert!(!report.complete, "report should be marked incomplete");
    assert!(
        report
            .warnings
            .iter()
            .any(|w| w.contains("alignment limits exceeded")),
        "expected limits exceeded warning; warnings: {:?}",
        report.warnings
    );
}


```

---

### File: `core\tests\engine_tests.rs`

```rust
mod common;

use common::sid;
use excel_diff::{
    CellAddress, CellSnapshot, CellValue, DiffConfig, DiffOp, DiffReport, FormulaDiffResult, Grid,
    Sheet, SheetKind, Workbook, WorkbookPackage,
};

type SheetSpec<'a> = (&'a str, Vec<(u32, u32, f64)>);

fn diff_workbooks(old: &Workbook, new: &Workbook, config: &DiffConfig) -> DiffReport {
    WorkbookPackage::from(old.clone()).diff(&WorkbookPackage::from(new.clone()), config)
}

fn make_workbook(sheets: Vec<SheetSpec<'_>>) -> Workbook {
    let sheet_ir: Vec<Sheet> = sheets
        .into_iter()
        .map(|(name, cells)| {
            let max_row = cells.iter().map(|(r, _, _)| *r).max().unwrap_or(0);
            let max_col = cells.iter().map(|(_, c, _)| *c).max().unwrap_or(0);
            let mut grid = Grid::new(max_row + 1, max_col + 1);
            for (r, c, val) in cells {
                grid.insert_cell(r, c, Some(CellValue::Number(val)), None);
            }
            Sheet {
                name: sid(name),
                kind: SheetKind::Worksheet,
                grid,
            }
        })
        .collect();
    Workbook {
        sheets: sheet_ir,
        ..Default::default()
    }
}

fn make_sheet_with_kind(name: &str, kind: SheetKind, cells: Vec<(u32, u32, f64)>) -> Sheet {
    let (nrows, ncols) = if cells.is_empty() {
        (0, 0)
    } else {
        let max_row = cells.iter().map(|(r, _, _)| *r).max().unwrap_or(0);
        let max_col = cells.iter().map(|(_, c, _)| *c).max().unwrap_or(0);
        (max_row + 1, max_col + 1)
    };

    let mut grid = Grid::new(nrows, ncols);
    for (r, c, val) in cells {
        grid.insert_cell(r, c, Some(CellValue::Number(val)), None);
    }

    Sheet {
        name: sid(name),
        kind,
        grid,
    }
}

#[test]
fn identical_workbooks_produce_empty_report() {
    let wb = make_workbook(vec![("Sheet1", vec![(0, 0, 1.0)])]);
    let report = diff_workbooks(&wb, &wb, &DiffConfig::default());
    assert!(report.ops.is_empty());
}

#[test]
fn sheet_added_detected() {
    let old = make_workbook(vec![("Sheet1", vec![(0, 0, 1.0)])]);
    let new = make_workbook(vec![
        ("Sheet1", vec![(0, 0, 1.0)]),
        ("Sheet2", vec![(0, 0, 2.0)]),
    ]);
    let report = diff_workbooks(&old, &new, &DiffConfig::default());
    assert!(
        report
            .ops
            .iter()
            .any(|op| matches!(op, DiffOp::SheetAdded { sheet } if *sheet == sid("Sheet2")))
    );
}

#[test]
fn sheet_removed_detected() {
    let old = make_workbook(vec![
        ("Sheet1", vec![(0, 0, 1.0)]),
        ("Sheet2", vec![(0, 0, 2.0)]),
    ]);
    let new = make_workbook(vec![("Sheet1", vec![(0, 0, 1.0)])]);
    let report = diff_workbooks(&old, &new, &DiffConfig::default());
    assert!(
        report
            .ops
            .iter()
            .any(|op| matches!(op, DiffOp::SheetRemoved { sheet } if *sheet == sid("Sheet2")))
    );
}

#[test]
fn cell_edited_detected() {
    let old = make_workbook(vec![("Sheet1", vec![(0, 0, 1.0)])]);
    let new = make_workbook(vec![("Sheet1", vec![(0, 0, 2.0)])]);
    let report = diff_workbooks(&old, &new, &DiffConfig::default());
    assert_eq!(report.ops.len(), 1);
    match &report.ops[0] {
        DiffOp::CellEdited {
            sheet,
            addr,
            from,
            to,
            ..
        } => {
            assert_eq!(*sheet, sid("Sheet1"));
            assert_eq!(addr.to_a1(), "A1");
            assert_eq!(from.value, Some(CellValue::Number(1.0)));
            assert_eq!(to.value, Some(CellValue::Number(2.0)));
        }
        _ => panic!("expected CellEdited"),
    }
}

#[test]
fn diff_report_json_round_trips() {
    let old = make_workbook(vec![("Sheet1", vec![(0, 0, 1.0)])]);
    let new = make_workbook(vec![("Sheet1", vec![(0, 0, 2.0)])]);
    let report = diff_workbooks(&old, &new, &DiffConfig::default());
    let json = serde_json::to_string(&report).expect("serialize");
    let parsed: DiffReport = serde_json::from_str(&json).expect("deserialize");
    assert_eq!(report, parsed);
}

#[test]
fn sheet_name_case_insensitive_no_changes() {
    let old = make_workbook(vec![("Sheet1", vec![(0, 0, 1.0)])]);
    let new = make_workbook(vec![("sheet1", vec![(0, 0, 1.0)])]);

    let report = diff_workbooks(&old, &new, &DiffConfig::default());
    assert!(report.ops.is_empty());
}

#[test]
fn sheet_name_case_insensitive_cell_edit() {
    let old = make_workbook(vec![("Sheet1", vec![(0, 0, 1.0)])]);
    let new = make_workbook(vec![("sheet1", vec![(0, 0, 2.0)])]);

    let report = diff_workbooks(&old, &new, &DiffConfig::default());
    assert_eq!(report.ops.len(), 1);

    match &report.ops[0] {
        DiffOp::CellEdited {
            sheet,
            addr,
            from,
            to,
            ..
        } => {
            assert_eq!(*sheet, sid("Sheet1"));
            assert_eq!(addr.to_a1(), "A1");
            assert_eq!(from.value, Some(CellValue::Number(1.0)));
            assert_eq!(to.value, Some(CellValue::Number(2.0)));
        }
        other => panic!("expected CellEdited, got {other:?}"),
    }
}

#[test]
fn sheet_identity_includes_kind() {
    let mut grid = Grid::new(1, 1);
    grid.insert_cell(0, 0, Some(CellValue::Number(1.0)), None);

    let worksheet = Sheet {
        name: sid("Sheet1"),
        kind: SheetKind::Worksheet,
        grid: grid.clone(),
    };

    let chart = Sheet {
        name: sid("Sheet1"),
        kind: SheetKind::Chart,
        grid,
    };

    let old = Workbook {
        sheets: vec![worksheet],
        ..Default::default()
    };
    let new = Workbook {
        sheets: vec![chart],
        ..Default::default()
    };

    let report = diff_workbooks(&old, &new, &DiffConfig::default());

    let mut added = 0;
    let mut removed = 0;
    for op in &report.ops {
        match op {
            DiffOp::SheetAdded { sheet } if *sheet == sid("Sheet1") => added += 1,
            DiffOp::SheetRemoved { sheet } if *sheet == sid("Sheet1") => removed += 1,
            _ => {}
        }
    }

    assert_eq!(added, 1, "expected one SheetAdded for Chart 'Sheet1'");
    assert_eq!(
        removed, 1,
        "expected one SheetRemoved for Worksheet 'Sheet1'"
    );
    assert_eq!(report.ops.len(), 2, "no other ops expected");
}

#[test]
fn deterministic_sheet_op_ordering() {
    let budget_old = make_sheet_with_kind("Budget", SheetKind::Worksheet, vec![(0, 0, 1.0)]);
    let budget_new = make_sheet_with_kind("Budget", SheetKind::Worksheet, vec![(0, 0, 2.0)]);
    let sheet1_old = make_sheet_with_kind("Sheet1", SheetKind::Worksheet, vec![(0, 1, 5.0)]);
    let sheet1_chart = make_sheet_with_kind("sheet1", SheetKind::Chart, Vec::new());
    let summary_new = make_sheet_with_kind("Summary", SheetKind::Worksheet, vec![(0, 0, 3.0)]);

    let old = Workbook {
        sheets: vec![budget_old.clone(), sheet1_old],
        ..Default::default()
    };
    let new = Workbook {
        sheets: vec![budget_new.clone(), sheet1_chart, summary_new],
        ..Default::default()
    };

    let budget_addr = CellAddress::from_indices(0, 0);
    let expected = vec![
        DiffOp::cell_edited(
            sid("Budget"),
            budget_addr,
            CellSnapshot {
                addr: budget_addr,
                value: Some(CellValue::Number(1.0)),
                formula: None,
            },
            CellSnapshot {
                addr: budget_addr,
                value: Some(CellValue::Number(2.0)),
                formula: None,
            },
            FormulaDiffResult::Unchanged,
        ),
        DiffOp::SheetRemoved {
            sheet: sid("Sheet1"),
        },
        DiffOp::SheetAdded {
            sheet: sid("sheet1"),
        },
        DiffOp::SheetAdded {
            sheet: sid("Summary"),
        },
    ];

    let report = diff_workbooks(&old, &new, &DiffConfig::default());
    assert_eq!(
        report.ops, expected,
        "ops should be ordered by lowercase name then sheet kind"
    );
}

#[test]
fn sheet_identity_includes_kind_for_macro_and_other() {
    let mut grid = Grid::new(1, 1);
    grid.insert_cell(0, 0, Some(CellValue::Number(1.0)), None);

    let macro_sheet = Sheet {
        name: sid("Code"),
        kind: SheetKind::Macro,
        grid: grid.clone(),
    };

    let other_sheet = Sheet {
        name: sid("Code"),
        kind: SheetKind::Other,
        grid,
    };

    let old = Workbook {
        sheets: vec![macro_sheet],
        ..Default::default()
    };
    let new = Workbook {
        sheets: vec![other_sheet],
        ..Default::default()
    };

    let report = diff_workbooks(&old, &new, &DiffConfig::default());

    let mut added = 0;
    let mut removed = 0;
    for op in &report.ops {
        match op {
            DiffOp::SheetAdded { sheet } if *sheet == sid("Code") => added += 1,
            DiffOp::SheetRemoved { sheet } if *sheet == sid("Code") => removed += 1,
            _ => {}
        }
    }

    assert_eq!(added, 1, "expected one SheetAdded for Other 'Code'");
    assert_eq!(removed, 1, "expected one SheetRemoved for Macro 'Code'");
    assert_eq!(report.ops.len(), 2, "no other ops expected");
}

#[cfg(not(debug_assertions))]
#[test]
fn duplicate_sheet_identity_last_writer_wins_release() {
    let duplicate_a = make_sheet_with_kind("Sheet1", SheetKind::Worksheet, vec![(0, 0, 1.0)]);
    let duplicate_b = make_sheet_with_kind("sheet1", SheetKind::Worksheet, vec![(0, 1, 2.0)]);

    let old = Workbook {
        sheets: vec![duplicate_a, duplicate_b],
        ..Default::default()
    };
    let new = Workbook {
        sheets: Vec::new(),
        ..Default::default()
    };

    let report = diff_workbooks(&old, &new, &DiffConfig::default());
    assert_eq!(report.ops.len(), 1, "expected last writer to win");

    match &report.ops[0] {
        DiffOp::SheetRemoved { sheet } => assert_eq!(
            *sheet,
            sid("sheet1"),
            "duplicate identity should prefer the last sheet in release builds"
        ),
        other => panic!("expected SheetRemoved, got {other:?}"),
    }
}

#[test]
fn move_detection_respects_column_gate() {
    let nrows: u32 = 4;
    let ncols: u32 = 300;
    let src_rows = 1..3;
    let src_cols = 2..7;
    let dst_start_col: u32 = 200;
    let dst_end_col = dst_start_col + (src_cols.end - src_cols.start);

    let mut grid_a = Grid::new(nrows, ncols);
    let mut grid_b = Grid::new(nrows, ncols);

    for r in 0..nrows {
        for c in 0..ncols {
            let base_value = Some(CellValue::Number((r * 1_000 + c) as f64));

            grid_a.insert_cell(r, c, base_value.clone(), None);

            let in_src = src_rows.contains(&r) && src_cols.contains(&c);
            let in_dst = src_rows.contains(&r) && c >= dst_start_col && c < dst_end_col;

            if in_dst {
                let offset = c - dst_start_col;
                let src_c = src_cols.start + offset;
                let moved_value = Some(CellValue::Number((r * 1_000 + src_c) as f64));
                grid_b.insert_cell(r, c, moved_value, None);
            } else if !in_src {
                grid_b.insert_cell(r, c, base_value, None);
            }
        }
    }

    let wb_a = Workbook {
        sheets: vec![Sheet {
            name: sid("Sheet1"),
            kind: SheetKind::Worksheet,
            grid: grid_a,
        }],
        ..Default::default()
    };
    let wb_b = Workbook {
        sheets: vec![Sheet {
            name: sid("Sheet1"),
            kind: SheetKind::Worksheet,
            grid: grid_b,
        }],
        ..Default::default()
    };

    let default_report = diff_workbooks(&wb_a, &wb_b, &DiffConfig::default());
    assert!(
        !default_report.ops.is_empty(),
        "changes should be detected even when move detection is gated off"
    );
    assert!(
        !default_report
            .ops
            .iter()
            .any(|op| matches!(op, DiffOp::BlockMovedRect { .. })),
        "default gate should skip block move detection on wide sheets"
    );

    let wide_gate = DiffConfig {
        max_move_detection_cols: 512,
        ..DiffConfig::default()
    };
    let wide_report = diff_workbooks(&wb_a, &wb_b, &wide_gate);
    assert!(
        !wide_report.ops.is_empty(),
        "expected diffs when move detection is enabled"
    );
    assert!(
        wide_report
            .ops
            .iter()
            .any(|op| matches!(op, DiffOp::BlockMovedRect { .. })),
        "wider gate should allow block move detection on wide sheets"
    );
}

#[test]
fn duplicate_sheet_identity_emits_warning() {
    let duplicate_a = make_sheet_with_kind("Sheet1", SheetKind::Worksheet, vec![(0, 0, 1.0)]);
    let duplicate_b = make_sheet_with_kind("sheet1", SheetKind::Worksheet, vec![(0, 1, 2.0)]);
    let old = Workbook {
        sheets: vec![duplicate_a, duplicate_b],
        ..Default::default()
    };
    let new = Workbook {
        sheets: Vec::new(),
        ..Default::default()
    };

    let result = std::panic::catch_unwind(|| diff_workbooks(&old, &new, &DiffConfig::default()));
    assert!(result.is_ok(), "duplicate sheet identity should not panic");
    let report = result.unwrap();
    assert!(
        report.warnings.iter().any(|w| w.contains("duplicate sheet identity")),
        "should emit warning about duplicate sheet identity; warnings: {:?}",
        report.warnings
    );
}

```

---

### File: `core\tests\excel_open_xml_tests.rs`

```rust
mod common;

use common::{fixture_path, open_fixture_workbook, sid};
use excel_diff::{
    CellAddress, ContainerError, ContainerLimits, DataMashupError, OpcContainer, PackageError,
    SheetKind, WorkbookPackage, open_data_mashup,
};
use std::fs;
use std::io::{Cursor, ErrorKind, Write};
use std::path::Path;
use std::time::SystemTime;
use zip::write::FileOptions;
use zip::{CompressionMethod, ZipWriter};

fn temp_xlsx_path(prefix: &str) -> std::path::PathBuf {
    let mut path = std::env::temp_dir();
    let nanos = SystemTime::now()
        .duration_since(std::time::UNIX_EPOCH)
        .expect("system time should be after unix epoch")
        .as_nanos();
    path.push(format!("excel_diff_{prefix}_{nanos}.xlsx"));
    path
}

fn write_zip(entries: &[(&str, &str)], path: &Path) {
    let file = fs::File::create(path).expect("create temp zip");
    let mut writer = ZipWriter::new(file);
    let options = FileOptions::default().compression_method(CompressionMethod::Stored);

    for (name, contents) in entries {
        writer.start_file(*name, options).expect("start zip entry");
        writer
            .write_all(contents.as_bytes())
            .expect("write zip entry");
    }

    writer.finish().expect("finish zip");
}

#[test]
fn open_minimal_workbook_succeeds() {
    let workbook = open_fixture_workbook("minimal.xlsx");
    assert_eq!(workbook.sheets.len(), 1);

    let sheet = &workbook.sheets[0];
    assert_eq!(sheet.name, sid("Sheet1"));
    assert!(matches!(sheet.kind, SheetKind::Worksheet));
    assert_eq!(sheet.grid.nrows, 1);
    assert_eq!(sheet.grid.ncols, 1);

    let cell = sheet.grid.get(0, 0).expect("A1 should be present");
    assert_eq!(CellAddress::from_coords(0, 0).to_a1(), "A1");
    assert!(cell.value.is_some());
}

#[test]
fn open_nonexistent_file_returns_io_error() {
    let path = fixture_path("definitely_missing.xlsx");
    let file = std::fs::File::open(&path);
    assert!(file.is_err(), "missing file should error");
    let io_err = file.unwrap_err();
    assert_eq!(io_err.kind(), ErrorKind::NotFound);
}

#[test]
fn random_zip_is_not_excel() {
    let path = fixture_path("random_zip.zip");
    let file = std::fs::File::open(&path).expect("random zip file exists");
    let err = WorkbookPackage::open(file).expect_err("random zip should not parse");
    assert!(matches!(
        err,
        PackageError::Container(ContainerError::NotOpcPackage)
    ));
}

#[test]
fn no_content_types_is_not_excel() {
    let path = fixture_path("no_content_types.xlsx");
    let file = std::fs::File::open(&path).expect("no content types file exists");
    let err = WorkbookPackage::open(file).expect_err("missing content types should fail");
    assert!(matches!(
        err,
        PackageError::Container(ContainerError::NotOpcPackage)
    ));
}

#[test]
fn not_zip_container_returns_error() {
    let path = std::env::temp_dir().join("excel_diff_not_zip.txt");
    fs::write(&path, "this is not a zip container").expect("write temp file");
    let file = std::fs::File::open(&path).expect("not zip file exists");
    let err = WorkbookPackage::open(file).expect_err("non-zip should fail");
    assert!(matches!(
        err,
        PackageError::Container(ContainerError::NotZipContainer)
    ));
    let _ = fs::remove_file(&path);
}

#[test]
fn missing_workbook_xml_returns_missing_part() {
    let path = temp_xlsx_path("missing_workbook_xml");
    let content_types = r#"<?xml version="1.0" encoding="UTF-8"?>
<Types xmlns="http://schemas.openxmlformats.org/package/2006/content-types">
  <Default Extension="rels" ContentType="application/vnd.openxmlformats-package.relationships+xml"/>
  <Default Extension="xml" ContentType="application/xml"/>
</Types>"#;

    write_zip(&[("[Content_Types].xml", content_types)], &path);

    let file = std::fs::File::open(&path).expect("temp file exists");
    let err = WorkbookPackage::open(file).expect_err("missing workbook xml should error");
    match err {
        PackageError::MissingPart { path } => {
            assert_eq!(path, "xl/workbook.xml");
        }
        other => panic!("expected MissingPart for xl/workbook.xml, got {other:?}"),
    }

    let _ = fs::remove_file(&path);
}

#[test]
fn missing_worksheet_xml_returns_missing_part() {
    let path = temp_xlsx_path("missing_worksheet_xml");
    let content_types = r#"<?xml version="1.0" encoding="UTF-8"?>
<Types xmlns="http://schemas.openxmlformats.org/package/2006/content-types">
  <Default Extension="rels" ContentType="application/vnd.openxmlformats-package.relationships+xml"/>
  <Default Extension="xml" ContentType="application/xml"/>
</Types>"#;

    let workbook_xml = r#"<?xml version="1.0" encoding="UTF-8"?>
<workbook xmlns="http://schemas.openxmlformats.org/spreadsheetml/2006/main"
          xmlns:r="http://schemas.openxmlformats.org/officeDocument/2006/relationships">
  <sheets>
    <sheet name="Sheet1" sheetId="1" r:id="rId1"/>
  </sheets>
</workbook>"#;

    let relationships = r#"<?xml version="1.0" encoding="UTF-8"?>
<Relationships xmlns="http://schemas.openxmlformats.org/package/2006/relationships">
  <Relationship Id="rId1"
                Type="http://schemas.openxmlformats.org/officeDocument/2006/relationships/worksheet"
                Target="worksheets/sheet1.xml"/>
</Relationships>"#;

    write_zip(
        &[
            ("[Content_Types].xml", content_types),
            ("xl/workbook.xml", workbook_xml),
            ("xl/_rels/workbook.xml.rels", relationships),
        ],
        &path,
    );

    let file = std::fs::File::open(&path).expect("temp file exists");
    let err = WorkbookPackage::open(file).expect_err("missing worksheet xml should error");
    match err {
        PackageError::MissingPart { path: part_path } => {
            assert!(
                part_path.contains("sheet1.xml"),
                "expected path to contain sheet1.xml, got {part_path}"
            );
        }
        other => panic!("expected MissingPart for worksheet, got {other:?}"),
    }

    let _ = fs::remove_file(&path);
}

#[test]
fn truncated_zip_never_panics() {
    let valid_zip_bytes = {
        let mut buf = Vec::new();
        {
            let cursor = Cursor::new(&mut buf);
            let mut writer = ZipWriter::new(cursor);
            let options = FileOptions::default().compression_method(CompressionMethod::Stored);
            writer.start_file("[Content_Types].xml", options).unwrap();
            writer.write_all(b"<Types/>").unwrap();
            writer.finish().unwrap();
        }
        buf
    };

    for truncate_at in [0, 4, 10, 20, valid_zip_bytes.len() / 2] {
        let truncated = &valid_zip_bytes[..truncate_at.min(valid_zip_bytes.len())];
        let cursor = Cursor::new(truncated.to_vec());
        let result = std::panic::catch_unwind(|| OpcContainer::open_from_reader(cursor));
        assert!(result.is_ok(), "truncated ZIP at byte {} should not panic", truncate_at);
        let inner = result.unwrap();
        assert!(inner.is_err(), "truncated ZIP should return error, not Ok");
    }
}

#[test]
fn zip_bomb_defense_rejects_oversized_part() {
    let path = temp_xlsx_path("oversized_part");
    let content_types = r#"<?xml version="1.0" encoding="UTF-8"?>
<Types xmlns="http://schemas.openxmlformats.org/package/2006/content-types">
  <Default Extension="xml" ContentType="application/xml"/>
</Types>"#;

    let large_content = "x".repeat(1024);

    write_zip(
        &[
            ("[Content_Types].xml", content_types),
            ("large_file.xml", &large_content),
        ],
        &path,
    );

    let file = std::fs::File::open(&path).expect("temp file exists");
    let limits = ContainerLimits {
        max_entries: 100,
        max_part_uncompressed_bytes: 512,
        max_total_uncompressed_bytes: 10_000,
    };
    let mut container = OpcContainer::open_from_reader_with_limits(file, limits)
        .expect("container should open (content_types is small)");

    let err = container.read_file_checked("large_file.xml")
        .expect_err("oversized part should be rejected");
    assert!(
        matches!(err, ContainerError::PartTooLarge { .. }),
        "expected PartTooLarge error, got {err:?}"
    );

    let _ = fs::remove_file(&path);
}

#[test]
fn oversized_content_types_is_rejected_during_open() {
    let path = temp_xlsx_path("oversized_content_types");
    let huge_content_types = "x".repeat(1024);

    write_zip(&[("[Content_Types].xml", &huge_content_types)], &path);

    let file = std::fs::File::open(&path).expect("temp file exists");
    let limits = ContainerLimits {
        max_entries: 100,
        max_part_uncompressed_bytes: 100,
        max_total_uncompressed_bytes: 10_000,
    };

    let err = match OpcContainer::open_from_reader_with_limits(file, limits) {
        Ok(_) => panic!("expected oversized [Content_Types].xml to be rejected"),
        Err(e) => e,
    };

    match err {
        ContainerError::PartTooLarge { path, size, limit } => {
            assert_eq!(path, "[Content_Types].xml");
            assert_eq!(size, 1024);
            assert_eq!(limit, 100);
        }
        other => panic!("expected PartTooLarge, got {other:?}"),
    }

    let _ = fs::remove_file(&path);
}

#[test]
fn invalid_xml_in_workbook_does_not_panic() {
    let path = temp_xlsx_path("invalid_xml");
    let content_types = r#"<?xml version="1.0" encoding="UTF-8"?>
<Types xmlns="http://schemas.openxmlformats.org/package/2006/content-types">
  <Default Extension="xml" ContentType="application/xml"/>
</Types>"#;

    let malformed_workbook = "<workbook><sheets><sheet name='x' unclosed";

    write_zip(
        &[
            ("[Content_Types].xml", content_types),
            ("xl/workbook.xml", malformed_workbook),
        ],
        &path,
    );

    let file = std::fs::File::open(&path).expect("temp file exists");
    let result = std::panic::catch_unwind(|| WorkbookPackage::open(file));
    assert!(result.is_ok(), "malformed XML should not panic (catch_unwind succeeded)");
    let err = result
        .unwrap()
        .expect_err("malformed XML should return error, not Ok");
    match err {
        PackageError::InvalidXml {
            part,
            line,
            column,
            ..
        } => {
            assert_eq!(part, "xl/workbook.xml");
            assert!(line > 0, "expected line > 0, got {line}");
            assert!(column > 0, "expected column > 0, got {column}");
        }
        other => panic!("expected InvalidXml, got {other:?}"),
    }

    let _ = fs::remove_file(&path);
}

#[test]
fn invalid_xml_in_relationships_includes_part_and_position() {
    let path = temp_xlsx_path("invalid_rels_xml");
    let content_types = r#"<?xml version="1.0" encoding="UTF-8"?>
<Types xmlns="http://schemas.openxmlformats.org/package/2006/content-types">
  <Default Extension="rels" ContentType="application/vnd.openxmlformats-package.relationships+xml"/>
  <Default Extension="xml" ContentType="application/xml"/>
</Types>"#;

    let workbook_xml = r#"<?xml version="1.0" encoding="UTF-8"?>
<workbook xmlns="http://schemas.openxmlformats.org/spreadsheetml/2006/main"
          xmlns:r="http://schemas.openxmlformats.org/officeDocument/2006/relationships">
  <sheets>
    <sheet name="Sheet1" sheetId="1" r:id="rId1"/>
  </sheets>
</workbook>"#;

    let malformed_rels = r#"<?xml version="1.0" encoding="UTF-8"?>
<Relationships xmlns="http://schemas.openxmlformats.org/package/2006/relationships">
  <Relationship Id="rId1" Target="worksheets/sheet1.xml""#;

    write_zip(
        &[
            ("[Content_Types].xml", content_types),
            ("xl/workbook.xml", workbook_xml),
            ("xl/_rels/workbook.xml.rels", malformed_rels),
        ],
        &path,
    );

    let file = std::fs::File::open(&path).expect("temp file exists");
    let result = std::panic::catch_unwind(|| WorkbookPackage::open(file));
    assert!(result.is_ok(), "malformed relationships XML should not panic");
    let err = result.unwrap().expect_err("malformed relationships XML should error");
    match err {
        PackageError::InvalidXml {
            part,
            line,
            column,
            ..
        } => {
            assert_eq!(part, "xl/_rels/workbook.xml.rels");
            assert!(line > 0, "expected line > 0, got {line}");
            assert!(column > 0, "expected column > 0, got {column}");
        }
        other => panic!("expected InvalidXml, got {other:?}"),
    }

    let _ = fs::remove_file(&path);
}

#[test]
fn invalid_xml_in_worksheet_includes_part_and_position() {
    let path = temp_xlsx_path("invalid_sheet_xml");
    let content_types = r#"<?xml version="1.0" encoding="UTF-8"?>
<Types xmlns="http://schemas.openxmlformats.org/package/2006/content-types">
  <Default Extension="rels" ContentType="application/vnd.openxmlformats-package.relationships+xml"/>
  <Default Extension="xml" ContentType="application/xml"/>
</Types>"#;

    let workbook_xml = r#"<?xml version="1.0" encoding="UTF-8"?>
<workbook xmlns="http://schemas.openxmlformats.org/spreadsheetml/2006/main"
          xmlns:r="http://schemas.openxmlformats.org/officeDocument/2006/relationships">
  <sheets>
    <sheet name="Sheet1" sheetId="1" r:id="rId1"/>
  </sheets>
</workbook>"#;

    let relationships = r#"<?xml version="1.0" encoding="UTF-8"?>
<Relationships xmlns="http://schemas.openxmlformats.org/package/2006/relationships">
  <Relationship Id="rId1"
                Type="http://schemas.openxmlformats.org/officeDocument/2006/relationships/worksheet"
                Target="worksheets/sheet1.xml"/>
</Relationships>"#;

    let malformed_sheet = r#"<?xml version="1.0" encoding="UTF-8"?>
<worksheet xmlns="http://schemas.openxmlformats.org/spreadsheetml/2006/main">
  <sheetData>
    <row r="1">
      <c r="A1"><v>1</v>
    </row>
  </sheetData>
</worksheet>"#;

    write_zip(
        &[
            ("[Content_Types].xml", content_types),
            ("xl/workbook.xml", workbook_xml),
            ("xl/_rels/workbook.xml.rels", relationships),
            ("xl/worksheets/sheet1.xml", malformed_sheet),
        ],
        &path,
    );

    let file = std::fs::File::open(&path).expect("temp file exists");
    let result = std::panic::catch_unwind(|| WorkbookPackage::open(file));
    assert!(result.is_ok(), "malformed worksheet XML should not panic");
    let err = result.unwrap().expect_err("malformed worksheet XML should error");
    match err {
        PackageError::InvalidXml {
            part,
            line,
            column,
            ..
        } => {
            assert_eq!(part, "xl/worksheets/sheet1.xml");
            assert!(line > 0, "expected line > 0, got {line}");
            assert!(column > 0, "expected column > 0, got {column}");
        }
        other => panic!("expected InvalidXml, got {other:?}"),
    }

    let _ = fs::remove_file(&path);
}

#[test]
fn datamashup_base64_decodes_but_framing_invalid_includes_part() {
    let path = temp_xlsx_path("dm_framing_invalid");
    let content_types = r#"<?xml version="1.0" encoding="UTF-8"?>
<Types xmlns="http://schemas.openxmlformats.org/package/2006/content-types">
  <Default Extension="xml" ContentType="application/xml"/>
</Types>"#;

    let dm_xml = r#"<?xml version="1.0" encoding="UTF-8"?>
<root xmlns:dm="http://schemas.microsoft.com/DataMashup">
  <dm:DataMashup>AAAA</dm:DataMashup>
</root>"#;

    write_zip(
        &[
            ("[Content_Types].xml", content_types),
            ("customXml/item1.xml", dm_xml),
        ],
        &path,
    );

    let err = open_data_mashup(&path).expect_err("expected framing error");
    let err = match err {
        PackageError::WithPath { source, .. } => *source,
        other => other,
    };

    match err {
        PackageError::DataMashupPartError { part, source } => {
            assert_eq!(part, "customXml/item1.xml");
            assert!(matches!(source, DataMashupError::FramingInvalid));
        }
        other => panic!("expected DataMashupPartError, got {other:?}"),
    }

    let _ = fs::remove_file(&path);
}

#[test]
fn corrupt_inputs_never_panic() {
    let test_cases: Vec<(&str, Vec<u8>)> = vec![
        ("empty", vec![]),
        ("garbage", vec![0xFF, 0xFE, 0x00, 0x01, 0x02, 0x03]),
        ("partial_zip_header", vec![0x50, 0x4B, 0x03, 0x04]),
        ("random_bytes", (0..100).map(|i| (i * 17 + 31) as u8).collect()),
    ];

    for (name, bytes) in test_cases {
        let cursor = Cursor::new(bytes);
        let result = std::panic::catch_unwind(|| WorkbookPackage::open(cursor));
        assert!(
            result.is_ok(),
            "corrupt input '{}' should not panic",
            name
        );
    }
}

```

---

### File: `core\tests\f7_formula_canonicalization_tests.rs`

```rust
use excel_diff::parse_formula;

#[test]
fn canonicalizes_commutative_binary_ops() {
    let a = parse_formula("A1+B1").unwrap().canonicalize();
    let b = parse_formula("B1+A1").unwrap().canonicalize();
    assert_eq!(a, b);

    let a = parse_formula("A1*B1").unwrap().canonicalize();
    let b = parse_formula("B1*A1").unwrap().canonicalize();
    assert_eq!(a, b);
}

#[test]
fn canonicalizes_commutative_functions_by_sorting_args() {
    let a = parse_formula("SUM(A1,B1)").unwrap().canonicalize();
    let b = parse_formula("SUM(B1,A1)").unwrap().canonicalize();
    assert_eq!(a, b);

    let a = parse_formula("AND(TRUE,FALSE)").unwrap().canonicalize();
    let b = parse_formula("AND(FALSE,TRUE)").unwrap().canonicalize();
    assert_eq!(a, b);
}

#[test]
fn does_not_canonicalize_non_commutative_ops() {
    let a = parse_formula("A1-B1").unwrap().canonicalize();
    let b = parse_formula("B1-A1").unwrap().canonicalize();
    assert_ne!(a, b);
}

#[test]
fn canonicalizes_range_endpoints() {
    let a = parse_formula("B2:A1").unwrap().canonicalize();
    let b = parse_formula("A1:B2").unwrap().canonicalize();
    assert_eq!(a, b);
}

#[test]
fn structured_refs_parse_and_canonicalize() {
    let a = parse_formula("Table1[Column1]").unwrap().canonicalize();
    let b = parse_formula("TABLE1[COLUMN1]").unwrap().canonicalize();
    assert_eq!(a, b);
}

```

---

### File: `core\tests\f7_formula_diff_integration_tests.rs`

```rust
use excel_diff::{
    CellValue, DiffConfig, DiffOp, FormulaDiffResult, Grid, Sheet, SheetKind, StringPool, Workbook,
    diff_grids_database_mode, diff_workbooks_with_pool,
};

fn workbook_with_formula(
    pool: &mut StringPool,
    sheet: excel_diff::StringId,
    row: u32,
    col: u32,
    formula: &str,
) -> Workbook {
    let mut grid = Grid::new(row + 1, col + 1);
    let formula_id = pool.intern(formula);
    grid.insert_cell(row, col, None, Some(formula_id));

    Workbook {
        sheets: vec![Sheet {
            name: sheet,
            kind: SheetKind::Worksheet,
            grid,
        }],
        ..Default::default()
    }
}

fn cell_edit_op(report: &excel_diff::DiffReport) -> DiffOp {
    report
        .ops
        .iter()
        .find(|op| matches!(op, DiffOp::CellEdited { .. }))
        .cloned()
        .expect("expected a cell edit in the diff")
}

#[test]
fn formatting_only_vs_text_change_respects_flag() {
    let mut pool = StringPool::new();
    let sheet = pool.intern("Sheet1");
    let old = workbook_with_formula(&mut pool, sheet, 0, 0, "sum(a1,b1)");
    let new = workbook_with_formula(&mut pool, sheet, 0, 0, "SUM(A1,B1)");

    let mut enabled = DiffConfig::default();
    enabled.enable_formula_semantic_diff = true;
    let disabled = DiffConfig::default();

    let report_enabled = diff_workbooks_with_pool(&old, &new, &mut pool, &enabled);
    let report_disabled = diff_workbooks_with_pool(&old, &new, &mut pool, &disabled);

    match cell_edit_op(&report_enabled) {
        DiffOp::CellEdited { formula_diff, .. } => {
            assert_eq!(formula_diff, FormulaDiffResult::FormattingOnly);
        }
        _ => panic!("expected CellEdited op in enabled diff"),
    }

    match cell_edit_op(&report_disabled) {
        DiffOp::CellEdited { formula_diff, .. } => {
            assert_eq!(formula_diff, FormulaDiffResult::TextChange);
        }
        _ => panic!("expected CellEdited op in disabled diff"),
    }
}

#[test]
fn filled_down_formulas_detect_row_shift() {
    let mut pool = StringPool::new();

    let mut config = DiffConfig::default();
    config.enable_formula_semantic_diff = true;

    let mut old = Grid::new(1, 2);
    old.insert_cell(0, 0, Some(CellValue::Number(1.0)), None);
    old.insert_cell(0, 1, None, Some(pool.intern("A1+B1")));

    let mut new = Grid::new(2, 2);
    new.insert_cell(0, 0, Some(CellValue::Number(0.0)), None);
    new.insert_cell(1, 0, Some(CellValue::Number(1.0)), None);
    new.insert_cell(1, 1, None, Some(pool.intern("A2+B2")));

    let report = diff_grids_database_mode(&old, &new, &[0], &mut pool, &config);

    let cell_edit = cell_edit_op(&report);
    match cell_edit {
        DiffOp::CellEdited {
            addr, formula_diff, ..
        } => {
            assert_eq!(addr.row, 1);
            assert_eq!(addr.col, 1);
            assert_eq!(formula_diff, FormulaDiffResult::Filled);
        }
        _ => panic!("expected CellEdited op"),
    }

    assert!(
        report
            .ops
            .iter()
            .any(|op| matches!(op, DiffOp::RowAdded { row_idx, .. } if *row_idx == 0)),
        "expected a row insertion ahead of the filled-down formula",
    );
}

```

---

### File: `core\tests\f7_formula_parser_tests.rs`

```rust
use excel_diff::{
    BinaryOperator, CellReference, ColRef, ExcelError, FormulaExpr, RangeReference, RowRef,
    UnaryOperator, parse_formula,
};

fn cell(sheet: Option<&str>, row: RowRef, col: ColRef) -> FormulaExpr {
    FormulaExpr::CellRef(CellReference {
        sheet: sheet.map(|s| s.to_string()),
        row,
        col,
        spill: false,
    })
}

#[test]
fn parses_expected_ast_shapes() {
    let cases = vec![
        ("1", FormulaExpr::Number(1.0)),
        ("\"x\"", FormulaExpr::Text("x".to_string())),
        ("TRUE", FormulaExpr::Boolean(true)),
        ("#DIV/0!", FormulaExpr::Error(ExcelError::Div0)),
        ("A1", cell(None, RowRef::Relative(1), ColRef::Relative(1))),
        ("$B$2", cell(None, RowRef::Absolute(2), ColRef::Absolute(2))),
        (
            "R[1]C[-1]",
            cell(None, RowRef::Offset(1), ColRef::Offset(-1)),
        ),
        (
            "SUM(A1,B1)",
            FormulaExpr::FunctionCall {
                name: "SUM".into(),
                args: vec![
                    cell(None, RowRef::Relative(1), ColRef::Relative(1)),
                    cell(None, RowRef::Relative(1), ColRef::Relative(2)),
                ],
            },
        ),
        (
            "{1,2;3,4}",
            FormulaExpr::Array(vec![
                vec![FormulaExpr::Number(1.0), FormulaExpr::Number(2.0)],
                vec![FormulaExpr::Number(3.0), FormulaExpr::Number(4.0)],
            ]),
        ),
        (
            "A1:B2",
            FormulaExpr::RangeRef(RangeReference {
                sheet: None,
                start: CellReference {
                    sheet: None,
                    row: RowRef::Relative(1),
                    col: ColRef::Relative(1),
                    spill: false,
                },
                end: CellReference {
                    sheet: None,
                    row: RowRef::Relative(2),
                    col: ColRef::Relative(2),
                    spill: false,
                },
            }),
        ),
        (
            "A1^-1",
            FormulaExpr::BinaryOp {
                op: BinaryOperator::Pow,
                left: Box::new(cell(None, RowRef::Relative(1), ColRef::Relative(1))),
                right: Box::new(FormulaExpr::UnaryOp {
                    op: UnaryOperator::Minus,
                    operand: Box::new(FormulaExpr::Number(1.0)),
                }),
            },
        ),
    ];

    for (text, expected) in cases {
        let parsed = parse_formula(text).expect("formula should parse");
        assert_eq!(parsed, expected, "mismatched AST for '{text}'");
    }
}

#[test]
fn parses_varied_syntaxes() {
    let samples = [
        "=sum( A1 , B1 )",
        "'My Sheet'!$A$1",
        "[Book1.xlsx]Sheet1!A1",
        "{1,2;3,4}",
        "Table1[Column1]",
        "R1C1",
        "R[2]C[-3]",
    ];

    for text in samples {
        parse_formula(text).unwrap_or_else(|e| panic!("failed to parse {text}: {e}"));
    }
}

```

---

### File: `core\tests\f7_formula_shift_tests.rs`

```rust
use excel_diff::{formulas_equivalent_modulo_shift, parse_formula};

#[test]
fn filled_down_formulas_match_under_row_shift() {
    let old = parse_formula("A1+B1").expect("old formula parses");
    let new = parse_formula("A2+B2").expect("new formula parses");

    assert!(
        formulas_equivalent_modulo_shift(&old, &new, 1, 0),
        "expected formulas to match after row shift",
    );
    assert!(
        !formulas_equivalent_modulo_shift(&old, &new, 0, 0),
        "without shift they should differ",
    );
}

#[test]
fn mismatched_refs_do_not_match_under_zero_shift() {
    let old = parse_formula("A1+B1").expect("old formula parses");
    let new = parse_formula("A1+B2").expect("new formula parses");

    assert!(
        !formulas_equivalent_modulo_shift(&old, &new, 0, 0),
        "different refs should not be equivalent without a shift",
    );
}

```

---

### File: `core\tests\g10_row_block_alignment_grid_workbook_tests.rs`

```rust
mod common;

use common::{diff_fixture_pkgs, sid};
use excel_diff::{DiffConfig, DiffOp};

#[test]
fn g10_row_block_insert_middle_emits_four_rowadded_and_no_noise() {
    let report = diff_fixture_pkgs(
        "row_block_insert_a.xlsx",
        "row_block_insert_b.xlsx",
        &DiffConfig::default(),
    );

    let rows_added: Vec<u32> = report
        .ops
        .iter()
        .filter_map(|op| match op {
            DiffOp::RowAdded {
                sheet,
                row_idx,
                row_signature,
            } => {
                assert_eq!(*sheet, sid("Sheet1"));
                assert!(row_signature.is_none());
                Some(*row_idx)
            }
            _ => None,
        })
        .collect();

    assert_eq!(
        rows_added,
        vec![3, 4, 5, 6],
        "expected four RowAdded ops for the inserted block"
    );

    assert!(
        !report
            .ops
            .iter()
            .any(|op| matches!(op, DiffOp::RowRemoved { .. })),
        "no rows should be removed for block insert"
    );

    assert!(
        !report
            .ops
            .iter()
            .any(|op| matches!(op, DiffOp::CellEdited { .. })),
        "aligned block insert should not emit CellEdited noise"
    );
}

#[test]
fn g10_row_block_delete_middle_emits_four_rowremoved_and_no_noise() {
    let report = diff_fixture_pkgs(
        "row_block_delete_a.xlsx",
        "row_block_delete_b.xlsx",
        &DiffConfig::default(),
    );

    let rows_removed: Vec<u32> = report
        .ops
        .iter()
        .filter_map(|op| match op {
            DiffOp::RowRemoved {
                sheet,
                row_idx,
                row_signature,
            } => {
                assert_eq!(*sheet, sid("Sheet1"));
                assert!(row_signature.is_none());
                Some(*row_idx)
            }
            _ => None,
        })
        .collect();

    assert_eq!(
        rows_removed,
        vec![3, 4, 5, 6],
        "expected four RowRemoved ops for the deleted block"
    );

    assert!(
        !report
            .ops
            .iter()
            .any(|op| matches!(op, DiffOp::RowAdded { .. })),
        "no rows should be added for block delete"
    );

    assert!(
        !report
            .ops
            .iter()
            .any(|op| matches!(op, DiffOp::CellEdited { .. })),
        "aligned block delete should not emit CellEdited noise"
    );
}

```

---

### File: `core\tests\g11_row_block_move_grid_workbook_tests.rs`

```rust
mod common;

use common::{diff_fixture_pkgs, grid_from_numbers, single_sheet_workbook};
use excel_diff::{DiffConfig, DiffOp, DiffReport, Workbook, WorkbookPackage};

fn diff_workbooks(old: &Workbook, new: &Workbook, config: &DiffConfig) -> DiffReport {
    WorkbookPackage::from(old.clone()).diff(&WorkbookPackage::from(new.clone()), config)
}

#[test]
fn g11_row_block_move_emits_single_blockmovedrows() {
    let report = diff_fixture_pkgs(
        "row_block_move_a.xlsx",
        "row_block_move_b.xlsx",
        &DiffConfig::default(),
    );

    assert_eq!(report.ops.len(), 1, "expected a single diff op");
    let strings = &report.strings;

    match &report.ops[0] {
        DiffOp::BlockMovedRows {
            sheet,
            src_start_row,
            row_count,
            dst_start_row,
            block_hash,
        } => {
            assert_eq!(
                strings.get(sheet.0 as usize).map(String::as_str),
                Some("Sheet1")
            );
            assert_eq!(*src_start_row, 4);
            assert_eq!(*row_count, 4);
            assert_eq!(*dst_start_row, 12);
            assert!(block_hash.is_none());
        }
        other => panic!("expected BlockMovedRows op, got {:?}", other),
    }

    assert!(
        !report
            .ops
            .iter()
            .any(|op| matches!(op, DiffOp::RowAdded { .. })),
        "pure move should not emit RowAdded"
    );
    assert!(
        !report
            .ops
            .iter()
            .any(|op| matches!(op, DiffOp::RowRemoved { .. })),
        "pure move should not emit RowRemoved"
    );
    assert!(
        !report
            .ops
            .iter()
            .any(|op| matches!(op, DiffOp::CellEdited { .. })),
        "pure move should not emit CellEdited noise"
    );
}

#[test]
fn g11_repeated_rows_do_not_emit_blockmove() {
    let grid_a = grid_from_numbers(&[&[1, 10], &[1, 10], &[2, 20], &[2, 20]]);

    let grid_b = grid_from_numbers(&[&[2, 20], &[2, 20], &[1, 10], &[1, 10]]);

    let wb_a = single_sheet_workbook("Sheet1", grid_a);
    let wb_b = single_sheet_workbook("Sheet1", grid_b);

    let report = diff_workbooks(&wb_a, &wb_b, &DiffConfig::default());

    assert!(
        !report
            .ops
            .iter()
            .any(|op| matches!(op, DiffOp::BlockMovedRows { .. })),
        "ambiguous repeated rows must not emit BlockMovedRows"
    );

    assert!(
        report
            .ops
            .iter()
            .any(|op| matches!(op, DiffOp::CellEdited { .. })),
        "fallback path should emit positional CellEdited noise"
    );
}

```

---

### File: `core\tests\g12_column_block_move_grid_workbook_tests.rs`

```rust
mod common;

use common::{diff_fixture_pkgs, grid_from_numbers, sid, single_sheet_workbook};
use excel_diff::{DiffConfig, DiffOp, DiffReport, Workbook, WorkbookPackage};

fn diff_workbooks(old: &Workbook, new: &Workbook, config: &DiffConfig) -> DiffReport {
    WorkbookPackage::from(old.clone()).diff(&WorkbookPackage::from(new.clone()), config)
}

#[test]
fn g12_column_move_emits_single_blockmovedcolumns() {
    let report = diff_fixture_pkgs(
        "column_move_a.xlsx",
        "column_move_b.xlsx",
        &DiffConfig::default(),
    );

    assert_eq!(report.ops.len(), 1, "expected a single diff op");

    match &report.ops[0] {
        DiffOp::BlockMovedColumns {
            sheet,
            src_start_col,
            col_count,
            dst_start_col,
            block_hash,
        } => {
            assert_eq!(sheet, &sid("Data"));
            assert_eq!(*src_start_col, 2);
            assert_eq!(*col_count, 1);
            assert_eq!(*dst_start_col, 5);
            assert!(block_hash.is_none());
        }
        other => panic!("expected BlockMovedColumns op, got {:?}", other),
    }

    assert!(
        !report
            .ops
            .iter()
            .any(|op| matches!(op, DiffOp::ColumnAdded { .. })),
        "pure move should not emit ColumnAdded"
    );
    assert!(
        !report
            .ops
            .iter()
            .any(|op| matches!(op, DiffOp::ColumnRemoved { .. })),
        "pure move should not emit ColumnRemoved"
    );
    assert!(
        !report
            .ops
            .iter()
            .any(|op| matches!(op, DiffOp::RowAdded { .. } | DiffOp::RowRemoved { .. })),
        "pure move should not emit row operations"
    );
    assert!(
        !report
            .ops
            .iter()
            .any(|op| matches!(op, DiffOp::CellEdited { .. })),
        "pure move should not emit CellEdited noise"
    );
}

#[test]
fn g12_repeated_columns_do_not_emit_blockmovedcolumns() {
    let grid_a = grid_from_numbers(&[&[1, 1, 2, 2], &[10, 10, 20, 20]]);
    let grid_b = grid_from_numbers(&[&[2, 2, 1, 1], &[20, 20, 10, 10]]);

    let wb_a = single_sheet_workbook("Data", grid_a);
    let wb_b = single_sheet_workbook("Data", grid_b);

    let report = diff_workbooks(&wb_a, &wb_b, &DiffConfig::default());

    assert!(
        !report
            .ops
            .iter()
            .any(|op| matches!(op, DiffOp::BlockMovedColumns { .. })),
        "ambiguous repeated columns must not emit BlockMovedColumns"
    );

    assert!(
        report.ops.iter().any(|op| matches!(
            op,
            DiffOp::CellEdited { .. } | DiffOp::ColumnAdded { .. } | DiffOp::ColumnRemoved { .. }
        )),
        "fallback path should emit some other diff operation"
    );
}

#[test]
fn g12_multi_column_block_move_emits_blockmovedcolumns() {
    let grid_a = grid_from_numbers(&[
        &[10, 20, 30, 40, 50, 60],
        &[11, 21, 31, 41, 51, 61],
        &[12, 22, 32, 42, 52, 62],
    ]);

    let grid_b = grid_from_numbers(&[
        &[10, 40, 50, 20, 30, 60],
        &[11, 41, 51, 21, 31, 61],
        &[12, 42, 52, 22, 32, 62],
    ]);

    let wb_a = single_sheet_workbook("Data", grid_a);
    let wb_b = single_sheet_workbook("Data", grid_b);

    let report = diff_workbooks(&wb_a, &wb_b, &DiffConfig::default());

    assert_eq!(
        report.ops.len(),
        1,
        "expected a single diff op for multi-column move"
    );

    match &report.ops[0] {
        DiffOp::BlockMovedColumns {
            sheet,
            src_start_col,
            col_count,
            dst_start_col,
            block_hash,
        } => {
            assert_eq!(sheet, &sid("Data"));
            assert_eq!(*src_start_col, 3);
            assert_eq!(*col_count, 2, "should detect a 2-column block move");
            assert_eq!(*dst_start_col, 1);
            assert!(block_hash.is_none());
        }
        other => panic!("expected BlockMovedColumns op, got {:?}", other),
    }
}

#[test]
fn g12_two_independent_column_moves_do_not_emit_blockmovedcolumns() {
    let grid_a = grid_from_numbers(&[&[10, 20, 30, 40, 50, 60], &[11, 21, 31, 41, 51, 61]]);

    let grid_b = grid_from_numbers(&[&[20, 10, 30, 40, 60, 50], &[21, 11, 31, 41, 61, 51]]);

    let wb_a = single_sheet_workbook("Data", grid_a);
    let wb_b = single_sheet_workbook("Data", grid_b);

    let report = diff_workbooks(&wb_a, &wb_b, &DiffConfig::default());

    assert!(
        !report
            .ops
            .iter()
            .any(|op| matches!(op, DiffOp::BlockMovedColumns { .. })),
        "two independent column swaps must not emit BlockMovedColumns"
    );

    assert!(
        !report.ops.is_empty(),
        "fallback path should emit some diff operations"
    );
}

#[test]
fn g12_column_swap_emits_blockmovedcolumns() {
    let grid_a = grid_from_numbers(&[&[10, 20, 30, 40], &[11, 21, 31, 41]]);

    let grid_b = grid_from_numbers(&[&[20, 10, 30, 40], &[21, 11, 31, 41]]);

    let wb_a = single_sheet_workbook("Data", grid_a);
    let wb_b = single_sheet_workbook("Data", grid_b);

    let report = diff_workbooks(&wb_a, &wb_b, &DiffConfig::default());

    assert_eq!(
        report.ops.len(),
        1,
        "swap should produce single BlockMovedColumns op"
    );

    match &report.ops[0] {
        DiffOp::BlockMovedColumns {
            sheet,
            col_count,
            src_start_col,
            dst_start_col,
            ..
        } => {
            assert_eq!(sheet, &sid("Data"));
            assert_eq!(*col_count, 1, "swap is represented as moving one column");
            assert!(
                (*src_start_col == 0 && *dst_start_col == 1)
                    || (*src_start_col == 1 && *dst_start_col == 0),
                "swap should move column 0 or 1 past the other"
            );
        }
        other => panic!("expected BlockMovedColumns, got {:?}", other),
    }
}

```

---

### File: `core\tests\g12_rect_block_move_grid_workbook_tests.rs`

```rust
mod common;

use common::{diff_fixture_pkgs, grid_from_numbers, sid, single_sheet_workbook};
use excel_diff::{DiffConfig, DiffOp, DiffReport, Workbook, WorkbookPackage};

fn diff_workbooks(old: &Workbook, new: &Workbook, config: &DiffConfig) -> DiffReport {
    WorkbookPackage::from(old.clone()).diff(&WorkbookPackage::from(new.clone()), config)
}

#[test]
fn g12_rect_block_move_emits_single_blockmovedrect() {
    let report = diff_fixture_pkgs(
        "rect_block_move_a.xlsx",
        "rect_block_move_b.xlsx",
        &DiffConfig::default(),
    );

    assert_eq!(report.ops.len(), 1, "expected a single diff op");

    match &report.ops[0] {
        DiffOp::BlockMovedRect {
            sheet,
            src_start_row,
            src_row_count,
            src_start_col,
            src_col_count,
            dst_start_row,
            dst_start_col,
            block_hash: _,
        } => {
            assert_eq!(*sheet, sid("Data"));
            assert_eq!(*src_start_row, 2);
            assert_eq!(*src_row_count, 3);
            assert_eq!(*src_start_col, 1);
            assert_eq!(*src_col_count, 3);
            assert_eq!(*dst_start_row, 9);
            assert_eq!(*dst_start_col, 6);
        }
        other => panic!("expected BlockMovedRect op, got {:?}", other),
    }
}

#[test]
fn g12_rect_block_move_ambiguous_swap_does_not_emit_blockmovedrect() {
    let (grid_a, grid_b) = swap_two_blocks();
    let wb_a = single_sheet_workbook("Data", grid_a);
    let wb_b = single_sheet_workbook("Data", grid_b);

    let report = diff_workbooks(&wb_a, &wb_b, &DiffConfig::default());

    assert!(
        !report
            .ops
            .iter()
            .any(|op| matches!(op, DiffOp::BlockMovedRect { .. })),
        "ambiguous block swap must not emit BlockMovedRect"
    );
    assert!(
        !report.ops.is_empty(),
        "fallback path should emit some diff operations"
    );
}

#[test]
fn g12_rect_block_move_with_internal_edit_falls_back() {
    let (grid_a, grid_b) = move_with_edit();
    let wb_a = single_sheet_workbook("Data", grid_a);
    let wb_b = single_sheet_workbook("Data", grid_b);

    let report = diff_workbooks(&wb_a, &wb_b, &DiffConfig::default());

    assert!(
        !report
            .ops
            .iter()
            .any(|op| matches!(op, DiffOp::BlockMovedRect { .. })),
        "move with internal edit should not be treated as exact rectangular move"
    );
    assert!(
        report
            .ops
            .iter()
            .any(|op| matches!(op, DiffOp::CellEdited { .. })),
        "edited block should surface as cell edits or structural diffs"
    );
}

fn swap_two_blocks() -> (excel_diff::Grid, excel_diff::Grid) {
    let base: Vec<Vec<i32>> = (0..6)
        .map(|r| (0..6).map(|c| 100 * r + c).collect())
        .collect();
    let mut grid_a = base.clone();
    let mut grid_b = base.clone();

    let block_one = vec![vec![900, 901], vec![902, 903]];
    let block_two = vec![vec![700, 701], vec![702, 703]];

    place_block(&mut grid_a, 0, 0, &block_one);
    place_block(&mut grid_a, 3, 3, &block_two);

    // Swap the two distinct blocks in grid B.
    place_block(&mut grid_b, 0, 0, &block_two);
    place_block(&mut grid_b, 3, 3, &block_one);

    (grid_from_matrix(grid_a), grid_from_matrix(grid_b))
}

fn move_with_edit() -> (excel_diff::Grid, excel_diff::Grid) {
    let mut grid_a = base_background(10, 10);
    let mut grid_b = base_background(10, 10);

    let block = vec![vec![11, 12, 13], vec![21, 22, 23], vec![31, 32, 33]];

    place_block(&mut grid_a, 1, 1, &block);
    place_block(&mut grid_b, 6, 4, &block);
    grid_b[7][5] = 9_999; // edit inside the moved block

    (grid_from_matrix(grid_a), grid_from_matrix(grid_b))
}

fn base_background(rows: usize, cols: usize) -> Vec<Vec<i32>> {
    (0..rows)
        .map(|r| (0..cols).map(|c| (r as i32) * 1_000 + c as i32).collect())
        .collect()
}

fn place_block(target: &mut [Vec<i32>], top: usize, left: usize, block: &[Vec<i32>]) {
    for (r_offset, row_vals) in block.iter().enumerate() {
        for (c_offset, value) in row_vals.iter().enumerate() {
            let row = top + r_offset;
            let col = left + c_offset;
            if let Some(row_slice) = target.get_mut(row)
                && let Some(cell) = row_slice.get_mut(col)
            {
                *cell = *value;
            }
        }
    }
}

fn grid_from_matrix(matrix: Vec<Vec<i32>>) -> excel_diff::Grid {
    let refs: Vec<&[i32]> = matrix.iter().map(|row| row.as_slice()).collect();
    grid_from_numbers(&refs)
}

```

---

### File: `core\tests\g13_fuzzy_row_move_grid_workbook_tests.rs`

```rust
mod common;

use common::{diff_fixture_pkgs, grid_from_numbers, single_sheet_workbook};
use excel_diff::{DiffConfig, DiffOp, DiffReport, Workbook, WorkbookPackage};

fn diff_workbooks(old: &Workbook, new: &Workbook, config: &DiffConfig) -> DiffReport {
    WorkbookPackage::from(old.clone()).diff(&WorkbookPackage::from(new.clone()), config)
}

#[test]
fn g13_fuzzy_row_move_emits_blockmovedrows_and_celledited() {
    let report = diff_fixture_pkgs(
        "grid_move_and_edit_a.xlsx",
        "grid_move_and_edit_b.xlsx",
        &DiffConfig::default(),
    );

    let block_moves: Vec<(u32, u32, u32, Option<u64>)> = report
        .ops
        .iter()
        .filter_map(|op| match op {
            DiffOp::BlockMovedRows {
                src_start_row,
                row_count,
                dst_start_row,
                block_hash,
                ..
            } => Some((*src_start_row, *row_count, *dst_start_row, *block_hash)),
            _ => None,
        })
        .collect();

    assert_eq!(block_moves.len(), 1, "expected a single BlockMovedRows op");
    let (src_start_row, row_count, dst_start_row, block_hash) = block_moves[0];
    assert_eq!(src_start_row, 4);
    assert_eq!(row_count, 4);
    assert_eq!(dst_start_row, 13);
    assert!(block_hash.is_none());

    let edited_rows: Vec<u32> = report
        .ops
        .iter()
        .filter_map(|op| match op {
            DiffOp::CellEdited { addr, .. } => Some(addr.row),
            _ => None,
        })
        .collect();
    assert!(
        edited_rows
            .iter()
            .any(|r| *r >= dst_start_row && *r < dst_start_row + row_count),
        "expected a CellEdited inside the moved block"
    );

    assert!(
        !report
            .ops
            .iter()
            .any(|op| matches!(op, DiffOp::RowAdded { row_idx, .. } if *row_idx >= dst_start_row && *row_idx < dst_start_row + row_count)),
        "moved rows must not be reported as added"
    );
    assert!(
        !report
            .ops
            .iter()
            .any(|op| matches!(op, DiffOp::RowRemoved { row_idx, .. } if *row_idx >= src_start_row && *row_idx < src_start_row + row_count)),
        "moved rows must not be reported as removed"
    );
}

#[test]
fn g13_fuzzy_row_move_can_be_disabled() {
    let base: Vec<Vec<i32>> = (1..=18)
        .map(|r| (1..=3).map(|c| r * 10 + c).collect())
        .collect();
    let base_refs: Vec<&[i32]> = base.iter().map(|row| row.as_slice()).collect();
    let grid_a = grid_from_numbers(&base_refs);

    let mut rows_b = base.clone();
    let mut moved_block: Vec<Vec<i32>> = rows_b.drain(4..8).collect();
    moved_block[1][1] = 9_999;
    rows_b.splice(12..12, moved_block);
    let rows_b_refs: Vec<&[i32]> = rows_b.iter().map(|row| row.as_slice()).collect();
    let grid_b = grid_from_numbers(&rows_b_refs);

    let wb_a = single_sheet_workbook("Sheet1", grid_a);
    let wb_b = single_sheet_workbook("Sheet1", grid_b);

    let disabled = DiffConfig {
        enable_fuzzy_moves: false,
        ..DiffConfig::default()
    };
    let report_disabled = diff_workbooks(&wb_a, &wb_b, &disabled);
    let disabled_moves = report_disabled
        .ops
        .iter()
        .filter(|op| matches!(op, DiffOp::BlockMovedRows { .. }))
        .count();
    let disabled_block_edits = report_disabled
        .ops
        .iter()
        .filter(|op| {
            matches!(
                op,
                DiffOp::CellEdited { addr, .. }
                if addr.row >= 12 && addr.row < 16
            )
        })
        .count();

    let report_enabled = diff_workbooks(&wb_a, &wb_b, &DiffConfig::default());
    let enabled_moves = report_enabled
        .ops
        .iter()
        .filter(|op| matches!(op, DiffOp::BlockMovedRows { .. }))
        .count();
    let enabled_block_edits = report_enabled
        .ops
        .iter()
        .filter(|op| {
            matches!(
                op,
                DiffOp::CellEdited { addr, .. }
                if addr.row >= 12 && addr.row < 16
            )
        })
        .count();

    assert!(
        enabled_moves >= disabled_moves,
        "enabling fuzzy moves should not reduce move detection"
    );
    assert!(
        enabled_block_edits > disabled_block_edits,
        "fuzzy move detection should emit edits within the moved block"
    );
}

#[test]
fn g13_in_place_edits_do_not_emit_blockmovedrows() {
    let rows: Vec<Vec<i32>> = (1..=12)
        .map(|r| (1..=3).map(|c| r * 10 + c).collect())
        .collect();
    let rows_refs: Vec<&[i32]> = rows.iter().map(|r| r.as_slice()).collect();
    let grid_a = grid_from_numbers(&rows_refs);

    let mut edited_rows = rows.clone();
    if let Some(cell) = edited_rows.get_mut(5).and_then(|row| row.get_mut(1)) {
        *cell += 7;
    }
    let edited_refs: Vec<&[i32]> = edited_rows.iter().map(|r| r.as_slice()).collect();
    let grid_b = grid_from_numbers(&edited_refs);

    let wb_a = single_sheet_workbook("Sheet1", grid_a);
    let wb_b = single_sheet_workbook("Sheet1", grid_b);

    let report = diff_workbooks(&wb_a, &wb_b, &DiffConfig::default());

    assert!(
        !report
            .ops
            .iter()
            .any(|op| matches!(op, DiffOp::BlockMovedRows { .. })),
        "in-place edits must not be classified as BlockMovedRows"
    );
    assert!(
        report
            .ops
            .iter()
            .any(|op| matches!(op, DiffOp::CellEdited { .. })),
        "edits should still be surfaced as CellEdited"
    );
}

#[test]
fn g13_ambiguous_repeated_blocks_do_not_emit_blockmovedrows() {
    let mut rows_a: Vec<Vec<i32>> = vec![vec![1, 1]; 10];
    rows_a.push(vec![99, 99]);
    rows_a.push(vec![2, 2]);

    let mut rows_b = rows_a.clone();
    let moved = rows_b.remove(10);
    rows_b.insert(3, moved);

    let refs_a: Vec<&[i32]> = rows_a.iter().map(|r| r.as_slice()).collect();
    let refs_b: Vec<&[i32]> = rows_b.iter().map(|r| r.as_slice()).collect();
    let grid_a = grid_from_numbers(&refs_a);
    let grid_b = grid_from_numbers(&refs_b);

    let wb_a = single_sheet_workbook("Sheet1", grid_a);
    let wb_b = single_sheet_workbook("Sheet1", grid_b);

    let report = diff_workbooks(&wb_a, &wb_b, &DiffConfig::default());

    assert!(
        !report
            .ops
            .iter()
            .any(|op| matches!(op, DiffOp::BlockMovedRows { .. })),
        "ambiguous repeated patterns should not emit BlockMovedRows"
    );
    assert!(
        !report.ops.is_empty(),
        "fallback path should produce some diff noise"
    );
}

```

---

### File: `core\tests\g14_move_combination_tests.rs`

```rust
mod common;

use common::{grid_from_numbers, single_sheet_workbook};
use excel_diff::{DiffConfig, DiffOp, DiffReport, Workbook, WorkbookPackage};

fn diff_workbooks(old: &Workbook, new: &Workbook, config: &DiffConfig) -> DiffReport {
    WorkbookPackage::from(old.clone()).diff(&WorkbookPackage::from(new.clone()), config)
}

fn collect_rect_moves(report: &DiffReport) -> Vec<&DiffOp> {
    report
        .ops
        .iter()
        .filter(|op| matches!(op, DiffOp::BlockMovedRect { .. }))
        .collect()
}

fn collect_row_moves(report: &DiffReport) -> Vec<&DiffOp> {
    report
        .ops
        .iter()
        .filter(|op| matches!(op, DiffOp::BlockMovedRows { .. }))
        .collect()
}

fn collect_col_moves(report: &DiffReport) -> Vec<&DiffOp> {
    report
        .ops
        .iter()
        .filter(|op| matches!(op, DiffOp::BlockMovedColumns { .. }))
        .collect()
}

fn collect_row_adds(report: &DiffReport) -> Vec<&DiffOp> {
    report
        .ops
        .iter()
        .filter(|op| matches!(op, DiffOp::RowAdded { .. }))
        .collect()
}

fn collect_row_removes(report: &DiffReport) -> Vec<&DiffOp> {
    report
        .ops
        .iter()
        .filter(|op| matches!(op, DiffOp::RowRemoved { .. }))
        .collect()
}

fn collect_cell_edits(report: &DiffReport) -> Vec<&DiffOp> {
    report
        .ops
        .iter()
        .filter(|op| matches!(op, DiffOp::CellEdited { .. }))
        .collect()
}

fn base_grid(rows: usize, cols: usize) -> Vec<Vec<i32>> {
    (0..rows)
        .map(|r| {
            (0..cols)
                .map(|c| (r as i32 + 1) * 100 + c as i32 + 1)
                .collect()
        })
        .collect()
}

fn place_block(target: &mut [Vec<i32>], top: usize, left: usize, block: &[Vec<i32>]) {
    for (r_offset, row_vals) in block.iter().enumerate() {
        for (c_offset, value) in row_vals.iter().enumerate() {
            let row = top + r_offset;
            let col = left + c_offset;
            if let Some(row_slice) = target.get_mut(row)
                && let Some(cell) = row_slice.get_mut(col)
            {
                *cell = *value;
            }
        }
    }
}

fn grid_from_matrix(matrix: &[Vec<i32>]) -> excel_diff::Grid {
    let refs: Vec<&[i32]> = matrix.iter().map(|row| row.as_slice()).collect();
    grid_from_numbers(&refs)
}

#[test]
fn g14_rect_move_no_additional_changes_produces_single_op() {
    let mut grid_a = base_grid(12, 10);
    let mut grid_b = base_grid(12, 10);

    let block = vec![vec![9001, 9002], vec![9003, 9004]];
    place_block(&mut grid_a, 2, 2, &block);
    place_block(&mut grid_b, 8, 6, &block);

    let wb_a = single_sheet_workbook("Sheet1", grid_from_matrix(&grid_a));
    let wb_b = single_sheet_workbook("Sheet1", grid_from_matrix(&grid_b));

    let report = diff_workbooks(&wb_a, &wb_b, &DiffConfig::default());

    let has_rect_move = report
        .ops
        .iter()
        .any(|op| matches!(op, DiffOp::BlockMovedRect { .. }));

    assert!(has_rect_move, "pure rect move should be detected");

    assert_eq!(
        report.ops.len(),
        1,
        "pure rect move should produce exactly one BlockMovedRect op"
    );
}

#[test]
fn g14_rect_move_plus_cell_edit_no_silent_data_loss() {
    let mut grid_a = base_grid(12, 10);
    let mut grid_b = base_grid(12, 10);

    let block = vec![vec![9001, 9002], vec![9003, 9004]];
    place_block(&mut grid_a, 2, 2, &block);
    place_block(&mut grid_b, 8, 6, &block);
    grid_b[0][0] = 77777;

    let wb_a = single_sheet_workbook("Sheet1", grid_from_matrix(&grid_a));
    let wb_b = single_sheet_workbook("Sheet1", grid_from_matrix(&grid_b));

    let report = diff_workbooks(&wb_a, &wb_b, &DiffConfig::default());

    let rect_moves = collect_rect_moves(&report);
    let cell_edits = collect_cell_edits(&report);

    assert_eq!(
        rect_moves.len(),
        1,
        "expected single BlockMovedRect for the moved block"
    );

    if let DiffOp::BlockMovedRect {
        src_start_row,
        src_start_col,
        src_row_count,
        src_col_count,
        dst_start_row,
        dst_start_col,
        ..
    } = rect_moves[0]
    {
        assert_eq!(*src_start_row, 2);
        assert_eq!(*src_start_col, 2);
        assert_eq!(*src_row_count, 2);
        assert_eq!(*src_col_count, 2);
        assert_eq!(*dst_start_row, 8);
        assert_eq!(*dst_start_col, 6);
    } else {
        panic!("expected BlockMovedRect");
    }

    assert!(
        !cell_edits.is_empty(),
        "expected cell edits outside the moved block"
    );
}

#[test]
fn g14_pure_row_move_produces_single_op() {
    let rows: Vec<Vec<i32>> = (1..=20)
        .map(|r| (1..=4).map(|c| r * 10 + c).collect())
        .collect();
    let refs: Vec<&[i32]> = rows.iter().map(|r| r.as_slice()).collect();
    let grid_a = grid_from_numbers(&refs);

    let mut rows_b = rows.clone();
    let moved_block: Vec<Vec<i32>> = rows_b.drain(4..8).collect();
    rows_b.splice(12..12, moved_block);
    let refs_b: Vec<&[i32]> = rows_b.iter().map(|r| r.as_slice()).collect();
    let grid_b = grid_from_numbers(&refs_b);

    let wb_a = single_sheet_workbook("Sheet1", grid_a);
    let wb_b = single_sheet_workbook("Sheet1", grid_b);

    let report = diff_workbooks(&wb_a, &wb_b, &DiffConfig::default());

    let has_row_move = report
        .ops
        .iter()
        .any(|op| matches!(op, DiffOp::BlockMovedRows { .. }));

    assert!(has_row_move, "pure row block move should be detected");

    assert_eq!(
        report.ops.len(),
        1,
        "pure row block move should produce exactly one BlockMovedRows op"
    );
}

#[test]
fn g14_row_move_plus_cell_edit_no_silent_data_loss() {
    let rows: Vec<Vec<i32>> = (1..=20)
        .map(|r| (1..=4).map(|c| r * 10 + c).collect())
        .collect();
    let refs: Vec<&[i32]> = rows.iter().map(|r| r.as_slice()).collect();
    let grid_a = grid_from_numbers(&refs);

    let mut rows_b = rows.clone();
    let moved_block: Vec<Vec<i32>> = rows_b.drain(4..8).collect();
    rows_b.splice(12..12, moved_block);
    rows_b[0][0] = 99999;
    let refs_b: Vec<&[i32]> = rows_b.iter().map(|r| r.as_slice()).collect();
    let grid_b = grid_from_numbers(&refs_b);

    let wb_a = single_sheet_workbook("Sheet1", grid_a);
    let wb_b = single_sheet_workbook("Sheet1", grid_b);

    let report = diff_workbooks(&wb_a, &wb_b, &DiffConfig::default());

    assert!(
        !report.ops.is_empty(),
        "should not have silent data loss - changes must be reported"
    );
}

#[test]
fn g14_pure_column_move_produces_single_op() {
    let rows: Vec<Vec<i32>> = (0..5)
        .map(|r| (0..8).map(|c| (r + 1) * 10 + c + 1).collect())
        .collect();
    let refs: Vec<&[i32]> = rows.iter().map(|r| r.as_slice()).collect();
    let grid_a = grid_from_numbers(&refs);

    let mut rows_b: Vec<Vec<i32>> = rows.clone();
    for row in &mut rows_b {
        let moved_col = row.remove(1);
        row.insert(5, moved_col);
    }
    let refs_b: Vec<&[i32]> = rows_b.iter().map(|r| r.as_slice()).collect();
    let grid_b = grid_from_numbers(&refs_b);

    let wb_a = single_sheet_workbook("Sheet1", grid_a);
    let wb_b = single_sheet_workbook("Sheet1", grid_b);

    let report = diff_workbooks(&wb_a, &wb_b, &DiffConfig::default());

    let has_col_move = report
        .ops
        .iter()
        .any(|op| matches!(op, DiffOp::BlockMovedColumns { .. }));

    assert!(has_col_move, "pure column block move should be detected");

    assert_eq!(
        report.ops.len(),
        1,
        "pure column block move should produce exactly one BlockMovedColumns op"
    );
}

#[test]
fn g14_column_move_plus_cell_edit_no_silent_data_loss() {
    let rows: Vec<Vec<i32>> = (0..5)
        .map(|r| (0..8).map(|c| (r + 1) * 10 + c + 1).collect())
        .collect();
    let refs: Vec<&[i32]> = rows.iter().map(|r| r.as_slice()).collect();
    let grid_a = grid_from_numbers(&refs);

    let mut rows_b: Vec<Vec<i32>> = rows.clone();
    for row in &mut rows_b {
        let moved_col = row.remove(1);
        row.insert(5, moved_col);
    }
    rows_b[0][0] = 88888;
    let refs_b: Vec<&[i32]> = rows_b.iter().map(|r| r.as_slice()).collect();
    let grid_b = grid_from_numbers(&refs_b);

    let wb_a = single_sheet_workbook("Sheet1", grid_a);
    let wb_b = single_sheet_workbook("Sheet1", grid_b);

    let report = diff_workbooks(&wb_a, &wb_b, &DiffConfig::default());

    assert!(
        !report.ops.is_empty(),
        "should not have silent data loss - changes must be reported"
    );
}

#[test]
fn g14_two_disjoint_row_block_moves_detected() {
    let rows: Vec<Vec<i32>> = (1..=24)
        .map(|r| (1..=3).map(|c| r * 10 + c).collect())
        .collect();
    let refs: Vec<&[i32]> = rows.iter().map(|r| r.as_slice()).collect();
    let grid_a = grid_from_numbers(&refs);

    let mut rows_b: Vec<Vec<i32>> = Vec::new();

    rows_b.extend_from_slice(&rows[0..3]);
    rows_b.extend_from_slice(&rows[7..10]);
    rows_b.extend_from_slice(&rows[13..24]);
    rows_b.extend_from_slice(&rows[3..7]);
    rows_b.extend_from_slice(&rows[10..13]);

    let refs_b: Vec<&[i32]> = rows_b.iter().map(|r| r.as_slice()).collect();
    let grid_b = grid_from_numbers(&refs_b);

    let wb_a = single_sheet_workbook("Sheet1", grid_a);
    let wb_b = single_sheet_workbook("Sheet1", grid_b);

    let report = diff_workbooks(&wb_a, &wb_b, &DiffConfig::default());

    let row_moves = collect_row_moves(&report);
    assert_eq!(
        row_moves.len(),
        2,
        "expected exactly two BlockMovedRows ops for two disjoint moves"
    );

    let mut actual: Vec<(u32, u32, u32)> = row_moves
        .iter()
        .map(|op| {
            if let DiffOp::BlockMovedRows {
                src_start_row,
                row_count,
                dst_start_row,
                ..
            } = **op
            {
                (src_start_row, row_count, dst_start_row)
            } else {
                unreachable!()
            }
        })
        .collect();
    actual.sort();

    let mut expected = vec![(3u32, 4u32, 17u32), (10u32, 3u32, 21u32)];
    expected.sort();

    assert_eq!(
        actual, expected,
        "row move ops should match the two expected disjoint moves"
    );
}

#[test]
fn g14_row_move_plus_column_move_both_detected() {
    let rows: Vec<Vec<i32>> = (0..15)
        .map(|r| (0..10).map(|c| (r + 1) * 100 + c + 1).collect())
        .collect();
    let refs: Vec<&[i32]> = rows.iter().map(|r| r.as_slice()).collect();
    let grid_a = grid_from_numbers(&refs);

    let mut rows_b = rows.clone();

    let moved_rows: Vec<Vec<i32>> = rows_b.drain(2..5).collect();
    rows_b.splice(10..10, moved_rows);

    for row in &mut rows_b {
        let moved_col = row.remove(1);
        row.insert(7, moved_col);
    }

    let refs_b: Vec<&[i32]> = rows_b.iter().map(|r| r.as_slice()).collect();
    let grid_b = grid_from_numbers(&refs_b);

    let wb_a = single_sheet_workbook("Sheet1", grid_a);
    let wb_b = single_sheet_workbook("Sheet1", grid_b);

    let report = diff_workbooks(&wb_a, &wb_b, &DiffConfig::default());

    let row_moves = collect_row_moves(&report);
    let col_moves = collect_col_moves(&report);

    assert_eq!(
        row_moves.len(),
        1,
        "expected a single BlockMovedRows op for the moved row block"
    );
    assert_eq!(
        col_moves.len(),
        1,
        "expected a single BlockMovedColumns op for the moved column"
    );

    if let DiffOp::BlockMovedRows {
        src_start_row,
        row_count,
        dst_start_row,
        ..
    } = *row_moves[0]
    {
        assert_eq!(src_start_row, 2);
        assert_eq!(row_count, 3);
        assert_eq!(dst_start_row, 10);
    } else {
        panic!("expected BlockMovedRows op");
    }

    if let DiffOp::BlockMovedColumns {
        src_start_col,
        col_count,
        dst_start_col,
        ..
    } = *col_moves[0]
    {
        assert_eq!(src_start_col, 1);
        assert_eq!(col_count, 1);
        assert_eq!(dst_start_col, 7);
    } else {
        panic!("expected BlockMovedColumns op");
    }
}

#[test]
fn g14_fuzzy_row_move_produces_move_and_internal_edits() {
    let rows: Vec<Vec<i32>> = (1..=20)
        .map(|r| (1..=4).map(|c| r * 10 + c).collect())
        .collect();
    let refs: Vec<&[i32]> = rows.iter().map(|r| r.as_slice()).collect();
    let grid_a = grid_from_numbers(&refs);

    let mut rows_b = rows.clone();
    let mut moved_block: Vec<Vec<i32>> = rows_b.drain(4..8).collect();
    moved_block[1][1] = 5555;
    rows_b.splice(12..12, moved_block);
    let refs_b: Vec<&[i32]> = rows_b.iter().map(|r| r.as_slice()).collect();
    let grid_b = grid_from_numbers(&refs_b);

    let wb_a = single_sheet_workbook("Sheet1", grid_a);
    let wb_b = single_sheet_workbook("Sheet1", grid_b);

    let report = diff_workbooks(&wb_a, &wb_b, &DiffConfig::default());

    let has_row_move = report
        .ops
        .iter()
        .any(|op| matches!(op, DiffOp::BlockMovedRows { .. }));

    let has_internal_edit = report
        .ops
        .iter()
        .any(|op| matches!(op, DiffOp::CellEdited { .. }));

    assert!(has_row_move, "should detect the fuzzy row block move");
    assert!(
        has_internal_edit,
        "should report cell edits inside the moved block"
    );
}

#[test]
fn g14_fuzzy_row_move_plus_outside_edit_no_silent_data_loss() {
    let rows: Vec<Vec<i32>> = (1..=20)
        .map(|r| (1..=4).map(|c| r * 10 + c).collect())
        .collect();
    let refs: Vec<&[i32]> = rows.iter().map(|r| r.as_slice()).collect();
    let grid_a = grid_from_numbers(&refs);

    let mut rows_b = rows.clone();
    let mut moved_block: Vec<Vec<i32>> = rows_b.drain(4..8).collect();
    moved_block[1][1] = 5555;
    rows_b.splice(12..12, moved_block);
    rows_b[0][0] = 99999;
    let refs_b: Vec<&[i32]> = rows_b.iter().map(|r| r.as_slice()).collect();
    let grid_b = grid_from_numbers(&refs_b);

    let wb_a = single_sheet_workbook("Sheet1", grid_a);
    let wb_b = single_sheet_workbook("Sheet1", grid_b);

    let report = diff_workbooks(&wb_a, &wb_b, &DiffConfig::default());

    assert!(
        !report.ops.is_empty(),
        "should not have silent data loss - changes must be reported"
    );
}

#[test]
fn g14_grid_changes_no_silent_data_loss() {
    let mut grid_a = base_grid(15, 12);
    let mut grid_b = base_grid(15, 12);

    let block = vec![vec![7001, 7002], vec![7003, 7004], vec![7005, 7006]];
    place_block(&mut grid_a, 3, 3, &block);
    place_block(&mut grid_b, 10, 8, &block);
    grid_b[0][0] = 11111;
    grid_b[0][11] = 22222;
    grid_b[14][0] = 33333;
    grid_b[14][11] = 44444;

    let wb_a = single_sheet_workbook("Sheet1", grid_from_matrix(&grid_a));
    let wb_b = single_sheet_workbook("Sheet1", grid_from_matrix(&grid_b));

    let report = diff_workbooks(&wb_a, &wb_b, &DiffConfig::default());

    assert!(
        !report.ops.is_empty(),
        "should not have silent data loss - changes must be reported"
    );

    let cell_edits: Vec<(u32, u32)> = report
        .ops
        .iter()
        .filter_map(|op| {
            if let DiffOp::CellEdited { addr, .. } = op {
                Some((addr.row, addr.col))
            } else {
                None
            }
        })
        .collect();

    assert!(
        !cell_edits.is_empty() || !report.ops.is_empty(),
        "some form of changes should be reported"
    );
}

#[test]
fn g14_three_disjoint_rect_block_moves_detected() {
    let mut grid_a = base_grid(20, 10);
    let mut grid_b = base_grid(20, 10);

    let block1 = vec![vec![1001, 1002], vec![1003, 1004]];
    let block2 = vec![vec![2001, 2002], vec![2003, 2004]];
    let block3 = vec![vec![3001, 3002], vec![3003, 3004]];

    place_block(&mut grid_a, 2, 1, &block1);
    place_block(&mut grid_a, 6, 3, &block2);
    place_block(&mut grid_a, 12, 5, &block3);

    place_block(&mut grid_b, 10, 1, &block1);
    place_block(&mut grid_b, 4, 6, &block2);
    place_block(&mut grid_b, 16, 2, &block3);

    let wb_a = single_sheet_workbook("Sheet1", grid_from_matrix(&grid_a));
    let wb_b = single_sheet_workbook("Sheet1", grid_from_matrix(&grid_b));

    let report = diff_workbooks(&wb_a, &wb_b, &DiffConfig::default());

    let rect_moves: Vec<_> = report
        .ops
        .iter()
        .filter(|op| matches!(op, DiffOp::BlockMovedRect { .. }))
        .collect();

    assert_eq!(
        rect_moves.len(),
        3,
        "expected exactly three rect block moves to be detected"
    );
    assert_eq!(
        report.ops.len(),
        3,
        "multi-rect move scenario should not emit extra structural ops"
    );
}

#[test]
fn g14_two_disjoint_rect_moves_plus_outside_edits_no_silent_data_loss() {
    let mut grid_a = base_grid(20, 12);
    let mut grid_b = base_grid(20, 12);

    let block1 = vec![vec![8001, 8002], vec![8003, 8004]];
    let block2 = vec![vec![9001, 9002], vec![9003, 9004]];

    place_block(&mut grid_a, 2, 2, &block1);
    place_block(&mut grid_a, 10, 7, &block2);

    place_block(&mut grid_b, 8, 4, &block1);
    place_block(&mut grid_b, 14, 1, &block2);

    grid_b[0][0] = 77777;
    grid_b[19][11] = 88888;

    let wb_a = single_sheet_workbook("Sheet1", grid_from_matrix(&grid_a));
    let wb_b = single_sheet_workbook("Sheet1", grid_from_matrix(&grid_b));

    let report = diff_workbooks(&wb_a, &wb_b, &DiffConfig::default());

    let rect_moves: Vec<_> = report
        .ops
        .iter()
        .filter(|op| matches!(op, DiffOp::BlockMovedRect { .. }))
        .collect();
    assert!(
        rect_moves.len() >= 2,
        "should detect both rect block moves in the scenario"
    );

    let rect_regions = [
        (2u32, 2u32, 2u32, 2u32),
        (10u32, 7u32, 2u32, 2u32),
        (8u32, 4u32, 2u32, 2u32),
        (14u32, 1u32, 2u32, 2u32),
    ];

    let outside_cell_edits: Vec<_> = report
        .ops
        .iter()
        .filter_map(|op| {
            if let DiffOp::CellEdited { addr, .. } = op {
                let in_rect = rect_regions.iter().any(|(r, c, h, w)| {
                    addr.row >= *r && addr.row < *r + *h && addr.col >= *c && addr.col < *c + *w
                });
                if !in_rect {
                    return Some((addr.row, addr.col));
                }
            }
            None
        })
        .collect();

    assert!(
        !outside_cell_edits.is_empty(),
        "cell edits outside moved rects should be surfaced"
    );
}

#[allow(clippy::needless_range_loop)]
#[test]
fn g14_rect_move_plus_row_insertion_outside_no_silent_data_loss() {
    let mut grid_a = base_grid(12, 10);
    let block = vec![vec![9001, 9002], vec![9003, 9004]];
    place_block(&mut grid_a, 2, 2, &block);

    let mut grid_b = base_grid(13, 10);

    for col in 0..10 {
        grid_b[0][col] = 50000 + col as i32;
    }

    for row in 1..13 {
        for col in 0..10 {
            grid_b[row][col] = (row as i32) * 100 + col as i32 + 1;
        }
    }

    place_block(&mut grid_b, 9, 6, &block);

    let wb_a = single_sheet_workbook("Sheet1", grid_from_matrix(&grid_a));
    let wb_b = single_sheet_workbook("Sheet1", grid_from_matrix(&grid_b));

    let report = diff_workbooks(&wb_a, &wb_b, &DiffConfig::default());

    let rect_moves = collect_rect_moves(&report);
    let row_adds = collect_row_adds(&report);

    assert_eq!(
        rect_moves.len(),
        1,
        "expected a single BlockMovedRect for the moved block"
    );
    assert!(
        !row_adds.is_empty(),
        "expected at least one RowAdded for the inserted row"
    );
}

#[test]
fn g14_rect_move_plus_row_deletion_outside_no_silent_data_loss() {
    let mut grid_a = base_grid(14, 10);
    let block = vec![vec![8001, 8002], vec![8003, 8004]];
    place_block(&mut grid_a, 3, 3, &block);

    let mut grid_b = base_grid(13, 10);

    place_block(&mut grid_b, 8, 6, &block);

    let wb_a = single_sheet_workbook("Sheet1", grid_from_matrix(&grid_a));
    let wb_b = single_sheet_workbook("Sheet1", grid_from_matrix(&grid_b));

    let report = diff_workbooks(&wb_a, &wb_b, &DiffConfig::default());

    let rect_moves = collect_rect_moves(&report);
    let row_removes = collect_row_removes(&report);

    assert_eq!(
        rect_moves.len(),
        1,
        "expected a single BlockMovedRect for the moved block"
    );
    assert!(
        !row_removes.is_empty(),
        "expected at least one RowRemoved for the deleted row"
    );
}

#[test]
fn g14_row_block_move_plus_row_insertion_outside_no_silent_data_loss() {
    let rows: Vec<Vec<i32>> = (1..=20)
        .map(|r| (1..=4).map(|c| r * 10 + c).collect())
        .collect();
    let refs: Vec<&[i32]> = rows.iter().map(|r| r.as_slice()).collect();
    let grid_a = grid_from_numbers(&refs);

    let mut rows_b: Vec<Vec<i32>> = Vec::with_capacity(21);

    rows_b.push(vec![9991, 9992, 9993, 9994]);

    let mut original = rows.clone();
    let moved_block: Vec<Vec<i32>> = original.drain(4..8).collect();
    original.splice(12..12, moved_block);
    rows_b.extend(original);

    let refs_b: Vec<&[i32]> = rows_b.iter().map(|r| r.as_slice()).collect();
    let grid_b = grid_from_numbers(&refs_b);

    let wb_a = single_sheet_workbook("Sheet1", grid_a);
    let wb_b = single_sheet_workbook("Sheet1", grid_b);

    let report = diff_workbooks(&wb_a, &wb_b, &DiffConfig::default());

    assert!(
        !report.ops.is_empty(),
        "row block move + row insertion should produce operations"
    );
}

#[test]
fn g14_move_detection_disabled_falls_back_to_positional() {
    let grid_a = grid_from_numbers(&[
        &[1, 2, 3],
        &[10, 20, 30],
        &[100, 200, 300],
        &[1000, 2000, 3000],
        &[10000, 20000, 30000],
    ]);

    let grid_b = grid_from_numbers(&[
        &[1, 2, 3],
        &[1000, 2000, 3000],
        &[10000, 20000, 30000],
        &[10, 20, 30],
        &[100, 200, 300],
    ]);

    let wb_a = single_sheet_workbook("Sheet1", grid_a);
    let wb_b = single_sheet_workbook("Sheet1", grid_b);

    let config = DiffConfig {
        max_move_iterations: 0,
        ..DiffConfig::default()
    };
    let report = diff_workbooks(&wb_a, &wb_b, &config);

    assert!(
        report
            .ops
            .iter()
            .any(|op| matches!(op, DiffOp::RowRemoved { .. })),
        "expected positional fallback when move detection disabled"
    );
    assert!(
        report
            .ops
            .iter()
            .any(|op| matches!(op, DiffOp::RowAdded { .. })),
        "expected positional fallback when move detection disabled"
    );
    assert!(
        !report
            .ops
            .iter()
            .any(|op| matches!(op, DiffOp::BlockMovedRows { .. })),
        "no block move should be present when move detection disabled"
    );
}

#[test]
fn g14_masked_move_detection_not_gated_by_recursive_align_threshold() {
    let grid_a = grid_from_numbers(&[
        &[1, 2, 3],
        &[10, 20, 30],
        &[100, 200, 300],
        &[1000, 2000, 3000],
        &[10000, 20000, 30000],
    ]);

    let grid_b = grid_from_numbers(&[
        &[1, 2, 3],
        &[1000, 2000, 3000],
        &[10000, 20000, 30000],
        &[10, 20, 30],
        &[100, 200, 300],
    ]);

    let wb_a = single_sheet_workbook("Sheet1", grid_a);
    let wb_b = single_sheet_workbook("Sheet1", grid_b);

    let config = DiffConfig {
        recursive_align_threshold: 1,
        max_move_detection_rows: 10,
        ..DiffConfig::default()
    };

    let report = diff_workbooks(&wb_a, &wb_b, &config);

    assert!(
        report
            .ops
            .iter()
            .any(|op| matches!(op, DiffOp::BlockMovedRows { .. })),
        "masked move detection should be enabled by max_move_detection_rows, independent of recursion threshold"
    );
}

#[test]
fn g14_max_move_iterations_limits_detected_moves() {
    let mut grid_a = base_grid(50, 10);
    let mut grid_b = base_grid(50, 10);

    let block1 = vec![vec![1001, 1002], vec![1003, 1004]];
    let block2 = vec![vec![2001, 2002], vec![2003, 2004]];
    let block3 = vec![vec![3001, 3002], vec![3003, 3004]];
    let block4 = vec![vec![4001, 4002], vec![4003, 4004]];
    let block5 = vec![vec![5001, 5002], vec![5003, 5004]];

    place_block(&mut grid_a, 2, 1, &block1);
    place_block(&mut grid_a, 8, 1, &block2);
    place_block(&mut grid_a, 14, 1, &block3);
    place_block(&mut grid_a, 20, 1, &block4);
    place_block(&mut grid_a, 26, 1, &block5);

    place_block(&mut grid_b, 40, 7, &block1);
    place_block(&mut grid_b, 34, 7, &block2);
    place_block(&mut grid_b, 28, 7, &block3);
    place_block(&mut grid_b, 22, 7, &block4);
    place_block(&mut grid_b, 16, 7, &block5);

    let wb_a = single_sheet_workbook("Sheet1", grid_from_matrix(&grid_a));
    let wb_b = single_sheet_workbook("Sheet1", grid_from_matrix(&grid_b));

    let limited_config = DiffConfig {
        max_move_iterations: 2,
        ..DiffConfig::default()
    };
    let report_limited = diff_workbooks(&wb_a, &wb_b, &limited_config);

    let rect_moves_limited = collect_rect_moves(&report_limited);

    assert!(
        rect_moves_limited.len() <= 2,
        "with max_move_iterations=2, at most 2 rect moves should be detected, got {}",
        rect_moves_limited.len()
    );

    assert!(
        !report_limited.ops.is_empty(),
        "remaining differences should still be surfaced, not silently dropped"
    );

    let full_config = DiffConfig::default();
    let report_full = diff_workbooks(&wb_a, &wb_b, &full_config);

    let rect_moves_full = collect_rect_moves(&report_full);

    assert!(
        rect_moves_full.len() >= 5,
        "with default config, all 5 rect moves should be detected, got {}",
        rect_moves_full.len()
    );
}

```

---

### File: `core\tests\g15_column_structure_row_alignment_tests.rs`

```rust
//! Integration tests verifying column structural changes do not break row alignment when row content is preserved.
//! Covers Branch 1.3 acceptance criteria for column insertion/deletion resilience.

mod common;

use common::single_sheet_workbook;
use excel_diff::{CellValue, DiffConfig, DiffOp, DiffReport, Grid, Workbook, WorkbookPackage};

fn diff_workbooks(old: &Workbook, new: &Workbook, config: &DiffConfig) -> DiffReport {
    WorkbookPackage::from(old.clone()).diff(&WorkbookPackage::from(new.clone()), config)
}

fn make_grid_with_cells(nrows: u32, ncols: u32, cells: &[(u32, u32, i32)]) -> Grid {
    let mut grid = Grid::new(nrows, ncols);
    for (row, col, val) in cells {
        grid.insert_cell(*row, *col, Some(CellValue::Number(*val as f64)), None);
    }
    grid
}

fn grid_from_row_data(rows: &[Vec<i32>]) -> Grid {
    let nrows = rows.len() as u32;
    let ncols = rows.iter().map(|r| r.len()).max().unwrap_or(0) as u32;
    let mut grid = Grid::new(nrows, ncols);

    for (r, row_vals) in rows.iter().enumerate() {
        for (c, val) in row_vals.iter().enumerate() {
            grid.insert_cell(
                r as u32,
                c as u32,
                Some(CellValue::Number(*val as f64)),
                None,
            );
        }
    }
    grid
}

#[test]
fn g15_blank_column_insert_at_position_zero_preserves_row_alignment() {
    let grid_a = grid_from_row_data(&[
        vec![10, 20, 30],
        vec![11, 21, 31],
        vec![12, 22, 32],
        vec![13, 23, 33],
        vec![14, 24, 34],
    ]);

    let grid_b = make_grid_with_cells(
        5,
        4,
        &[
            (0, 1, 10),
            (0, 2, 20),
            (0, 3, 30),
            (1, 1, 11),
            (1, 2, 21),
            (1, 3, 31),
            (2, 1, 12),
            (2, 2, 22),
            (2, 3, 32),
            (3, 1, 13),
            (3, 2, 23),
            (3, 3, 33),
            (4, 1, 14),
            (4, 2, 24),
            (4, 3, 34),
        ],
    );

    let wb_a = single_sheet_workbook("Sheet1", grid_a);
    let wb_b = single_sheet_workbook("Sheet1", grid_b);

    let report = diff_workbooks(&wb_a, &wb_b, &DiffConfig::default());

    let column_adds: Vec<u32> = report
        .ops
        .iter()
        .filter_map(|op| match op {
            DiffOp::ColumnAdded { col_idx, .. } => Some(*col_idx),
            _ => None,
        })
        .collect();

    let row_changes: Vec<&DiffOp> = report
        .ops
        .iter()
        .filter(|op| {
            matches!(
                op,
                DiffOp::RowAdded { .. } | DiffOp::RowRemoved { .. } | DiffOp::BlockMovedRows { .. }
            )
        })
        .collect();

    assert!(
        column_adds.contains(&0) || !report.ops.is_empty(),
        "blank column insert at position 0 should be detected as ColumnAdded or produce some diff"
    );

    assert!(
        row_changes.is_empty(),
        "blank column insert should NOT produce spurious row add/remove operations; got {:?}",
        row_changes
    );
}

#[test]
fn g15_blank_column_insert_middle_preserves_row_alignment() {
    let grid_a = grid_from_row_data(&[
        vec![1, 2, 3, 4],
        vec![5, 6, 7, 8],
        vec![9, 10, 11, 12],
        vec![13, 14, 15, 16],
    ]);

    let grid_b = make_grid_with_cells(
        4,
        5,
        &[
            (0, 0, 1),
            (0, 1, 2),
            (0, 3, 3),
            (0, 4, 4),
            (1, 0, 5),
            (1, 1, 6),
            (1, 3, 7),
            (1, 4, 8),
            (2, 0, 9),
            (2, 1, 10),
            (2, 3, 11),
            (2, 4, 12),
            (3, 0, 13),
            (3, 1, 14),
            (3, 3, 15),
            (3, 4, 16),
        ],
    );

    let wb_a = single_sheet_workbook("Sheet1", grid_a);
    let wb_b = single_sheet_workbook("Sheet1", grid_b);

    let report = diff_workbooks(&wb_a, &wb_b, &DiffConfig::default());

    let row_structural_ops: Vec<&DiffOp> = report
        .ops
        .iter()
        .filter(|op| {
            matches!(
                op,
                DiffOp::RowAdded { .. } | DiffOp::RowRemoved { .. } | DiffOp::BlockMovedRows { .. }
            )
        })
        .collect();

    assert!(
        row_structural_ops.is_empty(),
        "blank column insert in middle should not cause row structural changes; got {:?}",
        row_structural_ops
    );

    let has_column_op = report.ops.iter().any(|op| {
        matches!(
            op,
            DiffOp::ColumnAdded { .. } | DiffOp::ColumnRemoved { .. }
        )
    });

    assert!(
        has_column_op || !report.ops.is_empty(),
        "column structure change should be detected"
    );
}

#[test]
fn g15_column_delete_preserves_row_alignment_when_content_order_maintained() {
    let grid_a = grid_from_row_data(&[
        vec![1, 2, 3, 4, 5],
        vec![6, 7, 8, 9, 10],
        vec![11, 12, 13, 14, 15],
        vec![16, 17, 18, 19, 20],
    ]);

    let grid_b = grid_from_row_data(&[
        vec![1, 2, 4, 5],
        vec![6, 7, 9, 10],
        vec![11, 12, 14, 15],
        vec![16, 17, 19, 20],
    ]);

    let wb_a = single_sheet_workbook("Sheet1", grid_a);
    let wb_b = single_sheet_workbook("Sheet1", grid_b);

    let report = diff_workbooks(&wb_a, &wb_b, &DiffConfig::default());

    let column_removes: Vec<u32> = report
        .ops
        .iter()
        .filter_map(|op| match op {
            DiffOp::ColumnRemoved { col_idx, .. } => Some(*col_idx),
            _ => None,
        })
        .collect();

    let row_structural_ops: Vec<&DiffOp> = report
        .ops
        .iter()
        .filter(|op| {
            matches!(
                op,
                DiffOp::RowAdded { .. } | DiffOp::RowRemoved { .. } | DiffOp::BlockMovedRows { .. }
            )
        })
        .collect();

    assert!(
        row_structural_ops.is_empty(),
        "column deletion should not cause spurious row changes; got {:?}",
        row_structural_ops
    );

    assert!(
        !column_removes.is_empty() || !report.ops.is_empty(),
        "column deletion should be detected"
    );
}

#[test]
fn g15_row_insert_with_column_structure_change_both_detected() {
    let grid_a = grid_from_row_data(&[vec![1, 2, 3], vec![4, 5, 6], vec![7, 8, 9]]);

    let grid_b = make_grid_with_cells(
        4,
        4,
        &[
            (0, 0, 1000),
            (0, 1, 1),
            (0, 2, 2),
            (0, 3, 3),
            (1, 0, 1001),
            (1, 1, 100),
            (1, 2, 200),
            (1, 3, 300),
            (2, 0, 1002),
            (2, 1, 4),
            (2, 2, 5),
            (2, 3, 6),
            (3, 0, 1003),
            (3, 1, 7),
            (3, 2, 8),
            (3, 3, 9),
        ],
    );

    let wb_a = single_sheet_workbook("Sheet1", grid_a);
    let wb_b = single_sheet_workbook("Sheet1", grid_b);

    let report = diff_workbooks(&wb_a, &wb_b, &DiffConfig::default());

    assert!(
        !report.ops.is_empty(),
        "row insert + column change should produce diff operations"
    );

    let has_row_op = report.ops.iter().any(|op| {
        matches!(
            op,
            DiffOp::RowAdded { .. } | DiffOp::RowRemoved { .. } | DiffOp::CellEdited { .. }
        )
    });

    let has_col_op = report.ops.iter().any(|op| {
        matches!(
            op,
            DiffOp::ColumnAdded { .. } | DiffOp::ColumnRemoved { .. } | DiffOp::CellEdited { .. }
        )
    });

    assert!(
        has_row_op || has_col_op,
        "at least one structural change type should be detected"
    );
}

#[test]
fn g15_single_row_grid_column_insert_no_spurious_row_ops() {
    let grid_a = grid_from_row_data(&[vec![10, 20]]);

    let grid_b = make_grid_with_cells(1, 3, &[(0, 0, 10), (0, 2, 20)]);

    let wb_a = single_sheet_workbook("Sheet1", grid_a);
    let wb_b = single_sheet_workbook("Sheet1", grid_b);

    let report = diff_workbooks(&wb_a, &wb_b, &DiffConfig::default());

    let row_ops: Vec<&DiffOp> = report
        .ops
        .iter()
        .filter(|op| matches!(op, DiffOp::RowAdded { .. } | DiffOp::RowRemoved { .. }))
        .collect();

    assert!(
        row_ops.is_empty(),
        "single row grid with column insert should not have row ops; got {:?}",
        row_ops
    );
}

#[test]
fn g15_all_blank_column_insert_no_content_change_minimal_diff() {
    let grid_a = grid_from_row_data(&[vec![1, 2], vec![3, 4], vec![5, 6]]);

    let grid_b = make_grid_with_cells(
        3,
        3,
        &[
            (0, 0, 1),
            (0, 1, 2),
            (1, 0, 3),
            (1, 1, 4),
            (2, 0, 5),
            (2, 1, 6),
        ],
    );

    let wb_a = single_sheet_workbook("Sheet1", grid_a);
    let wb_b = single_sheet_workbook("Sheet1", grid_b);

    let report = diff_workbooks(&wb_a, &wb_b, &DiffConfig::default());

    let row_ops: Vec<&DiffOp> = report
        .ops
        .iter()
        .filter(|op| matches!(op, DiffOp::RowAdded { .. } | DiffOp::RowRemoved { .. }))
        .collect();

    assert!(
        row_ops.is_empty(),
        "appending blank column should not cause row operations; got {:?}",
        row_ops
    );
}

#[test]
fn g15_large_grid_column_insert_row_alignment_preserved() {
    let rows: Vec<Vec<i32>> = (0..50)
        .map(|r| (0..10).map(|c| r * 100 + c).collect())
        .collect();
    let grid_a = grid_from_row_data(&rows);

    let mut cells_b: Vec<(u32, u32, i32)> = Vec::with_capacity(50 * 10);
    for r in 0..50 {
        for c in 0..10 {
            let new_col = if c < 5 { c } else { c + 1 };
            cells_b.push((r, new_col, r as i32 * 100 + c as i32));
        }
    }
    let grid_b = make_grid_with_cells(50, 11, &cells_b);

    let wb_a = single_sheet_workbook("Sheet1", grid_a);
    let wb_b = single_sheet_workbook("Sheet1", grid_b);

    let report = diff_workbooks(&wb_a, &wb_b, &DiffConfig::default());

    let row_structural_ops: Vec<&DiffOp> = report
        .ops
        .iter()
        .filter(|op| {
            matches!(
                op,
                DiffOp::RowAdded { .. } | DiffOp::RowRemoved { .. } | DiffOp::BlockMovedRows { .. }
            )
        })
        .collect();

    assert!(
        row_structural_ops.is_empty(),
        "large grid column insert should not cause row changes; got {} row ops",
        row_structural_ops.len()
    );

    let column_adds = report
        .ops
        .iter()
        .filter(|op| matches!(op, DiffOp::ColumnAdded { .. }))
        .count();

    assert!(
        column_adds > 0 || !report.ops.is_empty(),
        "column insertion should be detected in large grid"
    );
}

```

---

### File: `core\tests\g1_g2_grid_workbook_tests.rs`

```rust
mod common;

use common::{diff_fixture_pkgs, sid};
use excel_diff::{
    CellValue, DiffConfig, DiffOp, DiffReport, Grid, Sheet, SheetKind, Workbook, WorkbookPackage,
};

fn workbook_with_number(value: f64) -> Workbook {
    let mut grid = Grid::new(1, 1);
    grid.insert_cell(0, 0, Some(CellValue::Number(value)), None);

    Workbook {
        sheets: vec![Sheet {
            name: sid("Sheet1"),
            kind: SheetKind::Worksheet,
            grid,
        }],
        ..Default::default()
    }
}

fn diff_workbooks(old: &Workbook, new: &Workbook, config: &DiffConfig) -> DiffReport {
    WorkbookPackage::from(old.clone()).diff(&WorkbookPackage::from(new.clone()), config)
}

#[test]
fn g1_equal_sheet_produces_empty_diff() {
    let report = diff_fixture_pkgs(
        "equal_sheet_a.xlsx",
        "equal_sheet_b.xlsx",
        &DiffConfig::default(),
    );

    assert!(
        report.ops.is_empty(),
        "identical 5x5 sheet should produce an empty diff"
    );
}

#[test]
fn g2_single_cell_literal_change_produces_one_celledited() {
    let report = diff_fixture_pkgs(
        "single_cell_value_a.xlsx",
        "single_cell_value_b.xlsx",
        &DiffConfig::default(),
    );

    assert_eq!(
        report.ops.len(),
        1,
        "expected exactly one diff op for a single edited cell"
    );

    match &report.ops[0] {
        DiffOp::CellEdited {
            sheet,
            addr,
            from,
            to,
            ..
        } => {
            assert_eq!(*sheet, sid("Sheet1"));
            assert_eq!(addr.to_a1(), "C3");
            assert_eq!(from.value, Some(CellValue::Number(1.0)));
            assert_eq!(to.value, Some(CellValue::Number(2.0)));
            assert_eq!(from.formula, to.formula, "no formula changes expected");
        }
        other => panic!("expected CellEdited, got {other:?}"),
    }

    assert!(
        !report.ops.iter().any(|op| matches!(
            op,
            DiffOp::RowAdded { .. }
                | DiffOp::RowRemoved { .. }
                | DiffOp::ColumnAdded { .. }
                | DiffOp::ColumnRemoved { .. }
        )),
        "single cell change should not produce row/column structure ops"
    );
}

#[test]
fn g2_float_ulp_noise_is_ignored_in_diff() {
    let old = workbook_with_number(1.0);
    let new = workbook_with_number(1.0000000000000002);

    let report = diff_workbooks(&old, &new, &DiffConfig::default());

    assert!(
        report.ops.is_empty(),
        "ULP-level float drift should not produce a diff op"
    );
}

#[test]
fn g2_meaningful_float_change_emits_cell_edit() {
    let old = workbook_with_number(1.0);
    let new = workbook_with_number(1.0001);

    let report = diff_workbooks(&old, &new, &DiffConfig::default());

    assert_eq!(
        report.ops.len(),
        1,
        "meaningful float change should produce exactly one diff op"
    );

    match &report.ops[0] {
        DiffOp::CellEdited { addr, from, to, .. } => {
            assert_eq!(addr.to_a1(), "A1");
            assert_eq!(from.value, Some(CellValue::Number(1.0)));
            assert_eq!(to.value, Some(CellValue::Number(1.0001)));
        }
        other => panic!("expected CellEdited diff op, got {other:?}"),
    }
}

#[test]
fn g2_nan_values_are_treated_as_equal() {
    let signaling_nan = f64::from_bits(0x7ff8_0000_0000_0000);
    let quiet_nan = f64::NAN;

    let old = workbook_with_number(signaling_nan);
    let new = workbook_with_number(quiet_nan);

    let report = diff_workbooks(&old, &new, &DiffConfig::default());

    assert!(
        report.ops.is_empty(),
        "different NaN bit patterns should be considered equal in diffing"
    );
}

```

---

### File: `core\tests\g5_g7_grid_workbook_tests.rs`

```rust
mod common;

use common::diff_fixture_pkgs;
use excel_diff::{CellValue, DiffConfig, DiffOp, with_default_session};
use std::collections::BTreeSet;

#[test]
fn g5_multi_cell_edits_produces_only_celledited_ops() {
    let report = diff_fixture_pkgs(
        "multi_cell_edits_a.xlsx",
        "multi_cell_edits_b.xlsx",
        &DiffConfig::default(),
    );

    let (text_x, text_y) = with_default_session(|session| {
        let x = session.strings.intern("x");
        let y = session.strings.intern("y");
        (CellValue::Text(x), CellValue::Text(y))
    });
    let expected = vec![
        ("B2", CellValue::Number(1.0), CellValue::Number(42.0)),
        ("D5", CellValue::Number(2.0), CellValue::Number(99.0)),
        ("H7", CellValue::Number(3.0), CellValue::Number(3.5)),
        ("J10", text_x, text_y),
    ];

    assert_eq!(
        report.ops.len(),
        expected.len(),
        "expected one DiffOp per configured edit"
    );
    assert!(
        report
            .ops
            .iter()
            .all(|op| matches!(op, DiffOp::CellEdited { .. })),
        "multi-cell edits should produce only CellEdited ops"
    );

    for (addr, expected_from, expected_to) in expected {
        let (sheet, from, to) = report
            .ops
            .iter()
            .find_map(|op| match op {
                DiffOp::CellEdited {
                    sheet,
                    addr: a,
                    from,
                    to,
                    ..
                } if a.to_a1() == addr => Some((sheet, from, to)),
                _ => None,
            })
            .unwrap_or_else(|| panic!("missing CellEdited for {addr}"));

        let sheet_name = report.strings[sheet.0 as usize].as_str();
        assert_eq!(sheet_name, "Sheet1");
        assert_eq!(from.value, Some(expected_from));
        assert_eq!(to.value, Some(expected_to));
        assert_eq!(from.formula, to.formula, "no formula changes expected");
    }

    assert!(
        !report.ops.iter().any(|op| matches!(
            op,
            DiffOp::RowAdded { .. }
                | DiffOp::RowRemoved { .. }
                | DiffOp::ColumnAdded { .. }
                | DiffOp::ColumnRemoved { .. }
        )),
        "multi-cell edits should not produce row/column structure ops"
    );
}

#[test]
fn g6_row_append_bottom_emits_two_rowadded_and_no_celledited() {
    let report = diff_fixture_pkgs(
        "row_append_bottom_a.xlsx",
        "row_append_bottom_b.xlsx",
        &DiffConfig::default(),
    );

    assert_eq!(
        report.ops.len(),
        2,
        "expected exactly two RowAdded ops for appended rows"
    );

    let rows_added: BTreeSet<u32> = report
        .ops
        .iter()
        .filter_map(|op| match op {
            DiffOp::RowAdded {
                sheet,
                row_idx,
                row_signature,
            } => {
                let sheet_name = report.strings[sheet.0 as usize].as_str();
                assert_eq!(sheet_name, "Sheet1");
                assert!(row_signature.is_none());
                Some(*row_idx)
            }
            _ => None,
        })
        .collect();

    let expected: BTreeSet<u32> = [10u32, 11u32].into_iter().collect();
    assert_eq!(rows_added, expected);

    assert!(
        !report.ops.iter().any(|op| matches!(
            op,
            DiffOp::RowRemoved { .. }
                | DiffOp::ColumnAdded { .. }
                | DiffOp::ColumnRemoved { .. }
                | DiffOp::CellEdited { .. }
        )),
        "row append should not emit removals, column ops, or cell edits"
    );
}

#[test]
fn g6_row_delete_bottom_emits_two_rowremoved_and_no_celledited() {
    let report = diff_fixture_pkgs(
        "row_delete_bottom_a.xlsx",
        "row_delete_bottom_b.xlsx",
        &DiffConfig::default(),
    );

    assert_eq!(
        report.ops.len(),
        2,
        "expected exactly two RowRemoved ops for deleted rows"
    );

    let rows_removed: BTreeSet<u32> = report
        .ops
        .iter()
        .filter_map(|op| match op {
            DiffOp::RowRemoved {
                sheet,
                row_idx,
                row_signature,
            } => {
                let sheet_name = report.strings[sheet.0 as usize].as_str();
                assert_eq!(sheet_name, "Sheet1");
                assert!(row_signature.is_none());
                Some(*row_idx)
            }
            _ => None,
        })
        .collect();

    let expected: BTreeSet<u32> = [10u32, 11u32].into_iter().collect();
    assert_eq!(rows_removed, expected);

    assert!(
        !report.ops.iter().any(|op| matches!(
            op,
            DiffOp::RowAdded { .. }
                | DiffOp::ColumnAdded { .. }
                | DiffOp::ColumnRemoved { .. }
                | DiffOp::CellEdited { .. }
        )),
        "row delete should not emit additions, column ops, or cell edits"
    );
}

#[test]
fn g7_col_append_right_emits_two_columnadded_and_no_celledited() {
    let report = diff_fixture_pkgs(
        "col_append_right_a.xlsx",
        "col_append_right_b.xlsx",
        &DiffConfig::default(),
    );

    assert_eq!(
        report.ops.len(),
        2,
        "expected exactly two ColumnAdded ops for appended columns"
    );

    let cols_added: BTreeSet<u32> = report
        .ops
        .iter()
        .filter_map(|op| match op {
            DiffOp::ColumnAdded {
                sheet,
                col_idx,
                col_signature,
            } => {
                let sheet_name = report.strings[sheet.0 as usize].as_str();
                assert_eq!(sheet_name, "Sheet1");
                assert!(col_signature.is_none());
                Some(*col_idx)
            }
            _ => None,
        })
        .collect();

    let expected: BTreeSet<u32> = [4u32, 5u32].into_iter().collect();
    assert_eq!(cols_added, expected);

    assert!(
        !report.ops.iter().any(|op| matches!(
            op,
            DiffOp::ColumnRemoved { .. }
                | DiffOp::RowAdded { .. }
                | DiffOp::RowRemoved { .. }
                | DiffOp::CellEdited { .. }
        )),
        "column append should not emit removals, row ops, or cell edits"
    );
}

#[test]
fn g7_col_delete_right_emits_two_columnremoved_and_no_celledited() {
    let report = diff_fixture_pkgs(
        "col_delete_right_a.xlsx",
        "col_delete_right_b.xlsx",
        &DiffConfig::default(),
    );

    assert_eq!(
        report.ops.len(),
        2,
        "expected exactly two ColumnRemoved ops for deleted columns"
    );

    let cols_removed: BTreeSet<u32> = report
        .ops
        .iter()
        .filter_map(|op| match op {
            DiffOp::ColumnRemoved {
                sheet,
                col_idx,
                col_signature,
            } => {
                let sheet_name = report.strings[sheet.0 as usize].as_str();
                assert_eq!(sheet_name, "Sheet1");
                assert!(col_signature.is_none());
                Some(*col_idx)
            }
            _ => None,
        })
        .collect();

    let expected: BTreeSet<u32> = [4u32, 5u32].into_iter().collect();
    assert_eq!(cols_removed, expected);

    assert!(
        !report.ops.iter().any(|op| matches!(
            op,
            DiffOp::ColumnAdded { .. }
                | DiffOp::RowAdded { .. }
                | DiffOp::RowRemoved { .. }
                | DiffOp::CellEdited { .. }
        )),
        "column delete should not emit additions, row ops, or cell edits"
    );
}

```

---

### File: `core\tests\g8_row_alignment_grid_workbook_tests.rs`

```rust
mod common;

use common::diff_fixture_pkgs;
use excel_diff::{DiffConfig, DiffOp};

#[test]
fn single_row_insert_middle_produces_one_row_added() {
    let report = diff_fixture_pkgs(
        "row_insert_middle_a.xlsx",
        "row_insert_middle_b.xlsx",
        &DiffConfig::default(),
    );

    let strings = &report.strings;

    let rows_added: Vec<u32> = report
        .ops
        .iter()
        .filter_map(|op| match op {
            DiffOp::RowAdded {
                sheet,
                row_idx,
                row_signature,
            } => {
                assert_eq!(
                    strings.get(sheet.0 as usize).map(String::as_str),
                    Some("Sheet1")
                );
                assert!(row_signature.is_none());
                Some(*row_idx)
            }
            _ => None,
        })
        .collect();

    assert_eq!(rows_added, vec![5], "expected single RowAdded at index 5");

    assert!(
        !report
            .ops
            .iter()
            .any(|op| matches!(op, DiffOp::RowRemoved { .. })),
        "no rows should be removed for middle insert"
    );

    assert!(
        !report
            .ops
            .iter()
            .any(|op| matches!(op, DiffOp::CellEdited { .. })),
        "aligned insert should not emit CellEdited noise"
    );
}

#[test]
fn single_row_delete_middle_produces_one_row_removed() {
    let report = diff_fixture_pkgs(
        "row_delete_middle_a.xlsx",
        "row_delete_middle_b.xlsx",
        &DiffConfig::default(),
    );

    let strings = &report.strings;

    let rows_removed: Vec<u32> = report
        .ops
        .iter()
        .filter_map(|op| match op {
            DiffOp::RowRemoved {
                sheet,
                row_idx,
                row_signature,
            } => {
                assert_eq!(
                    strings.get(sheet.0 as usize).map(String::as_str),
                    Some("Sheet1")
                );
                assert!(row_signature.is_none());
                Some(*row_idx)
            }
            _ => None,
        })
        .collect();

    assert_eq!(
        rows_removed,
        vec![5],
        "expected single RowRemoved at index 5"
    );

    assert!(
        !report
            .ops
            .iter()
            .any(|op| matches!(op, DiffOp::RowAdded { .. })),
        "no rows should be added for middle delete"
    );

    assert!(
        !report
            .ops
            .iter()
            .any(|op| matches!(op, DiffOp::CellEdited { .. })),
        "aligned delete should not emit CellEdited noise"
    );
}

#[test]
fn alignment_bails_out_when_additional_edits_present() {
    let report = diff_fixture_pkgs(
        "row_insert_with_edit_a.xlsx",
        "row_insert_with_edit_b.xlsx",
        &DiffConfig::default(),
    );

    let rows_added: Vec<u32> = report
        .ops
        .iter()
        .filter_map(|op| match op {
            DiffOp::RowAdded { row_idx, .. } => Some(*row_idx),
            _ => None,
        })
        .collect();

    assert!(
        rows_added.contains(&10),
        "fallback positional diff should add the tail row"
    );
    assert!(
        !rows_added.contains(&5),
        "mid-sheet RowAdded at 5 would indicate the alignment path was taken"
    );

    let edited_rows: Vec<u32> = report
        .ops
        .iter()
        .filter_map(|op| match op {
            DiffOp::CellEdited { addr, .. } => Some(addr.row),
            _ => None,
        })
        .collect();

    assert!(
        !edited_rows.is_empty(),
        "fallback positional diff should surface cell edits after the inserted row"
    );
    assert!(
        edited_rows.iter().any(|row| *row >= 5),
        "cell edits should include rows at or below the insertion point"
    );
}

```

---

### File: `core\tests\g9_column_alignment_grid_workbook_tests.rs`

```rust
mod common;

use common::{diff_fixture_pkgs, open_fixture_workbook, sid};
use excel_diff::{CellValue, DiffConfig, DiffOp, Workbook};

#[test]
fn g9_col_insert_middle_emits_one_columnadded_and_no_noise() {
    let report = diff_fixture_pkgs(
        "col_insert_middle_a.xlsx",
        "col_insert_middle_b.xlsx",
        &DiffConfig::default(),
    );

    let cols_added: Vec<u32> = report
        .ops
        .iter()
        .filter_map(|op| match op {
            DiffOp::ColumnAdded {
                sheet,
                col_idx,
                col_signature,
            } => {
                assert_eq!(sheet, &sid("Data"));
                assert!(col_signature.is_none());
                Some(*col_idx)
            }
            _ => None,
        })
        .collect();

    assert_eq!(
        cols_added,
        vec![3],
        "expected single ColumnAdded at inserted position"
    );

    assert!(
        !report.ops.iter().any(|op| matches!(
            op,
            DiffOp::ColumnRemoved { .. } | DiffOp::RowAdded { .. } | DiffOp::RowRemoved { .. }
        )),
        "column insert should not emit row ops or ColumnRemoved"
    );

    assert!(
        !report
            .ops
            .iter()
            .any(|op| matches!(op, DiffOp::CellEdited { .. })),
        "aligned insert should not emit CellEdited noise"
    );
}

#[test]
fn g9_col_delete_middle_emits_one_columnremoved_and_no_noise() {
    let report = diff_fixture_pkgs(
        "col_delete_middle_a.xlsx",
        "col_delete_middle_b.xlsx",
        &DiffConfig::default(),
    );

    let cols_removed: Vec<u32> = report
        .ops
        .iter()
        .filter_map(|op| match op {
            DiffOp::ColumnRemoved {
                sheet,
                col_idx,
                col_signature,
            } => {
                assert_eq!(sheet, &sid("Data"));
                assert!(col_signature.is_none());
                Some(*col_idx)
            }
            _ => None,
        })
        .collect();

    assert_eq!(
        cols_removed,
        vec![3],
        "expected single ColumnRemoved at deleted position"
    );

    assert!(
        !report.ops.iter().any(|op| matches!(
            op,
            DiffOp::ColumnAdded { .. } | DiffOp::RowAdded { .. } | DiffOp::RowRemoved { .. }
        )),
        "column delete should not emit ColumnAdded or row ops"
    );

    assert!(
        !report
            .ops
            .iter()
            .any(|op| matches!(op, DiffOp::CellEdited { .. })),
        "aligned delete should not emit CellEdited noise"
    );
}

#[test]
fn g9_alignment_bails_out_when_additional_edits_present() {
    let wb_b = open_fixture_workbook("col_insert_with_edit_b.xlsx");
    let report = diff_fixture_pkgs(
        "col_insert_with_edit_a.xlsx",
        "col_insert_with_edit_b.xlsx",
        &DiffConfig::default(),
    );
    let inserted_idx = find_header_col(&wb_b, "Inserted");

    let has_middle_column_add = report.ops.iter().any(|op| match op {
        DiffOp::ColumnAdded { col_idx, .. } => *col_idx == inserted_idx,
        _ => false,
    });
    assert!(
        !has_middle_column_add,
        "alignment should bail out; no ColumnAdded at the inserted index"
    );

    let edited_cols: Vec<u32> = report
        .ops
        .iter()
        .filter_map(|op| match op {
            DiffOp::CellEdited { addr, .. } => Some(addr.col),
            _ => None,
        })
        .collect();

    assert!(
        !edited_cols.is_empty(),
        "fallback positional diff should emit CellEdited ops"
    );
    assert!(
        edited_cols.iter().any(|col| *col > inserted_idx),
        "CellEdited ops should appear in columns to the right of the insertion"
    );
}

fn find_header_col(workbook: &Workbook, header: &str) -> u32 {
    let header_id = sid(header);
    workbook
        .sheets
        .iter()
        .flat_map(|sheet| sheet.grid.cells.iter())
        .find_map(|((row, col), cell)| match &cell.value {
            Some(CellValue::Text(text)) if *row == 0 && *text == header_id => Some(*col),
            _ => None,
        })
        .expect("header column should exist in fixture")
}

```

---

### File: `core\tests\grid_view_hashstats_tests.rs`

```rust
use excel_diff::{
    ColHash, ColMeta, ColSignature, FrequencyClass, HashStats, RowHash, RowMeta, RowSignature,
};

fn row_meta(row_idx: u32, hash: RowHash) -> RowMeta {
    RowMeta {
        row_idx,
        signature: hash,
        non_blank_count: 0,
        first_non_blank_col: 0,
        frequency_class: FrequencyClass::Common,
        is_low_info: false,
    }
}

fn col_meta(col_idx: u32, hash: ColHash) -> ColMeta {
    ColMeta {
        col_idx,
        hash,
        non_blank_count: 0,
        first_non_blank_row: 0,
    }
}

#[test]
fn hashstats_counts_and_positions_basic() {
    let h1: RowHash = RowSignature { hash: 1 };
    let h2: RowHash = RowSignature { hash: 2 };
    let h3: RowHash = RowSignature { hash: 3 };
    let h4: RowHash = RowSignature { hash: 4 };

    let rows_a = vec![
        row_meta(0, h1),
        row_meta(1, h2),
        row_meta(2, h2),
        row_meta(3, h3),
    ];
    let rows_b = vec![row_meta(0, h2), row_meta(1, h3), row_meta(2, h4)];

    let stats = HashStats::from_row_meta(&rows_a, &rows_b);

    assert_eq!(stats.freq_a.get(&h1).copied().unwrap_or(0), 1);
    assert_eq!(stats.freq_b.get(&h1).copied().unwrap_or(0), 0);

    assert_eq!(stats.freq_a.get(&h2).copied().unwrap_or(0), 2);
    assert_eq!(stats.freq_b.get(&h2).copied().unwrap_or(0), 1);

    assert_eq!(stats.freq_a.get(&h3).copied().unwrap_or(0), 1);
    assert_eq!(stats.freq_b.get(&h3).copied().unwrap_or(0), 1);

    assert_eq!(stats.freq_a.get(&h4).copied().unwrap_or(0), 0);
    assert_eq!(stats.freq_b.get(&h4).copied().unwrap_or(0), 1);

    assert_eq!(
        stats.hash_to_positions_b.get(&h2).cloned().unwrap(),
        vec![0]
    );
    assert_eq!(
        stats.hash_to_positions_b.get(&h3).cloned().unwrap(),
        vec![1]
    );
    assert_eq!(
        stats.hash_to_positions_b.get(&h4).cloned().unwrap(),
        vec![2]
    );

    let threshold = 1;
    assert!(stats.is_unique(h3));
    assert!(stats.is_common(h2, threshold));
    assert!(!stats.is_rare(h3, threshold));
    assert!(stats.appears_in_both(h3));
    assert!(!stats.appears_in_both(h1));
    assert!(!stats.appears_in_both(h4));
}

#[test]
fn hashstats_rare_but_not_common_boundary() {
    let h: RowHash = RowSignature { hash: 42 };
    let rows_a = vec![row_meta(0, h), row_meta(1, h)];
    let rows_b = vec![row_meta(0, h)];

    let stats = HashStats::from_row_meta(&rows_a, &rows_b);
    let threshold = 2;

    assert!(stats.is_rare(h, threshold));
    assert!(!stats.is_common(h, threshold));
    assert!(stats.appears_in_both(h));
    assert!(!stats.is_unique(h));
}

#[test]
fn hashstats_equal_to_threshold_behavior() {
    let h: RowHash = RowSignature { hash: 99 };
    let rows_a = vec![row_meta(0, h), row_meta(1, h), row_meta(2, h)];
    let rows_b = vec![row_meta(0, h), row_meta(1, h), row_meta(2, h)];

    let stats = HashStats::from_row_meta(&rows_a, &rows_b);
    let threshold = 3;

    assert!(stats.is_rare(h, threshold));
    assert!(!stats.is_common(h, threshold));
    assert!(stats.appears_in_both(h));
    assert!(!stats.is_unique(h));
}

#[test]
fn hashstats_empty_inputs() {
    let stats = HashStats::from_row_meta(&[], &[]);
    let dummy_hash: RowHash = RowSignature { hash: 123 };

    assert!(stats.freq_a.is_empty());
    assert!(stats.freq_b.is_empty());
    assert!(stats.hash_to_positions_b.is_empty());

    assert!(!stats.is_unique(dummy_hash));
    assert!(!stats.is_rare(dummy_hash, 1));
    assert!(!stats.is_common(dummy_hash, 0));
    assert!(!stats.appears_in_both(dummy_hash));
}

#[test]
fn hashstats_from_col_meta_tracks_positions() {
    let h1: ColHash = ColSignature { hash: 10 };
    let h2: ColHash = ColSignature { hash: 20 };
    let h3: ColHash = ColSignature { hash: 30 };

    let cols_a = vec![col_meta(0, h1), col_meta(1, h2), col_meta(2, h2)];
    let cols_b = vec![col_meta(0, h2), col_meta(1, h3)];

    let stats = HashStats::from_col_meta(&cols_a, &cols_b);

    assert_eq!(stats.freq_a.get(&h1).copied().unwrap_or(0), 1);
    assert_eq!(stats.freq_b.get(&h1).copied().unwrap_or(0), 0);

    assert_eq!(stats.freq_a.get(&h2).copied().unwrap_or(0), 2);
    assert_eq!(stats.freq_b.get(&h2).copied().unwrap_or(0), 1);

    assert_eq!(stats.freq_b.get(&h3).copied().unwrap_or(0), 1);
    assert_eq!(stats.freq_a.get(&h3).copied().unwrap_or(0), 0);

    assert_eq!(
        stats
            .hash_to_positions_b
            .get(&h2)
            .cloned()
            .unwrap_or_default(),
        vec![0]
    );
    assert_eq!(
        stats
            .hash_to_positions_b
            .get(&h3)
            .cloned()
            .unwrap_or_default(),
        vec![1]
    );
}

```

---

### File: `core\tests\grid_view_tests.rs`

```rust
use excel_diff::{CellValue, DiffConfig, Grid, GridView, with_default_session};

mod common;
use common::grid_from_numbers;

fn insert_cell(
    grid: &mut Grid,
    row: u32,
    col: u32,
    value: Option<CellValue>,
    formula: Option<&str>,
) {
    let formula_id = formula.map(|s| with_default_session(|session| session.strings.intern(s)));
    grid.insert_cell(row, col, value, formula_id);
}

fn text(value: &str) -> CellValue {
    with_default_session(|session| CellValue::Text(session.strings.intern(value)))
}

#[test]
fn gridview_dense_3x3_layout_and_metadata() {
    let grid = grid_from_numbers(&[&[1, 2, 3], &[4, 5, 6], &[7, 8, 9]]);

    let view = GridView::from_grid(&grid);

    assert_eq!(view.rows.len(), 3);
    assert_eq!(view.row_meta.len(), 3);
    assert_eq!(view.col_meta.len(), 3);

    for (row_idx, row_view) in view.rows.iter().enumerate() {
        assert_eq!(row_view.cells.len(), 3);
        for (col_idx, (col, _cell)) in row_view.cells.iter().enumerate() {
            assert_eq!(*col as usize, col_idx);
        }

        let meta = &view.row_meta[row_idx];
        assert_eq!(meta.non_blank_count, 3);
        assert_eq!(meta.first_non_blank_col, 0);
        assert!(!meta.is_low_info);
    }

    for (col_idx, col_meta) in view.col_meta.iter().enumerate() {
        assert_eq!(col_meta.non_blank_count, 3);
        assert_eq!(col_meta.first_non_blank_row, 0);
        assert_eq!(col_meta.col_idx as usize, col_idx);
    }
}

#[test]
fn gridview_sparse_rows_low_info_classification() {
    let mut grid = Grid::new(4, 4);
    insert_cell(&mut grid, 0, 0, Some(text("Header")), None);
    insert_cell(&mut grid, 2, 2, Some(CellValue::Number(10.0)), None);
    insert_cell(&mut grid, 3, 1, Some(text("   ")), None);

    let view = GridView::from_grid(&grid);

    assert_eq!(view.row_meta[0].non_blank_count, 1);
    assert!(view.row_meta[0].is_low_info);
    assert_eq!(view.row_meta[0].first_non_blank_col, 0);

    assert_eq!(view.row_meta[1].non_blank_count, 0);
    assert!(view.row_meta[1].is_low_info);
    assert_eq!(view.row_meta[1].first_non_blank_col, 0);

    assert_eq!(view.row_meta[2].non_blank_count, 1);
    assert!(view.row_meta[2].is_low_info);
    assert_eq!(view.row_meta[2].first_non_blank_col, 2);

    assert_eq!(view.row_meta[3].non_blank_count, 1);
    assert!(view.row_meta[3].is_low_info);
    assert_eq!(view.row_meta[3].first_non_blank_col, 1);
}

#[allow(clippy::field_reassign_with_default)]
#[test]
fn gridview_formula_only_row_respects_threshold() {
    let mut grid = Grid::new(2, 2);
    insert_cell(&mut grid, 0, 0, None, Some("=A1+1"));

    let view_default = GridView::from_grid(&grid);
    assert_eq!(view_default.row_meta[0].non_blank_count, 1);
    assert!(view_default.row_meta[0].is_low_info);

    let mut config = DiffConfig::default();
    config.low_info_threshold = 1;
    let view_tuned = GridView::from_grid_with_config(&grid, &config);
    assert_eq!(view_tuned.row_meta[0].non_blank_count, 1);
    assert!(!view_tuned.row_meta[0].is_low_info);
}

#[test]
fn gridview_column_metadata_matches_signatures() {
    let mut grid = Grid::new(4, 4);
    insert_cell(&mut grid, 0, 1, Some(text("a")), Some("=B1"));
    insert_cell(&mut grid, 1, 3, Some(CellValue::Number(2.0)), Some("=1+1"));
    insert_cell(&mut grid, 2, 0, Some(CellValue::Bool(true)), None);
    insert_cell(&mut grid, 2, 2, Some(text("mid")), None);
    insert_cell(&mut grid, 3, 0, None, Some("=A1"));

    grid.compute_all_signatures();
    let row_signatures = grid
        .row_signatures
        .as_ref()
        .expect("row signatures should be computed")
        .clone();
    let col_signatures = grid
        .col_signatures
        .as_ref()
        .expect("col signatures should be computed")
        .clone();

    let view = GridView::from_grid(&grid);

    for (idx, meta) in view.col_meta.iter().enumerate() {
        assert_eq!(meta.hash, col_signatures[idx]);
    }

    for (idx, meta) in view.row_meta.iter().enumerate() {
        assert_eq!(meta.signature, row_signatures[idx]);
    }

    assert_eq!(view.col_meta[0].non_blank_count, 2);
    assert_eq!(view.col_meta[0].first_non_blank_row, 2);
    assert_eq!(view.col_meta[1].non_blank_count, 1);
    assert_eq!(view.col_meta[1].first_non_blank_row, 0);
    assert_eq!(view.col_meta[2].non_blank_count, 1);
    assert_eq!(view.col_meta[2].first_non_blank_row, 2);
    assert_eq!(view.col_meta[3].non_blank_count, 1);
    assert_eq!(view.col_meta[3].first_non_blank_row, 1);
}

#[test]
fn gridview_empty_grid_is_stable() {
    let grid = Grid::new(0, 0);

    let view = GridView::from_grid(&grid);

    assert!(view.rows.is_empty());
    assert!(view.row_meta.is_empty());
    assert!(view.col_meta.is_empty());
}

#[test]
fn gridview_large_sparse_grid_constructs_without_panic() {
    let nrows = 10_000;
    let ncols = 10;
    let mut grid = Grid::new(nrows, ncols);

    for r in (0..nrows).step_by(100) {
        let col = (r / 100) % ncols;
        insert_cell(
            &mut grid,
            r,
            col,
            Some(CellValue::Number((r / 100) as f64)),
            None,
        );
    }

    let view = GridView::from_grid(&grid);

    assert_eq!(view.rows.len(), nrows as usize);
    assert_eq!(view.col_meta.len(), ncols as usize);

    assert_eq!(view.row_meta[1].non_blank_count, 0);
    assert_eq!(view.row_meta[100].non_blank_count, 1);
    assert_eq!(view.row_meta[100].first_non_blank_col, 1);

    assert!(
        view.col_meta
            .iter()
            .any(|meta| meta.non_blank_count > 0 && meta.first_non_blank_row == 0)
    );
}

#[test]
fn gridview_row_hashes_ignore_small_float_drift() {
    let mut grid_a = Grid::new(1, 1);
    insert_cell(&mut grid_a, 0, 0, Some(CellValue::Number(1.0)), None);

    let mut grid_b = Grid::new(1, 1);
    insert_cell(
        &mut grid_b,
        0,
        0,
        Some(CellValue::Number(1.0000000000000002)),
        None,
    );

    let view_a = GridView::from_grid(&grid_a);
    let view_b = GridView::from_grid(&grid_b);

    assert_eq!(
        view_a.row_meta[0].signature, view_b.row_meta[0].signature,
        "row signatures should be stable under ULP-level float differences"
    );
}

```

---

### File: `core\tests\hardening_tests.rs`

```rust
mod common;

use common::single_sheet_workbook;
use excel_diff::{CellValue, DiffConfig, DiffOp, Grid, ProgressCallback, WorkbookPackage};
use std::sync::Mutex;

fn create_simple_grid(nrows: u32, ncols: u32, base_value: i32) -> Grid {
    let mut grid = Grid::new(nrows, ncols);
    for row in 0..nrows {
        for col in 0..ncols {
            grid.insert_cell(
                row,
                col,
                Some(CellValue::Number(
                    (base_value as i64 + row as i64 * 1000 + col as i64) as f64,
                )),
                None,
            );
        }
    }
    grid
}

#[test]
fn memory_budget_forces_positional_fallback_and_warning() {
    let grid_a = create_simple_grid(10, 3, 0);
    let mut grid_b = create_simple_grid(10, 3, 0);
    grid_b.insert_cell(5, 1, Some(CellValue::Number(999999.0)), None);

    let wb_a = single_sheet_workbook("Sheet1", grid_a);
    let wb_b = single_sheet_workbook("Sheet1", grid_b);

    let config = DiffConfig {
        max_memory_mb: Some(0),
        ..Default::default()
    };

    let report = WorkbookPackage::from(wb_a).diff(&WorkbookPackage::from(wb_b), &config);

    assert!(!report.complete, "memory fallback should mark report incomplete");
    assert!(
        report
            .warnings
            .iter()
            .any(|w| w.to_lowercase().contains("memory")),
        "expected a memory warning: {:?}",
        report.warnings
    );
    assert!(
        report
            .warnings
            .iter()
            .any(|w| w.to_lowercase().contains("positional")),
        "expected warning to mention positional diff: {:?}",
        report.warnings
    );
    assert!(
        report.ops.iter().any(|op| matches!(op, DiffOp::CellEdited { .. })),
        "should still emit ops via positional diff"
    );
}

#[test]
fn timeout_yields_partial_report_and_warning() {
    let grid_a = create_simple_grid(10, 3, 0);
    let mut grid_b = create_simple_grid(10, 3, 0);
    grid_b.insert_cell(5, 1, Some(CellValue::Number(999999.0)), None);

    let wb_a = single_sheet_workbook("Sheet1", grid_a);
    let wb_b = single_sheet_workbook("Sheet1", grid_b);

    let config = DiffConfig {
        timeout_seconds: Some(0),
        ..Default::default()
    };

    let report = WorkbookPackage::from(wb_a).diff(&WorkbookPackage::from(wb_b), &config);

    assert!(!report.complete, "timeout should mark report incomplete");
    assert!(
        report
            .warnings
            .iter()
            .any(|w| w.to_lowercase().contains("timeout")),
        "expected a timeout warning: {:?}",
        report.warnings
    );
}

#[derive(Default)]
struct CollectProgress {
    events: Mutex<Vec<(String, f32)>>,
}

impl ProgressCallback for CollectProgress {
    fn on_progress(&self, phase: &str, percent: f32) {
        let mut events = match self.events.lock() {
            Ok(guard) => guard,
            Err(poisoned) => poisoned.into_inner(),
        };
        events.push((phase.to_string(), percent));
    }
}

#[test]
fn progress_callback_fires_for_cell_diff() {
    let grid_a = create_simple_grid(512, 10, 0);
    let mut grid_b = create_simple_grid(512, 10, 0);
    grid_b.insert_cell(500, 5, Some(CellValue::Number(999999.0)), None);

    let wb_a = single_sheet_workbook("Sheet1", grid_a);
    let wb_b = single_sheet_workbook("Sheet1", grid_b);

    let config = DiffConfig::default();
    let progress = CollectProgress::default();

    let _report =
        WorkbookPackage::from(wb_a).diff_with_progress(&WorkbookPackage::from(wb_b), &config, &progress);

    let events = match progress.events.lock() {
        Ok(guard) => guard,
        Err(poisoned) => poisoned.into_inner(),
    };

    assert!(
        events.iter().any(|(phase, _)| phase == "cell_diff"),
        "expected at least one cell_diff progress event: {:?}",
        *events
    );
    assert!(
        events.iter().all(|(_, pct)| *pct >= 0.0 && *pct <= 1.0),
        "percent should stay within [0.0, 1.0]: {:?}",
        *events
    );
    assert!(
        events.len() < 10_000,
        "progress callbacks should be throttled: got {} callbacks",
        events.len()
    );
}


```

---

### File: `core\tests\integration_test.rs`

```rust
use std::path::PathBuf;

fn get_fixture_path(filename: &str) -> PathBuf {
    let mut d = PathBuf::from(env!("CARGO_MANIFEST_DIR"));
    // Go up one level from 'core', then into 'fixtures/generated'
    d.push("../fixtures/generated");
    d.push(filename);
    d
}

#[test]
fn test_locate_fixture() {
    let path = get_fixture_path("minimal.xlsx");
    // This test confirms that the Rust code can locate the Python-generated fixtures
    // using the relative path strategy from the monorepo root.
    assert!(
        path.exists(),
        "Fixture minimal.xlsx should exist at {:?}",
        path
    );
}

```

---

### File: `core\tests\limit_behavior_tests.rs`

```rust
mod common;

use common::{sid, single_sheet_workbook};
use excel_diff::{
    CellValue, DiffConfig, DiffError, DiffOp, DiffReport, Grid, LimitBehavior, Workbook,
    WorkbookPackage, try_diff_workbooks_with_pool, with_default_session,
};

fn diff_workbooks(old: &Workbook, new: &Workbook, config: &DiffConfig) -> DiffReport {
    WorkbookPackage::from(old.clone()).diff(&WorkbookPackage::from(new.clone()), config)
}

fn try_diff_workbooks(
    old: &Workbook,
    new: &Workbook,
    config: &DiffConfig,
) -> Result<DiffReport, DiffError> {
    with_default_session(|session| {
        try_diff_workbooks_with_pool(old, new, &mut session.strings, config)
    })
}

fn create_simple_grid(nrows: u32, ncols: u32, base_value: i32) -> Grid {
    let mut grid = Grid::new(nrows, ncols);
    for row in 0..nrows {
        for col in 0..ncols {
            grid.insert_cell(
                row,
                col,
                Some(CellValue::Number(
                    (base_value as i64 + row as i64 * 1000 + col as i64) as f64,
                )),
                None,
            );
        }
    }
    grid
}

fn count_ops(ops: &[DiffOp], predicate: impl Fn(&DiffOp) -> bool) -> usize {
    ops.iter().filter(|op| predicate(op)).count()
}

#[test]
fn large_grid_completes_within_default_limits() {
    let grid_a = create_simple_grid(1000, 10, 0);
    let mut grid_b = create_simple_grid(1000, 10, 0);
    grid_b.insert_cell(500, 5, Some(CellValue::Number(999999.0)), None);

    let wb_a = single_sheet_workbook("Sheet1", grid_a);
    let wb_b = single_sheet_workbook("Sheet1", grid_b);

    let config = DiffConfig::default();
    let report = diff_workbooks(&wb_a, &wb_b, &config);

    assert!(
        report.complete,
        "1000-row grid should complete within default limits"
    );
    assert!(
        report.warnings.is_empty(),
        "should have no warnings for successful diff"
    );
    assert!(
        count_ops(&report.ops, |op| matches!(op, DiffOp::CellEdited { .. })) >= 1,
        "should detect the cell edit"
    );
}

#[test]
fn limit_exceeded_fallback_to_positional() {
    let grid_a = create_simple_grid(100, 10, 0);
    let mut grid_b = create_simple_grid(100, 10, 0);
    grid_b.insert_cell(50, 5, Some(CellValue::Number(999999.0)), None);

    let wb_a = single_sheet_workbook("Sheet1", grid_a);
    let wb_b = single_sheet_workbook("Sheet1", grid_b);

    let config = DiffConfig {
        max_align_rows: 50,
        on_limit_exceeded: LimitBehavior::FallbackToPositional,
        ..Default::default()
    };

    let report = diff_workbooks(&wb_a, &wb_b, &config);

    assert!(
        report.complete,
        "FallbackToPositional should still produce a complete result"
    );
    assert!(
        report.warnings.is_empty(),
        "FallbackToPositional should not add warnings"
    );
    assert!(
        count_ops(&report.ops, |op| matches!(op, DiffOp::CellEdited { .. })) >= 1,
        "should detect the cell edit via positional diff"
    );
}

#[test]
fn limit_exceeded_return_partial_result() {
    let grid_a = create_simple_grid(100, 10, 0);
    let mut grid_b = create_simple_grid(100, 10, 0);
    grid_b.insert_cell(50, 5, Some(CellValue::Number(999999.0)), None);

    let wb_a = single_sheet_workbook("Sheet1", grid_a);
    let wb_b = single_sheet_workbook("Sheet1", grid_b);

    let config = DiffConfig {
        max_align_rows: 50,
        on_limit_exceeded: LimitBehavior::ReturnPartialResult,
        ..Default::default()
    };

    let report = diff_workbooks(&wb_a, &wb_b, &config);

    assert!(
        !report.complete,
        "ReturnPartialResult should mark report as incomplete"
    );
    assert!(
        !report.warnings.is_empty(),
        "ReturnPartialResult should add a warning about limits exceeded"
    );
    assert!(
        report.warnings[0].contains("limits exceeded"),
        "warning should mention limits exceeded"
    );
    assert!(
        !report.ops.is_empty(),
        "ReturnPartialResult should still produce ops via positional diff"
    );
}

#[test]
fn limit_exceeded_return_error_returns_structured_error() {
    let grid_a = create_simple_grid(100, 10, 0);
    let grid_b = create_simple_grid(100, 10, 0);

    let wb_a = single_sheet_workbook("Sheet1", grid_a);
    let wb_b = single_sheet_workbook("Sheet1", grid_b);

    let config = DiffConfig {
        max_align_rows: 50,
        on_limit_exceeded: LimitBehavior::ReturnError,
        ..Default::default()
    };

    let result = try_diff_workbooks(&wb_a, &wb_b, &config);
    assert!(result.is_err(), "should return error when limits exceeded");

    let err = result.unwrap_err();
    match err {
        DiffError::LimitsExceeded {
            sheet,
            rows,
            cols,
            max_rows,
            max_cols,
        } => {
            assert_eq!(sheet, sid("Sheet1"));
            assert_eq!(rows, 100);
            assert_eq!(cols, 10);
            assert_eq!(max_rows, 50);
            assert_eq!(max_cols, 16384);
        }
        _ => panic!("unexpected error variant: {err:?}"),
    }
}

#[test]
fn limit_exceeded_return_error_produces_warning_via_legacy_api() {
    let grid_a = create_simple_grid(100, 10, 0);
    let grid_b = create_simple_grid(100, 10, 0);

    let wb_a = single_sheet_workbook("Sheet1", grid_a);
    let wb_b = single_sheet_workbook("Sheet1", grid_b);

    let config = DiffConfig {
        max_align_rows: 50,
        on_limit_exceeded: LimitBehavior::ReturnError,
        ..Default::default()
    };

    let report = diff_workbooks(&wb_a, &wb_b, &config);
    assert!(!report.complete, "report should be incomplete");
    assert!(
        report.warnings.iter().any(|w| w.contains("limits exceeded")),
        "should have limits exceeded warning; warnings: {:?}",
        report.warnings
    );
}

#[test]
fn column_limit_exceeded() {
    let grid_a = create_simple_grid(10, 100, 0);
    let mut grid_b = create_simple_grid(10, 100, 0);
    grid_b.insert_cell(5, 50, Some(CellValue::Number(999999.0)), None);

    let wb_a = single_sheet_workbook("Sheet1", grid_a);
    let wb_b = single_sheet_workbook("Sheet1", grid_b);

    let config = DiffConfig {
        max_align_cols: 50,
        on_limit_exceeded: LimitBehavior::ReturnPartialResult,
        ..Default::default()
    };

    let report = diff_workbooks(&wb_a, &wb_b, &config);

    assert!(
        !report.complete,
        "should be marked incomplete when column limit exceeded"
    );
    assert!(
        !report.warnings.is_empty(),
        "should have warning about column limit"
    );
}

#[test]
fn within_limits_no_warning() {
    let grid_a = create_simple_grid(45, 10, 0);
    let mut grid_b = create_simple_grid(45, 10, 0);
    grid_b.insert_cell(20, 5, Some(CellValue::Number(999999.0)), None);

    let wb_a = single_sheet_workbook("Sheet1", grid_a);
    let wb_b = single_sheet_workbook("Sheet1", grid_b);

    let config = DiffConfig {
        max_align_rows: 50,
        on_limit_exceeded: LimitBehavior::ReturnPartialResult,
        ..Default::default()
    };

    let report = diff_workbooks(&wb_a, &wb_b, &config);

    assert!(report.complete, "should be complete when within limits");
    assert!(
        report.warnings.is_empty(),
        "should have no warnings when within limits"
    );
}

#[test]
fn multiple_sheets_limit_warning_includes_sheet_name() {
    let grid_small = create_simple_grid(10, 5, 0);
    let grid_large_a = create_simple_grid(100, 10, 1000);
    let grid_large_b = create_simple_grid(100, 10, 2000);

    let wb_a = excel_diff::Workbook {
        sheets: vec![
            excel_diff::Sheet {
                name: sid("SmallSheet"),
                kind: excel_diff::SheetKind::Worksheet,
                grid: grid_small.clone(),
            },
            excel_diff::Sheet {
                name: sid("LargeSheet"),
                kind: excel_diff::SheetKind::Worksheet,
                grid: grid_large_a,
            },
        ],
        ..Default::default()
    };

    let wb_b = excel_diff::Workbook {
        sheets: vec![
            excel_diff::Sheet {
                name: sid("SmallSheet"),
                kind: excel_diff::SheetKind::Worksheet,
                grid: grid_small,
            },
            excel_diff::Sheet {
                name: sid("LargeSheet"),
                kind: excel_diff::SheetKind::Worksheet,
                grid: grid_large_b,
            },
        ],
        ..Default::default()
    };

    let config = DiffConfig {
        max_align_rows: 50,
        on_limit_exceeded: LimitBehavior::ReturnPartialResult,
        ..Default::default()
    };

    let report = diff_workbooks(&wb_a, &wb_b, &config);

    assert!(!report.complete, "should be incomplete due to large sheet");
    assert!(
        report.warnings.iter().any(|w| w.contains("LargeSheet")),
        "warning should reference the sheet that exceeded limits"
    );
}

#[test]
fn large_grid_5k_rows_completes_within_default_limits() {
    let grid_a = create_simple_grid(5000, 10, 0);
    let mut grid_b = create_simple_grid(5000, 10, 0);
    grid_b.insert_cell(2500, 5, Some(CellValue::Number(999999.0)), None);

    let wb_a = single_sheet_workbook("LargeSheet", grid_a);
    let wb_b = single_sheet_workbook("LargeSheet", grid_b);

    let config = DiffConfig::default();
    let report = diff_workbooks(&wb_a, &wb_b, &config);

    assert!(
        report.complete,
        "5000-row grid should complete within default limits (max_align_rows=500000)"
    );
    assert!(
        report.warnings.is_empty(),
        "should have no warnings for successful large grid diff"
    );
    assert!(
        count_ops(&report.ops, |op| matches!(op, DiffOp::CellEdited { .. })) >= 1,
        "should detect the cell edit in large grid"
    );
}

#[test]
fn wide_grid_500_cols_completes_within_default_limits() {
    let grid_a = create_simple_grid(100, 500, 0);
    let mut grid_b = create_simple_grid(100, 500, 0);
    grid_b.insert_cell(50, 250, Some(CellValue::Number(999999.0)), None);

    let wb_a = single_sheet_workbook("WideSheet", grid_a);
    let wb_b = single_sheet_workbook("WideSheet", grid_b);

    let config = DiffConfig::default();
    let report = diff_workbooks(&wb_a, &wb_b, &config);

    assert!(
        report.complete,
        "500-column grid should complete within default limits (max_align_cols=16384)"
    );
    assert!(
        report.warnings.is_empty(),
        "should have no warnings for successful wide grid diff"
    );
    assert!(
        count_ops(&report.ops, |op| matches!(op, DiffOp::CellEdited { .. })) >= 1,
        "should detect the cell edit in wide grid"
    );
}

```

---

### File: `core\tests\m4_package_parts_tests.rs`

```rust
use std::io::{Cursor, Write};

use excel_diff::{
    DataMashupError, DataMashupLimits, open_data_mashup, parse_package_parts,
    parse_package_parts_with_limits, parse_section_members,
};
use zip::write::FileOptions;
use zip::{CompressionMethod, ZipWriter};

mod common;
use common::fixture_path;

const MIN_PACKAGE_XML: &str = "<Package></Package>";
const MIN_SECTION: &str = "section Section1;\nshared Foo = 1;";
const BOM_SECTION: &str = "\u{FEFF}section Section1;\nshared Foo = 1;";

#[test]
fn package_parts_contains_expected_entries() {
    let path = fixture_path("one_query.xlsx");
    let raw = open_data_mashup(&path)
        .expect("fixture should open")
        .expect("mashup should be present");

    let parts = parse_package_parts(&raw.package_parts).expect("PackageParts should parse");

    assert!(!parts.package_xml.raw_xml.is_empty());
    assert!(
        parts.main_section.source.contains("section Section1;"),
        "main Section1.m should be present"
    );
    assert!(
        parts.main_section.source.contains("shared"),
        "at least one shared query should be present"
    );
    assert!(
        parts.embedded_contents.is_empty(),
        "one_query.xlsx should not contain embedded contents"
    );
}

#[test]
fn embedded_content_detection() {
    let path = fixture_path("multi_query_with_embedded.xlsx");
    let raw = open_data_mashup(&path)
        .expect("fixture should open")
        .expect("mashup should be present");

    let parts = parse_package_parts(&raw.package_parts).expect("PackageParts should parse");

    assert!(
        !parts.embedded_contents.is_empty(),
        "multi_query_with_embedded.xlsx should expose at least one embedded content"
    );

    for embedded in &parts.embedded_contents {
        assert!(
            embedded.section.source.contains("section Section1"),
            "embedded Section1.m should be present for {}",
            embedded.name
        );
        assert!(
            embedded.section.source.contains("shared"),
            "embedded Section1.m should contain at least one shared member for {}",
            embedded.name
        );
    }
}

#[test]
fn parse_package_parts_rejects_non_zip() {
    let bogus = b"this is not a zip file";
    let err = parse_package_parts(bogus).expect_err("non-zip bytes should fail");
    assert!(matches!(err, DataMashupError::FramingInvalid));
}

#[test]
fn missing_config_package_xml_errors() {
    let bytes = build_zip(vec![(
        "Formulas/Section1.m",
        MIN_SECTION.as_bytes().to_vec(),
    )]);
    let err = parse_package_parts(&bytes)
        .expect_err("missing Config/Package.xml should be framing invalid");
    assert!(matches!(err, DataMashupError::FramingInvalid));
}

#[test]
fn missing_section1_errors() {
    let bytes = build_zip(vec![(
        "Config/Package.xml",
        MIN_PACKAGE_XML.as_bytes().to_vec(),
    )]);
    let err = parse_package_parts(&bytes)
        .expect_err("missing Formulas/Section1.m should be framing invalid");
    assert!(matches!(err, DataMashupError::FramingInvalid));
}

#[test]
fn invalid_utf8_in_package_xml_errors() {
    let bytes = build_zip(vec![
        ("Config/Package.xml", vec![0xFF, 0xFF, 0xFF]),
        ("Formulas/Section1.m", MIN_SECTION.as_bytes().to_vec()),
    ]);
    let err = parse_package_parts(&bytes).expect_err("invalid UTF-8 in Package.xml should error");
    assert!(matches!(err, DataMashupError::FramingInvalid));
}

#[test]
fn invalid_utf8_in_section1_errors() {
    let bytes = build_zip(vec![
        ("Config/Package.xml", MIN_PACKAGE_XML.as_bytes().to_vec()),
        ("Formulas/Section1.m", vec![0xFF, 0xFF]),
    ]);

    let err = parse_package_parts(&bytes).expect_err("invalid UTF-8 in Section1.m should error");
    assert!(matches!(err, DataMashupError::FramingInvalid));
}

#[test]
fn embedded_content_invalid_zip_is_skipped() {
    let bytes =
        build_minimal_package_parts_with(vec![("Content/bogus.package", b"not a zip".to_vec())]);
    let parts = parse_package_parts(&bytes).expect("outer package should parse");
    assert!(parts.embedded_contents.is_empty());
}

#[test]
fn embedded_content_missing_section1_is_skipped() {
    let nested = build_zip(vec![("Config/Formulas.xml", b"<Formulas/>".to_vec())]);
    let bytes = build_minimal_package_parts_with(vec![("Content/no_section1.package", nested)]);
    let parts = parse_package_parts(&bytes).expect("outer package should parse");
    assert!(parts.embedded_contents.is_empty());
}

#[test]
fn embedded_content_invalid_utf8_is_skipped() {
    let nested = build_zip(vec![("Formulas/Section1.m", vec![0xFF, 0xFF])]);
    let bytes = build_minimal_package_parts_with(vec![("Content/bad_utf8.package", nested)]);
    let parts = parse_package_parts(&bytes).expect("outer package should parse");
    assert!(parts.embedded_contents.is_empty());
}

#[test]
fn embedded_content_partial_failure_retains_valid_entries() {
    let good_nested = build_embedded_section_zip(MIN_SECTION.as_bytes().to_vec());
    let bytes = build_minimal_package_parts_with(vec![
        ("Content/good.package", good_nested),
        ("Content/bad.package", b"not a zip".to_vec()),
    ]);

    let parts = parse_package_parts(&bytes).expect("outer package should parse");
    assert_eq!(parts.embedded_contents.len(), 1);
    let embedded = &parts.embedded_contents[0];
    assert_eq!(embedded.name, "Content/good.package");
    assert!(embedded.section.source.contains("section Section1;"));
    assert!(embedded.section.source.contains("shared"));
}

#[test]
fn leading_slash_paths_are_accepted() {
    let embedded =
        build_embedded_section_zip("section Section1;\nshared Bar = 2;".as_bytes().to_vec());
    let bytes = build_zip(vec![
        (
            "/Config/Package.xml",
            br#"<Package from="leading"/>"#.to_vec(),
        ),
        ("/Formulas/Section1.m", MIN_SECTION.as_bytes().to_vec()),
        ("/Content/abcd.package", embedded),
        (
            "Config/Package.xml",
            br#"<Package from="canonical"/>"#.to_vec(),
        ),
    ]);

    let parts = parse_package_parts(&bytes).expect("leading slash entries should parse");
    assert!(
        parts.package_xml.raw_xml.contains(r#"from="leading""#),
        "first encountered Package.xml should win"
    );
    assert!(parts.main_section.source.contains("shared Foo = 1;"));
    assert_eq!(parts.embedded_contents.len(), 1);
    assert!(
        parts.embedded_contents[0]
            .section
            .source
            .contains("shared Bar = 2;")
    );
}

#[test]
fn embedded_content_name_is_canonicalized() {
    let nested = build_embedded_section_zip(MIN_SECTION.as_bytes().to_vec());
    let bytes = build_minimal_package_parts_with(vec![("/Content/efgh.package", nested)]);

    let parts =
        parse_package_parts(&bytes).expect("embedded content with leading slash should parse");
    assert_eq!(parts.embedded_contents.len(), 1);
    assert_eq!(parts.embedded_contents[0].name, "Content/efgh.package");
}

#[test]
fn empty_content_directory_is_ignored() {
    let bytes = build_zip(vec![
        ("Config/Package.xml", MIN_PACKAGE_XML.as_bytes().to_vec()),
        ("Formulas/Section1.m", MIN_SECTION.as_bytes().to_vec()),
        ("Content/", Vec::new()),
    ]);

    let parts = parse_package_parts(&bytes).expect("package with empty Content/ directory parses");
    assert!(!parts.package_xml.raw_xml.is_empty());
    assert!(!parts.main_section.source.is_empty());
    assert!(
        parts.embedded_contents.is_empty(),
        "bare Content/ directory should not produce embedded contents"
    );
}

#[test]
fn parse_package_parts_never_panics_on_random_bytes() {
    for seed in 0u64..64 {
        let len = (seed as usize * 13 % 256) + (seed as usize % 7);
        let bytes = random_bytes(seed, len);
        let _ = parse_package_parts(&bytes);
    }
}

#[test]
fn package_parts_section1_with_bom_parses_via_parse_section_members() {
    let bytes = build_zip(vec![
        ("Config/Package.xml", MIN_PACKAGE_XML.as_bytes().to_vec()),
        ("Formulas/Section1.m", BOM_SECTION.as_bytes().to_vec()),
    ]);

    let parts = parse_package_parts(&bytes).expect("BOM-prefixed Section1.m should parse");
    assert!(
        !parts.main_section.source.starts_with('\u{FEFF}'),
        "PackageParts should strip a single leading BOM from Section1.m"
    );
    let members = parse_section_members(&parts.main_section.source)
        .expect("parse_section_members should accept BOM-prefixed Section1");
    assert_eq!(members.len(), 1);
    assert_eq!(members[0].member_name, "Foo");
    assert_eq!(members[0].section_name, "Section1");
}

#[test]
fn embedded_content_section1_with_bom_parses_via_parse_section_members() {
    let embedded = build_embedded_section_zip(BOM_SECTION.as_bytes().to_vec());
    let bytes = build_zip(vec![
        ("Config/Package.xml", MIN_PACKAGE_XML.as_bytes().to_vec()),
        ("Formulas/Section1.m", MIN_SECTION.as_bytes().to_vec()),
        ("Content/bom_embedded.package", embedded),
    ]);

    let parts = parse_package_parts(&bytes).expect("outer package should parse");
    assert!(
        !parts.embedded_contents.is_empty(),
        "embedded package should be detected"
    );

    let embedded = parts
        .embedded_contents
        .iter()
        .find(|entry| entry.name == "Content/bom_embedded.package")
        .expect("expected embedded package to round-trip name");

    assert!(
        !embedded.section.source.starts_with('\u{FEFF}'),
        "embedded Section1.m should strip leading BOM"
    );

    let members = parse_section_members(&embedded.section.source)
        .expect("parse_section_members should accept embedded BOM Section1");
    assert!(
        !members.is_empty(),
        "embedded Section1.m should contain members"
    );
    assert!(
        members.iter().any(|member| {
            member.section_name == "Section1"
                && member.member_name == "Foo"
                && member.expression_m == "1"
        }),
        "embedded Section1.m should parse shared Foo = 1"
    );
}

#[test]
fn package_parts_with_limits_rejects_oversized_required_part() {
    let bytes = build_zip(vec![
        ("Config/Package.xml", MIN_PACKAGE_XML.as_bytes().to_vec()),
        ("Formulas/Section1.m", vec![b'a'; 200]),
    ]);

    let limits = DataMashupLimits {
        max_inner_entries: 100,
        max_inner_part_bytes: 100,
        max_inner_total_bytes: 10_000,
    };

    let err =
        parse_package_parts_with_limits(&bytes, limits).expect_err("expected oversized part error");

    match err {
        DataMashupError::InnerPartTooLarge { path, size, limit } => {
            assert_eq!(path, "Formulas/Section1.m");
            assert_eq!(size, 200);
            assert_eq!(limit, 100);
        }
        other => panic!("expected InnerPartTooLarge, got {other:?}"),
    }
}

#[test]
fn package_parts_with_limits_rejects_too_many_entries() {
    let bytes = build_zip(vec![
        ("Config/Package.xml", MIN_PACKAGE_XML.as_bytes().to_vec()),
        ("Formulas/Section1.m", MIN_SECTION.as_bytes().to_vec()),
        ("Foo.txt", b"1".to_vec()),
        ("Bar.txt", b"2".to_vec()),
        ("Baz.txt", b"3".to_vec()),
    ]);

    let limits = DataMashupLimits {
        max_inner_entries: 4,
        max_inner_part_bytes: 10_000,
        max_inner_total_bytes: 10_000,
    };

    let err =
        parse_package_parts_with_limits(&bytes, limits).expect_err("expected too-many-entries error");
    match err {
        DataMashupError::InnerTooManyEntries {
            entries,
            max_entries,
        } => {
            assert_eq!(entries, 5);
            assert_eq!(max_entries, 4);
        }
        other => panic!("expected InnerTooManyEntries, got {other:?}"),
    }
}

#[test]
fn package_parts_with_limits_rejects_total_size() {
    let base = (MIN_PACKAGE_XML.len() + MIN_SECTION.len()) as u64;
    let limit = base + 10;

    let bytes = build_zip(vec![
        ("Config/Package.xml", MIN_PACKAGE_XML.as_bytes().to_vec()),
        ("Formulas/Section1.m", MIN_SECTION.as_bytes().to_vec()),
        ("Content/too_much.package", vec![0u8; 11]),
    ]);

    let limits = DataMashupLimits {
        max_inner_entries: 100,
        max_inner_part_bytes: 10_000,
        max_inner_total_bytes: limit,
    };

    let err =
        parse_package_parts_with_limits(&bytes, limits).expect_err("expected total-size error");
    match err {
        DataMashupError::InnerTotalTooLarge { limit: got } => {
            assert_eq!(got, limit);
        }
        other => panic!("expected InnerTotalTooLarge, got {other:?}"),
    }
}

#[test]
fn embedded_content_limits_apply_to_nested_packages() {
    let huge_section = vec![b'A'; 50_000];
    let nested = {
        let cursor = Cursor::new(Vec::new());
        let mut writer = ZipWriter::new(cursor);
        let options = FileOptions::default().compression_method(CompressionMethod::Deflated);
        writer
            .start_file("Formulas/Section1.m", options)
            .expect("start zip entry");
        writer
            .write_all(&huge_section)
            .expect("write zip entry");
        writer.finish().expect("finish zip").into_inner()
    };

    let bytes = build_zip(vec![
        ("Config/Package.xml", MIN_PACKAGE_XML.as_bytes().to_vec()),
        ("Formulas/Section1.m", MIN_SECTION.as_bytes().to_vec()),
        ("Content/oversized.package", nested),
    ]);

    let limits = DataMashupLimits {
        max_inner_entries: 100,
        max_inner_part_bytes: 10_000,
        max_inner_total_bytes: 100_000,
    };

    let err =
        parse_package_parts_with_limits(&bytes, limits).expect_err("expected nested size error");
    match err {
        DataMashupError::InnerPartTooLarge { path, size, limit } => {
            assert_eq!(path, "Content/oversized.package/Formulas/Section1.m");
            assert_eq!(size, 50_000);
            assert_eq!(limit, 10_000);
        }
        other => panic!("expected InnerPartTooLarge, got {other:?}"),
    }
}

fn build_minimal_package_parts_with(entries: Vec<(&str, Vec<u8>)>) -> Vec<u8> {
    let mut all_entries = Vec::with_capacity(entries.len() + 2);
    all_entries.push(("Config/Package.xml", MIN_PACKAGE_XML.as_bytes().to_vec()));
    all_entries.push(("Formulas/Section1.m", MIN_SECTION.as_bytes().to_vec()));
    all_entries.extend(entries);
    build_zip(all_entries)
}

fn build_embedded_section_zip(section_bytes: Vec<u8>) -> Vec<u8> {
    build_zip(vec![("Formulas/Section1.m", section_bytes)])
}

fn build_zip(entries: Vec<(&str, Vec<u8>)>) -> Vec<u8> {
    let cursor = Cursor::new(Vec::new());
    let mut writer = ZipWriter::new(cursor);
    let options = FileOptions::default().compression_method(CompressionMethod::Stored);

    for (name, bytes) in entries {
        if name.ends_with('/') {
            writer
                .add_directory(name, options)
                .expect("start zip directory");
        } else {
            writer.start_file(name, options).expect("start zip entry");
            writer.write_all(&bytes).expect("write zip entry");
        }
    }

    writer.finish().expect("finish zip").into_inner()
}

fn random_bytes(seed: u64, len: usize) -> Vec<u8> {
    let mut bytes = Vec::with_capacity(len);
    let mut state = seed.wrapping_mul(6364136223846793005).wrapping_add(1);
    for _ in 0..len {
        state = state
            .wrapping_mul(2862933555777941757)
            .wrapping_add(3037000493);
        bytes.push((state >> 32) as u8);
    }
    bytes
}

```

---

### File: `core\tests\m4_permissions_metadata_tests.rs`

```rust
use excel_diff::{
    DataMashupError, Permissions, RawDataMashup, build_data_mashup, build_queries,
    open_data_mashup, parse_metadata, parse_package_parts, parse_section_members,
};

mod common;
use common::fixture_path;

fn load_datamashup(path: &str) -> excel_diff::DataMashup {
    let raw = open_data_mashup(fixture_path(path))
        .expect("fixture should load")
        .expect("DataMashup should be present");
    build_data_mashup(&raw).expect("DataMashup should build")
}

#[test]
fn permissions_parsed_flags_default_vs_firewall_off() {
    let defaults = load_datamashup("permissions_defaults.xlsx");
    let firewall_off = load_datamashup("permissions_firewall_off.xlsx");

    assert_eq!(defaults.version, 0);
    assert_eq!(firewall_off.version, 0);

    assert!(defaults.permissions.firewall_enabled);
    assert!(!defaults.permissions.can_evaluate_future_packages);
    assert!(!firewall_off.permissions.firewall_enabled);
    assert_eq!(
        defaults.permissions.workbook_group_type,
        firewall_off.permissions.workbook_group_type
    );
}

#[test]
fn permissions_missing_or_malformed_yields_defaults() {
    let base_raw = open_data_mashup(fixture_path("one_query.xlsx"))
        .expect("fixture should load")
        .expect("DataMashup should be present");

    let mut missing = base_raw.clone();
    missing.permissions = Vec::new();
    missing.permission_bindings = Vec::new();
    let dm = build_data_mashup(&missing).expect("missing permissions should default");
    assert_eq!(dm.permissions, Permissions::default());

    let mut malformed = base_raw.clone();
    malformed.permissions = b"<not-xml".to_vec();
    let dm = build_data_mashup(&malformed).expect("malformed permissions should default");
    assert_eq!(dm.permissions, Permissions::default());
}

#[test]
fn permissions_invalid_entities_yield_defaults() {
    let base_raw = open_data_mashup(fixture_path("one_query.xlsx"))
        .expect("fixture should load")
        .expect("DataMashup should be present");

    let invalid_permissions = br#"
        <Permissions>
            <CanEvaluateFuturePackages>&bad;</CanEvaluateFuturePackages>
            <FirewallEnabled>true</FirewallEnabled>
        </Permissions>
    "#;
    let mut raw = base_raw.clone();
    raw.permissions = invalid_permissions.to_vec();

    let dm = build_data_mashup(&raw).expect("invalid permissions entities should default");
    assert_eq!(dm.permissions, Permissions::default());
}

#[test]
fn metadata_empty_bytes_returns_empty_struct() {
    let metadata = parse_metadata(&[]).expect("empty metadata should parse");
    assert!(metadata.formulas.is_empty());
}

#[test]
fn metadata_invalid_header_too_short_errors() {
    let err = parse_metadata(&[0x01]).expect_err("short metadata should error");
    match err {
        DataMashupError::XmlError(msg) => {
            assert!(msg.contains("metadata XML not found"));
        }
        other => panic!("expected XmlError, got {other:?}"),
    }
}

#[test]
fn metadata_invalid_length_prefix_errors() {
    let mut bytes = Vec::new();
    bytes.extend_from_slice(&0u32.to_le_bytes());
    bytes.extend_from_slice(&100u32.to_le_bytes());
    bytes.extend_from_slice(&[0u8; 10]);

    let err = parse_metadata(&bytes).expect_err("invalid length prefix should error");
    match err {
        DataMashupError::InvalidHeader(msg) => {
            assert!(msg.contains("metadata length prefix invalid"));
        }
        other => panic!("expected InvalidHeader, got {other:?}"),
    }
}

#[test]
fn metadata_invalid_utf8_errors() {
    let mut bytes = Vec::new();
    bytes.extend_from_slice(&0u32.to_le_bytes());
    bytes.extend_from_slice(&2u32.to_le_bytes());
    bytes.extend_from_slice(&[0xFF, 0xFF]);

    let err = parse_metadata(&bytes).expect_err("invalid utf-8 should error");
    match err {
        DataMashupError::XmlError(msg) => {
            assert!(msg.contains("metadata is not valid UTF-8"));
        }
        other => panic!("expected XmlError, got {other:?}"),
    }
}

#[test]
fn metadata_malformed_xml_errors() {
    let xml = b"<LocalPackageMetadataFile><foo";
    let mut bytes = Vec::new();
    bytes.extend_from_slice(&0u32.to_le_bytes());
    bytes.extend_from_slice(&(xml.len() as u32).to_le_bytes());
    bytes.extend_from_slice(xml);

    let err = parse_metadata(&bytes).expect_err("malformed xml should error");
    match err {
        DataMashupError::XmlError(_) => {}
        other => panic!("expected XmlError, got {other:?}"),
    }
}

#[test]
fn metadata_formulas_match_section_members() {
    let raw = open_data_mashup(fixture_path("metadata_simple.xlsx"))
        .expect("fixture should load")
        .expect("DataMashup should be present");
    let package = parse_package_parts(&raw.package_parts).expect("package parts should parse");
    let metadata = parse_metadata(&raw.metadata).expect("metadata should parse");
    let members =
        parse_section_members(&package.main_section.source).expect("section members should parse");

    let section1_formulas: Vec<_> = metadata
        .formulas
        .iter()
        .filter(|m| m.section_name == "Section1" && !m.is_connection_only)
        .collect();

    assert_eq!(section1_formulas.len(), members.len());
    for meta in section1_formulas {
        assert!(!meta.formula_name.is_empty());
    }
}

#[test]
fn metadata_load_destinations_simple() {
    let dm = load_datamashup("metadata_simple.xlsx");
    let load_to_sheet = dm
        .metadata
        .formulas
        .iter()
        .find(|m| m.item_path == "Section1/LoadToSheet")
        .expect("LoadToSheet metadata missing");
    assert!(load_to_sheet.load_to_sheet);
    assert!(!load_to_sheet.load_to_model);
    assert!(!load_to_sheet.is_connection_only);

    let load_to_model = dm
        .metadata
        .formulas
        .iter()
        .find(|m| m.item_path == "Section1/LoadToModel")
        .expect("LoadToModel metadata missing");
    assert!(!load_to_model.load_to_sheet);
    assert!(load_to_model.load_to_model);
    assert!(!load_to_model.is_connection_only);
}

#[test]
fn metadata_groups_basic_hierarchy() {
    let dm = load_datamashup("metadata_query_groups.xlsx");
    let grouped = dm
        .metadata
        .formulas
        .iter()
        .find(|m| m.item_path == "Section1/GroupedFoo")
        .expect("GroupedFoo metadata missing");
    assert_eq!(grouped.group_path.as_deref(), Some("Inputs/DimTables"));

    let root = dm
        .metadata
        .formulas
        .iter()
        .find(|m| m.item_path == "Section1/RootQuery")
        .expect("RootQuery metadata missing");
    assert!(root.group_path.is_none());
}

#[test]
fn metadata_hidden_queries_connection_only() {
    let dm = load_datamashup("metadata_hidden_queries.xlsx");
    let has_connection_only = dm
        .metadata
        .formulas
        .iter()
        .any(|m| !m.load_to_sheet && !m.load_to_model && m.is_connection_only);
    assert!(has_connection_only);
}

#[test]
fn metadata_itempath_decodes_percent_encoded_utf8() {
    let xml = r#"
        <LocalPackageMetadataFile>
            <Formulas>
                <Item>
                    <ItemType>Formula</ItemType>
                    <ItemPath>Section1/Foo%20Bar%C3%A9</ItemPath>
                    <Entry Type="FillEnabled" Value="l1" />
                </Item>
            </Formulas>
        </LocalPackageMetadataFile>
    "#;

    let metadata = parse_metadata(xml.as_bytes()).expect("metadata should parse");
    assert_eq!(metadata.formulas.len(), 1);
    let item = &metadata.formulas[0];
    assert_eq!(item.item_path, "Section1/Foo Bar\u{00e9}");
    assert_eq!(item.section_name, "Section1");
    assert_eq!(item.formula_name, "Foo Bar\u{00e9}");
    assert!(item.load_to_sheet);
    assert!(!item.is_connection_only);
}

#[test]
fn metadata_itempath_decodes_space_and_slash() {
    let xml = r#"
        <LocalPackageMetadataFile>
            <Formulas>
                <Item>
                    <ItemType>Formula</ItemType>
                    <ItemPath>Section1/Foo%20Bar%2FInner</ItemPath>
                    <Entry Type="FillEnabled" Value="l1" />
                </Item>
            </Formulas>
        </LocalPackageMetadataFile>
    "#;

    let metadata = parse_metadata(xml.as_bytes()).expect("metadata should parse");
    assert_eq!(metadata.formulas.len(), 1);
    let item = &metadata.formulas[0];
    assert_eq!(item.item_path, "Section1/Foo Bar/Inner");
    assert_eq!(item.section_name, "Section1");
    assert_eq!(item.formula_name, "Foo Bar/Inner");
}

#[test]
fn permission_bindings_present_flag() {
    let dm = load_datamashup("permissions_defaults.xlsx");
    assert!(!dm.permission_bindings_raw.is_empty());
}

#[test]
fn permission_bindings_missing_ok() {
    let base_raw = open_data_mashup(fixture_path("one_query.xlsx"))
        .expect("fixture should load")
        .expect("DataMashup should be present");

    let mut synthetic = RawDataMashup {
        permission_bindings: Vec::new(),
        ..base_raw.clone()
    };
    synthetic.permissions = Vec::new();
    synthetic.metadata = Vec::new();

    let dm = build_data_mashup(&synthetic).expect("empty bindings should build");
    assert!(dm.permission_bindings_raw.is_empty());
    assert_eq!(dm.permissions, Permissions::default());
}

#[test]
fn build_queries_is_compatible_with_metadata_simple() {
    let dm = load_datamashup("metadata_simple.xlsx");
    let queries = build_queries(&dm).expect("queries should build");
    assert!(!queries.is_empty());
}

```

---

### File: `core\tests\m5_query_domain_tests.rs`

```rust
use std::collections::HashSet;

use excel_diff::{build_data_mashup, build_queries, open_data_mashup, parse_section_members};

mod common;
use common::fixture_path;

fn load_datamashup(path: &str) -> excel_diff::DataMashup {
    let raw = open_data_mashup(fixture_path(path))
        .expect("fixture should load")
        .expect("DataMashup should be present");
    build_data_mashup(&raw).expect("DataMashup should build")
}

#[test]
fn metadata_join_simple() {
    let dm = load_datamashup("metadata_simple.xlsx");
    let queries = build_queries(&dm).expect("queries should build");

    assert_eq!(queries.len(), 2);
    let names: HashSet<_> = queries.iter().map(|q| q.name.as_str()).collect();
    assert_eq!(
        names,
        HashSet::from(["Section1/LoadToSheet", "Section1/LoadToModel"])
    );

    let sheet = queries
        .iter()
        .find(|q| q.section_member == "LoadToSheet")
        .expect("LoadToSheet query missing");
    assert!(sheet.metadata.load_to_sheet);
    assert!(!sheet.metadata.load_to_model);

    let model = queries
        .iter()
        .find(|q| q.section_member == "LoadToModel")
        .expect("LoadToModel query missing");
    assert!(!model.metadata.load_to_sheet);
    assert!(model.metadata.load_to_model);
}

#[test]
fn metadata_join_url_encoding() {
    let dm = load_datamashup("metadata_url_encoding.xlsx");
    let queries = build_queries(&dm).expect("queries should build");

    assert_eq!(queries.len(), 1);
    let q = &queries[0];
    assert_eq!(q.name, "Section1/Query with space & #");
    assert_eq!(q.section_member, "Query with space & #");
    assert!(q.metadata.load_to_sheet || q.metadata.load_to_model);
}

#[test]
fn member_without_metadata_is_preserved() {
    let dm = load_datamashup("metadata_missing_entry.xlsx");
    assert!(dm.metadata.formulas.is_empty());
    let queries = build_queries(&dm).expect("queries should build");

    assert_eq!(queries.len(), 1);
    let q = &queries[0];
    assert_eq!(q.name, "Section1/MissingMetadata");
    assert_eq!(q.section_member, "MissingMetadata");
    assert_eq!(q.metadata.item_path, "Section1/MissingMetadata");
    assert!(!q.metadata.load_to_sheet);
    assert!(!q.metadata.load_to_model);
    assert!(q.metadata.is_connection_only);
    assert_eq!(q.metadata.group_path, None);
}

#[test]
fn query_names_unique() {
    let dm = load_datamashup("metadata_simple.xlsx");
    let queries = build_queries(&dm).expect("queries should build");

    let mut seen = HashSet::new();
    for q in &queries {
        assert!(seen.insert(&q.name));
    }
}

#[test]
fn metadata_orphan_entries() {
    let dm = load_datamashup("metadata_orphan_entries.xlsx");
    let queries = build_queries(&dm).expect("queries should build");

    assert_eq!(queries.len(), 1);
    assert_eq!(queries[0].name, "Section1/Foo");
    assert!(
        dm.metadata
            .formulas
            .iter()
            .any(|m| m.item_path == "Section1/Nonexistent")
    );
}

#[test]
fn queries_preserve_section_member_order() {
    let dm = load_datamashup("metadata_simple.xlsx");
    let members = parse_section_members(&dm.package_parts.main_section.source)
        .expect("Section1 should parse");
    let queries = build_queries(&dm).expect("queries should build");

    assert_eq!(members.len(), queries.len());
    for (idx, (member, query)) in members.iter().zip(queries.iter()).enumerate() {
        assert_eq!(
            query.section_member, member.member_name,
            "query at position {} should match Section1 member order",
            idx
        );
    }
}

```

---

### File: `core\tests\m6_textual_m_diff_tests.rs`

```rust
use excel_diff::{
    DiffConfig, DiffOp, DiffReport, QueryChangeKind, QueryMetadataField, WorkbookPackage,
};
use std::fs::File;

mod common;
use common::fixture_path;

fn load_package(name: &str) -> WorkbookPackage {
    let path = fixture_path(name);
    let file = File::open(&path).expect("fixture file should open");
    WorkbookPackage::open(file).expect("fixture should parse as WorkbookPackage")
}

fn m_ops(report: &DiffReport) -> Vec<&DiffOp> {
    report.m_ops().collect()
}

fn resolve_name<'a>(report: &'a DiffReport, op: &DiffOp) -> &'a str {
    let name_id = match op {
        DiffOp::QueryAdded { name } => *name,
        DiffOp::QueryRemoved { name } => *name,
        DiffOp::QueryRenamed { from, .. } => *from,
        DiffOp::QueryDefinitionChanged { name, .. } => *name,
        DiffOp::QueryMetadataChanged { name, .. } => *name,
        _ => panic!("not a query op"),
    };
    &report.strings[name_id.0 as usize]
}

#[test]
fn basic_add_query_diff() {
    let pkg_a = load_package("m_add_query_a.xlsx");
    let pkg_b = load_package("m_add_query_b.xlsx");

    let report = pkg_a.diff(&pkg_b, &DiffConfig::default());
    let ops = m_ops(&report);

    assert_eq!(ops.len(), 1, "expected exactly one diff for added query");
    assert!(
        matches!(ops[0], DiffOp::QueryAdded { .. }),
        "expected QueryAdded"
    );
    assert_eq!(resolve_name(&report, ops[0]), "Section1/Bar");
}

#[test]
fn basic_remove_query_diff() {
    let pkg_a = load_package("m_remove_query_a.xlsx");
    let pkg_b = load_package("m_remove_query_b.xlsx");

    let report = pkg_a.diff(&pkg_b, &DiffConfig::default());
    let ops = m_ops(&report);

    assert_eq!(ops.len(), 1, "expected exactly one diff for removed query");
    assert!(
        matches!(ops[0], DiffOp::QueryRemoved { .. }),
        "expected QueryRemoved"
    );
    assert_eq!(resolve_name(&report, ops[0]), "Section1/Bar");
}

#[test]
fn literal_change_produces_definitionchanged() {
    let pkg_a = load_package("m_change_literal_a.xlsx");
    let pkg_b = load_package("m_change_literal_b.xlsx");

    let report = pkg_a.diff(&pkg_b, &DiffConfig::default());
    let ops = m_ops(&report);

    assert_eq!(ops.len(), 1, "expected one diff for changed literal");
    match ops[0] {
        DiffOp::QueryDefinitionChanged {
            change_kind,
            old_hash,
            new_hash,
            ..
        } => {
            assert_eq!(
                *change_kind,
                QueryChangeKind::Semantic,
                "literal change is semantic"
            );
            assert_ne!(
                old_hash, new_hash,
                "hashes should differ for semantic change"
            );
        }
        _ => panic!("expected QueryDefinitionChanged, got {:?}", ops[0]),
    }
    assert_eq!(resolve_name(&report, ops[0]), "Section1/Foo");
}

#[test]
fn metadata_change_produces_metadata_ops() {
    let pkg_a = load_package("m_metadata_only_change_a.xlsx");
    let pkg_b = load_package("m_metadata_only_change_b.xlsx");

    let report = pkg_a.diff(&pkg_b, &DiffConfig::default());
    let ops = m_ops(&report);

    assert!(
        !ops.is_empty(),
        "expected at least one diff for metadata change"
    );
    for op in &ops {
        match op {
            DiffOp::QueryMetadataChanged { field, .. } => {
                assert!(
                    matches!(
                        field,
                        QueryMetadataField::LoadToSheet
                            | QueryMetadataField::LoadToModel
                            | QueryMetadataField::GroupPath
                            | QueryMetadataField::ConnectionOnly
                    ),
                    "expected a recognized metadata field"
                );
            }
            _ => panic!("expected only QueryMetadataChanged ops, got {:?}", op),
        }
    }
}

#[test]
fn definition_and_metadata_change_produces_both() {
    let pkg_a = load_package("m_def_and_metadata_change_a.xlsx");
    let pkg_b = load_package("m_def_and_metadata_change_b.xlsx");

    let report = pkg_a.diff(&pkg_b, &DiffConfig::default());
    let ops = m_ops(&report);

    let has_definition_change = ops
        .iter()
        .any(|op| matches!(op, DiffOp::QueryDefinitionChanged { .. }));
    assert!(
        has_definition_change,
        "expected QueryDefinitionChanged when definition changes"
    );
}

#[test]
fn identical_workbooks_produce_no_diffs() {
    let pkg = load_package("one_query.xlsx");

    let report = pkg.diff(&pkg, &DiffConfig::default());
    let ops = m_ops(&report);

    assert!(
        ops.is_empty(),
        "identical WorkbookPackage should produce no M diffs"
    );
}

#[test]
fn rename_produces_query_renamed() {
    let pkg_a = load_package("m_rename_query_a.xlsx");
    let pkg_b = load_package("m_rename_query_b.xlsx");

    let report = pkg_a.diff(&pkg_b, &DiffConfig::default());
    let ops = m_ops(&report);

    let renamed_ops: Vec<_> = ops
        .iter()
        .filter(|op| matches!(op, DiffOp::QueryRenamed { .. }))
        .collect();

    assert_eq!(
        renamed_ops.len(),
        1,
        "expected exactly one QueryRenamed op for rename scenario"
    );

    match renamed_ops[0] {
        DiffOp::QueryRenamed { from, to } => {
            let from_name = &report.strings[from.0 as usize];
            let to_name = &report.strings[to.0 as usize];
            assert_eq!(from_name, "Section1/Foo");
            assert_eq!(to_name, "Section1/Bar");
        }
        _ => unreachable!(),
    }
}

```

---

### File: `core\tests\m7_ast_canonicalization_tests.rs`

```rust
use excel_diff::{
    DataMashup, MAstKind, MParseError, MTokenDebug, ast_semantically_equal, build_data_mashup,
    build_queries, canonicalize_m_ast, open_data_mashup, parse_m_expression, tokenize_for_testing,
};

mod common;
use common::fixture_path;

fn load_datamashup(name: &str) -> DataMashup {
    let raw = open_data_mashup(fixture_path(name))
        .expect("fixture should open")
        .expect("DataMashup should be present");
    build_data_mashup(&raw).expect("DataMashup should build")
}

fn load_single_query_expression(workbook: &str) -> String {
    let dm = load_datamashup(workbook);
    let queries = build_queries(&dm).expect("queries should parse");
    queries
        .first()
        .expect("fixture should contain a query")
        .expression_m
        .clone()
}

fn load_query_expression(workbook: &str, query_name: &str) -> String {
    let dm = load_datamashup(workbook);
    let queries = build_queries(&dm).expect("queries should parse");
    queries
        .into_iter()
        .find(|q| q.name == query_name)
        .expect("expected query to exist")
        .expression_m
}

#[test]
fn parse_basic_let_query_succeeds() {
    let expr = load_single_query_expression("one_query.xlsx");

    let result = parse_m_expression(&expr);

    assert!(result.is_ok(), "expected parse to succeed");
}

#[test]
fn basic_let_query_ast_is_let() {
    let expr = load_single_query_expression("one_query.xlsx");

    let ast = parse_m_expression(&expr).expect("expected parse to succeed");
    match ast.root_kind_for_testing() {
        MAstKind::Let { binding_count } => {
            assert!(
                binding_count >= 1,
                "expected at least one binding in basic let query"
            );
        }
        other => panic!("expected let root, got {:?}", other),
    }
}

#[test]
fn nested_let_in_binding_parses_successfully() {
    let expr = r#"
        let
            Source = let x = 1 in x,
            Result = Source
        in
            Result
    "#;

    let mut ast = parse_m_expression(expr).expect("nested let should parse");
    let mut ast_again = ast.clone();

    canonicalize_m_ast(&mut ast);
    canonicalize_m_ast(&mut ast_again);

    assert!(
        ast_semantically_equal(&ast, &ast_again),
        "canonicalization should not change equality for nested lets"
    );
}

#[test]
fn nested_let_formatting_only_equal() {
    let expr_a = r#"
        let
            Source = let x = 1 in x,
            Result = Source
        in
            Result
    "#;
    let expr_b = r#"let Source = let x = 1 in x, Result = Source in Result"#;

    let mut ast_a = parse_m_expression(expr_a).expect("first nested let should parse");
    let mut ast_b = parse_m_expression(expr_b).expect("second nested let should parse");

    canonicalize_m_ast(&mut ast_a);
    canonicalize_m_ast(&mut ast_b);

    assert!(
        ast_semantically_equal(&ast_a, &ast_b),
        "formatting-only differences with nested lets should compare equal"
    );
}

#[test]
fn formatting_only_queries_semantically_equal() {
    let expr_a = load_query_expression("m_formatting_only_a.xlsx", "Section1/FormatTest");
    let expr_b = load_query_expression("m_formatting_only_b.xlsx", "Section1/FormatTest");

    let mut ast_a = parse_m_expression(&expr_a).expect("formatting-only A should parse");
    let mut ast_b = parse_m_expression(&expr_b).expect("formatting-only B should parse");

    canonicalize_m_ast(&mut ast_a);
    canonicalize_m_ast(&mut ast_b);

    assert!(
        ast_semantically_equal(&ast_a, &ast_b),
        "formatting-only variants should be equal after canonicalization"
    );
}

#[test]
fn formatting_only_variant_detects_semantic_change() {
    let expr_b = load_query_expression("m_formatting_only_b.xlsx", "Section1/FormatTest");
    let expr_variant =
        load_query_expression("m_formatting_only_b_variant.xlsx", "Section1/FormatTest");

    let mut ast_b = parse_m_expression(&expr_b).expect("formatting-only B should parse");
    let mut ast_variant =
        parse_m_expression(&expr_variant).expect("formatting-only B variant should parse");

    canonicalize_m_ast(&mut ast_b);
    canonicalize_m_ast(&mut ast_variant);

    assert!(
        !ast_semantically_equal(&ast_b, &ast_variant),
        "semantic change should be detected even after canonicalization"
    );
}

#[test]
fn malformed_query_yields_parse_error() {
    let malformed = "let\n    Source = 1\n// missing 'in' and expression";

    let result = parse_m_expression(malformed);

    assert!(
        matches!(
            result,
            Err(MParseError::MissingInClause | MParseError::InvalidLetBinding)
        ),
        "missing 'in' should produce a parse error"
    );
}

#[test]
fn empty_expression_is_error() {
    let cases = ["", "   // only comment", "/* only block comment */"];

    for case in cases {
        let result = parse_m_expression(case);
        assert!(
            matches!(result, Err(MParseError::Empty)),
            "empty or comment-only input should return Empty, got {:?}",
            result
        );
    }
}

#[test]
fn unterminated_string_yields_error() {
    let result = parse_m_expression("\"unterminated");

    assert!(
        matches!(result, Err(MParseError::UnterminatedString)),
        "unterminated string should surface the correct error"
    );
}

#[test]
fn unterminated_block_comment_yields_error() {
    let result = parse_m_expression("let Source = 1 /* unterminated");

    assert!(
        matches!(result, Err(MParseError::UnterminatedBlockComment)),
        "unterminated block comment should surface the correct error"
    );
}

#[test]
fn unbalanced_delimiter_yields_error() {
    let cases = [
        "let Source = (1",
        "let Source = [1",
        "let Source = {1",
        "let Source = (1]",
    ];

    for case in cases {
        let result = parse_m_expression(case);
        assert!(
            matches!(result, Err(MParseError::UnbalancedDelimiter)),
            "unbalanced delimiters should error, got {:?}",
            result
        );
    }
}

#[test]
fn canonicalization_is_idempotent() {
    let expr = load_query_expression("m_formatting_only_b.xlsx", "Section1/FormatTest");

    let mut ast_once = parse_m_expression(&expr).expect("formatting-only B should parse");
    let mut ast_twice = ast_once.clone();

    canonicalize_m_ast(&mut ast_once);
    canonicalize_m_ast(&mut ast_twice);
    canonicalize_m_ast(&mut ast_twice);

    assert_eq!(
        ast_once, ast_twice,
        "canonicalization should produce a stable AST"
    );
}

#[test]
fn hash_date_tokenization_is_atomic() {
    let tokens = tokenize_for_testing(r#"#"Foo" = #date(2020,1,1)"#)
        .expect("hash literal tokenization should succeed");

    let expected = vec![
        MTokenDebug::Identifier("Foo".to_string()),
        MTokenDebug::Symbol('='),
        MTokenDebug::Identifier("#date".to_string()),
        MTokenDebug::Symbol('('),
        MTokenDebug::Number("2020".to_string()),
        MTokenDebug::Symbol(','),
        MTokenDebug::Number("1".to_string()),
        MTokenDebug::Symbol(','),
        MTokenDebug::Number("1".to_string()),
        MTokenDebug::Symbol(')'),
    ];

    assert_eq!(
        expected, tokens,
        "hash-prefixed literals should be lexed as single identifiers"
    );
}

```

---

### File: `core\tests\m7_semantic_m_diff_tests.rs`

```rust
use excel_diff::{DiffConfig, DiffOp, DiffReport, QueryChangeKind, WorkbookPackage};
use std::fs::File;

mod common;
use common::fixture_path;

fn load_package(name: &str) -> WorkbookPackage {
    let path = fixture_path(name);
    let file = File::open(&path).expect("fixture file should open");
    WorkbookPackage::open(file).expect("fixture should parse as WorkbookPackage")
}

fn m_ops(report: &DiffReport) -> Vec<&DiffOp> {
    report.m_ops().collect()
}

fn resolve_name<'a>(report: &'a DiffReport, op: &DiffOp) -> &'a str {
    let name_id = match op {
        DiffOp::QueryAdded { name } => *name,
        DiffOp::QueryRemoved { name } => *name,
        DiffOp::QueryRenamed { from, .. } => *from,
        DiffOp::QueryDefinitionChanged { name, .. } => *name,
        DiffOp::QueryMetadataChanged { name, .. } => *name,
        _ => panic!("not a query op"),
    };
    &report.strings[name_id.0 as usize]
}

#[test]
fn formatting_only_diff_produces_formatting_only_change() {
    let pkg_a = load_package("m_formatting_only_a.xlsx");
    let pkg_b = load_package("m_formatting_only_b.xlsx");

    let report = pkg_a.diff(&pkg_b, &DiffConfig::default());
    let ops = m_ops(&report);

    let def_changed: Vec<_> = ops
        .iter()
        .filter(|op| matches!(op, DiffOp::QueryDefinitionChanged { .. }))
        .collect();

    assert_eq!(
        def_changed.len(),
        1,
        "formatting-only changes should produce QueryDefinitionChanged with FormattingOnly kind"
    );

    match def_changed[0] {
        DiffOp::QueryDefinitionChanged {
            change_kind,
            old_hash,
            new_hash,
            ..
        } => {
            assert_eq!(
                *change_kind,
                QueryChangeKind::FormattingOnly,
                "formatting-only diff should have FormattingOnly change kind"
            );
            assert_eq!(
                old_hash, new_hash,
                "formatting-only changes have equal canonical hashes"
            );
        }
        _ => unreachable!(),
    }
    assert_eq!(resolve_name(&report, def_changed[0]), "Section1/FormatTest");
}

#[test]
fn semantic_gate_disabled_produces_semantic_change() {
    let pkg_a = load_package("m_formatting_only_a.xlsx");
    let pkg_b = load_package("m_formatting_only_b.xlsx");

    let config = DiffConfig {
        enable_m_semantic_diff: false,
        ..DiffConfig::default()
    };

    let report = pkg_a.diff(&pkg_b, &config);
    let ops = m_ops(&report);

    let def_changed: Vec<_> = ops
        .iter()
        .filter(|op| matches!(op, DiffOp::QueryDefinitionChanged { .. }))
        .collect();

    assert_eq!(
        def_changed.len(),
        1,
        "disabling semantic gate should surface formatting-only differences as Semantic"
    );

    match def_changed[0] {
        DiffOp::QueryDefinitionChanged {
            change_kind,
            old_hash,
            new_hash,
            ..
        } => {
            assert_eq!(
                *change_kind,
                QueryChangeKind::Semantic,
                "with semantic diff disabled, changes are reported as Semantic"
            );
            assert_ne!(
                old_hash, new_hash,
                "textual hashes should differ when semantic diff is disabled"
            );
        }
        _ => unreachable!(),
    }
    assert_eq!(resolve_name(&report, def_changed[0]), "Section1/FormatTest");
}

#[test]
fn formatting_variant_with_real_change_still_reports_semantic() {
    let pkg_b = load_package("m_formatting_only_b.xlsx");
    let pkg_b_variant = load_package("m_formatting_only_b_variant.xlsx");

    let report = pkg_b.diff(&pkg_b_variant, &DiffConfig::default());
    let ops = m_ops(&report);

    let def_changed: Vec<_> = ops
        .iter()
        .filter(|op| matches!(op, DiffOp::QueryDefinitionChanged { .. }))
        .collect();

    assert_eq!(
        def_changed.len(),
        1,
        "expected exactly one diff for semantic change"
    );

    match def_changed[0] {
        DiffOp::QueryDefinitionChanged {
            change_kind,
            old_hash,
            new_hash,
            ..
        } => {
            assert_eq!(
                *change_kind,
                QueryChangeKind::Semantic,
                "real change should be reported as Semantic"
            );
            assert_ne!(
                old_hash, new_hash,
                "semantic changes should have different hashes"
            );
        }
        _ => unreachable!(),
    }
    assert_eq!(resolve_name(&report, def_changed[0]), "Section1/FormatTest");
}

#[test]
fn semantic_gate_does_not_mask_metadata_only_change() {
    let pkg_a = load_package("m_metadata_only_change_a.xlsx");
    let pkg_b = load_package("m_metadata_only_change_b.xlsx");

    let report = pkg_a.diff(&pkg_b, &DiffConfig::default());
    let ops = m_ops(&report);

    let metadata_ops: Vec<_> = ops
        .iter()
        .filter(|op| matches!(op, DiffOp::QueryMetadataChanged { .. }))
        .collect();

    assert!(
        !metadata_ops.is_empty(),
        "expected metadata changes to be reported"
    );
    assert_eq!(resolve_name(&report, metadata_ops[0]), "Section1/Foo");
}

#[test]
fn semantic_gate_does_not_mask_definition_plus_metadata_change() {
    let pkg_a = load_package("m_def_and_metadata_change_a.xlsx");
    let pkg_b = load_package("m_def_and_metadata_change_b.xlsx");

    let report = pkg_a.diff(&pkg_b, &DiffConfig::default());
    let ops = m_ops(&report);

    let has_def_change = ops
        .iter()
        .any(|op| matches!(op, DiffOp::QueryDefinitionChanged { .. }));

    assert!(
        has_def_change,
        "expected QueryDefinitionChanged for definition+metadata change"
    );
}

```

---

### File: `core\tests\m8_m_canonicalize_tokens_tests.rs`

```rust
use excel_diff::{ast_semantically_equal, canonicalize_m_ast, parse_m_expression};

#[test]
fn opaque_boolean_literal_case_is_canonicalized() {
    let a = "if TRUE then 1 else 0";
    let b = "if true then 1 else 0";

    let mut ast_a = parse_m_expression(a).expect("a should parse");
    let mut ast_b = parse_m_expression(b).expect("b should parse");

    canonicalize_m_ast(&mut ast_a);
    canonicalize_m_ast(&mut ast_b);

    assert!(ast_semantically_equal(&ast_a, &ast_b));
}

#[test]
fn opaque_null_literal_case_is_canonicalized() {
    let a = "if NULL then 1 else 0";
    let b = "if null then 1 else 0";

    let mut ast_a = parse_m_expression(a).expect("a should parse");
    let mut ast_b = parse_m_expression(b).expect("b should parse");

    canonicalize_m_ast(&mut ast_a);
    canonicalize_m_ast(&mut ast_b);

    assert!(ast_semantically_equal(&ast_a, &ast_b));
}

```

---

### File: `core\tests\m8_m_parser_coverage_audit_tests.rs`

```rust
use excel_diff::{MAstKind, canonicalize_m_ast, parse_m_expression};

fn assert_opaque(expr: &str) {
    let mut ast = parse_m_expression(expr).expect("expression should parse into an AST container");
    canonicalize_m_ast(&mut ast);
    match ast.root_kind_for_testing() {
        MAstKind::Opaque { token_count } => {
            assert!(token_count > 0, "opaque token_count must be > 0")
        }
        other => panic!("expected Opaque, got {:?}", other),
    }
}

#[test]
fn coverage_audit_unsupported_constructs_are_opaque() {
    let cases = [
        "Source",
        "#\"Previous Step\"",
        "if true then 1 else 0",
        "each _ + 1",
        "(x) => x",
        "1 + 2",
        "not true",
        "Source[Field]",
        "Source{0}",
        "Source{0}[Content]",
        "x as number",
    ];

    for expr in cases {
        assert_opaque(expr);
    }
}

```

---

### File: `core\tests\m8_m_parser_expansion_tests.rs`

```rust
use excel_diff::{MAstKind, ast_semantically_equal, canonicalize_m_ast, parse_m_expression};

#[test]
fn record_literal_parses_as_record() {
    let ast = parse_m_expression("[Field1 = 1, Field2 = 2]").unwrap();
    assert_eq!(
        ast.root_kind_for_testing(),
        MAstKind::Record { field_count: 2 }
    );
}

#[test]
fn list_literal_parses_as_list() {
    let ast = parse_m_expression("{1,2,3}").unwrap();
    assert_eq!(
        ast.root_kind_for_testing(),
        MAstKind::List { item_count: 3 }
    );
}

#[test]
fn function_call_parses_as_call() {
    let ast = parse_m_expression("Table.FromRows(.)").unwrap();
    assert_eq!(
        ast.root_kind_for_testing(),
        MAstKind::FunctionCall {
            name: "Table.FromRows".to_string(),
            arg_count: 1
        }
    );
}

#[test]
fn primitive_string_parses() {
    let ast = parse_m_expression(r#""hello""#).unwrap();
    assert_eq!(ast.root_kind_for_testing(), MAstKind::Primitive);
}

#[test]
fn primitive_number_parses() {
    let ast = parse_m_expression("42").unwrap();
    assert_eq!(ast.root_kind_for_testing(), MAstKind::Primitive);
}

#[test]
fn record_field_order_is_semantically_equivalent() {
    let mut a = parse_m_expression("[B=2, A=1]").unwrap();
    let mut b = parse_m_expression("[A=1, B=2]").unwrap();

    canonicalize_m_ast(&mut a);
    canonicalize_m_ast(&mut b);

    assert!(ast_semantically_equal(&a, &b));
}

#[test]
fn list_order_is_not_semantically_equivalent() {
    let mut a = parse_m_expression("{1,2}").unwrap();
    let mut b = parse_m_expression("{2,1}").unwrap();

    canonicalize_m_ast(&mut a);
    canonicalize_m_ast(&mut b);

    assert!(!ast_semantically_equal(&a, &b));
}

```

---

### File: `core\tests\m8_semantic_m_diff_nonlet_tests.rs`

```rust
use excel_diff::{DiffConfig, DiffOp, QueryChangeKind, WorkbookPackage};
use std::fs::File;

mod common;
use common::fixture_path;

fn load_pkg(name: &str) -> WorkbookPackage {
    let path = fixture_path(name);
    let file = File::open(&path).expect("fixture file should open");
    WorkbookPackage::open(file).expect("fixture should parse")
}

fn m_ops<'a>(ops: &'a [DiffOp]) -> Vec<&'a DiffOp> {
    ops.iter()
        .filter(|op| {
            matches!(
                op,
                DiffOp::QueryAdded { .. }
                    | DiffOp::QueryRemoved { .. }
                    | DiffOp::QueryRenamed { .. }
                    | DiffOp::QueryDefinitionChanged { .. }
            )
        })
        .collect()
}

#[test]
fn record_reorder_is_masked_by_semantic_canonicalization() {
    let a = load_pkg("m_record_equiv_a.xlsx");
    let b = load_pkg("m_record_equiv_b.xlsx");

    let cfg = DiffConfig {
        enable_m_semantic_diff: true,
        ..DiffConfig::default()
    };
    let diff = a.diff(&b, &cfg);

    let ops = m_ops(&diff.ops);
    assert_eq!(ops.len(), 1);

    match ops[0] {
        DiffOp::QueryDefinitionChanged {
            change_kind,
            old_hash,
            new_hash,
            ..
        } => {
            assert_eq!(*change_kind, QueryChangeKind::FormattingOnly);
            assert_eq!(old_hash, new_hash);
        }
        _ => panic!("expected QueryDefinitionChanged"),
    }
}

#[test]
fn list_formatting_only_is_masked() {
    let a = load_pkg("m_list_formatting_a.xlsx");
    let b = load_pkg("m_list_formatting_b.xlsx");

    let cfg = DiffConfig {
        enable_m_semantic_diff: true,
        ..DiffConfig::default()
    };
    let diff = a.diff(&b, &cfg);

    let ops = m_ops(&diff.ops);
    assert_eq!(ops.len(), 1);

    match ops[0] {
        DiffOp::QueryDefinitionChanged {
            change_kind,
            old_hash,
            new_hash,
            ..
        } => {
            assert_eq!(*change_kind, QueryChangeKind::FormattingOnly);
            assert_eq!(old_hash, new_hash);
        }
        _ => panic!("expected QueryDefinitionChanged"),
    }
}

#[test]
fn call_formatting_only_is_masked() {
    let a = load_pkg("m_call_formatting_a.xlsx");
    let b = load_pkg("m_call_formatting_b.xlsx");

    let cfg = DiffConfig {
        enable_m_semantic_diff: true,
        ..DiffConfig::default()
    };
    let diff = a.diff(&b, &cfg);

    let ops = m_ops(&diff.ops);
    assert_eq!(ops.len(), 1);

    match ops[0] {
        DiffOp::QueryDefinitionChanged {
            change_kind,
            old_hash,
            new_hash,
            ..
        } => {
            assert_eq!(*change_kind, QueryChangeKind::FormattingOnly);
            assert_eq!(old_hash, new_hash);
        }
        _ => panic!("expected QueryDefinitionChanged"),
    }
}

#[test]
fn primitive_formatting_only_is_masked() {
    let a = load_pkg("m_primitive_formatting_a.xlsx");
    let b = load_pkg("m_primitive_formatting_b.xlsx");

    let cfg = DiffConfig {
        enable_m_semantic_diff: true,
        ..DiffConfig::default()
    };
    let diff = a.diff(&b, &cfg);

    let ops = m_ops(&diff.ops);
    assert_eq!(ops.len(), 1);

    match ops[0] {
        DiffOp::QueryDefinitionChanged {
            change_kind,
            old_hash,
            new_hash,
            ..
        } => {
            assert_eq!(*change_kind, QueryChangeKind::FormattingOnly);
            assert_eq!(old_hash, new_hash);
        }
        _ => panic!("expected QueryDefinitionChanged"),
    }
}

```

---

### File: `core\tests\m_section_splitting_tests.rs`

```rust
use excel_diff::{SectionParseError, parse_section_members};

const SECTION_SINGLE: &str = r#"
    section Section1;

    shared Foo = 1;
"#;

const SECTION_MULTI: &str = r#"
    section Section1;

    shared Foo = 1;
    shared Bar = 2;
    Baz = 3;
"#;

const SECTION_NOISY: &str = r#"

// Leading comment

section Section1;

// Comment before Foo
shared Foo = 1;

// Another comment

    shared   Bar   =    2    ;

"#;

const SECTION_WITH_BOM: &str = "\u{FEFF}section Section1;\nshared Foo = 1;";

const SECTION_WITH_QUOTED_IDENTIFIER: &str = r#"
    section Section1;

    shared #"Query with space & #" = 1;
"#;

const SECTION_INVALID_SHARED: &str = r#"
    section Section1;

    shared Broken // missing '=' and ';'
"#;

#[test]
fn parse_single_member_section() {
    let members = parse_section_members(SECTION_SINGLE).expect("single member section parses");
    assert_eq!(members.len(), 1);

    let foo = &members[0];
    assert_eq!(foo.section_name, "Section1");
    assert_eq!(foo.member_name, "Foo");
    assert_eq!(foo.expression_m, "1");
    assert!(foo.is_shared);
}

#[test]
fn parse_multiple_members() {
    let members = parse_section_members(SECTION_MULTI).expect("multi-member section parses");
    assert_eq!(members.len(), 2);

    assert_eq!(members[0].member_name, "Foo");
    assert_eq!(members[0].section_name, "Section1");
    assert_eq!(members[0].expression_m, "1");
    assert!(members[0].is_shared);

    assert_eq!(members[1].member_name, "Bar");
    assert_eq!(members[1].section_name, "Section1");
    assert_eq!(members[1].expression_m, "2");
    assert!(members[1].is_shared);
}

#[test]
fn tolerate_whitespace_comments() {
    let members = parse_section_members(SECTION_NOISY).expect("noisy section still parses");
    assert_eq!(members.len(), 2);

    assert_eq!(members[0].member_name, "Foo");
    assert_eq!(members[0].expression_m, "1");
    assert!(members[0].is_shared);
    assert_eq!(members[0].section_name, "Section1");

    assert_eq!(members[1].member_name, "Bar");
    assert_eq!(members[1].expression_m, "2");
    assert!(members[1].is_shared);
    assert_eq!(members[1].section_name, "Section1");
}

#[test]
fn error_on_missing_section_header() {
    const NO_SECTION: &str = r#"
        shared Foo = 1;
    "#;

    let result = parse_section_members(NO_SECTION);
    assert_eq!(result, Err(SectionParseError::MissingSectionHeader));
}

#[test]
fn section_parsing_tolerates_utf8_bom() {
    let members =
        parse_section_members(SECTION_WITH_BOM).expect("BOM-prefixed section should parse");
    assert_eq!(members.len(), 1);

    let member = &members[0];
    assert_eq!(member.member_name, "Foo");
    assert_eq!(member.section_name, "Section1");
    assert_eq!(member.expression_m, "1");
    assert!(member.is_shared);
}

#[test]
fn parse_quoted_identifier_member() {
    let members = parse_section_members(SECTION_WITH_QUOTED_IDENTIFIER)
        .expect("quoted identifier should parse");
    assert_eq!(members.len(), 1);

    let member = &members[0];
    assert_eq!(member.section_name, "Section1");
    assert_eq!(member.member_name, "Query with space & #");
    assert_eq!(member.expression_m, "1");
    assert!(member.is_shared);
}

#[test]
fn error_on_invalid_shared_member_syntax() {
    let result = parse_section_members(SECTION_INVALID_SHARED);
    assert_eq!(result, Err(SectionParseError::InvalidMemberSyntax));
}

```

---

### File: `core\tests\metrics_unit_tests.rs`

```rust
#![cfg(feature = "perf-metrics")]

use excel_diff::perf::{DiffMetrics, Phase};

#[test]
fn metrics_starts_with_zero_counts() {
    let metrics = DiffMetrics::default();
    assert_eq!(metrics.rows_processed, 0);
    assert_eq!(metrics.cells_compared, 0);
    assert_eq!(metrics.anchors_found, 0);
    assert_eq!(metrics.moves_detected, 0);
    assert_eq!(metrics.alignment_time_ms, 0);
    assert_eq!(metrics.move_detection_time_ms, 0);
    assert_eq!(metrics.cell_diff_time_ms, 0);
    assert_eq!(metrics.total_time_ms, 0);
}

#[test]
fn metrics_add_cells_compared_accumulates() {
    let mut metrics = DiffMetrics::default();
    metrics.add_cells_compared(100);
    assert_eq!(metrics.cells_compared, 100);
    metrics.add_cells_compared(50);
    assert_eq!(metrics.cells_compared, 150);
    metrics.add_cells_compared(1000);
    assert_eq!(metrics.cells_compared, 1150);
}

#[test]
fn metrics_add_cells_compared_saturates() {
    let mut metrics = DiffMetrics::default();
    metrics.cells_compared = u64::MAX - 10;
    metrics.add_cells_compared(100);
    assert_eq!(metrics.cells_compared, u64::MAX);
}

#[test]
fn metrics_phase_timing_accumulates() {
    let mut metrics = DiffMetrics::default();

    metrics.start_phase(Phase::Alignment);
    std::thread::sleep(std::time::Duration::from_millis(10));
    metrics.end_phase(Phase::Alignment);

    assert!(
        metrics.alignment_time_ms > 0,
        "alignment_time_ms should be non-zero after timed phase"
    );

    let first_alignment = metrics.alignment_time_ms;

    metrics.start_phase(Phase::Alignment);
    std::thread::sleep(std::time::Duration::from_millis(10));
    metrics.end_phase(Phase::Alignment);

    assert!(
        metrics.alignment_time_ms > first_alignment,
        "alignment_time_ms should accumulate across multiple phases"
    );
}

#[test]
fn metrics_different_phases_tracked_separately() {
    let mut metrics = DiffMetrics::default();

    metrics.start_phase(Phase::Alignment);
    std::thread::sleep(std::time::Duration::from_millis(5));
    metrics.end_phase(Phase::Alignment);

    metrics.start_phase(Phase::MoveDetection);
    std::thread::sleep(std::time::Duration::from_millis(5));
    metrics.end_phase(Phase::MoveDetection);

    metrics.start_phase(Phase::CellDiff);
    std::thread::sleep(std::time::Duration::from_millis(5));
    metrics.end_phase(Phase::CellDiff);

    assert!(metrics.alignment_time_ms > 0, "alignment should be tracked");
    assert!(
        metrics.move_detection_time_ms > 0,
        "move detection should be tracked"
    );
    assert!(metrics.cell_diff_time_ms > 0, "cell diff should be tracked");
}

#[test]
fn metrics_total_phase_separate_from_components() {
    let mut metrics = DiffMetrics::default();

    metrics.start_phase(Phase::Total);
    metrics.start_phase(Phase::Alignment);
    std::thread::sleep(std::time::Duration::from_millis(10));
    metrics.end_phase(Phase::Alignment);
    metrics.end_phase(Phase::Total);

    assert!(metrics.alignment_time_ms > 0);
    assert!(metrics.total_time_ms > 0);
    assert!(
        metrics.total_time_ms >= metrics.alignment_time_ms,
        "total should be >= alignment since it wraps alignment"
    );
}

#[test]
fn metrics_end_phase_without_start_is_safe() {
    let mut metrics = DiffMetrics::default();
    metrics.end_phase(Phase::Alignment);
    assert_eq!(metrics.alignment_time_ms, 0);
}

#[test]
fn metrics_parse_phase_is_no_op() {
    let mut metrics = DiffMetrics::default();
    metrics.start_phase(Phase::Parse);
    std::thread::sleep(std::time::Duration::from_millis(5));
    metrics.end_phase(Phase::Parse);
    assert_eq!(metrics.alignment_time_ms, 0);
    assert_eq!(metrics.move_detection_time_ms, 0);
    assert_eq!(metrics.cell_diff_time_ms, 0);
    assert_eq!(metrics.total_time_ms, 0);
}

#[test]
fn metrics_rows_processed_can_be_set_directly() {
    let mut metrics = DiffMetrics::default();
    metrics.rows_processed = 5000;
    assert_eq!(metrics.rows_processed, 5000);
    metrics.rows_processed = metrics.rows_processed.saturating_add(3000);
    assert_eq!(metrics.rows_processed, 8000);
}

#[test]
fn metrics_anchors_and_moves_can_be_set() {
    let mut metrics = DiffMetrics::default();
    metrics.anchors_found = 150;
    metrics.moves_detected = 3;
    assert_eq!(metrics.anchors_found, 150);
    assert_eq!(metrics.moves_detected, 3);
}

#[test]
fn metrics_clone_creates_independent_copy() {
    let mut metrics = DiffMetrics::default();
    metrics.rows_processed = 1000;
    metrics.cells_compared = 500;

    let cloned = metrics.clone();
    metrics.rows_processed = 2000;

    assert_eq!(cloned.rows_processed, 1000);
    assert_eq!(metrics.rows_processed, 2000);
}

#[test]
fn metrics_default_equality() {
    let m1 = DiffMetrics::default();
    let m2 = DiffMetrics::default();
    assert_eq!(m1, m2);
}

```

---

### File: `core\tests\output_tests.rs`

```rust
mod common;

use common::{fixture_path, open_fixture_workbook};
use excel_diff::{
    CellAddress, CellDiff, CellSnapshot, CellValue, ContainerError, DiffConfig, DiffOp, DiffReport,
    FormulaDiffResult, PackageError, WorkbookPackage, diff_report_to_cell_diffs,
    diff_workbooks_to_json, serialize_cell_diffs, serialize_diff_report,
};
use serde_json::Value;
#[cfg(feature = "perf-metrics")]
use std::collections::BTreeSet;

fn sid_local(pool: &mut excel_diff::StringPool, value: &str) -> excel_diff::StringId {
    pool.intern(value)
}

fn attach_strings(mut report: DiffReport, pool: excel_diff::StringPool) -> DiffReport {
    report.strings = pool.into_strings();
    report
}

fn render_value(report: &DiffReport, value: &Option<excel_diff::CellValue>) -> Option<String> {
    match value {
        Some(excel_diff::CellValue::Number(n)) => Some(n.to_string()),
        Some(excel_diff::CellValue::Text(id)) => report.strings.get(id.0 as usize).cloned(),
        Some(excel_diff::CellValue::Bool(b)) => Some(b.to_string()),
        Some(excel_diff::CellValue::Error(id)) => report.strings.get(id.0 as usize).cloned(),
        Some(excel_diff::CellValue::Blank) => Some(String::new()),
        None => None,
    }
}

fn make_cell_snapshot(addr: CellAddress, value: Option<CellValue>) -> CellSnapshot {
    CellSnapshot {
        addr,
        value,
        formula: None,
    }
}

fn cell_edit(
    sheet: excel_diff::StringId,
    addr: CellAddress,
    from: CellSnapshot,
    to: CellSnapshot,
) -> DiffOp {
    DiffOp::cell_edited(sheet, addr, from, to, FormulaDiffResult::Unchanged)
}

fn numeric_report(addr: CellAddress, from: f64, to: f64) -> DiffReport {
    let mut pool = excel_diff::StringPool::new();
    let sheet = sid_local(&mut pool, "Sheet1");
    attach_strings(
        DiffReport::new(vec![cell_edit(
            sheet,
            addr,
            make_cell_snapshot(addr, Some(CellValue::Number(from))),
            make_cell_snapshot(addr, Some(CellValue::Number(to))),
        )]),
        pool,
    )
}

#[test]
fn diff_report_to_cell_diffs_filters_non_cell_ops() {
    let mut pool = excel_diff::StringPool::new();
    let sheet_added = sid_local(&mut pool, "SheetAdded");
    let sheet1 = sid_local(&mut pool, "Sheet1");
    let sheet2 = sid_local(&mut pool, "Sheet2");
    let old_sheet = sid_local(&mut pool, "OldSheet");
    let old_text = sid_local(&mut pool, "old");
    let new_text = sid_local(&mut pool, "new");
    let addr1 = CellAddress::from_indices(0, 0);
    let addr2 = CellAddress::from_indices(1, 1);

    let report = attach_strings(
        DiffReport::new(vec![
            DiffOp::SheetAdded { sheet: sheet_added },
            cell_edit(
                sheet1,
                addr1,
                make_cell_snapshot(addr1, Some(CellValue::Number(1.0))),
                make_cell_snapshot(addr1, Some(CellValue::Number(2.0))),
            ),
            DiffOp::RowAdded {
                sheet: sheet1,
                row_idx: 5,
                row_signature: None,
            },
            cell_edit(
                sheet2,
                addr2,
                make_cell_snapshot(addr2, Some(CellValue::Text(old_text))),
                make_cell_snapshot(addr2, Some(CellValue::Text(new_text))),
            ),
            DiffOp::SheetRemoved { sheet: old_sheet },
        ]),
        pool,
    );

    let cell_diffs = diff_report_to_cell_diffs(&report);
    assert_eq!(
        cell_diffs.len(),
        2,
        "only CellEdited ops should be projected"
    );

    assert_eq!(cell_diffs[0].coords, addr1.to_a1());
    assert_eq!(cell_diffs[0].value_file1, Some("1".into()));
    assert_eq!(cell_diffs[0].value_file2, Some("2".into()));

    assert_eq!(cell_diffs[1].coords, addr2.to_a1());
    assert_eq!(cell_diffs[1].value_file1, Some("old".into()));
    assert_eq!(cell_diffs[1].value_file2, Some("new".into()));
}

#[test]
fn diff_report_to_cell_diffs_ignores_block_moved_rect() {
    let mut pool = excel_diff::StringPool::new();
    let sheet1 = sid_local(&mut pool, "Sheet1");
    let addr = CellAddress::from_indices(2, 2);

    let report = attach_strings(
        DiffReport::new(vec![
            DiffOp::block_moved_rect(sheet1, 2, 3, 1, 3, 9, 6, Some(0xCAFEBABE)),
            cell_edit(
                sheet1,
                addr,
                make_cell_snapshot(addr, Some(CellValue::Number(10.0))),
                make_cell_snapshot(addr, Some(CellValue::Number(20.0))),
            ),
            DiffOp::BlockMovedRows {
                sheet: sheet1,
                src_start_row: 0,
                row_count: 2,
                dst_start_row: 5,
                block_hash: None,
            },
            DiffOp::BlockMovedColumns {
                sheet: sheet1,
                src_start_col: 0,
                col_count: 2,
                dst_start_col: 5,
                block_hash: None,
            },
        ]),
        pool,
    );

    let cell_diffs = diff_report_to_cell_diffs(&report);
    assert_eq!(
        cell_diffs.len(),
        1,
        "only CellEdited should be projected; BlockMovedRect and other block moves should be ignored"
    );

    assert_eq!(cell_diffs[0].coords, addr.to_a1());
    assert_eq!(cell_diffs[0].value_file1, Some("10".into()));
    assert_eq!(cell_diffs[0].value_file2, Some("20".into()));
}

#[test]
fn diff_report_to_cell_diffs_maps_values_correctly() {
    let mut pool = excel_diff::StringPool::new();
    let sheet_id = sid_local(&mut pool, "SheetX");
    let addr_num = CellAddress::from_indices(2, 2); // C3
    let addr_bool = CellAddress::from_indices(3, 3); // D4

    let report = attach_strings(
        DiffReport::new(vec![
            cell_edit(
                sheet_id,
                addr_num,
                make_cell_snapshot(addr_num, Some(CellValue::Number(42.5))),
                make_cell_snapshot(addr_num, Some(CellValue::Number(43.5))),
            ),
            cell_edit(
                sheet_id,
                addr_bool,
                make_cell_snapshot(addr_bool, Some(CellValue::Bool(true))),
                make_cell_snapshot(addr_bool, Some(CellValue::Bool(false))),
            ),
        ]),
        pool,
    );

    let cell_diffs = diff_report_to_cell_diffs(&report);
    assert_eq!(cell_diffs.len(), 2);

    let number_diff = &cell_diffs[0];
    assert_eq!(number_diff.coords, addr_num.to_a1());
    assert_eq!(number_diff.value_file1, Some("42.5".into()));
    assert_eq!(number_diff.value_file2, Some("43.5".into()));

    let bool_diff = &cell_diffs[1];
    assert_eq!(bool_diff.coords, addr_bool.to_a1());
    assert_eq!(bool_diff.value_file1, Some("true".into()));
    assert_eq!(bool_diff.value_file2, Some("false".into()));
}

#[test]
fn diff_report_to_cell_diffs_filters_no_op_cell_edits() {
    let mut pool = excel_diff::StringPool::new();
    let sheet = sid_local(&mut pool, "Sheet1");
    let addr_a1 = CellAddress::from_indices(0, 0);
    let addr_a2 = CellAddress::from_indices(1, 0);

    let report = attach_strings(
        DiffReport::new(vec![
            cell_edit(
                sheet,
                addr_a1,
                make_cell_snapshot(addr_a1, Some(CellValue::Number(1.0))),
                make_cell_snapshot(addr_a1, Some(CellValue::Number(1.0))),
            ),
            cell_edit(
                sheet,
                addr_a2,
                make_cell_snapshot(addr_a2, Some(CellValue::Number(1.0))),
                make_cell_snapshot(addr_a2, Some(CellValue::Number(2.0))),
            ),
        ]),
        pool,
    );

    let diffs = diff_report_to_cell_diffs(&report);

    assert_eq!(diffs.len(), 1);
    assert_eq!(diffs[0].coords, "A2");
    assert_eq!(diffs[0].value_file1, Some("1".to_string()));
    assert_eq!(diffs[0].value_file2, Some("2".to_string()));
}

#[test]
fn test_json_format() {
    let diffs = vec![
        CellDiff {
            coords: "A1".into(),
            value_file1: Some("100".into()),
            value_file2: Some("200".into()),
        },
        CellDiff {
            coords: "B2".into(),
            value_file1: Some("true".into()),
            value_file2: Some("false".into()),
        },
        CellDiff {
            coords: "C3".into(),
            value_file1: Some("#DIV/0!".into()),
            value_file2: None,
        },
    ];

    let json = serialize_cell_diffs(&diffs).expect("serialization should succeed");
    let value: Value = serde_json::from_str(&json).expect("json should parse");

    assert!(value.is_array(), "expected an array of cell diffs");
    let arr = value
        .as_array()
        .expect("top-level json should be an array of cell diffs");
    assert_eq!(arr.len(), 3);

    let first = &arr[0];
    assert_eq!(first["coords"], Value::String("A1".into()));
    assert_eq!(first["value_file1"], Value::String("100".into()));
    assert_eq!(first["value_file2"], Value::String("200".into()));

    let second = &arr[1];
    assert_eq!(second["coords"], Value::String("B2".into()));
    assert_eq!(second["value_file1"], Value::String("true".into()));
    assert_eq!(second["value_file2"], Value::String("false".into()));

    let third = &arr[2];
    assert_eq!(third["coords"], Value::String("C3".into()));
    assert_eq!(third["value_file1"], Value::String("#DIV/0!".into()));
    assert_eq!(third["value_file2"], Value::Null);
}

#[test]
fn test_json_empty_diff() {
    let fixture = fixture_path("pg1_basic_two_sheets.xlsx");
    let json = diff_workbooks_to_json(&fixture, &fixture, &DiffConfig::default())
        .expect("diffing identical files should succeed");
    let report: DiffReport = serde_json::from_str(&json).expect("json should parse");
    assert!(
        report.ops.is_empty(),
        "identical files should produce no diff ops"
    );
}

#[test]
fn test_json_non_empty_diff() {
    let a = fixture_path("json_diff_single_cell_a.xlsx");
    let b = fixture_path("json_diff_single_cell_b.xlsx");

    let json = diff_workbooks_to_json(&a, &b, &DiffConfig::default())
        .expect("diffing different files should succeed");
    let report: DiffReport = serde_json::from_str(&json).expect("json should parse");
    assert_eq!(report.ops.len(), 1, "expected a single diff op");
    match &report.ops[0] {
        DiffOp::CellEdited { addr, from, to, .. } => {
            assert_eq!(addr.to_a1(), "C3");
            assert_eq!(render_value(&report, &from.value), Some("1".into()));
            assert_eq!(render_value(&report, &to.value), Some("2".into()));
        }
        other => panic!("expected CellEdited, got {other:?}"),
    }
}

#[test]
fn test_json_non_empty_diff_bool() {
    let a = fixture_path("json_diff_bool_a.xlsx");
    let b = fixture_path("json_diff_bool_b.xlsx");

    let json = diff_workbooks_to_json(&a, &b, &DiffConfig::default())
        .expect("diffing different files should succeed");
    let report: DiffReport = serde_json::from_str(&json).expect("json should parse");
    assert_eq!(report.ops.len(), 1, "expected a single diff op");
    match &report.ops[0] {
        DiffOp::CellEdited { addr, from, to, .. } => {
            assert_eq!(addr.to_a1(), "C3");
            assert_eq!(render_value(&report, &from.value), Some("true".into()));
            assert_eq!(render_value(&report, &to.value), Some("false".into()));
        }
        other => panic!("expected CellEdited, got {other:?}"),
    }
}

#[test]
fn test_json_diff_value_to_empty() {
    let a = fixture_path("json_diff_value_to_empty_a.xlsx");
    let b = fixture_path("json_diff_value_to_empty_b.xlsx");

    let json = diff_workbooks_to_json(&a, &b, &DiffConfig::default())
        .expect("diffing different files should succeed");
    let report: DiffReport = serde_json::from_str(&json).expect("json should parse");
    assert_eq!(report.ops.len(), 1, "expected a single diff op");
    match &report.ops[0] {
        DiffOp::CellEdited { addr, from, to, .. } => {
            assert_eq!(addr.to_a1(), "C3");
            assert_eq!(render_value(&report, &from.value), Some("1".into()));
            assert_eq!(render_value(&report, &to.value), None);
        }
        other => panic!("expected CellEdited, got {other:?}"),
    }
}

#[test]
fn json_diff_case_only_sheet_name_no_changes() {
    let old = open_fixture_workbook("sheet_case_only_rename_a.xlsx");
    let new = open_fixture_workbook("sheet_case_only_rename_b.xlsx");

    let report =
        WorkbookPackage::from(old).diff(&WorkbookPackage::from(new), &DiffConfig::default());
    assert!(
        report.ops.is_empty(),
        "case-only sheet rename with identical content should produce no diff ops"
    );
}

#[test]
fn json_diff_case_only_sheet_name_cell_edit() {
    let old = open_fixture_workbook("sheet_case_only_rename_edit_a.xlsx");
    let new = open_fixture_workbook("sheet_case_only_rename_edit_b.xlsx");

    let report =
        WorkbookPackage::from(old).diff(&WorkbookPackage::from(new), &DiffConfig::default());
    assert_eq!(report.ops.len(), 1, "expected a single cell edit");
    match &report.ops[0] {
        DiffOp::CellEdited {
            sheet,
            addr,
            from,
            to,
            ..
        } => {
            assert_eq!(
                report.strings.get(sheet.0 as usize),
                Some(&"Sheet1".to_string())
            );
            assert_eq!(addr.to_a1(), "A1");
            assert_eq!(render_value(&report, &from.value), Some("1".into()));
            assert_eq!(render_value(&report, &to.value), Some("2".into()));
        }
        other => panic!("expected CellEdited, got {other:?}"),
    }
}

#[test]
fn test_json_case_only_sheet_name_no_changes() {
    let a = fixture_path("sheet_case_only_rename_a.xlsx");
    let b = fixture_path("sheet_case_only_rename_b.xlsx");

    let json = diff_workbooks_to_json(&a, &b, &DiffConfig::default())
        .expect("diffing case-only sheet rename should succeed");
    let report: DiffReport = serde_json::from_str(&json).expect("json should parse");
    assert!(
        report.ops.is_empty(),
        "case-only sheet rename with identical content should serialize to no ops"
    );
}

#[test]
fn test_json_case_only_sheet_name_cell_edit_via_helper() {
    let a = fixture_path("sheet_case_only_rename_edit_a.xlsx");
    let b = fixture_path("sheet_case_only_rename_edit_b.xlsx");

    let json = diff_workbooks_to_json(&a, &b, &DiffConfig::default())
        .expect("diffing case-only sheet rename with cell edit should succeed");
    let report: DiffReport = serde_json::from_str(&json).expect("json should parse");
    assert_eq!(report.ops.len(), 1, "expected a single cell edit");

    match &report.ops[0] {
        DiffOp::CellEdited {
            sheet,
            addr,
            from,
            to,
            ..
        } => {
            assert_eq!(
                report.strings.get(sheet.0 as usize),
                Some(&"Sheet1".to_string())
            );
            assert_eq!(addr.to_a1(), "A1");
            assert_eq!(render_value(&report, &from.value), Some("1".into()));
            assert_eq!(render_value(&report, &to.value), Some("2".into()));
        }
        other => panic!("expected CellEdited, got {other:?}"),
    }
}

#[test]
fn test_diff_workbooks_to_json_reports_invalid_zip() {
    let path = fixture_path("not_a_zip.txt");
    let err = diff_workbooks_to_json(&path, &path, &DiffConfig::default())
        .expect_err("diffing invalid containers should return an error");

    let inner = match err {
        PackageError::WithPath { source, .. } => *source,
        other => other,
    };
    assert!(
        matches!(inner, PackageError::Container(ContainerError::NotZipContainer)),
        "expected container error, got {inner:?}"
    );
}

#[test]
fn serialize_diff_report_nan_maps_to_serialization_error() {
    let addr = CellAddress::from_indices(0, 0);
    let report = numeric_report(addr, f64::NAN, 1.0);

    let err = serialize_diff_report(&report).expect_err("NaN should fail to serialize");
    let wrapped = PackageError::SerializationError(err.to_string());

    match wrapped {
        PackageError::SerializationError(msg) => {
            assert!(
                msg.to_lowercase().contains("nan"),
                "error message should mention NaN for clarity"
            );
        }
        other => panic!("expected SerializationError, got {other:?}"),
    }
}

#[test]
fn serialize_diff_report_infinity_maps_to_serialization_error() {
    let addr = CellAddress::from_indices(0, 0);
    let report = numeric_report(addr, f64::INFINITY, 1.0);

    let err = serialize_diff_report(&report).expect_err("Infinity should fail to serialize");
    let wrapped = PackageError::SerializationError(err.to_string());
    match wrapped {
        PackageError::SerializationError(msg) => {
            assert!(
                msg.to_lowercase().contains("infinity"),
                "error message should mention infinity for clarity"
            );
        }
        other => panic!("expected SerializationError, got {other:?}"),
    }
}

#[test]
fn serialize_diff_report_neg_infinity_maps_to_serialization_error() {
    let addr = CellAddress::from_indices(0, 0);
    let report = numeric_report(addr, f64::NEG_INFINITY, 1.0);

    let err = serialize_diff_report(&report).expect_err("NEG_INFINITY should fail to serialize");
    let wrapped = PackageError::SerializationError(err.to_string());
    match wrapped {
        PackageError::SerializationError(msg) => {
            assert!(
                msg.to_lowercase().contains("infinity"),
                "error message should mention infinity for clarity"
            );
        }
        other => panic!("expected SerializationError, got {other:?}"),
    }
}

#[test]
fn serialize_diff_report_with_finite_numbers_succeeds() {
    let addr = CellAddress::from_indices(1, 1);
    let report = numeric_report(addr, 2.5, 3.5);

    let json = serialize_diff_report(&report).expect("finite values should serialize");
    let parsed: DiffReport = serde_json::from_str(&json).expect("json should parse");
    assert_eq!(parsed.ops.len(), 1);
}

#[test]
fn serialize_full_diff_report_has_complete_true_and_no_warnings() {
    let addr = CellAddress::from_indices(0, 0);
    let report = numeric_report(addr, 1.0, 2.0);

    let json = serialize_diff_report(&report).expect("full report should serialize");
    let value: Value = serde_json::from_str(&json).expect("json should parse");
    let obj = value.as_object().expect("should be object");

    assert_eq!(
        obj.get("complete").and_then(Value::as_bool),
        Some(true),
        "full result should have complete=true"
    );

    let has_warnings = obj
        .get("warnings")
        .map(|v| v.as_array().map(|arr| !arr.is_empty()).unwrap_or(false))
        .unwrap_or(false);
    assert!(
        !has_warnings,
        "full result should have no warnings or empty warnings array"
    );
}

#[test]
fn serialize_partial_diff_report_includes_complete_false_and_warnings() {
    let addr = CellAddress::from_indices(0, 0);
    let mut pool = excel_diff::StringPool::new();
    let sheet = sid_local(&mut pool, "Sheet1");
    let ops = vec![cell_edit(
        sheet,
        addr,
        make_cell_snapshot(addr, Some(CellValue::Number(1.0))),
        make_cell_snapshot(addr, Some(CellValue::Number(2.0))),
    )];
    let report = attach_strings(
        DiffReport::with_partial_result(
            ops,
            "Sheet 'LargeSheet': alignment limits exceeded".to_string(),
        ),
        pool,
    );

    let json = serialize_diff_report(&report).expect("partial report should serialize");
    let value: Value = serde_json::from_str(&json).expect("json should parse");
    let obj = value.as_object().expect("should be object");

    assert_eq!(
        obj.get("complete").and_then(Value::as_bool),
        Some(false),
        "partial result should have complete=false"
    );

    let warnings = obj
        .get("warnings")
        .and_then(Value::as_array)
        .expect("warnings should be present");
    assert!(!warnings.is_empty(), "warnings array should not be empty");
    assert!(
        warnings[0]
            .as_str()
            .unwrap_or("")
            .contains("limits exceeded"),
        "warning should mention limits exceeded"
    );
}

#[test]
#[cfg(feature = "perf-metrics")]
fn serialize_diff_report_with_metrics_includes_metrics_object() {
    use excel_diff::perf::DiffMetrics;

    let addr = CellAddress::from_indices(0, 0);
    let mut pool = excel_diff::StringPool::new();
    let sheet = sid_local(&mut pool, "Sheet1");
    let ops = vec![cell_edit(
        sheet,
        addr,
        make_cell_snapshot(addr, Some(CellValue::Number(1.0))),
        make_cell_snapshot(addr, Some(CellValue::Number(2.0))),
    )];

    let mut report = attach_strings(DiffReport::new(ops), pool);
    let mut metrics = DiffMetrics::default();
    metrics.move_detection_time_ms = 5;
    metrics.alignment_time_ms = 10;
    metrics.cell_diff_time_ms = 15;
    metrics.total_time_ms = 30;
    metrics.rows_processed = 500;
    metrics.cells_compared = 2500;
    metrics.anchors_found = 25;
    metrics.moves_detected = 1;
    report.metrics = Some(metrics);

    let json = serialize_diff_report(&report).expect("report with metrics should serialize");
    let value: Value = serde_json::from_str(&json).expect("json should parse");
    let obj = value.as_object().expect("should be object");

    let keys: BTreeSet<String> = obj.keys().cloned().collect();
    assert!(
        keys.contains("metrics"),
        "serialized report should include metrics key"
    );

    let metrics_obj = obj
        .get("metrics")
        .and_then(Value::as_object)
        .expect("metrics should be an object");

    assert!(
        metrics_obj.contains_key("move_detection_time_ms"),
        "metrics should contain move_detection_time_ms"
    );
    assert!(
        metrics_obj.contains_key("alignment_time_ms"),
        "metrics should contain alignment_time_ms"
    );
    assert!(
        metrics_obj.contains_key("cell_diff_time_ms"),
        "metrics should contain cell_diff_time_ms"
    );
    assert!(
        metrics_obj.contains_key("total_time_ms"),
        "metrics should contain total_time_ms"
    );
    assert!(
        metrics_obj.contains_key("rows_processed"),
        "metrics should contain rows_processed"
    );
    assert!(
        metrics_obj.contains_key("cells_compared"),
        "metrics should contain cells_compared"
    );
    assert!(
        metrics_obj.contains_key("anchors_found"),
        "metrics should contain anchors_found"
    );
    assert!(
        metrics_obj.contains_key("moves_detected"),
        "metrics should contain moves_detected"
    );

    assert_eq!(
        metrics_obj.get("rows_processed").and_then(Value::as_u64),
        Some(500)
    );
    assert_eq!(
        metrics_obj.get("cells_compared").and_then(Value::as_u64),
        Some(2500)
    );
}

```

---

### File: `core\tests\package_streaming_tests.rs`

```rust
use excel_diff::{
    CellValue, DataMashup, DiffConfig, DiffError, DiffOp, DiffSink, Grid, JsonLinesSink, Metadata,
    PackageParts, PackageXml, Permissions, SectionDocument, Sheet, SheetKind, StringId, Workbook,
    WorkbookPackage,
};
use serde::Deserialize;

#[derive(Default)]
struct StrictSink {
    finished: bool,
    finish_calls: usize,
    ops: Vec<DiffOp>,
}

impl DiffSink for StrictSink {
    fn emit(&mut self, op: DiffOp) -> Result<(), DiffError> {
        if self.finished {
            return Err(DiffError::SinkError {
                message: "emit called after finish".to_string(),
            });
        }
        self.ops.push(op);
        Ok(())
    }

    fn finish(&mut self) -> Result<(), DiffError> {
        self.finish_calls += 1;
        self.finished = true;
        Ok(())
    }
}

fn make_dm(section_source: &str) -> DataMashup {
    DataMashup {
        version: 0,
        package_parts: PackageParts {
            package_xml: PackageXml {
                raw_xml: "<Package/>".to_string(),
            },
            main_section: SectionDocument {
                source: section_source.to_string(),
            },
            embedded_contents: Vec::new(),
        },
        permissions: Permissions::default(),
        metadata: Metadata {
            formulas: Vec::new(),
        },
        permission_bindings_raw: Vec::new(),
    }
}

fn make_workbook(sheet_name: &str) -> Workbook {
    let sheet_id = excel_diff::with_default_session(|session| session.strings.intern(sheet_name));

    Workbook {
        sheets: vec![Sheet {
            name: sheet_id,
            kind: SheetKind::Worksheet,
            grid: Grid::new(0, 0),
        }],
        ..Default::default()
    }
}

#[test]
fn package_diff_streaming_does_not_emit_after_finish_and_finishes_once() {
    let wb = make_workbook("Sheet1");

    let dm_a = make_dm("section Section1;\nshared Foo = 1;");
    let dm_b = make_dm("section Section1;\nshared Bar = 1;");

    let pkg_a = WorkbookPackage {
        workbook: wb.clone(),
        data_mashup: Some(dm_a),
        vba_modules: None,
    };
    let pkg_b = WorkbookPackage {
        workbook: wb,
        data_mashup: Some(dm_b),
        vba_modules: None,
    };

    let mut sink = StrictSink::default();
    let summary = pkg_a
        .diff_streaming(&pkg_b, &DiffConfig::default(), &mut sink)
        .expect("diff_streaming should succeed");

    assert!(sink.finished, "sink should be finished at end");
    assert_eq!(
        sink.finish_calls, 1,
        "sink.finish() should be called exactly once"
    );

    assert!(
        sink.ops.iter().any(|op| op.is_m_op()),
        "expected at least one M diff op in streaming output"
    );

    assert_eq!(
        summary.op_count,
        sink.ops.len(),
        "summary.op_count should match ops actually emitted"
    );
}

#[test]
fn package_diff_streaming_finishes_on_error() {
    struct FailingSink {
        calls: usize,
        finish_called: bool,
    }

    impl DiffSink for FailingSink {
        fn emit(&mut self, _op: DiffOp) -> Result<(), DiffError> {
            self.calls += 1;
            if self.calls > 2 {
                return Err(DiffError::SinkError {
                    message: "intentional failure".to_string(),
                });
            }
            Ok(())
        }

        fn finish(&mut self) -> Result<(), DiffError> {
            self.finish_called = true;
            Ok(())
        }
    }

    let sheet_id = excel_diff::with_default_session(|session| session.strings.intern("Sheet1"));

    let mut grid_a = Grid::new(10, 1);
    let mut grid_b = Grid::new(10, 1);
    for i in 0..10 {
        grid_a.insert_cell(i, 0, Some(excel_diff::CellValue::Number(i as f64)), None);
        grid_b.insert_cell(
            i,
            0,
            Some(excel_diff::CellValue::Number((i + 100) as f64)),
            None,
        );
    }

    let wb_a = Workbook {
        sheets: vec![Sheet {
            name: sheet_id,
            kind: SheetKind::Worksheet,
            grid: grid_a,
        }],
        ..Default::default()
    };
    let wb_b = Workbook {
        sheets: vec![Sheet {
            name: sheet_id,
            kind: SheetKind::Worksheet,
            grid: grid_b,
        }],
        ..Default::default()
    };

    let pkg_a = WorkbookPackage {
        workbook: wb_a,
        data_mashup: None,
        vba_modules: None,
    };
    let pkg_b = WorkbookPackage {
        workbook: wb_b,
        data_mashup: None,
        vba_modules: None,
    };

    let mut sink = FailingSink {
        calls: 0,
        finish_called: false,
    };

    let result = pkg_a.diff_streaming(&pkg_b, &DiffConfig::default(), &mut sink);
    assert!(result.is_err(), "diff_streaming should return error");
    assert!(
        sink.finish_called,
        "sink.finish() should be called on error"
    );
}

#[test]
fn package_diff_streaming_finishes_on_m_emit_error() {
    struct FailOnMOpSink {
        finish_called: bool,
        finish_calls: usize,
    }

    impl DiffSink for FailOnMOpSink {
        fn emit(&mut self, op: DiffOp) -> Result<(), DiffError> {
            if op.is_m_op() {
                return Err(DiffError::SinkError {
                    message: "fail on m op".to_string(),
                });
            }
            Ok(())
        }

        fn finish(&mut self) -> Result<(), DiffError> {
            self.finish_calls += 1;
            self.finish_called = true;
            Ok(())
        }
    }

    let wb = make_workbook("Sheet1");

    let dm_a = make_dm("section Section1;\nshared Foo = 1;");
    let dm_b = make_dm("section Section1;\nshared Bar = 1;");

    let pkg_a = WorkbookPackage {
        workbook: wb.clone(),
        data_mashup: Some(dm_a),
        vba_modules: None,
    };
    let pkg_b = WorkbookPackage {
        workbook: wb,
        data_mashup: Some(dm_b),
        vba_modules: None,
    };

    let mut sink = FailOnMOpSink {
        finish_called: false,
        finish_calls: 0,
    };

    let result = pkg_a.diff_streaming(&pkg_b, &DiffConfig::default(), &mut sink);

    assert!(result.is_err(), "expected sink error during M op emission");
    assert!(
        sink.finish_called,
        "sink.finish() should be called on M emit error"
    );
    assert_eq!(sink.finish_calls, 1, "finish should be called exactly once");
}

#[test]
fn package_streaming_json_lines_header_includes_m_strings() {
    #[derive(Deserialize)]
    struct Header {
        kind: String,
        strings: Vec<String>,
    }

    fn collect_string_ids(op: &DiffOp) -> Vec<StringId> {
        fn collect_cell_value(ids: &mut Vec<StringId>, value: &CellValue) {
            match value {
                CellValue::Text(id) | CellValue::Error(id) => ids.push(*id),
                CellValue::Number(_) | CellValue::Bool(_) | CellValue::Blank => {}
            }
        }

        fn collect_snapshot(ids: &mut Vec<StringId>, snap: &excel_diff::CellSnapshot) {
            if let Some(value) = &snap.value {
                collect_cell_value(ids, value);
            }
            if let Some(formula) = snap.formula {
                ids.push(formula);
            }
        }

        let mut ids = Vec::new();
        match op {
            DiffOp::SheetAdded { sheet } | DiffOp::SheetRemoved { sheet } => ids.push(*sheet),
            DiffOp::RowAdded { sheet, .. } | DiffOp::RowRemoved { sheet, .. } => ids.push(*sheet),
            DiffOp::ColumnAdded { sheet, .. } | DiffOp::ColumnRemoved { sheet, .. } => {
                ids.push(*sheet);
            }
            DiffOp::BlockMovedRows { sheet, .. }
            | DiffOp::BlockMovedColumns { sheet, .. }
            | DiffOp::BlockMovedRect { sheet, .. } => ids.push(*sheet),
            DiffOp::CellEdited {
                sheet, from, to, ..
            } => {
                ids.push(*sheet);
                collect_snapshot(&mut ids, from);
                collect_snapshot(&mut ids, to);
            }
            DiffOp::QueryAdded { name }
            | DiffOp::QueryRemoved { name }
            | DiffOp::QueryDefinitionChanged { name, .. } => ids.push(*name),
            DiffOp::QueryRenamed { from, to } => {
                ids.push(*from);
                ids.push(*to);
            }
            DiffOp::QueryMetadataChanged { name, old, new, .. } => {
                ids.push(*name);
                ids.extend(old.iter().copied());
                ids.extend(new.iter().copied());
            }
            _ => {}
        }
        ids
    }

    let wb = make_workbook("Sheet1");

    let dm_a = make_dm("section Section1;\nshared Foo = 1;");
    let dm_b = make_dm("section Section1;\nshared Bar = 1;");

    let pkg_a = WorkbookPackage {
        workbook: wb.clone(),
        data_mashup: Some(dm_a),
        vba_modules: None,
    };
    let pkg_b = WorkbookPackage {
        workbook: wb,
        data_mashup: Some(dm_b),
        vba_modules: None,
    };

    let mut out = Vec::<u8>::new();
    let mut sink = JsonLinesSink::new(&mut out);

    let summary = pkg_a
        .diff_streaming(&pkg_b, &DiffConfig::default(), &mut sink)
        .expect("diff_streaming should succeed");

    let text = std::str::from_utf8(&out).expect("output should be valid UTF-8");
    let mut lines = text.lines().filter(|l| !l.trim().is_empty());
    let header_line = lines.next().expect("expected a JSON Lines header line");
    let header: Header = serde_json::from_str(header_line).expect("header should parse");

    assert_eq!(header.kind, "Header");
    assert!(
        header.strings.iter().any(|s| s == "Section1/Foo"),
        "expected header string table to include query name Section1/Foo"
    );
    assert!(
        header.strings.iter().any(|s| s == "Section1/Bar"),
        "expected header string table to include query name Section1/Bar"
    );

    let mut op_lines = 0usize;
    for line in lines {
        let op: DiffOp = serde_json::from_str(line).expect("op line should parse as DiffOp");
        for id in collect_string_ids(&op) {
            assert!(
                (id.0 as usize) < header.strings.len(),
                "StringId {} out of range for header string table (len={})",
                id.0,
                header.strings.len()
            );
        }
        op_lines += 1;
    }

    assert!(op_lines > 0, "expected at least one op line after header");
    assert_eq!(
        summary.op_count, op_lines,
        "summary op_count should match number of ops written after the header"
    );
}

```

---

### File: `core\tests\perf_large_grid_tests.rs`

```rust
#![cfg(feature = "perf-metrics")]

mod common;

use common::single_sheet_workbook;
use excel_diff::perf::DiffMetrics;
use excel_diff::{
    CellValue, DiffConfig, DiffConfigBuilder, DiffOp, DiffReport, Grid, Workbook, WorkbookPackage,
};

fn diff_workbooks(old: &Workbook, new: &Workbook, config: &DiffConfig) -> DiffReport {
    WorkbookPackage::from(old.clone()).diff(&WorkbookPackage::from(new.clone()), config)
}

fn create_large_grid(nrows: u32, ncols: u32, base_value: i32) -> Grid {
    let mut grid = Grid::new(nrows, ncols);
    for row in 0..nrows {
        for col in 0..ncols {
            grid.insert_cell(
                row,
                col,
                Some(CellValue::Number(
                    (base_value as i64 + row as i64 * 1000 + col as i64) as f64,
                )),
                None,
            );
        }
    }
    grid
}

fn create_repetitive_grid(nrows: u32, ncols: u32, pattern_length: u32) -> Grid {
    let mut grid = Grid::new(nrows, ncols);
    for row in 0..nrows {
        let pattern_idx = row % pattern_length;
        for col in 0..ncols {
            grid.insert_cell(
                row,
                col,
                Some(CellValue::Number((pattern_idx * 1000 + col) as f64)),
                None,
            );
        }
    }
    grid
}

fn create_sparse_grid(nrows: u32, ncols: u32, fill_percent: u32, seed: u64) -> Grid {
    use std::collections::hash_map::DefaultHasher;
    use std::hash::{Hash, Hasher};

    let mut grid = Grid::new(nrows, ncols);
    for row in 0..nrows {
        for col in 0..ncols {
            let mut hasher = DefaultHasher::new();
            (row, col, seed).hash(&mut hasher);
            let hash = hasher.finish();
            if (hash % 100) < fill_percent as u64 {
                grid.insert_cell(
                    row,
                    col,
                    Some(CellValue::Number((row * 1000 + col) as f64)),
                    None,
                );
            }
        }
    }
    grid
}

fn log_perf_metric(name: &str, metrics: &DiffMetrics, tail: &str) {
    println!(
        "PERF_METRIC {name} total_time_ms={} move_detection_time_ms={} alignment_time_ms={} cell_diff_time_ms={} rows_processed={} cells_compared={} anchors_found={} moves_detected={}{}",
        metrics.total_time_ms,
        metrics.move_detection_time_ms,
        metrics.alignment_time_ms,
        metrics.cell_diff_time_ms,
        metrics.rows_processed,
        metrics.cells_compared,
        metrics.anchors_found,
        metrics.moves_detected,
        tail
    );
}

#[test]
fn perf_p1_large_dense() {
    let grid_a = create_large_grid(1000, 20, 0);
    let mut grid_b = create_large_grid(1000, 20, 0);
    grid_b.insert_cell(500, 10, Some(CellValue::Number(999999.0)), None);

    let wb_a = single_sheet_workbook("Performance", grid_a);
    let wb_b = single_sheet_workbook("Performance", grid_b);

    let config = DiffConfig::default();
    let report = diff_workbooks(&wb_a, &wb_b, &config);

    assert!(
        report.complete,
        "P1 dense grid should complete successfully"
    );
    assert!(report.warnings.is_empty(), "P1 should have no warnings");
    assert!(
        report
            .ops
            .iter()
            .any(|op| matches!(op, DiffOp::CellEdited { .. })),
        "P1 should detect the cell edit"
    );
    assert!(
        report.metrics.is_some(),
        "P1 should have metrics when perf-metrics enabled"
    );
    let metrics = report.metrics.unwrap();
    assert!(metrics.rows_processed > 0, "P1 should process rows");
    assert!(metrics.cells_compared > 0, "P1 should compare cells");
    log_perf_metric("perf_p1_large_dense", &metrics, "");
}

#[test]
fn perf_p2_large_noise() {
    let grid_a = create_large_grid(1000, 20, 0);
    let grid_b = create_large_grid(1000, 20, 1);

    let wb_a = single_sheet_workbook("Performance", grid_a);
    let wb_b = single_sheet_workbook("Performance", grid_b);

    let config = DiffConfig::default();
    let report = diff_workbooks(&wb_a, &wb_b, &config);

    assert!(
        report.complete,
        "P2 noise grid should complete successfully"
    );
    assert!(report.metrics.is_some(), "P2 should have metrics");
    let metrics = report.metrics.unwrap();
    assert!(metrics.rows_processed > 0, "P2 should process rows");
    log_perf_metric("perf_p2_large_noise", &metrics, "");
}

#[test]
fn perf_p3_adversarial_repetitive() {
    let grid_a = create_repetitive_grid(1000, 50, 100);
    let mut grid_b = create_repetitive_grid(1000, 50, 100);
    grid_b.insert_cell(500, 25, Some(CellValue::Number(999999.0)), None);

    let wb_a = single_sheet_workbook("Performance", grid_a);
    let wb_b = single_sheet_workbook("Performance", grid_b);

    let config = DiffConfig::default();
    let report = diff_workbooks(&wb_a, &wb_b, &config);

    assert!(report.complete, "P3 repetitive grid should complete");
    assert!(report.metrics.is_some(), "P3 should have metrics");
    let metrics = report.metrics.unwrap();
    assert!(metrics.rows_processed > 0, "P3 should process rows");
    log_perf_metric("perf_p3_adversarial_repetitive", &metrics, "");
}

#[test]
fn perf_p4_99_percent_blank() {
    let grid_a = create_sparse_grid(1000, 100, 1, 12345);
    let mut grid_b = create_sparse_grid(1000, 100, 1, 12345);
    grid_b.insert_cell(500, 50, Some(CellValue::Number(999999.0)), None);

    let wb_a = single_sheet_workbook("Performance", grid_a);
    let wb_b = single_sheet_workbook("Performance", grid_b);

    let config = DiffConfig::default();
    let report = diff_workbooks(&wb_a, &wb_b, &config);

    assert!(report.complete, "P4 sparse grid should complete");
    assert!(report.metrics.is_some(), "P4 should have metrics");
    let metrics = report.metrics.unwrap();
    assert!(metrics.rows_processed > 0, "P4 should process rows");
    log_perf_metric("perf_p4_99_percent_blank", &metrics, "");
}

#[test]
fn perf_p5_identical() {
    let grid_a = create_large_grid(1000, 100, 0);
    let grid_b = create_large_grid(1000, 100, 0);

    let wb_a = single_sheet_workbook("Performance", grid_a);
    let wb_b = single_sheet_workbook("Performance", grid_b);

    let config = DiffConfig::default();
    let report = diff_workbooks(&wb_a, &wb_b, &config);

    assert!(report.complete, "P5 identical grid should complete");
    assert!(
        report.ops.is_empty(),
        "P5 identical grids should produce no ops"
    );
    assert!(report.metrics.is_some(), "P5 should have metrics");
    let metrics = report.metrics.unwrap();
    assert!(metrics.rows_processed > 0, "P5 should process rows");
    log_perf_metric("perf_p5_identical", &metrics, "");
}

#[test]
#[ignore = "Long-running test: run with `cargo test --features perf-metrics -- --ignored` to execute"]
fn perf_50k_dense_single_edit() {
    let grid_a = create_large_grid(50000, 100, 0);
    let mut grid_b = create_large_grid(50000, 100, 0);
    grid_b.insert_cell(25000, 50, Some(CellValue::Number(999999.0)), None);

    let wb_a = single_sheet_workbook("Performance", grid_a);
    let wb_b = single_sheet_workbook("Performance", grid_b);

    let config = DiffConfig::default();
    let report = diff_workbooks(&wb_a, &wb_b, &config);

    assert!(
        report.complete,
        "50k dense grid should complete successfully"
    );
    assert!(
        report.warnings.is_empty(),
        "50k dense should have no warnings"
    );
    assert!(
        report
            .ops
            .iter()
            .any(|op| matches!(op, DiffOp::CellEdited { .. })),
        "50k dense should detect the cell edit"
    );
    let metrics = report.metrics.expect("should have metrics");
    log_perf_metric(
        "perf_50k_dense_single_edit",
        &metrics,
        " (enforced: <30s; target: <5s)",
    );
    assert!(
        metrics.total_time_ms < 30000,
        "50k dense grid should complete in <30s, took {}ms",
        metrics.total_time_ms
    );
    assert_eq!(
        metrics.move_detection_time_ms, 0,
        "50k dense single edit should skip move detection (preflight bailout), got {}ms",
        metrics.move_detection_time_ms
    );
    assert_eq!(
        metrics.alignment_time_ms, 0,
        "50k dense single edit should skip alignment (preflight bailout), got {}ms",
        metrics.alignment_time_ms
    );
}

#[test]
#[ignore = "Long-running test: run with `cargo test --features perf-metrics -- --ignored` to execute"]
fn perf_50k_completely_different() {
    let grid_a = create_large_grid(50000, 100, 0);
    let grid_b = create_large_grid(50000, 100, 1);

    let wb_a = single_sheet_workbook("Performance", grid_a);
    let wb_b = single_sheet_workbook("Performance", grid_b);

    let config = DiffConfig::default();
    let report = diff_workbooks(&wb_a, &wb_b, &config);

    assert!(report.complete, "50k different grids should complete");
    let metrics = report.metrics.expect("should have metrics");
    log_perf_metric(
        "perf_50k_completely_different",
        &metrics,
        " (enforced: <60s; target: <10s)",
    );
    assert!(
        metrics.total_time_ms < 60000,
        "50k completely different should complete in <60s, took {}ms",
        metrics.total_time_ms
    );
    assert_eq!(
        metrics.move_detection_time_ms, 0,
        "50k completely different should skip move detection (preflight bailout), got {}ms",
        metrics.move_detection_time_ms
    );
    assert_eq!(
        metrics.alignment_time_ms, 0,
        "50k completely different should skip alignment (preflight bailout), got {}ms",
        metrics.alignment_time_ms
    );
}

#[test]
#[ignore = "Long-running test: run with `cargo test --features perf-metrics -- --ignored` to execute"]
fn perf_50k_adversarial_repetitive() {
    let grid_a = create_repetitive_grid(50000, 50, 100);
    let mut grid_b = create_repetitive_grid(50000, 50, 100);
    grid_b.insert_cell(25000, 25, Some(CellValue::Number(999999.0)), None);

    let wb_a = single_sheet_workbook("Performance", grid_a);
    let wb_b = single_sheet_workbook("Performance", grid_b);

    let config = DiffConfig::default();
    let report = diff_workbooks(&wb_a, &wb_b, &config);

    assert!(report.complete, "50k repetitive should complete");
    let metrics = report.metrics.expect("should have metrics");
    log_perf_metric(
        "perf_50k_adversarial_repetitive",
        &metrics,
        " (enforced: <120s; target: <15s)",
    );
    assert!(
        metrics.total_time_ms < 120000,
        "50k adversarial repetitive should complete in <120s, took {}ms",
        metrics.total_time_ms
    );
    assert_eq!(
        metrics.move_detection_time_ms, 0,
        "50k adversarial repetitive should skip move detection (preflight bailout), got {}ms",
        metrics.move_detection_time_ms
    );
    assert_eq!(
        metrics.alignment_time_ms, 0,
        "50k adversarial repetitive should skip alignment (preflight bailout), got {}ms",
        metrics.alignment_time_ms
    );
}

#[test]
#[ignore = "Long-running test: run with `cargo test --features perf-metrics -- --ignored` to execute"]
fn perf_50k_99_percent_blank() {
    let grid_a = create_sparse_grid(50000, 100, 1, 12345);
    let mut grid_b = create_sparse_grid(50000, 100, 1, 12345);
    grid_b.insert_cell(25000, 50, Some(CellValue::Number(999999.0)), None);

    let wb_a = single_sheet_workbook("Performance", grid_a);
    let wb_b = single_sheet_workbook("Performance", grid_b);

    let config = DiffConfig::default();
    let report = diff_workbooks(&wb_a, &wb_b, &config);

    assert!(report.complete, "50k sparse should complete");
    let metrics = report.metrics.expect("should have metrics");
    log_perf_metric("perf_50k_99_percent_blank", &metrics, " (target: <2s)");
    assert!(
        metrics.total_time_ms < 30000,
        "50k 99% blank should complete in <30s, took {}ms",
        metrics.total_time_ms
    );
}

#[test]
#[ignore = "Long-running test: run with `cargo test --features perf-metrics -- --ignored` to execute"]
fn perf_50k_identical() {
    let grid_a = create_large_grid(50000, 100, 0);
    let grid_b = create_large_grid(50000, 100, 0);

    let wb_a = single_sheet_workbook("Performance", grid_a);
    let wb_b = single_sheet_workbook("Performance", grid_b);

    let config = DiffConfig::default();
    let report = diff_workbooks(&wb_a, &wb_b, &config);

    assert!(report.complete, "50k identical should complete");
    assert!(
        report.ops.is_empty(),
        "50k identical grids should have no ops"
    );
    let metrics = report.metrics.expect("should have metrics");
    log_perf_metric("perf_50k_identical", &metrics, " (target: <1s)");
    assert!(
        metrics.total_time_ms < 15000,
        "50k identical should complete in <15s, took {}ms",
        metrics.total_time_ms
    );
}

#[test]
fn preflight_skips_move_and_alignment_for_single_cell_edit_same_shape() {
    let grid_a = create_large_grid(6000, 50, 0);
    let mut grid_b = create_large_grid(6000, 50, 0);
    grid_b.insert_cell(3000, 25, Some(CellValue::Number(999999.0)), None);

    let wb_a = single_sheet_workbook("Preflight", grid_a);
    let wb_b = single_sheet_workbook("Preflight", grid_b);

    let config = DiffConfig::builder()
        .preflight_min_rows(5000)
        .preflight_in_order_mismatch_max(32)
        .preflight_in_order_match_ratio_min(0.995)
        .bailout_similarity_threshold(0.05)
        .build()
        .expect("valid config");

    let report = diff_workbooks(&wb_a, &wb_b, &config);

    assert!(report.complete, "report should complete");

    let cell_edits: Vec<_> = report
        .ops
        .iter()
        .filter(|op| matches!(op, DiffOp::CellEdited { .. }))
        .collect();
    assert_eq!(
        cell_edits.len(),
        1,
        "should have exactly 1 CellEdited op, got {}",
        cell_edits.len()
    );

    let structural_ops = report
        .ops
        .iter()
        .filter(|op| {
            matches!(
                op,
                DiffOp::RowAdded { .. }
                    | DiffOp::RowRemoved { .. }
                    | DiffOp::ColumnAdded { .. }
                    | DiffOp::ColumnRemoved { .. }
                    | DiffOp::BlockMovedRows { .. }
                    | DiffOp::BlockMovedColumns { .. }
                    | DiffOp::BlockMovedRect { .. }
            )
        })
        .count();
    assert_eq!(structural_ops, 0, "should have no structural/move ops");

    let metrics = report.metrics.expect("should have metrics");
    assert_eq!(
        metrics.move_detection_time_ms, 0,
        "move_detection_time_ms should be 0 (skipped), got {}",
        metrics.move_detection_time_ms
    );
    assert_eq!(
        metrics.alignment_time_ms, 0,
        "alignment_time_ms should be 0 (skipped), got {}",
        metrics.alignment_time_ms
    );

    log_perf_metric(
        "preflight_single_cell_edit",
        &metrics,
        " (preflight bailout)",
    );
}

#[test]
fn preflight_skips_move_and_alignment_for_low_similarity_same_shape() {
    let grid_a = create_large_grid(6000, 50, 0);
    let grid_b = create_large_grid(6000, 50, 100_000_000);

    let wb_a = single_sheet_workbook("Preflight", grid_a);
    let wb_b = single_sheet_workbook("Preflight", grid_b);

    let config = DiffConfig::builder()
        .preflight_min_rows(5000)
        .bailout_similarity_threshold(0.05)
        .build()
        .expect("valid config");

    let report = diff_workbooks(&wb_a, &wb_b, &config);

    assert!(report.complete, "report should complete");

    let has_cell_edit = report
        .ops
        .iter()
        .any(|op| matches!(op, DiffOp::CellEdited { .. }));
    assert!(has_cell_edit, "should have at least one CellEdited op");

    let move_ops = report
        .ops
        .iter()
        .filter(|op| {
            matches!(
                op,
                DiffOp::BlockMovedRows { .. }
                    | DiffOp::BlockMovedColumns { .. }
                    | DiffOp::BlockMovedRect { .. }
            )
        })
        .count();
    assert_eq!(move_ops, 0, "should have no move ops");

    let metrics = report.metrics.expect("should have metrics");
    assert_eq!(
        metrics.move_detection_time_ms, 0,
        "move_detection_time_ms should be 0 (skipped), got {}",
        metrics.move_detection_time_ms
    );
    assert_eq!(
        metrics.alignment_time_ms, 0,
        "alignment_time_ms should be 0 (skipped), got {}",
        metrics.alignment_time_ms
    );

    log_perf_metric(
        "preflight_low_similarity",
        &metrics,
        " (dissimilar bailout)",
    );
}

#[test]
fn preflight_does_not_skip_when_multiset_equal_but_order_differs() {
    let mut grid_a = Grid::new(6000, 10);
    for row in 0..6000u32 {
        for col in 0..10u32 {
            grid_a.insert_cell(
                row,
                col,
                Some(CellValue::Number((row * 100 + col) as f64)),
                None,
            );
        }
    }

    let mut grid_b = grid_a.clone();

    for col in 0..10u32 {
        let tmp_row_50 = grid_b.get(50, col).cloned();
        let tmp_row_51 = grid_b.get(51, col).cloned();
        let tmp_row_52 = grid_b.get(52, col).cloned();

        let row_80 = grid_b.get(80, col).cloned();
        let row_81 = grid_b.get(81, col).cloned();
        let row_82 = grid_b.get(82, col).cloned();

        if let Some(c) = row_80 {
            grid_b.insert_cell(50, col, c.value, c.formula);
        }
        if let Some(c) = row_81 {
            grid_b.insert_cell(51, col, c.value, c.formula);
        }
        if let Some(c) = row_82 {
            grid_b.insert_cell(52, col, c.value, c.formula);
        }

        if let Some(c) = tmp_row_50 {
            grid_b.insert_cell(80, col, c.value, c.formula);
        }
        if let Some(c) = tmp_row_51 {
            grid_b.insert_cell(81, col, c.value, c.formula);
        }
        if let Some(c) = tmp_row_52 {
            grid_b.insert_cell(82, col, c.value, c.formula);
        }
    }

    let wb_a = single_sheet_workbook("MoveTest", grid_a);
    let wb_b = single_sheet_workbook("MoveTest", grid_b);

    let config = DiffConfig::builder()
        .preflight_min_rows(5000)
        .preflight_in_order_mismatch_max(32)
        .preflight_in_order_match_ratio_min(0.995)
        .build()
        .expect("valid config");

    let report = diff_workbooks(&wb_a, &wb_b, &config);

    assert!(report.complete, "report should complete");

    let metrics = report.metrics.expect("should have metrics");

    assert!(
        metrics.alignment_time_ms > 0 || metrics.cell_diff_time_ms > 0,
        "preflight should NOT short-circuit when rows are reordered (multiset equal); expected pipeline to proceed, but alignment_time_ms={}, cell_diff_time_ms={}",
        metrics.alignment_time_ms,
        metrics.cell_diff_time_ms
    );
}

```

---

### File: `core\tests\pg1_ir_tests.rs`

```rust
mod common;

use common::{open_fixture_workbook, sid};
use excel_diff::{CellAddress, CellValue, Sheet, with_default_session};

#[test]
fn pg1_basic_two_sheets_structure() {
    let workbook = open_fixture_workbook("pg1_basic_two_sheets.xlsx");
    assert_eq!(workbook.sheets.len(), 2);
    assert_eq!(workbook.sheets[0].name, sid("Sheet1"));
    assert_eq!(workbook.sheets[1].name, sid("Sheet2"));
    assert!(matches!(
        workbook.sheets[0].kind,
        excel_diff::SheetKind::Worksheet
    ));
    assert!(matches!(
        workbook.sheets[1].kind,
        excel_diff::SheetKind::Worksheet
    ));

    let sheet1 = &workbook.sheets[0];
    assert_eq!(sheet1.grid.nrows, 3);
    assert_eq!(sheet1.grid.ncols, 3);
    with_default_session(|session| {
        assert_eq!(
            sheet1.grid.get(0, 0).and_then(|cell| cell
                .value
                .as_ref()
                .and_then(|v| v.as_text(session.strings()))),
            Some("R1C1")
        );
    });

    let sheet2 = &workbook.sheets[1];
    assert_eq!(sheet2.grid.nrows, 5);
    assert_eq!(sheet2.grid.ncols, 2);
    with_default_session(|session| {
        assert_eq!(
            sheet2.grid.get(0, 0).and_then(|cell| {
                cell.value
                    .as_ref()
                    .and_then(|v| v.as_text(session.strings()))
            }),
            Some("S2_R1C1")
        );
    });
}

#[test]
fn pg1_sparse_used_range_extents() {
    let workbook = open_fixture_workbook("pg1_sparse_used_range.xlsx");
    let sheet = workbook
        .sheets
        .iter()
        .find(|s| s.name == sid("Sparse"))
        .expect("Sparse sheet present");

    assert_eq!(sheet.grid.nrows, 10);
    assert_eq!(sheet.grid.ncols, 7);

    assert_cell_text(sheet, 0, 0, "A1");
    assert_cell_text(sheet, 1, 1, "B2");
    assert_cell_text(sheet, 9, 6, "G10");
    assert_eq!(sheet.grid.cell_count(), 3);
}

#[test]
fn pg1_empty_and_mixed_sheets() {
    let workbook = open_fixture_workbook("pg1_empty_and_mixed_sheets.xlsx");

    let empty = sheet_by_name(&workbook, "Empty");
    assert_eq!(empty.grid.nrows, 0);
    assert_eq!(empty.grid.ncols, 0);
    assert_eq!(empty.grid.cell_count(), 0);

    let values_only = sheet_by_name(&workbook, "ValuesOnly");
    assert_eq!(values_only.grid.nrows, 10);
    assert_eq!(values_only.grid.ncols, 10);
    let values: Vec<_> = values_only
        .grid
        .iter_cells()
        .map(|(_, cell)| cell)
        .collect();
    assert!(
        values
            .iter()
            .all(|c| c.value.is_some() && c.formula.is_none()),
        "ValuesOnly cells should have values and no formulas"
    );
    assert_eq!(
        values_only
            .grid
            .get(0, 0)
            .and_then(|cell| cell.value.as_ref().and_then(CellValue::as_number)),
        Some(1.0)
    );

    let formulas = sheet_by_name(&workbook, "FormulasOnly");
    assert_eq!(formulas.grid.nrows, 10);
    assert_eq!(formulas.grid.ncols, 10);
    let first = formulas.grid.get(0, 0).expect("A1 should exist");
    with_default_session(|session| {
        assert_eq!(
            first.formula.map(|id| session.strings.resolve(id)),
            Some("ValuesOnly!A1")
        );
    });
    assert!(
        first.value.is_some(),
        "Formulas should surface cached values when present"
    );
    assert!(
        formulas
            .grid
            .iter_cells()
            .all(|(_, cell)| cell.formula.is_some()),
        "All cells should carry formulas in FormulasOnly"
    );
}

fn sheet_by_name<'a>(workbook: &'a excel_diff::Workbook, name: &str) -> &'a Sheet {
    workbook
        .sheets
        .iter()
        .find(|s| s.name == sid(name))
        .unwrap_or_else(|| panic!("sheet {name} not found"))
}

fn assert_cell_text(sheet: &Sheet, row: u32, col: u32, expected: &str) {
    let cell = sheet
        .grid
        .get(row, col)
        .unwrap_or_else(|| panic!("cell {expected} should exist"));
    assert_eq!(CellAddress::from_coords(row, col).to_a1(), expected);
    with_default_session(|session| {
        assert_eq!(
            cell.value
                .as_ref()
                .and_then(|v| v.as_text(session.strings()))
                .unwrap_or(""),
            expected
        );
    });
}

```

---

### File: `core\tests\pg3_snapshot_tests.rs`

```rust
mod common;

use common::{open_fixture_workbook, sid};
use excel_diff::{
    Cell, CellAddress, CellSnapshot, CellValue, Sheet, Workbook, address_to_index,
    with_default_session,
};

fn sheet_by_name<'a>(workbook: &'a Workbook, name: &str) -> &'a Sheet {
    with_default_session(|session| {
        let id = session.strings.intern(name);
        workbook
            .sheets
            .iter()
            .find(|s| s.name == id)
            .expect("sheet should exist")
    })
}

fn find_cell<'a>(sheet: &'a Sheet, addr: &str) -> Option<&'a Cell> {
    let (row, col) = address_to_index(addr).expect("address should parse");
    sheet.grid.get(row, col)
}

fn snapshot(sheet: &Sheet, addr: &str) -> CellSnapshot {
    let (row, col) = address_to_index(addr).expect("address should parse");
    if let Some(cell) = find_cell(sheet, addr) {
        CellSnapshot::from_cell(row, col, cell)
    } else {
        CellSnapshot {
            addr: CellAddress::from_indices(row, col),
            value: None,
            formula: None,
        }
    }
}

fn resolve_text(id: excel_diff::StringId) -> String {
    with_default_session(|session| session.strings.resolve(id).to_string())
}

#[test]
fn pg3_value_and_formula_cells_snapshot_from_excel() {
    let workbook = open_fixture_workbook("pg3_value_and_formula_cells.xlsx");
    let sheet = sheet_by_name(&workbook, "Types");

    let a1 = snapshot(sheet, "A1");
    assert_eq!(a1.addr.to_string(), "A1");
    assert_eq!(a1.value, Some(CellValue::Number(42.0)));
    assert!(a1.formula.is_none());

    let a2 = snapshot(sheet, "A2");
    let a2_text = match a2.value {
        Some(CellValue::Text(id)) => resolve_text(id),
        other => panic!("expected text cell, got {:?}", other),
    };
    assert_eq!(a2_text, "hello");
    assert!(a2.formula.is_none());

    let a3 = snapshot(sheet, "A3");
    assert_eq!(a3.value, Some(CellValue::Bool(true)));
    assert!(a3.formula.is_none());

    let a4 = snapshot(sheet, "A4");
    assert!(a4.value.is_none());
    assert!(a4.formula.is_none());

    let b1 = snapshot(sheet, "B1");
    assert!(matches!(
        b1.value,
        Some(CellValue::Number(n)) if (n - 43.0).abs() < 1e-6
    ));
    assert_eq!(b1.addr.to_string(), "B1");
    let b1_formula = b1
        .formula
        .map(resolve_text)
        .expect("B1 should have a formula");
    assert!(b1_formula.contains("A1+1"));

    let b2 = snapshot(sheet, "B2");
    let b2_text = match b2.value {
        Some(CellValue::Text(id)) => resolve_text(id),
        other => panic!("expected text cell, got {:?}", other),
    };
    assert_eq!(b2_text, "hello world");
    assert_eq!(b2.addr.to_string(), "B2");
    let b2_formula = b2
        .formula
        .map(resolve_text)
        .expect("B2 should have a formula");
    assert!(b2_formula.contains("hello"));
    assert!(b2_formula.contains("world"));

    let b3 = snapshot(sheet, "B3");
    assert_eq!(b3.value, Some(CellValue::Bool(true)));
    assert_eq!(b3.addr.to_string(), "B3");
    let b3_formula = b3
        .formula
        .map(resolve_text)
        .expect("B3 should have a formula");
    assert!(
        b3_formula.contains(">0"),
        "B3 formula should include comparison: {b3_formula:?}"
    );
}

#[test]
fn snapshot_json_roundtrip() {
    let workbook = open_fixture_workbook("pg3_value_and_formula_cells.xlsx");
    let sheet = sheet_by_name(&workbook, "Types");

    let snapshots = vec![
        snapshot(sheet, "A1"),
        snapshot(sheet, "A2"),
        snapshot(sheet, "B1"),
        snapshot(sheet, "B2"),
        snapshot(sheet, "B3"),
    ];

    for snap in snapshots {
        let addr = snap.addr.to_string();
        let json = serde_json::to_string(&snap).expect("snapshot should serialize");
        let as_value: serde_json::Value =
            serde_json::from_str(&json).expect("snapshot JSON should parse to value");
        assert_eq!(as_value["addr"], serde_json::Value::String(addr));
        let snap_back: CellSnapshot = serde_json::from_str(&json).expect("snapshot should parse");
        assert_eq!(snap.addr, snap_back.addr);
        assert_eq!(snap, snap_back);
    }
}

#[test]
fn snapshot_json_roundtrip_detects_tampered_addr() {
    let snap = CellSnapshot {
        addr: "Z9".parse().expect("address should parse"),
        value: Some(CellValue::Number(1.0)),
        formula: Some(sid("A1+1")),
    };

    let mut value: serde_json::Value =
        serde_json::from_str(&serde_json::to_string(&snap).expect("serialize should work"))
            .expect("serialized JSON should parse");
    value["addr"] = serde_json::Value::String("A1".into());

    let tampered_json = serde_json::to_string(&value).expect("tampered JSON should serialize");
    let tampered: CellSnapshot =
        serde_json::from_str(&tampered_json).expect("tampered JSON should parse");

    assert_ne!(snap.addr, tampered.addr);
    assert_eq!(snap, tampered, "value/formula equality ignores addr");
}

#[test]
fn snapshot_json_rejects_invalid_addr_1a() {
    let json = r#"{"addr":"1A","value":null,"formula":null}"#;
    let result: Result<CellSnapshot, _> = serde_json::from_str(json);
    let err = result
        .expect_err("invalid addr should fail to deserialize")
        .to_string();

    assert!(
        err.contains("invalid cell address"),
        "error should mention invalid cell address: {err}"
    );
    assert!(
        err.contains("1A"),
        "error should include the offending address: {err}"
    );
}

#[test]
fn snapshot_json_rejects_invalid_addr_a0() {
    let json = r#"{"addr":"A0","value":null,"formula":null}"#;
    let result: Result<CellSnapshot, _> = serde_json::from_str(json);
    let err = result
        .expect_err("invalid addr should fail to deserialize")
        .to_string();

    assert!(
        err.contains("invalid cell address"),
        "error should mention invalid cell address: {err}"
    );
    assert!(
        err.contains("A0"),
        "error should include the offending address: {err}"
    );
}

```

---

### File: `core\tests\pg4_diffop_tests.rs`

```rust
mod common;

use common::sid;
use excel_diff::{
    CellAddress, CellSnapshot, CellValue, ColSignature, DiffOp, DiffReport, FormulaDiffResult,
    QueryChangeKind, QueryMetadataField, RowSignature,
};
use serde_json::Value;
use std::collections::BTreeSet;

fn addr(a1: &str) -> CellAddress {
    a1.parse().expect("address should parse")
}

fn sid_json(s: &str) -> Value {
    Value::Number(sid(s).0.into())
}

fn snapshot(a1: &str, value: Option<CellValue>, formula: Option<&str>) -> CellSnapshot {
    CellSnapshot {
        addr: addr(a1),
        value,
        formula: formula.map(|s| sid(s)),
    }
}

fn sample_cell_edited() -> DiffOp {
    DiffOp::CellEdited {
        sheet: sid("Sheet1"),
        addr: addr("C3"),
        from: snapshot("C3", Some(CellValue::Number(1.0)), None),
        to: snapshot("C3", Some(CellValue::Number(2.0)), None),
        formula_diff: FormulaDiffResult::Unchanged,
    }
}

// Enforces the invariant documented on DiffOp::CellEdited.
fn assert_cell_edited_invariants(op: &DiffOp, expected_sheet: &str, expected_addr: &str) {
    let expected_addr_parsed: CellAddress =
        expected_addr.parse().expect("expected_addr should parse");
    if let DiffOp::CellEdited {
        sheet,
        addr,
        from,
        to,
        ..
    } = op
    {
        assert_eq!(sheet, &sid(expected_sheet));
        assert_eq!(*addr, expected_addr_parsed);
        assert_eq!(from.addr, expected_addr_parsed);
        assert_eq!(to.addr, expected_addr_parsed);
    } else {
        panic!("expected CellEdited");
    }
}

fn op_kind(op: &DiffOp) -> &'static str {
    match op {
        DiffOp::SheetAdded { .. } => "SheetAdded",
        DiffOp::SheetRemoved { .. } => "SheetRemoved",
        DiffOp::RowAdded { .. } => "RowAdded",
        DiffOp::RowRemoved { .. } => "RowRemoved",
        DiffOp::ColumnAdded { .. } => "ColumnAdded",
        DiffOp::ColumnRemoved { .. } => "ColumnRemoved",
        DiffOp::BlockMovedRows { .. } => "BlockMovedRows",
        DiffOp::BlockMovedColumns { .. } => "BlockMovedColumns",
        DiffOp::BlockMovedRect { .. } => "BlockMovedRect",
        DiffOp::CellEdited { .. } => "CellEdited",
        _ => "Unknown",
    }
}

fn json_keys(json: &Value) -> BTreeSet<String> {
    json.as_object()
        .expect("object json")
        .keys()
        .cloned()
        .collect()
}

#[test]
fn pg4_construct_cell_edited_diffop() {
    let op = sample_cell_edited();

    assert_cell_edited_invariants(&op, "Sheet1", "C3");
    if let DiffOp::CellEdited { from, to, .. } = &op {
        assert_ne!(from.value, to.value);
    }
}

#[test]
fn pg4_construct_row_and_column_diffops() {
    let row_added_with_sig = DiffOp::RowAdded {
        sheet: sid("Sheet1"),
        row_idx: 10,
        row_signature: Some(RowSignature { hash: 0xDEADBEEF }),
    };
    let row_added_without_sig = DiffOp::RowAdded {
        sheet: sid("Sheet1"),
        row_idx: 11,
        row_signature: None,
    };
    let row_removed_with_sig = DiffOp::RowRemoved {
        sheet: sid("Sheet1"),
        row_idx: 9,
        row_signature: Some(RowSignature { hash: 0x1234 }),
    };
    let row_removed_without_sig = DiffOp::RowRemoved {
        sheet: sid("Sheet1"),
        row_idx: 8,
        row_signature: None,
    };
    let col_added_with_sig = DiffOp::ColumnAdded {
        sheet: sid("Sheet2"),
        col_idx: 2,
        col_signature: Some(ColSignature { hash: 0xABCDEF }),
    };
    let col_added_without_sig = DiffOp::ColumnAdded {
        sheet: sid("Sheet2"),
        col_idx: 3,
        col_signature: None,
    };
    let col_removed_with_sig = DiffOp::ColumnRemoved {
        sheet: sid("Sheet2"),
        col_idx: 1,
        col_signature: Some(ColSignature { hash: 0x123456 }),
    };
    let col_removed_without_sig = DiffOp::ColumnRemoved {
        sheet: sid("Sheet2"),
        col_idx: 0,
        col_signature: None,
    };

    if let DiffOp::RowAdded {
        sheet,
        row_idx,
        row_signature,
    } = &row_added_with_sig
    {
        assert_eq!(sheet, &sid("Sheet1"));
        assert_eq!(*row_idx, 10);
        assert_eq!(row_signature.as_ref().unwrap().hash, 0xDEADBEEF);
    } else {
        panic!("expected RowAdded with signature");
    }

    if let DiffOp::RowAdded {
        sheet,
        row_idx,
        row_signature,
    } = &row_added_without_sig
    {
        assert_eq!(sheet, &sid("Sheet1"));
        assert_eq!(*row_idx, 11);
        assert!(row_signature.is_none());
    } else {
        panic!("expected RowAdded without signature");
    }

    if let DiffOp::RowRemoved {
        sheet,
        row_idx,
        row_signature,
    } = &row_removed_with_sig
    {
        assert_eq!(sheet, &sid("Sheet1"));
        assert_eq!(*row_idx, 9);
        assert_eq!(row_signature.as_ref().unwrap().hash, 0x1234);
    } else {
        panic!("expected RowRemoved with signature");
    }

    if let DiffOp::RowRemoved {
        sheet,
        row_idx,
        row_signature,
    } = &row_removed_without_sig
    {
        assert_eq!(sheet, &sid("Sheet1"));
        assert_eq!(*row_idx, 8);
        assert!(row_signature.is_none());
    } else {
        panic!("expected RowRemoved without signature");
    }

    if let DiffOp::ColumnAdded {
        sheet,
        col_idx,
        col_signature,
    } = &col_added_with_sig
    {
        assert_eq!(sheet, &sid("Sheet2"));
        assert_eq!(*col_idx, 2);
        assert_eq!(col_signature.as_ref().unwrap().hash, 0xABCDEF);
    } else {
        panic!("expected ColumnAdded with signature");
    }

    if let DiffOp::ColumnAdded {
        sheet,
        col_idx,
        col_signature,
    } = &col_added_without_sig
    {
        assert_eq!(sheet, &sid("Sheet2"));
        assert_eq!(*col_idx, 3);
        assert!(col_signature.is_none());
    } else {
        panic!("expected ColumnAdded without signature");
    }

    if let DiffOp::ColumnRemoved {
        sheet,
        col_idx,
        col_signature,
    } = &col_removed_with_sig
    {
        assert_eq!(sheet, &sid("Sheet2"));
        assert_eq!(*col_idx, 1);
        assert_eq!(col_signature.as_ref().unwrap().hash, 0x123456);
    } else {
        panic!("expected ColumnRemoved with signature");
    }

    if let DiffOp::ColumnRemoved {
        sheet,
        col_idx,
        col_signature,
    } = &col_removed_without_sig
    {
        assert_eq!(sheet, &sid("Sheet2"));
        assert_eq!(*col_idx, 0);
        assert!(col_signature.is_none());
    } else {
        panic!("expected ColumnRemoved without signature");
    }

    assert_ne!(row_added_with_sig, row_added_without_sig);
    assert_ne!(row_removed_with_sig, row_removed_without_sig);
    assert_ne!(col_added_with_sig, col_added_without_sig);
    assert_ne!(col_removed_with_sig, col_removed_without_sig);
}

#[test]
fn pg4_construct_block_move_diffops() {
    let block_rows_with_hash = DiffOp::BlockMovedRows {
        sheet: sid("Sheet1"),
        src_start_row: 10,
        row_count: 3,
        dst_start_row: 5,
        block_hash: Some(0x12345678),
    };
    let block_rows_without_hash = DiffOp::BlockMovedRows {
        sheet: sid("Sheet1"),
        src_start_row: 20,
        row_count: 2,
        dst_start_row: 0,
        block_hash: None,
    };
    let block_cols_with_hash = DiffOp::BlockMovedColumns {
        sheet: sid("Sheet2"),
        src_start_col: 7,
        col_count: 2,
        dst_start_col: 3,
        block_hash: Some(0xCAFEBABE),
    };
    let block_cols_without_hash = DiffOp::BlockMovedColumns {
        sheet: sid("Sheet2"),
        src_start_col: 4,
        col_count: 1,
        dst_start_col: 9,
        block_hash: None,
    };

    if let DiffOp::BlockMovedRows {
        sheet,
        src_start_row,
        row_count,
        dst_start_row,
        block_hash,
    } = &block_rows_with_hash
    {
        assert_eq!(sheet, &sid("Sheet1"));
        assert_eq!(*src_start_row, 10);
        assert_eq!(*row_count, 3);
        assert_eq!(*dst_start_row, 5);
        assert_eq!(block_hash.unwrap(), 0x12345678);
    } else {
        panic!("expected BlockMovedRows with hash");
    }

    if let DiffOp::BlockMovedRows {
        sheet,
        src_start_row,
        row_count,
        dst_start_row,
        block_hash,
    } = &block_rows_without_hash
    {
        assert_eq!(sheet, &sid("Sheet1"));
        assert_eq!(*src_start_row, 20);
        assert_eq!(*row_count, 2);
        assert_eq!(*dst_start_row, 0);
        assert!(block_hash.is_none());
    } else {
        panic!("expected BlockMovedRows without hash");
    }

    if let DiffOp::BlockMovedColumns {
        sheet,
        src_start_col,
        col_count,
        dst_start_col,
        block_hash,
    } = &block_cols_with_hash
    {
        assert_eq!(sheet, &sid("Sheet2"));
        assert_eq!(*src_start_col, 7);
        assert_eq!(*col_count, 2);
        assert_eq!(*dst_start_col, 3);
        assert_eq!(block_hash.unwrap(), 0xCAFEBABE);
    } else {
        panic!("expected BlockMovedColumns with hash");
    }

    if let DiffOp::BlockMovedColumns {
        sheet,
        src_start_col,
        col_count,
        dst_start_col,
        block_hash,
    } = &block_cols_without_hash
    {
        assert_eq!(sheet, &sid("Sheet2"));
        assert_eq!(*src_start_col, 4);
        assert_eq!(*col_count, 1);
        assert_eq!(*dst_start_col, 9);
        assert!(block_hash.is_none());
    } else {
        panic!("expected BlockMovedColumns without hash");
    }

    assert_ne!(block_rows_with_hash, block_rows_without_hash);
    assert_ne!(block_cols_with_hash, block_cols_without_hash);
}

#[test]
fn pg4_construct_block_rect_diffops() {
    let rect_with_hash = DiffOp::BlockMovedRect {
        sheet: sid("Sheet1"),
        src_start_row: 5,
        src_row_count: 3,
        src_start_col: 2,
        src_col_count: 4,
        dst_start_row: 10,
        dst_start_col: 6,
        block_hash: Some(0xCAFEBABE),
    };
    let rect_without_hash = DiffOp::BlockMovedRect {
        sheet: sid("Sheet1"),
        src_start_row: 0,
        src_row_count: 1,
        src_start_col: 0,
        src_col_count: 1,
        dst_start_row: 20,
        dst_start_col: 10,
        block_hash: None,
    };

    if let DiffOp::BlockMovedRect {
        sheet,
        src_start_row,
        src_row_count,
        src_start_col,
        src_col_count,
        dst_start_row,
        dst_start_col,
        block_hash,
    } = &rect_with_hash
    {
        assert_eq!(sheet, &sid("Sheet1"));
        assert_eq!(*src_start_row, 5);
        assert_eq!(*src_row_count, 3);
        assert_eq!(*src_start_col, 2);
        assert_eq!(*src_col_count, 4);
        assert_eq!(*dst_start_row, 10);
        assert_eq!(*dst_start_col, 6);
        assert_eq!(block_hash.unwrap(), 0xCAFEBABE);
    } else {
        panic!("expected BlockMovedRect with hash");
    }

    if let DiffOp::BlockMovedRect {
        sheet,
        src_start_row,
        src_row_count,
        src_start_col,
        src_col_count,
        dst_start_row,
        dst_start_col,
        block_hash,
    } = &rect_without_hash
    {
        assert_eq!(sheet, &sid("Sheet1"));
        assert_eq!(*src_start_row, 0);
        assert_eq!(*src_row_count, 1);
        assert_eq!(*src_start_col, 0);
        assert_eq!(*src_col_count, 1);
        assert_eq!(*dst_start_row, 20);
        assert_eq!(*dst_start_col, 10);
        assert!(block_hash.is_none());
    } else {
        panic!("expected BlockMovedRect without hash");
    }

    assert_ne!(rect_with_hash, rect_without_hash);
}

#[test]
fn pg4_cell_edited_json_shape() {
    let op = sample_cell_edited();
    let json = serde_json::to_value(&op).expect("serialize");
    assert_cell_edited_invariants(&op, "Sheet1", "C3");

    assert_eq!(json["kind"], "CellEdited");
    assert_eq!(json["sheet"], sid_json("Sheet1"));
    assert_eq!(json["addr"], "C3");
    assert_eq!(json["from"]["addr"], "C3");
    assert_eq!(json["to"]["addr"], "C3");
    assert_eq!(json["formula_diff"], "unchanged");

    let obj = json.as_object().expect("object json");
    let keys: BTreeSet<String> = obj.keys().cloned().collect();
    let expected: BTreeSet<String> = ["addr", "from", "kind", "sheet", "to", "formula_diff"]
        .into_iter()
        .map(String::from)
        .collect();
    assert_eq!(keys, expected);
}

#[test]
fn pg4_row_added_json_optional_signature() {
    let op_without_sig = DiffOp::RowAdded {
        sheet: sid("Sheet1"),
        row_idx: 10,
        row_signature: None,
    };
    let json_without = serde_json::to_value(&op_without_sig).expect("serialize without sig");
    let obj_without = json_without.as_object().expect("object json");
    assert_eq!(json_without["kind"], "RowAdded");
    assert_eq!(json_without["sheet"], sid_json("Sheet1"));
    assert_eq!(json_without["row_idx"], 10);
    assert!(obj_without.get("row_signature").is_none());

    let op_with_sig = DiffOp::RowAdded {
        sheet: sid("Sheet1"),
        row_idx: 10,
        row_signature: Some(RowSignature { hash: 123 }),
    };
    let json_with = serde_json::to_value(&op_with_sig).expect("serialize with sig");
    assert_eq!(
        json_with["row_signature"]["hash"],
        "0000000000000000000000000000007b"
    );
}

#[test]
fn pg4_column_added_json_optional_signature() {
    let added_without_sig = DiffOp::ColumnAdded {
        sheet: sid("Sheet1"),
        col_idx: 5,
        col_signature: None,
    };
    let json_added_without = serde_json::to_value(&added_without_sig).expect("serialize no sig");
    let obj_added_without = json_added_without.as_object().expect("object json");
    assert_eq!(json_added_without["kind"], "ColumnAdded");
    assert_eq!(json_added_without["sheet"], sid_json("Sheet1"));
    assert_eq!(json_added_without["col_idx"], 5);
    assert!(obj_added_without.get("col_signature").is_none());

    let added_with_sig = DiffOp::ColumnAdded {
        sheet: sid("Sheet1"),
        col_idx: 6,
        col_signature: Some(ColSignature { hash: 321 }),
    };
    let json_added_with = serde_json::to_value(&added_with_sig).expect("serialize with sig");
    assert_eq!(
        json_added_with["col_signature"]["hash"],
        "00000000000000000000000000000141"
    );

    let removed_without_sig = DiffOp::ColumnRemoved {
        sheet: sid("Sheet2"),
        col_idx: 2,
        col_signature: None,
    };
    let json_removed_without =
        serde_json::to_value(&removed_without_sig).expect("serialize removed no sig");
    let obj_removed_without = json_removed_without.as_object().expect("object json");
    assert_eq!(json_removed_without["kind"], "ColumnRemoved");
    assert!(obj_removed_without.get("col_signature").is_none());

    let removed_with_sig = DiffOp::ColumnRemoved {
        sheet: sid("Sheet2"),
        col_idx: 1,
        col_signature: Some(ColSignature { hash: 654 }),
    };
    let json_removed_with =
        serde_json::to_value(&removed_with_sig).expect("serialize removed with sig");
    assert_eq!(
        json_removed_with["col_signature"]["hash"],
        "0000000000000000000000000000028e"
    );
}

#[test]
fn pg4_block_moved_rows_json_optional_hash() {
    let op_without_hash = DiffOp::BlockMovedRows {
        sheet: sid("Sheet1"),
        src_start_row: 1,
        row_count: 2,
        dst_start_row: 5,
        block_hash: None,
    };
    let json_without = serde_json::to_value(&op_without_hash).expect("serialize without hash");
    let obj_without = json_without.as_object().expect("object json");
    assert_eq!(json_without["kind"], "BlockMovedRows");
    assert!(obj_without.get("block_hash").is_none());

    let op_with_hash = DiffOp::BlockMovedRows {
        sheet: sid("Sheet1"),
        src_start_row: 1,
        row_count: 2,
        dst_start_row: 5,
        block_hash: Some(777),
    };
    let json_with = serde_json::to_value(&op_with_hash).expect("serialize with hash");
    assert_eq!(json_with["block_hash"], Value::from(777));
}

#[test]
fn pg4_block_moved_columns_json_optional_hash() {
    let op_without_hash = DiffOp::BlockMovedColumns {
        sheet: sid("SheetX"),
        src_start_col: 2,
        col_count: 3,
        dst_start_col: 9,
        block_hash: None,
    };
    let json_without = serde_json::to_value(&op_without_hash).expect("serialize without hash");
    let obj_without = json_without.as_object().expect("object json");
    assert_eq!(json_without["kind"], "BlockMovedColumns");
    assert!(obj_without.get("block_hash").is_none());

    let op_with_hash = DiffOp::BlockMovedColumns {
        sheet: sid("SheetX"),
        src_start_col: 2,
        col_count: 3,
        dst_start_col: 9,
        block_hash: Some(4242),
    };
    let json_with = serde_json::to_value(&op_with_hash).expect("serialize with hash");
    assert_eq!(json_with["block_hash"], Value::from(4242));
}

#[test]
fn pg4_sheet_added_and_removed_json_shape() {
    let added = DiffOp::SheetAdded {
        sheet: sid("Sheet1"),
    };
    let added_json = serde_json::to_value(&added).expect("serialize sheet added");
    assert_eq!(added_json["kind"], "SheetAdded");
    assert_eq!(added_json["sheet"], sid_json("Sheet1"));
    let added_keys = json_keys(&added_json);
    let expected_keys: BTreeSet<String> = ["kind", "sheet"].into_iter().map(String::from).collect();
    assert_eq!(added_keys, expected_keys);

    let removed = DiffOp::SheetRemoved {
        sheet: sid("SheetX"),
    };
    let removed_json = serde_json::to_value(&removed).expect("serialize sheet removed");
    assert_eq!(removed_json["kind"], "SheetRemoved");
    assert_eq!(removed_json["sheet"], sid_json("SheetX"));
    let removed_keys = json_keys(&removed_json);
    assert_eq!(removed_keys, expected_keys);
}

#[test]
fn pg4_row_and_column_json_shape_keysets() {
    let expected_row_with_sig: BTreeSet<String> = ["kind", "row_idx", "row_signature", "sheet"]
        .into_iter()
        .map(String::from)
        .collect();
    let expected_row_without_sig: BTreeSet<String> = ["kind", "row_idx", "sheet"]
        .into_iter()
        .map(String::from)
        .collect();
    let expected_col_with_sig: BTreeSet<String> = ["col_idx", "col_signature", "kind", "sheet"]
        .into_iter()
        .map(String::from)
        .collect();
    let expected_col_without_sig: BTreeSet<String> = ["col_idx", "kind", "sheet"]
        .into_iter()
        .map(String::from)
        .collect();

    let row_added_with_sig = DiffOp::RowAdded {
        sheet: sid("Sheet1"),
        row_idx: 10,
        row_signature: Some(RowSignature { hash: 0xDEADBEEF }),
    };
    let row_added_without_sig = DiffOp::RowAdded {
        sheet: sid("Sheet1"),
        row_idx: 11,
        row_signature: None,
    };
    let row_removed_with_sig = DiffOp::RowRemoved {
        sheet: sid("Sheet1"),
        row_idx: 9,
        row_signature: Some(RowSignature { hash: 0x1234 }),
    };
    let row_removed_without_sig = DiffOp::RowRemoved {
        sheet: sid("Sheet1"),
        row_idx: 8,
        row_signature: None,
    };

    let col_added_with_sig = DiffOp::ColumnAdded {
        sheet: sid("Sheet2"),
        col_idx: 2,
        col_signature: Some(ColSignature { hash: 0xABCDEF }),
    };
    let col_added_without_sig = DiffOp::ColumnAdded {
        sheet: sid("Sheet2"),
        col_idx: 3,
        col_signature: None,
    };
    let col_removed_with_sig = DiffOp::ColumnRemoved {
        sheet: sid("Sheet2"),
        col_idx: 1,
        col_signature: Some(ColSignature { hash: 0x123456 }),
    };
    let col_removed_without_sig = DiffOp::ColumnRemoved {
        sheet: sid("Sheet2"),
        col_idx: 0,
        col_signature: None,
    };

    let cases = vec![
        (
            row_added_with_sig,
            "RowAdded",
            expected_row_with_sig.clone(),
        ),
        (
            row_added_without_sig,
            "RowAdded",
            expected_row_without_sig.clone(),
        ),
        (
            row_removed_with_sig,
            "RowRemoved",
            expected_row_with_sig.clone(),
        ),
        (
            row_removed_without_sig,
            "RowRemoved",
            expected_row_without_sig.clone(),
        ),
        (
            col_added_with_sig,
            "ColumnAdded",
            expected_col_with_sig.clone(),
        ),
        (
            col_added_without_sig,
            "ColumnAdded",
            expected_col_without_sig.clone(),
        ),
        (
            col_removed_with_sig,
            "ColumnRemoved",
            expected_col_with_sig.clone(),
        ),
        (
            col_removed_without_sig,
            "ColumnRemoved",
            expected_col_without_sig.clone(),
        ),
    ];

    for (op, expected_kind, expected_keys) in cases {
        let json = serde_json::to_value(&op).expect("serialize diffop");
        assert_eq!(json["kind"], expected_kind);
        let keys = json_keys(&json);
        assert_eq!(keys, expected_keys);
    }
}

#[test]
fn pg4_block_move_json_shape_keysets() {
    let expected_rows_with_hash: BTreeSet<String> = [
        "block_hash",
        "dst_start_row",
        "kind",
        "row_count",
        "sheet",
        "src_start_row",
    ]
    .into_iter()
    .map(String::from)
    .collect();
    let expected_rows_without_hash: BTreeSet<String> = [
        "dst_start_row",
        "kind",
        "row_count",
        "sheet",
        "src_start_row",
    ]
    .into_iter()
    .map(String::from)
    .collect();
    let expected_cols_with_hash: BTreeSet<String> = [
        "block_hash",
        "col_count",
        "dst_start_col",
        "kind",
        "sheet",
        "src_start_col",
    ]
    .into_iter()
    .map(String::from)
    .collect();
    let expected_cols_without_hash: BTreeSet<String> = [
        "col_count",
        "dst_start_col",
        "kind",
        "sheet",
        "src_start_col",
    ]
    .into_iter()
    .map(String::from)
    .collect();
    let expected_rect_with_hash: BTreeSet<String> = [
        "block_hash",
        "dst_start_col",
        "dst_start_row",
        "kind",
        "sheet",
        "src_col_count",
        "src_row_count",
        "src_start_col",
        "src_start_row",
    ]
    .into_iter()
    .map(String::from)
    .collect();
    let expected_rect_without_hash: BTreeSet<String> = [
        "dst_start_col",
        "dst_start_row",
        "kind",
        "sheet",
        "src_col_count",
        "src_row_count",
        "src_start_col",
        "src_start_row",
    ]
    .into_iter()
    .map(String::from)
    .collect();

    let block_rows_with_hash = DiffOp::BlockMovedRows {
        sheet: sid("Sheet1"),
        src_start_row: 10,
        row_count: 3,
        dst_start_row: 5,
        block_hash: Some(0x12345678),
    };
    let block_rows_without_hash = DiffOp::BlockMovedRows {
        sheet: sid("Sheet1"),
        src_start_row: 20,
        row_count: 2,
        dst_start_row: 0,
        block_hash: None,
    };
    let block_cols_with_hash = DiffOp::BlockMovedColumns {
        sheet: sid("Sheet2"),
        src_start_col: 7,
        col_count: 2,
        dst_start_col: 3,
        block_hash: Some(0xCAFEBABE),
    };
    let block_cols_without_hash = DiffOp::BlockMovedColumns {
        sheet: sid("Sheet2"),
        src_start_col: 4,
        col_count: 1,
        dst_start_col: 9,
        block_hash: None,
    };
    let block_rect_with_hash = DiffOp::BlockMovedRect {
        sheet: sid("SheetZ"),
        src_start_row: 2,
        src_row_count: 2,
        src_start_col: 3,
        src_col_count: 4,
        dst_start_row: 8,
        dst_start_col: 1,
        block_hash: Some(0xAABBCCDD),
    };
    let block_rect_without_hash = DiffOp::BlockMovedRect {
        sheet: sid("SheetZ"),
        src_start_row: 5,
        src_row_count: 1,
        src_start_col: 0,
        src_col_count: 2,
        dst_start_row: 10,
        dst_start_col: 4,
        block_hash: None,
    };

    let cases = vec![
        (
            block_rows_with_hash,
            "BlockMovedRows",
            expected_rows_with_hash.clone(),
        ),
        (
            block_rows_without_hash,
            "BlockMovedRows",
            expected_rows_without_hash.clone(),
        ),
        (
            block_cols_with_hash,
            "BlockMovedColumns",
            expected_cols_with_hash.clone(),
        ),
        (
            block_cols_without_hash,
            "BlockMovedColumns",
            expected_cols_without_hash.clone(),
        ),
        (
            block_rect_with_hash,
            "BlockMovedRect",
            expected_rect_with_hash.clone(),
        ),
        (
            block_rect_without_hash,
            "BlockMovedRect",
            expected_rect_without_hash.clone(),
        ),
    ];

    for (op, expected_kind, expected_keys) in cases {
        let json = serde_json::to_value(&op).expect("serialize diffop");
        assert_eq!(json["kind"], expected_kind);
        let keys = json_keys(&json);
        assert_eq!(keys, expected_keys);
    }
}

#[test]
fn pg4_block_rect_json_shape_and_roundtrip() {
    let without_hash = DiffOp::BlockMovedRect {
        sheet: sid("Sheet1"),
        src_start_row: 2,
        src_row_count: 3,
        src_start_col: 1,
        src_col_count: 2,
        dst_start_row: 10,
        dst_start_col: 5,
        block_hash: None,
    };
    let with_hash = DiffOp::BlockMovedRect {
        sheet: sid("Sheet1"),
        src_start_row: 4,
        src_row_count: 1,
        src_start_col: 0,
        src_col_count: 1,
        dst_start_row: 20,
        dst_start_col: 7,
        block_hash: Some(0x55AA),
    };

    let report = DiffReport::new(vec![without_hash.clone(), with_hash.clone()]);
    let json = serde_json::to_value(&report).expect("serialize rect report");

    let ops_json = json["ops"]
        .as_array()
        .expect("ops should be array for report");
    assert_eq!(ops_json.len(), 2);
    assert_eq!(ops_json[0]["kind"], "BlockMovedRect");
    assert_eq!(ops_json[0]["sheet"], sid_json("Sheet1"));
    assert_eq!(ops_json[0]["src_start_row"], 2);
    assert_eq!(ops_json[0]["src_row_count"], 3);
    assert_eq!(ops_json[0]["src_start_col"], 1);
    assert_eq!(ops_json[0]["src_col_count"], 2);
    assert_eq!(ops_json[0]["dst_start_row"], 10);
    assert_eq!(ops_json[0]["dst_start_col"], 5);
    assert!(
        ops_json[0].get("block_hash").is_none(),
        "block_hash should be omitted when None"
    );

    assert_eq!(ops_json[1]["kind"], "BlockMovedRect");
    assert_eq!(ops_json[1]["block_hash"], Value::from(0x55AA));

    let roundtrip: DiffReport =
        serde_json::from_value(json).expect("roundtrip deserialize rect report");
    assert_eq!(roundtrip.ops, vec![without_hash, with_hash]);
}

#[test]
fn pg4_diffop_roundtrip_each_variant() {
    let ops = vec![
        DiffOp::SheetAdded {
            sheet: sid("SheetA"),
        },
        DiffOp::SheetRemoved {
            sheet: sid("SheetB"),
        },
        DiffOp::RowAdded {
            sheet: sid("Sheet1"),
            row_idx: 1,
            row_signature: Some(RowSignature { hash: 42 }),
        },
        DiffOp::RowRemoved {
            sheet: sid("Sheet1"),
            row_idx: 0,
            row_signature: None,
        },
        DiffOp::ColumnAdded {
            sheet: sid("Sheet1"),
            col_idx: 2,
            col_signature: None,
        },
        DiffOp::ColumnRemoved {
            sheet: sid("Sheet1"),
            col_idx: 3,
            col_signature: Some(ColSignature { hash: 99 }),
        },
        DiffOp::BlockMovedRows {
            sheet: sid("Sheet1"),
            src_start_row: 5,
            row_count: 2,
            dst_start_row: 10,
            block_hash: Some(1234),
        },
        DiffOp::BlockMovedRows {
            sheet: sid("Sheet1"),
            src_start_row: 5,
            row_count: 2,
            dst_start_row: 10,
            block_hash: None,
        },
        DiffOp::BlockMovedColumns {
            sheet: sid("Sheet2"),
            src_start_col: 4,
            col_count: 1,
            dst_start_col: 6,
            block_hash: Some(888),
        },
        DiffOp::BlockMovedColumns {
            sheet: sid("Sheet2"),
            src_start_col: 4,
            col_count: 1,
            dst_start_col: 6,
            block_hash: None,
        },
        DiffOp::BlockMovedRect {
            sheet: sid("Sheet3"),
            src_start_row: 1,
            src_row_count: 2,
            src_start_col: 3,
            src_col_count: 4,
            dst_start_row: 10,
            dst_start_col: 20,
            block_hash: Some(0xABCD),
        },
        DiffOp::BlockMovedRect {
            sheet: sid("Sheet3"),
            src_start_row: 1,
            src_row_count: 2,
            src_start_col: 3,
            src_col_count: 4,
            dst_start_row: 10,
            dst_start_col: 20,
            block_hash: None,
        },
        sample_cell_edited(),
        DiffOp::QueryAdded {
            name: sid("Section1/NewQuery"),
        },
        DiffOp::QueryRemoved {
            name: sid("Section1/OldQuery"),
        },
        DiffOp::QueryRenamed {
            from: sid("Section1/Foo"),
            to: sid("Section1/Bar"),
        },
        DiffOp::QueryDefinitionChanged {
            name: sid("Section1/Query1"),
            change_kind: QueryChangeKind::Semantic,
            old_hash: 0x1234567890ABCDEF,
            new_hash: 0xFEDCBA0987654321,
        },
        DiffOp::QueryDefinitionChanged {
            name: sid("Section1/Query2"),
            change_kind: QueryChangeKind::FormattingOnly,
            old_hash: 0xAAAABBBBCCCCDDDD,
            new_hash: 0xAAAABBBBCCCCDDDD,
        },
        DiffOp::QueryMetadataChanged {
            name: sid("Section1/Query3"),
            field: QueryMetadataField::LoadToSheet,
            old: Some(sid("true")),
            new: Some(sid("false")),
        },
        DiffOp::QueryMetadataChanged {
            name: sid("Section1/Query4"),
            field: QueryMetadataField::LoadToModel,
            old: Some(sid("false")),
            new: Some(sid("true")),
        },
        DiffOp::QueryMetadataChanged {
            name: sid("Section1/Query5"),
            field: QueryMetadataField::GroupPath,
            old: None,
            new: Some(sid("Reports/Sales")),
        },
        DiffOp::QueryMetadataChanged {
            name: sid("Section1/Query6"),
            field: QueryMetadataField::ConnectionOnly,
            old: Some(sid("true")),
            new: Some(sid("false")),
        },
        DiffOp::NamedRangeAdded {
            name: sid("GlobalAdd"),
        },
        DiffOp::NamedRangeRemoved {
            name: sid("GlobalRemove"),
        },
        DiffOp::NamedRangeChanged {
            name: sid("Sheet1!LocalChange"),
            old_ref: sid("Sheet1!$C$1"),
            new_ref: sid("Sheet1!$C$2"),
        },
        DiffOp::ChartAdded {
            sheet: sid("Sheet1"),
            name: sid("Chart 1"),
        },
        DiffOp::ChartRemoved {
            sheet: sid("Sheet1"),
            name: sid("Chart 2"),
        },
        DiffOp::ChartChanged {
            sheet: sid("Sheet1"),
            name: sid("Chart 1"),
        },
        DiffOp::VbaModuleAdded {
            name: sid("Module1"),
        },
        DiffOp::VbaModuleRemoved {
            name: sid("Module2"),
        },
        DiffOp::VbaModuleChanged {
            name: sid("Module1"),
        },
    ];

    for original in ops {
        let serialized = serde_json::to_string(&original).expect("serialize");
        let deserialized: DiffOp = serde_json::from_str(&serialized).expect("deserialize");
        assert_eq!(deserialized, original);

        if let DiffOp::CellEdited { .. } = &deserialized {
            assert_cell_edited_invariants(&deserialized, "Sheet1", "C3");
        }
    }
}

#[test]
fn pg4_cell_edited_roundtrip_preserves_snapshot_addrs() {
    let op = sample_cell_edited();
    let json = serde_json::to_string(&op).expect("serialize");
    let round_tripped: DiffOp = serde_json::from_str(&json).expect("deserialize");

    assert_cell_edited_invariants(&round_tripped, "Sheet1", "C3");
}

#[test]
fn pg4_diff_report_roundtrip_preserves_order() {
    let op1 = DiffOp::SheetAdded {
        sheet: sid("Sheet1"),
    };
    let op2 = DiffOp::RowAdded {
        sheet: sid("Sheet1"),
        row_idx: 10,
        row_signature: None,
    };
    let op3 = sample_cell_edited();

    let ops = vec![op1, op2, op3];
    let report = DiffReport::new(ops.clone());
    assert_eq!(report.version, DiffReport::SCHEMA_VERSION);

    let serialized = serde_json::to_string(&report).expect("serialize report");
    let deserialized: DiffReport = serde_json::from_str(&serialized).expect("deserialize report");
    assert_eq!(deserialized.version, "1");
    assert_eq!(deserialized.ops, ops);

    let kinds: Vec<&str> = deserialized.ops.iter().map(op_kind).collect();
    assert_eq!(kinds, vec!["SheetAdded", "RowAdded", "CellEdited"]);
}

#[test]
fn pg4_diff_report_json_shape() {
    let ops = vec![
        DiffOp::SheetRemoved {
            sheet: sid("SheetX"),
        },
        DiffOp::RowRemoved {
            sheet: sid("SheetX"),
            row_idx: 3,
            row_signature: Some(RowSignature { hash: 7 }),
        },
    ];
    let report = DiffReport::new(ops);
    let json = serde_json::to_value(&report).expect("serialize to value");

    let obj = json.as_object().expect("report json object");
    let keys: BTreeSet<String> = obj.keys().cloned().collect();
    let expected: BTreeSet<String> = ["complete", "ops", "strings", "version"]
        .into_iter()
        .map(String::from)
        .collect();
    assert_eq!(keys, expected);
    assert_eq!(obj.get("version").and_then(Value::as_str), Some("1"));
    assert_eq!(obj.get("complete").and_then(Value::as_bool), Some(true));

    let ops_json = obj
        .get("ops")
        .and_then(Value::as_array)
        .expect("ops should be array");
    assert_eq!(ops_json.len(), 2);
    assert_eq!(ops_json[0]["kind"], "SheetRemoved");
    assert_eq!(ops_json[1]["kind"], "RowRemoved");
}

#[test]
fn pg4_diffop_cell_edited_rejects_invalid_top_level_addr() {
    let sheet_id = sid("Sheet1").0;
    let json = format!(
        r#"{{
        "kind": "CellEdited",
        "sheet": {sheet_id},
        "addr": "1A",
        "from": {{ "addr": "C3", "value": null, "formula": null }},
        "to":   {{ "addr": "C3", "value": null, "formula": null }}
    }}"#
    );

    let err = serde_json::from_str::<DiffOp>(&json)
        .expect_err("invalid top-level addr should fail to deserialize");
    let msg = err.to_string();
    assert!(
        msg.contains("invalid cell address") && msg.contains("1A"),
        "error should mention invalid address: {msg}",
    );
}

#[test]
fn pg4_diffop_cell_edited_rejects_invalid_snapshot_addrs() {
    let sheet_id = sid("Sheet1").0;
    let json = format!(
        r#"{{
        "kind": "CellEdited",
        "sheet": {sheet_id},
        "addr": "C3",
        "from": {{ "addr": "A0", "value": null, "formula": null }},
        "to":   {{ "addr": "C3", "value": null, "formula": null }}
    }}"#
    );

    let err = serde_json::from_str::<DiffOp>(&json)
        .expect_err("invalid snapshot addr should fail to deserialize");
    let msg = err.to_string();
    assert!(
        msg.contains("invalid cell address") && msg.contains("A0"),
        "error should mention invalid address: {msg}",
    );
}

#[test]
fn pg4_diff_report_rejects_invalid_nested_addr() {
    let sheet_id = sid("Sheet1").0;
    let json = format!(
        r#"{{
        "version": "1",
        "strings": [],
        "ops": [{{
            "kind": "CellEdited",
            "sheet": {sheet_id},
            "addr": "1A",
            "from": {{ "addr": "C3", "value": null, "formula": null }},
            "to":   {{ "addr": "C3", "value": null, "formula": null }}
        }}]
    }}"#
    );

    let err = serde_json::from_str::<DiffReport>(&json)
        .expect_err("invalid nested addr should fail to deserialize");
    let msg = err.to_string();
    assert!(
        msg.contains("invalid cell address") && msg.contains("1A"),
        "error should surface nested invalid address: {msg}",
    );
}

#[test]
#[should_panic]
fn pg4_cell_edited_invariant_helper_rejects_mismatched_snapshot_addr() {
    let op = DiffOp::CellEdited {
        sheet: sid("Sheet1"),
        addr: addr("C3"),
        from: snapshot("D4", Some(CellValue::Number(1.0)), None),
        to: snapshot("C3", Some(CellValue::Number(2.0)), None),
        formula_diff: FormulaDiffResult::Unchanged,
    };

    assert_cell_edited_invariants(&op, "Sheet1", "C3");
}

#[test]
#[cfg(feature = "perf-metrics")]
fn pg4_diff_report_json_shape_with_metrics() {
    use excel_diff::perf::DiffMetrics;

    let ops = vec![DiffOp::SheetAdded {
        sheet: sid("NewSheet"),
    }];
    let mut report = DiffReport::new(ops);
    let mut metrics = DiffMetrics::default();
    metrics.move_detection_time_ms = 10;
    metrics.alignment_time_ms = 20;
    metrics.cell_diff_time_ms = 30;
    metrics.total_time_ms = 60;
    metrics.rows_processed = 1000;
    metrics.cells_compared = 5000;
    metrics.anchors_found = 50;
    metrics.moves_detected = 2;
    report.metrics = Some(metrics);

    let json = serde_json::to_value(&report).expect("serialize to value");
    let obj = json.as_object().expect("report json object");

    let keys: BTreeSet<String> = obj.keys().cloned().collect();
    let expected: BTreeSet<String> = ["complete", "metrics", "ops", "strings", "version"]
        .into_iter()
        .map(String::from)
        .collect();
    assert_eq!(keys, expected, "report should include metrics key");

    let metrics_obj = obj
        .get("metrics")
        .and_then(Value::as_object)
        .expect("metrics object");

    assert!(metrics_obj.contains_key("move_detection_time_ms"));
    assert!(metrics_obj.contains_key("alignment_time_ms"));
    assert!(metrics_obj.contains_key("cell_diff_time_ms"));
    assert!(metrics_obj.contains_key("total_time_ms"));
    assert!(metrics_obj.contains_key("rows_processed"));
    assert!(metrics_obj.contains_key("cells_compared"));
    assert!(metrics_obj.contains_key("anchors_found"));
    assert!(metrics_obj.contains_key("moves_detected"));

    assert!(
        !metrics_obj.contains_key("parse_time_ms"),
        "parse_time_ms is planned for future phase"
    );
    assert!(
        !metrics_obj.contains_key("peak_memory_bytes"),
        "peak_memory_bytes is planned for future phase"
    );

    assert_eq!(
        metrics_obj.get("rows_processed").and_then(Value::as_u64),
        Some(1000)
    );
    assert_eq!(
        metrics_obj.get("cells_compared").and_then(Value::as_u64),
        Some(5000)
    );
}

```

---

### File: `core\tests\pg5_grid_diff_tests.rs`

```rust
mod common;

use common::{grid_from_numbers, single_sheet_workbook};
use excel_diff::{CellValue, DiffConfig, DiffOp, DiffReport, Grid, Workbook, WorkbookPackage};
use std::collections::BTreeSet;

fn sheet_name<'a>(report: &'a DiffReport, id: &excel_diff::SheetId) -> &'a str {
    report.strings[id.0 as usize].as_str()
}

fn diff_workbooks(old: &Workbook, new: &Workbook, config: &DiffConfig) -> DiffReport {
    WorkbookPackage::from(old.clone()).diff(&WorkbookPackage::from(new.clone()), config)
}

#[test]
fn pg5_1_grid_diff_1x1_identical_empty_diff() {
    let old = single_sheet_workbook("Sheet1", grid_from_numbers(&[&[1]]));
    let new = single_sheet_workbook("Sheet1", grid_from_numbers(&[&[1]]));

    let report = diff_workbooks(&old, &new, &DiffConfig::default());
    assert!(report.ops.is_empty());
}

#[test]
fn pg5_2_grid_diff_1x1_value_change_single_cell_edited() {
    let old = single_sheet_workbook("Sheet1", grid_from_numbers(&[&[1]]));
    let new = single_sheet_workbook("Sheet1", grid_from_numbers(&[&[2]]));

    let report = diff_workbooks(&old, &new, &DiffConfig::default());
    assert_eq!(report.ops.len(), 1);

    match &report.ops[0] {
        DiffOp::CellEdited {
            sheet,
            addr,
            from,
            to,
            ..
        } => {
            assert_eq!(sheet_name(&report, sheet), "Sheet1");
            assert_eq!(addr.to_a1(), "A1");
            assert_eq!(from.value, Some(CellValue::Number(1.0)));
            assert_eq!(to.value, Some(CellValue::Number(2.0)));
        }
        other => panic!("expected CellEdited, got {other:?}"),
    }
}

#[test]
fn pg5_3_grid_diff_row_appended_row_added_only() {
    let old = single_sheet_workbook("Sheet1", grid_from_numbers(&[&[1]]));
    let new = single_sheet_workbook("Sheet1", grid_from_numbers(&[&[1], &[2]]));

    let report = diff_workbooks(&old, &new, &DiffConfig::default());
    assert_eq!(report.ops.len(), 1);

    match &report.ops[0] {
        DiffOp::RowAdded {
            sheet,
            row_idx,
            row_signature,
        } => {
            assert_eq!(sheet_name(&report, sheet), "Sheet1");
            assert_eq!(*row_idx, 1);
            assert!(row_signature.is_none());
        }
        other => panic!("expected RowAdded, got {other:?}"),
    }
}

#[test]
fn pg5_4_grid_diff_column_appended_column_added_only() {
    let old = single_sheet_workbook("Sheet1", grid_from_numbers(&[&[1], &[2]]));
    let new = single_sheet_workbook("Sheet1", grid_from_numbers(&[&[1, 10], &[2, 20]]));

    let report = diff_workbooks(&old, &new, &DiffConfig::default());
    assert_eq!(report.ops.len(), 1);

    match &report.ops[0] {
        DiffOp::ColumnAdded {
            sheet,
            col_idx,
            col_signature,
        } => {
            assert_eq!(sheet_name(&report, sheet), "Sheet1");
            assert_eq!(*col_idx, 1);
            assert!(col_signature.is_none());
        }
        other => panic!("expected ColumnAdded, got {other:?}"),
    }
}

#[test]
fn pg5_5_grid_diff_same_shape_scattered_cell_edits() {
    let old = single_sheet_workbook(
        "Sheet1",
        grid_from_numbers(&[&[1, 2, 3], &[4, 5, 6], &[7, 8, 9]]),
    );
    let new = single_sheet_workbook(
        "Sheet1",
        grid_from_numbers(&[&[10, 2, 3], &[4, 50, 6], &[7, 8, 90]]),
    );

    let report = diff_workbooks(&old, &new, &DiffConfig::default());
    assert_eq!(report.ops.len(), 3);
    assert!(
        report
            .ops
            .iter()
            .all(|op| matches!(op, DiffOp::CellEdited { .. }))
    );

    let edited_addrs: BTreeSet<String> = report
        .ops
        .iter()
        .filter_map(|op| match op {
            DiffOp::CellEdited { addr, .. } => Some(addr.to_a1()),
            _ => None,
        })
        .collect();
    let expected: BTreeSet<String> = ["A1", "B2", "C3"].into_iter().map(String::from).collect();
    assert_eq!(edited_addrs, expected);
}

#[test]
fn pg5_6_grid_diff_degenerate_grids() {
    let empty_old = single_sheet_workbook("Sheet1", Grid::new(0, 0));
    let empty_new = single_sheet_workbook("Sheet1", Grid::new(0, 0));

    let empty_report = diff_workbooks(&empty_old, &empty_new, &DiffConfig::default());
    assert!(empty_report.ops.is_empty());

    let old = single_sheet_workbook("Sheet1", Grid::new(0, 0));
    let new = single_sheet_workbook("Sheet1", grid_from_numbers(&[&[1]]));

    let report = diff_workbooks(&old, &new, &DiffConfig::default());
    assert_eq!(report.ops.len(), 2);

    let mut row_added = 0;
    let mut col_added = 0;
    let mut cell_edits = 0;

    for op in &report.ops {
        match op {
            DiffOp::RowAdded {
                sheet,
                row_idx,
                row_signature,
            } => {
                assert_eq!(sheet_name(&report, sheet), "Sheet1");
                assert_eq!(*row_idx, 0);
                assert!(row_signature.is_none());
                row_added += 1;
            }
            DiffOp::ColumnAdded {
                sheet,
                col_idx,
                col_signature,
            } => {
                assert_eq!(sheet_name(&report, sheet), "Sheet1");
                assert_eq!(*col_idx, 0);
                assert!(col_signature.is_none());
                col_added += 1;
            }
            DiffOp::CellEdited { .. } => cell_edits += 1,
            other => panic!("unexpected op: {other:?}"),
        }
    }

    assert_eq!(row_added, 1);
    assert_eq!(col_added, 1);
    assert_eq!(cell_edits, 0);
}

#[test]
fn pg5_7_grid_diff_row_truncated_row_removed_only() {
    let old = single_sheet_workbook("Sheet1", grid_from_numbers(&[&[1], &[2]]));
    let new = single_sheet_workbook("Sheet1", grid_from_numbers(&[&[1]]));

    let report = diff_workbooks(&old, &new, &DiffConfig::default());
    assert_eq!(report.ops.len(), 1);

    match &report.ops[0] {
        DiffOp::RowRemoved {
            sheet,
            row_idx,
            row_signature,
        } => {
            assert_eq!(sheet_name(&report, sheet), "Sheet1");
            assert_eq!(*row_idx, 1);
            assert!(row_signature.is_none());
        }
        other => panic!("expected RowRemoved, got {other:?}"),
    }
}

#[test]
fn pg5_8_grid_diff_column_truncated_column_removed_only() {
    let old = single_sheet_workbook("Sheet1", grid_from_numbers(&[&[1, 10], &[2, 20]]));
    let new = single_sheet_workbook("Sheet1", grid_from_numbers(&[&[1], &[2]]));

    let report = diff_workbooks(&old, &new, &DiffConfig::default());
    assert_eq!(report.ops.len(), 1);

    match &report.ops[0] {
        DiffOp::ColumnRemoved {
            sheet,
            col_idx,
            col_signature,
        } => {
            assert_eq!(sheet_name(&report, sheet), "Sheet1");
            assert_eq!(*col_idx, 1);
            assert!(col_signature.is_none());
        }
        other => panic!("expected ColumnRemoved, got {other:?}"),
    }
}

#[test]
fn pg5_9_grid_diff_row_and_column_truncated_structure_only() {
    let old = single_sheet_workbook("Sheet1", grid_from_numbers(&[&[1, 2], &[3, 4]]));
    let new = single_sheet_workbook("Sheet1", grid_from_numbers(&[&[1]]));

    let report = diff_workbooks(&old, &new, &DiffConfig::default());
    assert_eq!(report.ops.len(), 2);

    let mut rows_removed = 0;
    let mut cols_removed = 0;
    let mut cell_edits = 0;

    for op in &report.ops {
        match op {
            DiffOp::RowRemoved {
                sheet,
                row_idx,
                row_signature,
            } => {
                assert_eq!(sheet_name(&report, sheet), "Sheet1");
                assert_eq!(*row_idx, 1);
                assert!(row_signature.is_none());
                rows_removed += 1;
            }
            DiffOp::ColumnRemoved {
                sheet,
                col_idx,
                col_signature,
            } => {
                assert_eq!(sheet_name(&report, sheet), "Sheet1");
                assert_eq!(*col_idx, 1);
                assert!(col_signature.is_none());
                cols_removed += 1;
            }
            DiffOp::CellEdited { .. } => cell_edits += 1,
            other => panic!("unexpected op: {other:?}"),
        }
    }

    assert_eq!(rows_removed, 1);
    assert_eq!(cols_removed, 1);
    assert_eq!(cell_edits, 0);
}

#[test]
fn pg5_10_grid_diff_row_appended_with_overlap_cell_edits() {
    let old = single_sheet_workbook("Sheet1", grid_from_numbers(&[&[1, 2], &[3, 4]]));
    let new = single_sheet_workbook("Sheet1", grid_from_numbers(&[&[1, 20], &[30, 4], &[5, 6]]));

    let report = diff_workbooks(&old, &new, &DiffConfig::default());
    assert_eq!(report.ops.len(), 3);

    let mut row_added = 0;
    let mut cell_edits = BTreeSet::new();

    for op in &report.ops {
        match op {
            DiffOp::RowAdded {
                sheet,
                row_idx,
                row_signature,
            } => {
                assert_eq!(sheet_name(&report, sheet), "Sheet1");
                assert_eq!(*row_idx, 2);
                assert!(row_signature.is_none());
                row_added += 1;
            }
            DiffOp::CellEdited { addr, .. } => {
                cell_edits.insert(addr.to_a1());
            }
            other => panic!("unexpected op: {other:?}"),
        }
    }

    assert_eq!(row_added, 1);
    let expected: BTreeSet<String> = ["B1", "A2"].into_iter().map(String::from).collect();
    assert_eq!(cell_edits, expected);
}

```

---

### File: `core\tests\pg6_object_vs_grid_tests.rs`

```rust
mod common;

use common::{open_fixture_workbook, sid};
use excel_diff::{DiffConfig, DiffOp, WorkbookPackage};

#[test]
fn pg6_1_sheet_added_no_grid_ops_on_main() {
    let old = open_fixture_workbook("pg6_sheet_added_a.xlsx");
    let new = open_fixture_workbook("pg6_sheet_added_b.xlsx");

    let report =
        WorkbookPackage::from(old).diff(&WorkbookPackage::from(new), &DiffConfig::default());

    let mut sheet_added = 0;
    for op in &report.ops {
        match op {
            DiffOp::SheetAdded { sheet } if *sheet == sid("NewSheet") => sheet_added += 1,
            DiffOp::RowAdded { sheet, .. }
            | DiffOp::RowRemoved { sheet, .. }
            | DiffOp::ColumnAdded { sheet, .. }
            | DiffOp::ColumnRemoved { sheet, .. }
            | DiffOp::CellEdited { sheet, .. }
                if *sheet == sid("Main") =>
            {
                panic!("unexpected grid op on Main: {op:?}");
            }
            DiffOp::SheetAdded { sheet } => {
                panic!("unexpected sheet added: {sheet}");
            }
            DiffOp::SheetRemoved { sheet } => {
                panic!("unexpected sheet removed: {sheet}");
            }
            DiffOp::BlockMovedRows { .. } | DiffOp::BlockMovedColumns { .. } => {
                panic!("block move ops are not expected in PG6.1: {op:?}");
            }
            _ => panic!("unexpected op variant: {op:?}"),
        }
    }

    assert_eq!(sheet_added, 1, "exactly one NewSheet addition expected");
    assert_eq!(report.ops.len(), 1, "no other operations expected");
}

#[test]
fn pg6_2_sheet_removed_no_grid_ops_on_main() {
    let old = open_fixture_workbook("pg6_sheet_removed_a.xlsx");
    let new = open_fixture_workbook("pg6_sheet_removed_b.xlsx");

    let report =
        WorkbookPackage::from(old).diff(&WorkbookPackage::from(new), &DiffConfig::default());

    let mut sheet_removed = 0;
    for op in &report.ops {
        match op {
            DiffOp::SheetRemoved { sheet } if *sheet == sid("OldSheet") => sheet_removed += 1,
            DiffOp::RowAdded { sheet, .. }
            | DiffOp::RowRemoved { sheet, .. }
            | DiffOp::ColumnAdded { sheet, .. }
            | DiffOp::ColumnRemoved { sheet, .. }
            | DiffOp::CellEdited { sheet, .. }
                if *sheet == sid("Main") =>
            {
                panic!("unexpected grid op on Main: {op:?}");
            }
            DiffOp::SheetAdded { sheet } => {
                panic!("unexpected sheet added: {sheet}");
            }
            DiffOp::SheetRemoved { sheet } => {
                panic!("unexpected sheet removed: {sheet}");
            }
            DiffOp::BlockMovedRows { .. } | DiffOp::BlockMovedColumns { .. } => {
                panic!("block move ops are not expected in PG6.2: {op:?}");
            }
            _ => panic!("unexpected op variant: {op:?}"),
        }
    }

    assert_eq!(sheet_removed, 1, "exactly one OldSheet removal expected");
    assert_eq!(report.ops.len(), 1, "no other operations expected");
}

#[test]
fn pg6_3_rename_as_remove_plus_add_no_grid_ops() {
    let old = open_fixture_workbook("pg6_sheet_renamed_a.xlsx");
    let new = open_fixture_workbook("pg6_sheet_renamed_b.xlsx");

    let report =
        WorkbookPackage::from(old).diff(&WorkbookPackage::from(new), &DiffConfig::default());

    let mut added = 0;
    let mut removed = 0;

    for op in &report.ops {
        match op {
            DiffOp::SheetAdded { sheet } if *sheet == sid("NewName") => added += 1,
            DiffOp::SheetRemoved { sheet } if *sheet == sid("OldName") => removed += 1,
            DiffOp::SheetAdded { sheet } => panic!("unexpected sheet added: {sheet}"),
            DiffOp::SheetRemoved { sheet } => panic!("unexpected sheet removed: {sheet}"),
            DiffOp::RowAdded { .. }
            | DiffOp::RowRemoved { .. }
            | DiffOp::ColumnAdded { .. }
            | DiffOp::ColumnRemoved { .. }
            | DiffOp::CellEdited { .. }
            | DiffOp::BlockMovedRows { .. }
            | DiffOp::BlockMovedColumns { .. } => {
                panic!("no grid-level ops expected for rename scenario: {op:?}");
            }
            _ => panic!("unexpected op variant: {op:?}"),
        }
    }

    assert_eq!(
        report.ops.len(),
        2,
        "rename should produce one add and one remove"
    );
    assert_eq!(added, 1, "expected one NewName addition");
    assert_eq!(removed, 1, "expected one OldName removal");
}

#[test]
fn pg6_4_sheet_and_grid_change_composed_cleanly() {
    let old = open_fixture_workbook("pg6_sheet_and_grid_change_a.xlsx");
    let new = open_fixture_workbook("pg6_sheet_and_grid_change_b.xlsx");

    let report =
        WorkbookPackage::from(old).diff(&WorkbookPackage::from(new), &DiffConfig::default());

    let mut scratch_added = 0;
    let mut main_cell_edits = 0;

    for op in &report.ops {
        match op {
            DiffOp::SheetAdded { sheet } if *sheet == sid("Scratch") => scratch_added += 1,
            DiffOp::CellEdited { sheet, .. } => {
                assert_eq!(sheet, &sid("Main"), "only Main should have cell edits");
                main_cell_edits += 1;
            }
            DiffOp::SheetRemoved { .. } => {
                panic!("no sheets should be removed in PG6.4: {op:?}");
            }
            DiffOp::RowAdded { .. }
            | DiffOp::RowRemoved { .. }
            | DiffOp::ColumnAdded { .. }
            | DiffOp::ColumnRemoved { .. }
            | DiffOp::BlockMovedRows { .. }
            | DiffOp::BlockMovedColumns { .. } => {
                panic!("no structural row/column ops expected in PG6.4: {op:?}");
            }
            _ => panic!("unexpected op variant: {op:?}"),
        }
    }

    assert_eq!(scratch_added, 1, "exactly one Scratch addition expected");
    assert!(
        main_cell_edits > 0,
        "Main should report at least one cell edit"
    );
}

```

---

### File: `core\tests\signature_tests.rs`

```rust
mod common;

use common::sid;
use excel_diff::{CellValue, Grid, GridView, StringId};

#[derive(Clone)]
struct TestCell {
    row: u32,
    col: u32,
    value: Option<CellValue>,
    formula: Option<StringId>,
}

trait GridTestInsert {
    fn insert_test(&mut self, cell: TestCell);
}

impl GridTestInsert for Grid {
    fn insert_test(&mut self, cell: TestCell) {
        self.insert_cell(cell.row, cell.col, cell.value, cell.formula);
    }
}

fn make_cell(row: u32, col: u32, value: Option<CellValue>, formula: Option<&str>) -> TestCell {
    TestCell {
        row,
        col,
        value,
        formula: formula.map(sid),
    }
}

#[test]
fn identical_rows_have_same_signature() {
    let mut grid1 = Grid::new(1, 3);
    let mut grid2 = Grid::new(1, 3);
    for c in 0..3 {
        let cell = make_cell(0, c, Some(CellValue::Number(c as f64)), None);
        grid1.insert_test(cell.clone());
        grid2.insert_test(cell);
    }
    let sig1 = grid1.compute_row_signature(0);
    let sig2 = grid2.compute_row_signature(0);
    assert_eq!(sig1, sig2);
}

#[test]
fn different_rows_have_different_signatures() {
    let mut grid1 = Grid::new(1, 3);
    let mut grid2 = Grid::new(1, 3);
    for c in 0..3 {
        grid1.insert_test(make_cell(0, c, Some(CellValue::Number(c as f64)), None));
        grid2.insert_test(make_cell(
            0,
            c,
            Some(CellValue::Number((c + 1) as f64)),
            None,
        ));
    }
    let sig1 = grid1.compute_row_signature(0);
    let sig2 = grid2.compute_row_signature(0);
    assert_ne!(sig1, sig2);
}

#[test]
fn compute_all_signatures_populates_fields() {
    let mut grid = Grid::new(5, 5);
    grid.insert_test(make_cell(2, 2, Some(CellValue::Text(sid("center"))), None));
    assert!(grid.row_signatures.is_none());
    assert!(grid.col_signatures.is_none());
    grid.compute_all_signatures();
    assert!(grid.row_signatures.is_some());
    assert!(grid.col_signatures.is_some());
    assert_eq!(grid.row_signatures.as_ref().unwrap().len(), 5);
    assert_eq!(grid.col_signatures.as_ref().unwrap().len(), 5);
    assert_ne!(grid.row_signatures.as_ref().unwrap()[2].hash, 0);
    assert_ne!(grid.col_signatures.as_ref().unwrap()[2].hash, 0);
}

#[test]
fn compute_all_signatures_on_empty_grid_produces_empty_vectors() {
    let mut grid = Grid::new(0, 0);

    grid.compute_all_signatures();

    assert!(grid.row_signatures.is_some());
    assert!(grid.col_signatures.is_some());
    assert!(grid.row_signatures.as_ref().unwrap().is_empty());
    assert!(grid.col_signatures.as_ref().unwrap().is_empty());
}

#[test]
fn compute_all_signatures_with_all_empty_rows_and_cols_is_stable() {
    let mut grid = Grid::new(3, 4);

    grid.compute_all_signatures();
    let first_rows = grid.row_signatures.as_ref().unwrap().clone();
    let first_cols = grid.col_signatures.as_ref().unwrap().clone();

    assert_eq!(first_rows.len(), 3);
    assert_eq!(first_cols.len(), 4);
    let empty_row_hash = first_rows[0].hash;
    let empty_col_hash = first_cols[0].hash;
    assert!(first_rows.iter().all(|sig| sig.hash == empty_row_hash));
    assert!(first_cols.iter().all(|sig| sig.hash == empty_col_hash));

    grid.compute_all_signatures();
    let second_rows = grid.row_signatures.as_ref().unwrap();
    let second_cols = grid.col_signatures.as_ref().unwrap();

    assert_eq!(first_rows, *second_rows);
    assert_eq!(first_cols, *second_cols);
}

#[test]
fn row_and_col_signatures_match_bulk_computation() {
    let mut grid = Grid::new(3, 2);
    grid.insert_test(make_cell(
        0,
        0,
        Some(CellValue::Number(std::f64::consts::PI)),
        Some("=PI()"),
    ));
    grid.insert_test(make_cell(1, 1, Some(CellValue::Text(sid("text"))), None));
    grid.insert_test(make_cell(2, 0, Some(CellValue::Bool(true)), Some("=A1")));

    grid.compute_all_signatures();

    let row_sigs = grid
        .row_signatures
        .as_ref()
        .expect("row signatures should exist");
    for r in 0..3 {
        assert_eq!(
            grid.compute_row_signature(r).hash,
            row_sigs[r as usize].hash
        );
    }

    let col_sigs = grid
        .col_signatures
        .as_ref()
        .expect("col signatures should exist");
    for c in 0..2 {
        assert_eq!(
            grid.compute_col_signature(c).hash,
            col_sigs[c as usize].hash
        );
    }
}

#[test]
fn compute_all_signatures_recomputes_after_mutation() {
    let mut grid = Grid::new(3, 3);
    grid.insert_test(make_cell(0, 0, Some(CellValue::Number(1.0)), None));
    grid.insert_test(make_cell(1, 1, Some(CellValue::Text(sid("x"))), None));

    grid.compute_all_signatures();
    let first_rows = grid.row_signatures.as_ref().unwrap().clone();
    let first_cols = grid.col_signatures.as_ref().unwrap().clone();

    grid.insert_test(make_cell(1, 1, Some(CellValue::Text(sid("y"))), None));
    grid.insert_test(make_cell(2, 2, Some(CellValue::Bool(true)), None));

    grid.compute_all_signatures();
    let second_rows = grid.row_signatures.as_ref().unwrap();
    let second_cols = grid.col_signatures.as_ref().unwrap();

    assert_ne!(first_rows[1].hash, second_rows[1].hash);
    assert_ne!(first_cols[1].hash, second_cols[1].hash);
}

#[test]
fn row_signatures_distinguish_column_positions() {
    let mut grid1 = Grid::new(1, 2);
    grid1.insert_test(make_cell(0, 0, Some(CellValue::Number(1.0)), None));
    grid1.insert_test(make_cell(0, 1, Some(CellValue::Number(2.0)), None));

    let mut grid2 = Grid::new(1, 2);
    grid2.insert_test(make_cell(0, 0, Some(CellValue::Number(2.0)), None));
    grid2.insert_test(make_cell(0, 1, Some(CellValue::Number(1.0)), None));

    let sig1 = grid1.compute_row_signature(0);
    let sig2 = grid2.compute_row_signature(0);
    assert_ne!(sig1.hash, sig2.hash);
}

#[test]
fn col_signatures_distinguish_row_positions() {
    let mut grid1 = Grid::new(2, 1);
    grid1.insert_test(make_cell(0, 0, Some(CellValue::Number(1.0)), None));
    grid1.insert_test(make_cell(1, 0, Some(CellValue::Number(2.0)), None));

    let mut grid2 = Grid::new(2, 1);
    grid2.insert_test(make_cell(0, 0, Some(CellValue::Number(2.0)), None));
    grid2.insert_test(make_cell(1, 0, Some(CellValue::Number(1.0)), None));

    let sig1 = grid1.compute_col_signature(0);
    let sig2 = grid2.compute_col_signature(0);
    assert_ne!(sig1.hash, sig2.hash);
}

#[test]
fn row_signature_independent_of_insertion_order() {
    let mut grid1 = Grid::new(1, 3);
    grid1.insert_test(make_cell(
        0,
        0,
        Some(CellValue::Number(10.0)),
        Some("=A1*2"),
    ));
    grid1.insert_test(make_cell(0, 1, Some(CellValue::Text(sid("mix"))), None));
    grid1.insert_test(make_cell(0, 2, Some(CellValue::Bool(true)), None));

    let mut grid2 = Grid::new(1, 3);
    grid2.insert_test(make_cell(0, 2, Some(CellValue::Bool(true)), None));
    grid2.insert_test(make_cell(
        0,
        0,
        Some(CellValue::Number(10.0)),
        Some("=A1*2"),
    ));
    grid2.insert_test(make_cell(0, 1, Some(CellValue::Text(sid("mix"))), None));

    let sig1 = grid1.compute_row_signature(0).hash;
    let sig2 = grid2.compute_row_signature(0).hash;
    assert_eq!(sig1, sig2);

    grid1.compute_all_signatures();
    grid2.compute_all_signatures();

    let bulk_sig1 = grid1.row_signatures.as_ref().unwrap()[0].hash;
    let bulk_sig2 = grid2.row_signatures.as_ref().unwrap()[0].hash;
    assert_eq!(bulk_sig1, bulk_sig2);
}

#[test]
fn col_signature_independent_of_insertion_order() {
    let mut grid1 = Grid::new(3, 1);
    grid1.insert_test(make_cell(
        0,
        0,
        Some(CellValue::Number(std::f64::consts::E)),
        Some("=EXP(1)"),
    ));
    grid1.insert_test(make_cell(1, 0, Some(CellValue::Text(sid("col"))), None));
    grid1.insert_test(make_cell(2, 0, Some(CellValue::Bool(false)), None));

    let mut grid2 = Grid::new(3, 1);
    grid2.insert_test(make_cell(2, 0, Some(CellValue::Bool(false)), None));
    grid2.insert_test(make_cell(
        0,
        0,
        Some(CellValue::Number(std::f64::consts::E)),
        Some("=EXP(1)"),
    ));
    grid2.insert_test(make_cell(1, 0, Some(CellValue::Text(sid("col"))), None));

    let sig1 = grid1.compute_col_signature(0).hash;
    let sig2 = grid2.compute_col_signature(0).hash;
    assert_eq!(sig1, sig2);

    grid1.compute_all_signatures();
    grid2.compute_all_signatures();

    let bulk_sig1 = grid1.col_signatures.as_ref().unwrap()[0].hash;
    let bulk_sig2 = grid2.col_signatures.as_ref().unwrap()[0].hash;
    assert_eq!(bulk_sig1, bulk_sig2);
}

#[test]
fn col_signature_distinguishes_numeric_text_bool() {
    let mut grid_num = Grid::new(3, 1);
    grid_num.insert_test(make_cell(0, 0, Some(CellValue::Number(1.0)), None));

    let mut grid_text = Grid::new(3, 1);
    grid_text.insert_test(make_cell(0, 0, Some(CellValue::Text(sid("1"))), None));

    let mut grid_bool = Grid::new(3, 1);
    grid_bool.insert_test(make_cell(0, 0, Some(CellValue::Bool(true)), None));

    let num = grid_num.compute_col_signature(0).hash;
    let txt = grid_text.compute_col_signature(0).hash;
    let boo = grid_bool.compute_col_signature(0).hash;

    assert_ne!(num, txt);
    assert_ne!(num, boo);
    assert_ne!(txt, boo);
}

#[test]
fn row_signature_distinguishes_numeric_text_bool() {
    let mut grid_num = Grid::new(1, 1);
    grid_num.insert_test(make_cell(0, 0, Some(CellValue::Number(1.0)), None));

    let mut grid_text = Grid::new(1, 1);
    grid_text.insert_test(make_cell(0, 0, Some(CellValue::Text(sid("1"))), None));

    let mut grid_bool = Grid::new(1, 1);
    grid_bool.insert_test(make_cell(0, 0, Some(CellValue::Bool(true)), None));

    let num = grid_num.compute_row_signature(0).hash;
    let txt = grid_text.compute_row_signature(0).hash;
    let boo = grid_bool.compute_row_signature(0).hash;

    assert_ne!(num, txt);
    assert_ne!(num, boo);
    assert_ne!(txt, boo);
}

#[test]
fn row_signature_ignores_empty_trailing_cells() {
    let mut grid1 = Grid::new(1, 3);
    grid1.insert_test(make_cell(0, 0, Some(CellValue::Number(42.0)), None));

    let mut grid2 = Grid::new(1, 10);
    grid2.insert_test(make_cell(0, 0, Some(CellValue::Number(42.0)), None));

    let sig1 = grid1.compute_row_signature(0).hash;
    let sig2 = grid2.compute_row_signature(0).hash;
    assert_eq!(sig1, sig2);
}

#[test]
fn col_signature_ignores_empty_trailing_rows() {
    let mut grid1 = Grid::new(3, 1);
    grid1.insert_test(make_cell(0, 0, Some(CellValue::Number(42.0)), None));

    let mut grid2 = Grid::new(10, 1);
    grid2.insert_test(make_cell(0, 0, Some(CellValue::Number(42.0)), None));

    let sig1 = grid1.compute_col_signature(0).hash;
    let sig2 = grid2.compute_col_signature(0).hash;
    assert_eq!(sig1, sig2);
}

#[test]
fn col_signature_includes_formulas_by_default() {
    let mut with_formula = Grid::new(2, 1);
    with_formula.insert_test(make_cell(0, 0, Some(CellValue::Number(10.0)), Some("=5+5")));

    let mut without_formula = Grid::new(2, 1);
    without_formula.insert_test(make_cell(0, 0, Some(CellValue::Number(10.0)), None));

    let sig_with = with_formula.compute_col_signature(0).hash;
    let sig_without = without_formula.compute_col_signature(0).hash;
    assert_ne!(sig_with, sig_without);
}

#[test]
fn col_signature_includes_formulas_sparse() {
    let mut formula_short = Grid::new(5, 1);
    formula_short.insert_test(make_cell(
        0,
        0,
        Some(CellValue::Text(sid("foo"))),
        Some("=A2"),
    ));

    let mut formula_tall = Grid::new(10, 1);
    formula_tall.insert_test(make_cell(
        0,
        0,
        Some(CellValue::Text(sid("foo"))),
        Some("=A2"),
    ));

    let mut value_only = Grid::new(10, 1);
    value_only.insert_test(make_cell(0, 0, Some(CellValue::Text(sid("foo"))), None));

    let sig_formula_short = formula_short.compute_col_signature(0).hash;
    let sig_formula_tall = formula_tall.compute_col_signature(0).hash;
    let sig_value_only = value_only.compute_col_signature(0).hash;

    assert_eq!(sig_formula_short, sig_formula_tall);
    assert_ne!(sig_formula_short, sig_value_only);
}

#[test]
fn row_signature_includes_formulas_by_default() {
    let mut grid_with_formula = Grid::new(1, 1);
    grid_with_formula.insert_test(make_cell(0, 0, Some(CellValue::Number(10.0)), Some("=5+5")));

    let mut grid_without_formula = Grid::new(1, 1);
    grid_without_formula.insert_test(make_cell(0, 0, Some(CellValue::Number(10.0)), None));

    let sig_with = grid_with_formula.compute_row_signature(0).hash;
    let sig_without = grid_without_formula.compute_row_signature(0).hash;
    assert_ne!(sig_with, sig_without);
}

#[test]
fn row_signature_is_stable_across_computations() {
    let mut grid = Grid::new(1, 3);
    grid.insert_test(make_cell(0, 0, Some(CellValue::Number(1.0)), None));
    grid.insert_test(make_cell(0, 1, Some(CellValue::Text(sid("x"))), None));
    grid.insert_test(make_cell(0, 2, Some(CellValue::Bool(false)), None));

    let sig1 = grid.compute_row_signature(0);
    let sig2 = grid.compute_row_signature(0);
    assert_eq!(sig1.hash, sig2.hash);
    assert_ne!(sig1.hash, 0);
}

#[test]
fn row_signature_with_formula_is_stable() {
    let mut grid = Grid::new(1, 2);
    grid.insert_test(make_cell(0, 0, Some(CellValue::Number(10.0)), Some("=5+5")));
    grid.insert_test(make_cell(0, 1, Some(CellValue::Text(sid("bar"))), None));

    let sig1 = grid.compute_row_signature(0);
    let sig2 = grid.compute_row_signature(0);
    assert_eq!(sig1.hash, sig2.hash);
    assert_ne!(sig1.hash, 0);
}

#[test]
fn gridview_rowmeta_hash_matches_compute_all_signatures() {
    let mut grid = Grid::new(3, 2);
    grid.insert_test(make_cell(
        0,
        0,
        Some(CellValue::Number(std::f64::consts::PI)),
        Some("=PI()"),
    ));
    grid.insert_test(make_cell(1, 1, Some(CellValue::Text(sid("text"))), None));
    grid.insert_test(make_cell(2, 0, Some(CellValue::Bool(true)), Some("=A1")));

    grid.compute_all_signatures();

    let row_signatures = grid
        .row_signatures
        .as_ref()
        .expect("row signatures should be computed")
        .clone();
    let col_signatures = grid
        .col_signatures
        .as_ref()
        .expect("col signatures should be computed")
        .clone();

    let view = GridView::from_grid(&grid);

    for (idx, meta) in view.row_meta.iter().enumerate() {
        assert_eq!(meta.signature, row_signatures[idx]);
    }

    for (idx, meta) in view.col_meta.iter().enumerate() {
        assert_eq!(meta.hash, col_signatures[idx]);
    }
}

#[test]
fn row_signature_unchanged_after_column_insert_at_position_zero() {
    let mut grid1 = Grid::new(2, 3);
    grid1.insert_test(make_cell(0, 0, Some(CellValue::Number(1.0)), None));
    grid1.insert_test(make_cell(0, 1, Some(CellValue::Number(2.0)), None));
    grid1.insert_test(make_cell(0, 2, Some(CellValue::Number(3.0)), None));
    grid1.insert_test(make_cell(1, 0, Some(CellValue::Text(sid("a"))), None));
    grid1.insert_test(make_cell(1, 1, Some(CellValue::Text(sid("b"))), None));
    grid1.insert_test(make_cell(1, 2, Some(CellValue::Text(sid("c"))), None));

    let mut grid2 = Grid::new(2, 4);
    grid2.insert_test(make_cell(0, 0, Some(CellValue::Number(99.0)), None));
    grid2.insert_test(make_cell(0, 1, Some(CellValue::Number(1.0)), None));
    grid2.insert_test(make_cell(0, 2, Some(CellValue::Number(2.0)), None));
    grid2.insert_test(make_cell(0, 3, Some(CellValue::Number(3.0)), None));
    grid2.insert_test(make_cell(1, 0, Some(CellValue::Text(sid("z"))), None));
    grid2.insert_test(make_cell(1, 1, Some(CellValue::Text(sid("a"))), None));
    grid2.insert_test(make_cell(1, 2, Some(CellValue::Text(sid("b"))), None));
    grid2.insert_test(make_cell(1, 3, Some(CellValue::Text(sid("c"))), None));

    let view1 = GridView::from_grid(&grid1);
    let view2 = GridView::from_grid(&grid2);

    assert_ne!(view1.row_meta[0].signature, view2.row_meta[0].signature);
    assert_ne!(view1.row_meta[1].signature, view2.row_meta[1].signature);
}

#[test]
fn row_signature_unchanged_after_column_delete_from_middle() {
    let mut grid1 = Grid::new(2, 4);
    grid1.insert_test(make_cell(0, 0, Some(CellValue::Number(1.0)), None));
    grid1.insert_test(make_cell(0, 1, Some(CellValue::Number(2.0)), None));
    grid1.insert_test(make_cell(0, 2, Some(CellValue::Number(3.0)), None));
    grid1.insert_test(make_cell(0, 3, Some(CellValue::Number(4.0)), None));
    grid1.insert_test(make_cell(1, 0, Some(CellValue::Text(sid("a"))), None));
    grid1.insert_test(make_cell(1, 1, Some(CellValue::Text(sid("b"))), None));
    grid1.insert_test(make_cell(1, 2, Some(CellValue::Text(sid("c"))), None));
    grid1.insert_test(make_cell(1, 3, Some(CellValue::Text(sid("d"))), None));

    let mut grid2 = Grid::new(2, 3);
    grid2.insert_test(make_cell(0, 0, Some(CellValue::Number(1.0)), None));
    grid2.insert_test(make_cell(0, 1, Some(CellValue::Number(3.0)), None));
    grid2.insert_test(make_cell(0, 2, Some(CellValue::Number(4.0)), None));
    grid2.insert_test(make_cell(1, 0, Some(CellValue::Text(sid("a"))), None));
    grid2.insert_test(make_cell(1, 1, Some(CellValue::Text(sid("c"))), None));
    grid2.insert_test(make_cell(1, 2, Some(CellValue::Text(sid("d"))), None));

    let view1 = GridView::from_grid(&grid1);
    let view2 = GridView::from_grid(&grid2);

    assert_ne!(view1.row_meta[0].signature, view2.row_meta[0].signature);
    assert_ne!(view1.row_meta[1].signature, view2.row_meta[1].signature);
}

#[test]
fn row_signature_consistent_for_same_content_different_column_indices() {
    let mut grid1 = Grid::new(1, 3);
    grid1.insert_test(make_cell(0, 0, Some(CellValue::Number(1.0)), None));
    grid1.insert_test(make_cell(0, 1, Some(CellValue::Number(2.0)), None));
    grid1.insert_test(make_cell(0, 2, Some(CellValue::Number(3.0)), None));

    let mut grid2 = Grid::new(1, 5);
    grid2.insert_test(make_cell(0, 1, Some(CellValue::Number(1.0)), None));
    grid2.insert_test(make_cell(0, 2, Some(CellValue::Number(2.0)), None));
    grid2.insert_test(make_cell(0, 3, Some(CellValue::Number(3.0)), None));

    let view1 = GridView::from_grid(&grid1);
    let view2 = GridView::from_grid(&grid2);

    assert_eq!(view1.row_meta[0].signature, view2.row_meta[0].signature);
}

```

---

### File: `core\tests\sparse_grid_tests.rs`

```rust
use excel_diff::{CellValue, Grid, with_default_session};

#[test]
fn sparse_grid_empty_has_zero_cells() {
    let grid = Grid::new(1000, 1000);
    assert_eq!(grid.cell_count(), 0);
    assert!(grid.is_empty());
    assert_eq!(grid.nrows, 1000);
    assert_eq!(grid.ncols, 1000);
}

#[test]
fn sparse_grid_insert_and_retrieve() {
    let mut grid = Grid::new(100, 100);
    grid.insert_cell(50, 50, Some(CellValue::Number(42.0)), None);
    assert_eq!(grid.cell_count(), 1);
    let retrieved = grid.get(50, 50).expect("cell should exist");
    assert_eq!(retrieved.value, Some(CellValue::Number(42.0)));
    assert!(grid.get(0, 0).is_none());
}

#[test]
fn sparse_grid_iter_cells_only_populated() {
    let mut grid = Grid::new(1000, 1000);
    for i in 0..10 {
        grid.insert_cell(i * 100, i * 100, Some(CellValue::Number(i as f64)), None);
    }
    let cells: Vec<_> = grid.iter_cells().collect();
    assert_eq!(cells.len(), 10);
}

#[test]
fn sparse_grid_memory_efficiency() {
    let grid = Grid::new(10_000, 1_000);
    assert!(std::mem::size_of_val(&grid) < 1024);
}

#[test]
fn rows_iter_covers_all_rows() {
    let grid = Grid::new(3, 5);
    let rows: Vec<u32> = grid.rows_iter().collect();
    assert_eq!(rows, vec![0, 1, 2]);
}

#[test]
fn cols_iter_covers_all_cols() {
    let grid = Grid::new(4, 2);
    let cols: Vec<u32> = grid.cols_iter().collect();
    assert_eq!(cols, vec![0, 1]);
}

#[test]
fn rows_iter_and_get_are_consistent() {
    let mut grid = Grid::new(2, 2);
    grid.insert_cell(1, 1, Some(CellValue::Number(1.0)), None);

    for r in grid.rows_iter() {
        for c in grid.cols_iter() {
            let _ = grid.get(r, c);
        }
    }
}

#[test]
fn sparse_grid_all_empty_rows_have_zero_signatures() {
    let mut grid = Grid::new(2, 3);

    grid.compute_all_signatures();

    let row_sigs = grid
        .row_signatures
        .as_ref()
        .expect("row signatures should exist");
    let col_sigs = grid
        .col_signatures
        .as_ref()
        .expect("col signatures should exist");

    assert_eq!(row_sigs.len(), 2);
    assert_eq!(col_sigs.len(), 3);
    let empty_row_hash = row_sigs[0].hash;
    let empty_col_hash = col_sigs[0].hash;
    assert!(row_sigs.iter().all(|sig| sig.hash == empty_row_hash));
    assert!(col_sigs.iter().all(|sig| sig.hash == empty_col_hash));
}

#[test]
fn compute_signatures_on_sparse_grid_produces_hashes() {
    let mut grid = Grid::new(4, 4);
    with_default_session(|session| {
        let text_id = session.strings.intern("value");
        let formula_id = session.strings.intern("=A1");
        grid.insert_cell(1, 3, Some(CellValue::Text(text_id)), Some(formula_id));
    });

    grid.compute_all_signatures();

    let row_hash = grid
        .row_signatures
        .as_ref()
        .expect("row signatures should exist")[1]
        .hash;
    let col_hash = grid
        .col_signatures
        .as_ref()
        .expect("col signatures should exist")[3]
        .hash;

    assert_ne!(row_hash, 0);
    assert_ne!(col_hash, 0);
}

#[test]
fn compute_all_signatures_matches_direct_computation() {
    let mut grid = Grid::new(3, 3);
    with_default_session(|session| {
        let formula_a = session.strings.intern("=5+5");
        let text_id = session.strings.intern("x");
        let formula_b = session.strings.intern("=A1");
        grid.insert_cell(0, 1, Some(CellValue::Number(10.0)), Some(formula_a));
        grid.insert_cell(1, 0, Some(CellValue::Text(text_id)), None);
        grid.insert_cell(2, 2, Some(CellValue::Bool(false)), Some(formula_b));
    });

    grid.compute_all_signatures();

    let row_sigs = grid
        .row_signatures
        .as_ref()
        .expect("row signatures should exist");
    let col_sigs = grid
        .col_signatures
        .as_ref()
        .expect("col signatures should exist");

    assert_eq!(grid.compute_row_signature(0).hash, row_sigs[0].hash);
    assert_eq!(grid.compute_row_signature(2).hash, row_sigs[2].hash);
    assert_eq!(grid.compute_col_signature(0).hash, col_sigs[0].hash);
    assert_eq!(grid.compute_col_signature(2).hash, col_sigs[2].hash);
}

```

---

### File: `core\tests\streaming_sink_tests.rs`

```rust
use excel_diff::{
    CallbackSink, CellValue, DiffConfig, DiffOp, DiffSession, Grid, Sheet, SheetKind, VecSink,
    Workbook, try_diff_workbooks_streaming,
};

fn make_test_workbook(session: &mut DiffSession, values: &[f64]) -> Workbook {
    let mut grid = Grid::new(values.len() as u32, 1);
    for (i, &val) in values.iter().enumerate() {
        grid.insert_cell(i as u32, 0, Some(CellValue::Number(val)), None);
    }

    let sheet_name = session.strings.intern("TestSheet");

    Workbook {
        sheets: vec![Sheet {
            name: sheet_name,
            kind: SheetKind::Worksheet,
            grid,
        }],
        ..Default::default()
    }
}

#[test]
fn vec_sink_and_callback_sink_produce_identical_ops() {
    let mut session = DiffSession::new();

    let wb_a = make_test_workbook(&mut session, &[1.0, 2.0, 3.0]);
    let wb_b = make_test_workbook(&mut session, &[1.0, 5.0, 3.0, 4.0]);

    let config = DiffConfig::default();

    let mut vec_sink = VecSink::new();
    let summary_vec =
        try_diff_workbooks_streaming(&wb_a, &wb_b, &mut session.strings, &config, &mut vec_sink)
            .expect("VecSink diff should succeed");
    let vec_ops = vec_sink.into_ops();

    let mut callback_ops: Vec<DiffOp> = Vec::new();
    {
        let mut callback_sink = CallbackSink::new(|op| callback_ops.push(op));
        let summary_callback = try_diff_workbooks_streaming(
            &wb_a,
            &wb_b,
            &mut session.strings,
            &config,
            &mut callback_sink,
        )
        .expect("CallbackSink diff should succeed");

        assert_eq!(
            summary_vec.op_count, summary_callback.op_count,
            "summaries should report same op count"
        );
        assert_eq!(
            summary_vec.complete, summary_callback.complete,
            "summaries should report same complete status"
        );
    }

    assert_eq!(
        vec_ops.len(),
        callback_ops.len(),
        "both sinks should collect same number of ops"
    );

    for (i, (vec_op, cb_op)) in vec_ops.iter().zip(callback_ops.iter()).enumerate() {
        assert_eq!(
            vec_op, cb_op,
            "op at index {} should be identical between VecSink and CallbackSink",
            i
        );
    }

    assert!(
        !vec_ops.is_empty(),
        "expected at least one diff op for the test workbooks"
    );
}

#[test]
fn streaming_produces_ops_in_consistent_order() {
    let mut session = DiffSession::new();

    let wb_a = make_test_workbook(&mut session, &[1.0, 2.0]);
    let wb_b = make_test_workbook(&mut session, &[3.0, 4.0]);

    let config = DiffConfig::default();

    let mut first_run_ops: Vec<DiffOp> = Vec::new();
    {
        let mut sink = CallbackSink::new(|op| first_run_ops.push(op));
        try_diff_workbooks_streaming(&wb_a, &wb_b, &mut session.strings, &config, &mut sink)
            .expect("first run should succeed");
    }

    let mut second_run_ops: Vec<DiffOp> = Vec::new();
    {
        let mut sink = CallbackSink::new(|op| second_run_ops.push(op));
        try_diff_workbooks_streaming(&wb_a, &wb_b, &mut session.strings, &config, &mut sink)
            .expect("second run should succeed");
    }

    assert_eq!(
        first_run_ops, second_run_ops,
        "streaming output should be deterministic across runs"
    );
}

#[test]
fn streaming_summary_matches_collected_ops() {
    let mut session = DiffSession::new();

    let wb_a = make_test_workbook(&mut session, &[1.0]);
    let wb_b = make_test_workbook(&mut session, &[2.0, 3.0]);

    let config = DiffConfig::default();

    let mut op_count = 0usize;
    let summary = {
        let mut sink = CallbackSink::new(|_op| op_count += 1);
        try_diff_workbooks_streaming(&wb_a, &wb_b, &mut session.strings, &config, &mut sink)
            .expect("streaming should succeed")
    };

    assert_eq!(
        summary.op_count, op_count,
        "summary.op_count should match actual ops emitted"
    );
    assert!(summary.complete, "diff should be complete");
}

```

---

### File: `core\tests\string_pool_tests.rs`

```rust
use excel_diff::StringPool;

#[test]
fn intern_50k_identical_strings_returns_same_id() {
    let mut pool = StringPool::new();
    let first_id = pool.intern("repeated_string");

    for _ in 1..50_000 {
        let id = pool.intern("repeated_string");
        assert_eq!(id, first_id, "interning same string must return same id");
    }

    assert!(
        pool.len() >= 2,
        "pool should have at least 2 entries (empty string + our string)"
    );
    assert!(
        pool.len() <= 3,
        "pool should not grow beyond initial strings"
    );

    assert_eq!(pool.resolve(first_id), "repeated_string");
}

#[test]
fn intern_distinct_strings_returns_different_ids() {
    let mut pool = StringPool::new();

    let id_a = pool.intern("alpha");
    let id_b = pool.intern("beta");
    let id_c = pool.intern("gamma");

    assert_ne!(id_a, id_b);
    assert_ne!(id_b, id_c);
    assert_ne!(id_a, id_c);

    assert_eq!(pool.resolve(id_a), "alpha");
    assert_eq!(pool.resolve(id_b), "beta");
    assert_eq!(pool.resolve(id_c), "gamma");
}

#[test]
fn empty_string_is_pre_interned() {
    let pool = StringPool::new();

    assert!(pool.len() >= 1, "pool should have at least empty string");
    assert_eq!(pool.resolve(excel_diff::StringId(0)), "");
}

#[test]
fn resolve_returns_original_string() {
    let mut pool = StringPool::new();

    let test_cases = vec![
        "hello",
        "world",
        "with spaces",
        "with\nnewline",
        "unicode: ",
        "",
    ];

    for s in &test_cases {
        let id = pool.intern(s);
        assert_eq!(pool.resolve(id), *s);
    }
}

#[test]
fn into_strings_returns_all_interned() {
    let mut pool = StringPool::new();

    pool.intern("first");
    pool.intern("second");
    pool.intern("third");

    let strings = pool.into_strings();

    assert!(strings.contains(&"".to_string()));
    assert!(strings.contains(&"first".to_string()));
    assert!(strings.contains(&"second".to_string()));
    assert!(strings.contains(&"third".to_string()));
    assert_eq!(strings.len(), 4);
}

```

---

### File: `fixtures\manifest.yaml`

```yaml
scenarios:
  # --- Phase 1.1: Basic File Opening ---
  - id: "smoke_minimal"
    generator: "basic_grid"
    args: { rows: 1, cols: 1 }
    output: "minimal.xlsx"

  # --- Phase 1.2: Is this a ZIP? ---
  - id: "container_random_zip"
    generator: "corrupt_container"
    args: { mode: "random_zip" }
    output: "random_zip.zip"
    
  - id: "container_no_content_types"
    generator: "corrupt_container"
    args: { mode: "no_content_types" }
    output: "no_content_types.xlsx"

  - id: "container_not_zip_text"
    generator: "corrupt_container"
    args: { mode: "not_zip_text" }
    output: "not_a_zip.txt"

  # --- PG1: Workbook -> Sheet -> Grid IR sanity ---
  - id: "pg1_basic_two_sheets"
    generator: "basic_grid"
    args: { rows: 3, cols: 3, two_sheets: true } # Sheet1 3x3, Sheet2 5x2 (logic in generator)
    output: "pg1_basic_two_sheets.xlsx"

  - id: "pg1_sparse"
    generator: "sparse_grid"
    output: "pg1_sparse_used_range.xlsx"

  - id: "pg1_mixed"
    generator: "edge_case"
    output: "pg1_empty_and_mixed_sheets.xlsx"

  # --- PG2: Addressing and index invariants ---
  - id: "pg2_addressing"
    generator: "address_sanity"
    args:
      targets: ["A1", "B2", "C3", "Z1", "Z10", "AA1", "AA10", "AB7", "AZ5", "BA1", "ZZ10", "AAA1"]
    output: "pg2_addressing_matrix.xlsx"

  # --- PG3: Cell snapshots and comparison semantics ---
  - id: "pg3_types"
    generator: "value_formula"
    output: "pg3_value_and_formula_cells.xlsx"

  # --- Phase 3: Spreadsheet-mode G1/G2 ---
  - id: "g1_equal_sheet"
    generator: "basic_grid"
    args:
      rows: 5
      cols: 5
      sheet: "Sheet1"
    output:
      - "equal_sheet_a.xlsx"
      - "equal_sheet_b.xlsx"

  - id: "g2_single_cell_value"
    generator: "single_cell_diff"
    args:
      rows: 5
      cols: 5
      sheet: "Sheet1"
      target_cell: "C3"
      value_a: 1.0
      value_b: 2.0
    output:
      - "single_cell_value_a.xlsx"
      - "single_cell_value_b.xlsx"

  # --- Phase 3: Spreadsheet-mode G5-G7 ---

  - id: "g5_multi_cell_edits"
    generator: "multi_cell_diff"
    args:
      rows: 20
      cols: 10
      sheet: "Sheet1"
      edits:
        - { addr: "B2", value_a: 1.0, value_b: 42.0 }
        - { addr: "D5", value_a: 2.0, value_b: 99.0 }
        - { addr: "H7", value_a: 3.0, value_b: 3.5 }
        - { addr: "J10", value_a: "x", value_b: "y" }
    output:
      - "multi_cell_edits_a.xlsx"
      - "multi_cell_edits_b.xlsx"

  - id: "g6_row_append_bottom"
    generator: "grid_tail_diff"
    args:
      mode: "row_append_bottom"
      sheet: "Sheet1"
      base_rows: 10
      tail_rows: 2
    output:
      - "row_append_bottom_a.xlsx"
      - "row_append_bottom_b.xlsx"

  - id: "g6_row_delete_bottom"
    generator: "grid_tail_diff"
    args:
      mode: "row_delete_bottom"
      sheet: "Sheet1"
      base_rows: 10
      tail_rows: 2
    output:
      - "row_delete_bottom_a.xlsx"
      - "row_delete_bottom_b.xlsx"

  - id: "g7_col_append_right"
    generator: "grid_tail_diff"
    args:
      mode: "col_append_right"
      sheet: "Sheet1"
      base_cols: 4
      tail_cols: 2
    output:
      - "col_append_right_a.xlsx"
      - "col_append_right_b.xlsx"

  - id: "g7_col_delete_right"
    generator: "grid_tail_diff"
    args:
      mode: "col_delete_right"
      sheet: "Sheet1"
      base_cols: 4
      tail_cols: 2
    output:
      - "col_delete_right_a.xlsx"
      - "col_delete_right_b.xlsx"

  # --- Phase 4: Spreadsheet-mode G8 ---
  - id: "g8_row_insert_middle"
    generator: "row_alignment_g8"
    args:
      mode: "insert"
      sheet: "Sheet1"
      base_rows: 10
      cols: 5
      insert_at: 6
    output:
      - "row_insert_middle_a.xlsx"
      - "row_insert_middle_b.xlsx"

  - id: "g8_row_delete_middle"
    generator: "row_alignment_g8"
    args:
      mode: "delete"
      sheet: "Sheet1"
      base_rows: 10
      cols: 5
      delete_row: 6
    output:
      - "row_delete_middle_a.xlsx"
      - "row_delete_middle_b.xlsx"

  - id: "g8_row_insert_with_edit_below"
    generator: "row_alignment_g8"
    args:
      mode: "insert_with_edit"
      sheet: "Sheet1"
      base_rows: 10
      cols: 5
      insert_at: 6
      edit_row: 8
      edit_col: 3
    output:
      - "row_insert_with_edit_a.xlsx"
      - "row_insert_with_edit_b.xlsx"

  # --- Phase 4: Spreadsheet-mode G9 ---
  - id: "g9_col_insert_middle"
    generator: "column_alignment_g9"
    args:
      mode: "insert"
      sheet: "Data"
      cols: 8
      data_rows: 9
      insert_at: 4
    output:
      - "col_insert_middle_a.xlsx"
      - "col_insert_middle_b.xlsx"

  - id: "g9_col_delete_middle"
    generator: "column_alignment_g9"
    args:
      mode: "delete"
      sheet: "Data"
      cols: 8
      data_rows: 9
      delete_col: 4
    output:
      - "col_delete_middle_a.xlsx"
      - "col_delete_middle_b.xlsx"

  - id: "g9_col_insert_with_edit"
    generator: "column_alignment_g9"
    args:
      mode: "insert_with_edit"
      sheet: "Data"
      cols: 8
      data_rows: 9
      insert_at: 4
      edit_row: 8
      edit_col_after_insert: 7
    output:
      - "col_insert_with_edit_a.xlsx"
      - "col_insert_with_edit_b.xlsx"

  # --- Phase 4: Spreadsheet-mode G10 ---
  - id: "g10_row_block_insert"
    generator: "row_alignment_g10"
    args:
      mode: "block_insert"
      sheet: "Sheet1"
      base_rows: 10
      cols: 5
      block_rows: 4
      insert_at: 4
    output:
      - "row_block_insert_a.xlsx"
      - "row_block_insert_b.xlsx"

  - id: "g10_row_block_delete"
    generator: "row_alignment_g10"
    args:
      mode: "block_delete"
      sheet: "Sheet1"
      base_rows: 10
      cols: 5
      block_rows: 4
      delete_start: 4
    output:
      - "row_block_delete_a.xlsx"
      - "row_block_delete_b.xlsx"

  # --- Phase 4: Spreadsheet-mode G11 ---
  - id: "g11_row_block_move"
    generator: "row_block_move_g11"
    args:
      sheet: "Sheet1"
      total_rows: 20
      cols: 5
      block_rows: 4
      src_start: 5    # 1-based in A
      dst_start: 13   # 1-based in B
    output:
      - "row_block_move_a.xlsx"
      - "row_block_move_b.xlsx"

  # --- Phase 4: Spreadsheet-mode G12 (column move only - G12a) ---
  - id: "g12_column_block_move"
    generator: "column_move_g12"
    args:
      sheet: "Data"
      cols: 8
      data_rows: 9
      src_col: 3      # 1-based: C
      dst_col: 6      # 1-based: F
    output:
      - "column_move_a.xlsx"
      - "column_move_b.xlsx"

  - id: "g12_rect_block_move"
    generator: "rect_block_move_g12"
    args:
      sheet: "Data"
      rows: 15
      cols: 15
      src_top: 3      # 1-based row in A (Excel row 3)
      src_left: 2     # 1-based column in A (Excel column B)
      dst_top: 10     # 1-based row in B (Excel row 10)
      dst_left: 7     # 1-based column in B (Excel column G)
      block_rows: 3
      block_cols: 3
    output:
      - "rect_block_move_a.xlsx"
      - "rect_block_move_b.xlsx"

  # --- Phase 4: Spreadsheet-mode G13 ---
  - id: "g13_fuzzy_row_move"
    generator: "row_fuzzy_move_g13"
    args:
      sheet: "Data"
      total_rows: 24
      cols: 6
      block_rows: 4
      src_start: 5      # 1-based in A
      dst_start: 14     # 1-based in B
      edits:
        - { row_offset: 1, col: 3, delta: 1 }
    output:
      - "grid_move_and_edit_a.xlsx"
      - "grid_move_and_edit_b.xlsx"

  # --- JSON diff: simple non-empty change ---
  - id: "json_diff_single_cell"
    generator: "single_cell_diff"
    args:
      rows: 3
      cols: 3
      sheet: "Sheet1"
      target_cell: "C3"
      value_a: "1"
      value_b: "2"
    output:
      - "json_diff_single_cell_a.xlsx"
      - "json_diff_single_cell_b.xlsx"

  - id: "json_diff_single_bool"
    generator: "single_cell_diff"
    args:
      rows: 3
      cols: 3
      sheet: "Sheet1"
      target_cell: "C3"
      value_a: true
      value_b: false
    output:
      - "json_diff_bool_a.xlsx"
      - "json_diff_bool_b.xlsx"

  - id: "json_diff_value_to_empty"
    generator: "single_cell_diff"
    args:
      rows: 3
      cols: 3
      sheet: "Sheet1"
      target_cell: "C3"
      value_a: "1"
      value_b: null
    output:
      - "json_diff_value_to_empty_a.xlsx"
      - "json_diff_value_to_empty_b.xlsx"

  # --- Sheet identity: case-only renames ---
  - id: "sheet_case_only_rename"
    generator: "sheet_case_rename"
    args:
      sheet_a: "Sheet1"
      sheet_b: "sheet1"
      cell: "A1"
      value_a: 1.0
      value_b: 1.0
    output:
      - "sheet_case_only_rename_a.xlsx"
      - "sheet_case_only_rename_b.xlsx"

  - id: "sheet_case_only_rename_cell_edit"
    generator: "sheet_case_rename"
    args:
      sheet_a: "Sheet1"
      sheet_b: "sheet1"
      cell: "A1"
      value_a: 1.0
      value_b: 2.0
    output:
      - "sheet_case_only_rename_edit_a.xlsx"
      - "sheet_case_only_rename_edit_b.xlsx"

  # --- PG6: Object graph vs grid responsibilities ---
  - id: "pg6_sheet_added"
    generator: "pg6_sheet_scenario"
    args:
      mode: "sheet_added"
    output:
      - "pg6_sheet_added_a.xlsx"
      - "pg6_sheet_added_b.xlsx"

  - id: "pg6_sheet_removed"
    generator: "pg6_sheet_scenario"
    args:
      mode: "sheet_removed"
    output:
      - "pg6_sheet_removed_a.xlsx"
      - "pg6_sheet_removed_b.xlsx"

  - id: "pg6_sheet_renamed"
    generator: "pg6_sheet_scenario"
    args:
      mode: "sheet_renamed"
    output:
      - "pg6_sheet_renamed_a.xlsx"
      - "pg6_sheet_renamed_b.xlsx"

  - id: "pg6_sheet_and_grid_change"
    generator: "pg6_sheet_scenario"
    args:
      mode: "sheet_and_grid_change"
    output:
      - "pg6_sheet_and_grid_change_a.xlsx"
      - "pg6_sheet_and_grid_change_b.xlsx"

  # --- Milestone 2.2: Base64 Correctness ---
  - id: "corrupt_base64"
    generator: "mashup_corrupt"
    args: 
      base_file: "templates/base_query.xlsx"
      mode: "byte_flip"
    output: "corrupt_base64.xlsx"

  - id: "duplicate_datamashup_parts"
    generator: "mashup_duplicate"
    args:
      base_file: "templates/base_query.xlsx"
    output: "duplicate_datamashup_parts.xlsx"

  - id: "duplicate_datamashup_elements"
    generator: "mashup_duplicate"
    args:
      base_file: "templates/base_query.xlsx"
      mode: "element"
    output: "duplicate_datamashup_elements.xlsx"

  - id: "mashup_utf16_le"
    generator: "mashup_encode"
    args:
      base_file: "templates/base_query.xlsx"
      encoding: "utf-16-le"
    output: "mashup_utf16_le.xlsx"

  - id: "mashup_utf16_be"
    generator: "mashup_encode"
    args:
      base_file: "templates/base_query.xlsx"
      encoding: "utf-16-be"
    output: "mashup_utf16_be.xlsx"

  - id: "mashup_base64_whitespace"
    generator: "mashup_encode"
    args:
      base_file: "templates/base_query.xlsx"
      whitespace: true
    output: "mashup_base64_whitespace.xlsx"

  # --- Milestone 4.1: PackageParts ---
  - id: "m4_packageparts_one_query"
    generator: "mashup:one_query"
    args:
      base_file: "templates/base_query.xlsx"
    output: "one_query.xlsx"

  - id: "m4_packageparts_multi_embedded"
    generator: "mashup:multi_query_with_embedded"
    args:
      base_file: "templates/base_query.xlsx"
    output: "multi_query_with_embedded.xlsx"

  # --- Milestone 4.2-4.4: Permissions / Metadata ---
  - id: "permissions_defaults"
    generator: "mashup:permissions_metadata"
    args:
      mode: "permissions_defaults"
      base_file: "templates/base_query.xlsx"
    output: "permissions_defaults.xlsx"

  - id: "permissions_firewall_off"
    generator: "mashup:permissions_metadata"
    args:
      mode: "permissions_firewall_off"
      base_file: "templates/base_query.xlsx"
    output: "permissions_firewall_off.xlsx"

  - id: "metadata_simple"
    generator: "mashup:permissions_metadata"
    args:
      mode: "metadata_simple"
      base_file: "templates/base_query.xlsx"
    output: "metadata_simple.xlsx"

  - id: "metadata_query_groups"
    generator: "mashup:permissions_metadata"
    args:
      mode: "metadata_query_groups"
      base_file: "templates/base_query.xlsx"
    output: "metadata_query_groups.xlsx"

  - id: "metadata_hidden_queries"
    generator: "mashup:permissions_metadata"
    args:
      mode: "metadata_hidden_queries"
      base_file: "templates/base_query.xlsx"
    output: "metadata_hidden_queries.xlsx"

  - id: "metadata_missing_entry"
    generator: "mashup:permissions_metadata"
    args:
      mode: "metadata_missing_entry"
      base_file: "templates/base_query.xlsx"
    output: "metadata_missing_entry.xlsx"

  - id: "metadata_url_encoding"
    generator: "mashup:permissions_metadata"
    args:
      mode: "metadata_url_encoding"
      base_file: "templates/base_query.xlsx"
    output: "metadata_url_encoding.xlsx"

  - id: "metadata_orphan_entries"
    generator: "mashup:permissions_metadata"
    args:
      mode: "metadata_orphan_entries"
      base_file: "templates/base_query.xlsx"
    output: "metadata_orphan_entries.xlsx"

  # --- Milestone 6: Basic M Diffs ---
  - id: "m_add_query_a"
    generator: "mashup:permissions_metadata"
    args:
      mode: "m_add_query_a"
      base_file: "templates/base_query.xlsx"
    output: "m_add_query_a.xlsx"

  - id: "m_add_query_b"
    generator: "mashup:permissions_metadata"
    args:
      mode: "m_add_query_b"
      base_file: "templates/base_query.xlsx"
    output: "m_add_query_b.xlsx"

  - id: "m_remove_query_a"
    generator: "mashup:permissions_metadata"
    args:
      mode: "m_remove_query_a"
      base_file: "templates/base_query.xlsx"
    output: "m_remove_query_a.xlsx"

  - id: "m_remove_query_b"
    generator: "mashup:permissions_metadata"
    args:
      mode: "m_remove_query_b"
      base_file: "templates/base_query.xlsx"
    output: "m_remove_query_b.xlsx"

  - id: "m_change_literal_a"
    generator: "mashup:permissions_metadata"
    args:
      mode: "m_change_literal_a"
      base_file: "templates/base_query.xlsx"
    output: "m_change_literal_a.xlsx"

  - id: "m_change_literal_b"
    generator: "mashup:permissions_metadata"
    args:
      mode: "m_change_literal_b"
      base_file: "templates/base_query.xlsx"
    output: "m_change_literal_b.xlsx"

  - id: "m_metadata_only_change_a"
    generator: "mashup:permissions_metadata"
    args:
      mode: "m_metadata_only_change_a"
      base_file: "templates/base_query.xlsx"
    output: "m_metadata_only_change_a.xlsx"

  - id: "m_metadata_only_change_b"
    generator: "mashup:permissions_metadata"
    args:
      mode: "m_metadata_only_change_b"
      base_file: "templates/base_query.xlsx"
    output: "m_metadata_only_change_b.xlsx"

  - id: "m_def_and_metadata_change_a"
    generator: "mashup:permissions_metadata"
    args:
      mode: "m_def_and_metadata_change_a"
      base_file: "templates/base_query.xlsx"
    output: "m_def_and_metadata_change_a.xlsx"

  - id: "m_def_and_metadata_change_b"
    generator: "mashup:permissions_metadata"
    args:
      mode: "m_def_and_metadata_change_b"
      base_file: "templates/base_query.xlsx"
    output: "m_def_and_metadata_change_b.xlsx"

  - id: "m_rename_query_a"
    generator: "mashup:permissions_metadata"
    args:
      mode: "m_rename_query_a"
      base_file: "templates/base_query.xlsx"
    output: "m_rename_query_a.xlsx"

  - id: "m_rename_query_b"
    generator: "mashup:permissions_metadata"
    args:
      mode: "m_rename_query_b"
      base_file: "templates/base_query.xlsx"
    output: "m_rename_query_b.xlsx"

  # --- Milestone 7: M AST canonicalization ---
  - id: "m_formatting_only_a"
    generator: "mashup:permissions_metadata"
    args:
      mode: "m_formatting_only_a"
      base_file: "templates/base_query.xlsx"
    output: "m_formatting_only_a.xlsx"

  - id: "m_formatting_only_b"
    generator: "mashup:permissions_metadata"
    args:
      mode: "m_formatting_only_b"
      base_file: "templates/base_query.xlsx"
    output: "m_formatting_only_b.xlsx"

  - id: "m_formatting_only_b_variant"
    generator: "mashup:permissions_metadata"
    args:
      mode: "m_formatting_only_b_variant"
      base_file: "templates/base_query.xlsx"
    output: "m_formatting_only_b_variant.xlsx"

  # --- Milestone 8: M Parser Expansion ---
  - id: "m_record_equiv_a"
    generator: "mashup:permissions_metadata"
    args:
      mode: "m_record_equiv_a"
      base_file: "templates/base_query.xlsx"
    output: "m_record_equiv_a.xlsx"

  - id: "m_record_equiv_b"
    generator: "mashup:permissions_metadata"
    args:
      mode: "m_record_equiv_b"
      base_file: "templates/base_query.xlsx"
    output: "m_record_equiv_b.xlsx"

  - id: "m_list_formatting_a"
    generator: "mashup:permissions_metadata"
    args:
      mode: "m_list_formatting_a"
      base_file: "templates/base_query.xlsx"
    output: "m_list_formatting_a.xlsx"

  - id: "m_list_formatting_b"
    generator: "mashup:permissions_metadata"
    args:
      mode: "m_list_formatting_b"
      base_file: "templates/base_query.xlsx"
    output: "m_list_formatting_b.xlsx"

  - id: "m_call_formatting_a"
    generator: "mashup:permissions_metadata"
    args:
      mode: "m_call_formatting_a"
      base_file: "templates/base_query.xlsx"
    output: "m_call_formatting_a.xlsx"

  - id: "m_call_formatting_b"
    generator: "mashup:permissions_metadata"
    args:
      mode: "m_call_formatting_b"
      base_file: "templates/base_query.xlsx"
    output: "m_call_formatting_b.xlsx"

  - id: "m_primitive_formatting_a"
    generator: "mashup:permissions_metadata"
    args:
      mode: "m_primitive_formatting_a"
      base_file: "templates/base_query.xlsx"
    output: "m_primitive_formatting_a.xlsx"

  - id: "m_primitive_formatting_b"
    generator: "mashup:permissions_metadata"
    args:
      mode: "m_primitive_formatting_b"
      base_file: "templates/base_query.xlsx"
    output: "m_primitive_formatting_b.xlsx"

  # --- P1: Large Dense Grid (Performance Baseline) ---
  - id: "p1_large_dense"
    generator: "perf_large"
    args: 
      rows: 50000 
      cols: 20
      mode: "dense" # Deterministic "R1C1" style data
    output: "grid_large_dense.xlsx"

  # --- P2: Large Noise Grid (Worst-case Alignment) ---
  - id: "p2_large_noise"
    generator: "perf_large"
    args: 
      rows: 50000 
      cols: 20
      mode: "noise" # Random float data
      seed: 12345
    output: "grid_large_noise.xlsx"

  # --- D1: Keyed Equality (Database Mode) ---
  # File A: Ordered IDs 1..1000
  - id: "db_equal_ordered_a"
    generator: "db_keyed"
    args: { count: 1000, shuffle: false, seed: 42 }
    output: "db_equal_ordered_a.xlsx"

  # File B: Same data, random order (Tests O(N) alignment)
  - id: "db_equal_ordered_b"
    generator: "db_keyed"
    args: { count: 1000, shuffle: true, seed: 42 }
    output: "db_equal_ordered_b.xlsx"

  # --- D2: Row Added (Database Mode) ---
  - id: "db_row_added_b"
    generator: "db_keyed"
    args: 
      count: 1000 
      seed: 42 
      extra_rows: [{id: 1001, name: "New Row", amount: 999}]
    output: "db_row_added_b.xlsx"

  # --- D3: Row Update (Database Mode) ---
  - id: "db_row_update_b"
    generator: "db_keyed"
    args:
      count: 1000
      seed: 42
      updates:
        - { id: 7, amount: 120 }
    output: "db_row_update_b.xlsx"

  # --- D4: Reorder + Change (Database Mode) ---
  - id: "db_reorder_and_change_b"
    generator: "db_keyed"
    args:
      count: 1000
      seed: 42
      shuffle: true
      updates:
        - { id: 7, amount: 120 }
    output: "db_reorder_and_change_b.xlsx"

  # --- P3: Adversarial Repetitive Grid (RLE stress test) ---
  - id: "p3_adversarial_repetitive"
    generator: "perf_large"
    args: 
      rows: 50000 
      cols: 50
      mode: "repetitive"
      pattern_length: 100
      seed: 99999
    output: "grid_adversarial_repetitive.xlsx"

  # --- P4: 99% Blank Grid (Sparse stress test) ---
  - id: "p4_99_percent_blank"
    generator: "perf_large"
    args: 
      rows: 50000 
      cols: 100
      mode: "sparse"
      fill_percent: 1
      seed: 77777
    output: "grid_99_percent_blank.xlsx"

  # --- P5: Identical Grids (Fast-path baseline) ---
  - id: "p5_identical"
    generator: "perf_large"
    args: 
      rows: 50000 
      cols: 100
      mode: "dense"
    output: "grid_identical.xlsx"

  # --- Branch 4: Workbook Object Graph ---
  - id: "branch4_named_ranges"
    generator: "named_ranges"
    output:
      - "named_ranges_a.xlsx"
      - "named_ranges_b.xlsx"

  - id: "branch4_charts"
    generator: "charts"
    output:
      - "charts_a.xlsx"
      - "charts_b.xlsx"

  - id: "branch4_vba_base"
    generator: "copy_template"
    args:
      template: "templates/vba_base.xlsm"
    output: "vba_base.xlsm"

  - id: "branch4_vba_added"
    generator: "copy_template"
    args:
      template: "templates/vba_added.xlsm"
    output: "vba_added.xlsm"

  - id: "branch4_vba_changed"
    generator: "copy_template"
    args:
      template: "templates/vba_changed.xlsm"
    output: "vba_changed.xlsm"

```

---

### File: `fixtures\manifest_cli_tests.yaml`

```yaml
scenarios:
  - id: "pg1_basic_two_sheets"
    generator: "basic_grid"
    args: { rows: 3, cols: 3, two_sheets: true }
    output: "pg1_basic_two_sheets.xlsx"

  - id: "m4_packageparts_one_query"
    generator: "mashup:one_query"
    args:
      base_file: "templates/base_query.xlsx"
    output: "one_query.xlsx"

  - id: "g1_equal_sheet"
    generator: "basic_grid"
    args:
      rows: 5
      cols: 5
      sheet: "Sheet1"
    output:
      - "equal_sheet_a.xlsx"
      - "equal_sheet_b.xlsx"

  - id: "g2_single_cell_value"
    generator: "single_cell_diff"
    args:
      rows: 5
      cols: 5
      sheet: "Sheet1"
      target_cell: "C3"
      value_a: 1.0
      value_b: 2.0
    output:
      - "single_cell_value_a.xlsx"
      - "single_cell_value_b.xlsx"

  - id: "g8_row_insert_middle"
    generator: "row_alignment_g8"
    args:
      mode: "insert"
      sheet: "Sheet1"
      base_rows: 10
      cols: 5
      insert_at: 6
    output:
      - "row_insert_middle_a.xlsx"
      - "row_insert_middle_b.xlsx"

  - id: "g9_col_insert_middle"
    generator: "column_alignment_g9"
    args:
      mode: "insert"
      sheet: "Data"
      cols: 8
      data_rows: 9
      insert_at: 4
    output:
      - "col_insert_middle_a.xlsx"
      - "col_insert_middle_b.xlsx"

  - id: "m_add_query_a"
    generator: "mashup:permissions_metadata"
    args:
      mode: "m_add_query_a"
      base_file: "templates/base_query.xlsx"
    output: "m_add_query_a.xlsx"

  - id: "m_add_query_b"
    generator: "mashup:permissions_metadata"
    args:
      mode: "m_add_query_b"
      base_file: "templates/base_query.xlsx"
    output: "m_add_query_b.xlsx"

  - id: "branch4_named_ranges"
    generator: "named_ranges"
    output:
      - "named_ranges_a.xlsx"
      - "named_ranges_b.xlsx"

  - id: "branch4_charts"
    generator: "charts"
    output:
      - "charts_a.xlsx"
      - "charts_b.xlsx"

  - id: "branch4_vba_base"
    generator: "copy_template"
    args:
      template: "templates/vba_base.xlsm"
    output: "vba_base.xlsm"

  - id: "branch4_vba_added"
    generator: "copy_template"
    args:
      template: "templates/vba_added.xlsm"
    output: "vba_added.xlsm"

  - id: "branch4_vba_changed"
    generator: "copy_template"
    args:
      template: "templates/vba_changed.xlsm"
    output: "vba_changed.xlsm"


```

---

### File: `fixtures\pyproject.toml`

```toml
[project]
name = "excel-fixtures"
version = "0.1.0"
description = "Deterministic artifact generator for Excel Diff testing"
readme = "README.md"
requires-python = ">=3.9"
dependencies = [
    "openpyxl>=3.1.0",
    "lxml>=4.9.0",
    "jinja2>=3.1.0",
    "pyyaml>=6.0",
]

[project.scripts]
generate-fixtures = "src.generate:main"

[build-system]
requires = ["hatchling"]
build-backend = "hatchling.build"

[tool.hatch.build.targets.wheel]
packages = ["src"]


```

---

### File: `fixtures\src\__init__.py`

```python


```

---

### File: `fixtures\src\generate.py`

```python
import argparse
import yaml
import sys
from pathlib import Path
from typing import Dict, Any, List

# Import generators
try:
    from .generators.corrupt import ContainerCorruptGenerator
    from .generators.database import KeyedTableGenerator
    from .generators.grid import (
        AddressSanityGenerator,
        BasicGridGenerator,
        ColumnAlignmentG9Generator,
        ColumnMoveG12Generator,
        EdgeCaseGenerator,
        GridTailDiffGenerator,
        MultiCellDiffGenerator,
        Pg6SheetScenarioGenerator,
        RectBlockMoveG12Generator,
        RowAlignmentG10Generator,
        RowAlignmentG8Generator,
        RowBlockMoveG11Generator,
        RowFuzzyMoveG13Generator,
        SheetCaseRenameGenerator,
        SingleCellDiffGenerator,
        SparseGridGenerator,
        ValueFormulaGenerator,
    )
    from .generators.mashup import (
        MashupCorruptGenerator,
        MashupDuplicateGenerator,
        MashupEncodeGenerator,
        MashupInjectGenerator,
        MashupMultiEmbeddedGenerator,
        MashupOneQueryGenerator,
        MashupPermissionsMetadataGenerator,
    )
    from .generators.objects import ChartsGenerator, CopyTemplateGenerator, NamedRangesGenerator
    from .generators.perf import LargeGridGenerator
except ImportError:
    from generators.corrupt import ContainerCorruptGenerator
    from generators.database import KeyedTableGenerator
    from generators.grid import (
        AddressSanityGenerator,
        BasicGridGenerator,
        ColumnAlignmentG9Generator,
        ColumnMoveG12Generator,
        EdgeCaseGenerator,
        GridTailDiffGenerator,
        MultiCellDiffGenerator,
        Pg6SheetScenarioGenerator,
        RectBlockMoveG12Generator,
        RowAlignmentG10Generator,
        RowAlignmentG8Generator,
        RowBlockMoveG11Generator,
        RowFuzzyMoveG13Generator,
        SheetCaseRenameGenerator,
        SingleCellDiffGenerator,
        SparseGridGenerator,
        ValueFormulaGenerator,
    )
    from generators.mashup import (
        MashupCorruptGenerator,
        MashupDuplicateGenerator,
        MashupEncodeGenerator,
        MashupInjectGenerator,
        MashupMultiEmbeddedGenerator,
        MashupOneQueryGenerator,
        MashupPermissionsMetadataGenerator,
    )
    from generators.objects import ChartsGenerator, CopyTemplateGenerator, NamedRangesGenerator
    from generators.perf import LargeGridGenerator

# Registry of generators
GENERATORS: Dict[str, Any] = {
    "basic_grid": BasicGridGenerator,
    "sparse_grid": SparseGridGenerator,
    "edge_case": EdgeCaseGenerator,
    "address_sanity": AddressSanityGenerator,
    "value_formula": ValueFormulaGenerator,
    "single_cell_diff": SingleCellDiffGenerator,
    "multi_cell_diff": MultiCellDiffGenerator,
    "grid_tail_diff": GridTailDiffGenerator,
    "row_alignment_g8": RowAlignmentG8Generator,
    "row_alignment_g10": RowAlignmentG10Generator,
    "row_block_move_g11": RowBlockMoveG11Generator,
    "row_fuzzy_move_g13": RowFuzzyMoveG13Generator,
    "column_move_g12": ColumnMoveG12Generator,
    "rect_block_move_g12": RectBlockMoveG12Generator,
    "column_alignment_g9": ColumnAlignmentG9Generator,
    "sheet_case_rename": SheetCaseRenameGenerator,
    "pg6_sheet_scenario": Pg6SheetScenarioGenerator,
    "corrupt_container": ContainerCorruptGenerator,
    "mashup_corrupt": MashupCorruptGenerator,
    "mashup_duplicate": MashupDuplicateGenerator,
    "mashup_inject": MashupInjectGenerator,
    "mashup_encode": MashupEncodeGenerator,
    "mashup:one_query": MashupOneQueryGenerator,
    "mashup:multi_query_with_embedded": MashupMultiEmbeddedGenerator,
    "mashup:permissions_metadata": MashupPermissionsMetadataGenerator,
    "perf_large": LargeGridGenerator,
    "db_keyed": KeyedTableGenerator,
    "named_ranges": NamedRangesGenerator,
    "charts": ChartsGenerator,
    "copy_template": CopyTemplateGenerator,
}

def load_manifest(manifest_path: Path) -> Dict[str, Any]:
    if not manifest_path.exists():
        print(f"Error: Manifest file not found at {manifest_path}")
        sys.exit(1)
    
    with open(manifest_path, 'r') as f:
        try:
            return yaml.safe_load(f)
        except yaml.YAMLError as e:
            print(f"Error parsing manifest: {e}")
            sys.exit(1)

def ensure_output_dir(output_dir: Path):
    output_dir.mkdir(parents=True, exist_ok=True)

def main():
    script_dir = Path(__file__).parent.resolve()
    fixtures_root = script_dir.parent
    
    default_manifest = fixtures_root / "manifest.yaml"
    default_output = fixtures_root / "generated"

    parser = argparse.ArgumentParser(description="Generate Excel fixtures based on a manifest.")
    parser.add_argument("--manifest", type=Path, default=default_manifest, help="Path to the manifest YAML file.")
    parser.add_argument("--output-dir", type=Path, default=default_output, help="Directory to output generated files.")
    parser.add_argument("--force", action="store_true", help="Force regeneration of existing files.")
    
    args = parser.parse_args()
    
    manifest = load_manifest(args.manifest)
    ensure_output_dir(args.output_dir)
    
    scenarios = manifest.get('scenarios', [])
    print(f"Found {len(scenarios)} scenarios in manifest.")
    
    for scenario in scenarios:
        scenario_id = scenario.get('id')
        generator_name = scenario.get('generator')
        generator_args = scenario.get('args', {})
        outputs = scenario.get('output')
        
        if not scenario_id or not generator_name or not outputs:
            print(f"Skipping invalid scenario: {scenario}")
            continue
            
        print(f"Processing scenario: {scenario_id} (Generator: {generator_name})")
        
        if generator_name not in GENERATORS:
            print(f"  Warning: Generator '{generator_name}' not implemented yet. Skipping.")
            continue
        
        try:
            generator_class = GENERATORS[generator_name]
            generator = generator_class(generator_args)
            generator.generate(args.output_dir, outputs)
            print(f"  Success: Generated {outputs}")
        except Exception as e:
            print(f"  Error generating scenario {scenario_id}: {e}")
            import traceback
            traceback.print_exc()

if __name__ == "__main__":
    main()

```

---

### File: `fixtures\src\generators\__init__.py`

```python
# Generators package


```

---

### File: `fixtures\src\generators\base.py`

```python
"""Base classes for fixture generators."""

from abc import ABC, abstractmethod
from pathlib import Path
from typing import Dict, Any, Union, List


class BaseGenerator(ABC):
    """Abstract base class for all fixture generators."""

    def __init__(self, args: Dict[str, Any]):
        self.args = args

    @abstractmethod
    def generate(self, output_dir: Path, output_names: Union[str, List[str]]):
        """Generate the fixture file(s).

        Args:
            output_dir: The directory to save the file(s) in.
            output_names: The name(s) of the output file(s) as specified in the manifest.
        """
        pass

```

---

### File: `fixtures\src\generators\corrupt.py`

```python
import zipfile
import io
import random
from pathlib import Path
from typing import Union, List
from .base import BaseGenerator

class ContainerCorruptGenerator(BaseGenerator):
    def generate(self, output_dir: Path, output_names: Union[str, List[str]]):
        if isinstance(output_names, str):
            output_names = [output_names]
            
        mode = self.args.get('mode', 'no_content_types')
        
        for name in output_names:
            # Create a dummy zip
            out_path = output_dir / name
            
            if mode == 'random_zip':
                # Just a zip with a text file
                with zipfile.ZipFile(out_path, 'w') as z:
                    z.writestr("hello.txt", "This is not excel")
                    
            elif mode == 'no_content_types':
                # Create a valid excel in memory, then strip [Content_Types].xml
                buffer = io.BytesIO()
                import openpyxl
                wb = openpyxl.Workbook()
                # Add some content just so it's not totally empty
                wb.active['A1'] = 1
                wb.save(buffer)
                buffer.seek(0)
                
                with zipfile.ZipFile(buffer, 'r') as zin:
                    with zipfile.ZipFile(out_path, 'w') as zout:
                        for item in zin.infolist():
                            if item.filename != "[Content_Types].xml":
                                zout.writestr(item, zin.read(item.filename))
            elif mode == 'not_zip_text':
                out_path.write_text("This is not a zip container", encoding="utf-8")
            else:
                raise ValueError(f"Unsupported corrupt_container mode: {mode}")


```

---

### File: `fixtures\src\generators\database.py`

```python
import openpyxl
import random
from pathlib import Path
from typing import Union, List, Dict, Any
from .base import BaseGenerator

class KeyedTableGenerator(BaseGenerator):
    """
    Generates datasets with Primary Keys (ID columns).
    Capable of shuffling rows to test O(N) alignment (Database Mode).
    
    Supports:
    - extra_rows: Add new rows with specified id/name/amount/category
    - updates: Modify existing rows by id (e.g., [{ id: 7, amount: 120 }])
    - shuffle: Randomize row order
    """
    def generate(self, output_dir: Path, output_names: Union[str, List[str]]):
        if isinstance(output_names, str):
            output_names = [output_names]

        count = self.args.get('count', 100)
        shuffle = self.args.get('shuffle', False)
        seed = self.args.get('seed', 42)
        extra_rows = self.args.get('extra_rows', [])
        updates = self.args.get('updates', [])

        rng = random.Random(seed)

        for name in output_names:
            wb = openpyxl.Workbook()
            ws = wb.active
            ws.title = "Data"

            data_rows = []
            for i in range(1, count + 1):
                data_rows.append({
                    'id': i,
                    'name': f"Customer_{i}",
                    'amount': i * 10.5,
                    'category': rng.choice(['A', 'B', 'C'])
                })

            for row in extra_rows:
                data_rows.append(row)

            updates_by_id = {u['id']: u for u in updates}
            for row in data_rows:
                if row['id'] in updates_by_id:
                    upd = updates_by_id[row['id']]
                    for key in ['name', 'amount', 'category']:
                        if key in upd:
                            row[key] = upd[key]

            if shuffle:
                rng.shuffle(data_rows)

            headers = ['ID', 'Name', 'Amount', 'Category']
            ws.append(headers)

            for row in data_rows:
                ws.append([
                    row.get('id'),
                    row.get('name'),
                    row.get('amount'),
                    row.get('category')
                ])

            wb.save(output_dir / name)


```

---

### File: `fixtures\src\generators\grid.py`

```python
import openpyxl
import zipfile
import xml.etree.ElementTree as ET
from openpyxl.utils import get_column_letter
from pathlib import Path
from typing import Union, List, Dict, Any
from .base import BaseGenerator

class BasicGridGenerator(BaseGenerator):
    def generate(self, output_dir: Path, output_names: Union[str, List[str]]):
        if isinstance(output_names, str):
            output_names = [output_names]
            
        rows = self.args.get('rows', 5)
        cols = self.args.get('cols', 5)
        two_sheets = self.args.get('two_sheets', False)
        
        for name in output_names:
            wb = openpyxl.Workbook()
            ws = wb.active
            ws.title = "Sheet1"
            
            # Fill grid
            for r in range(1, rows + 1):
                for c in range(1, cols + 1):
                    ws.cell(row=r, column=c, value=f"R{r}C{c}")
            
            # Check if we need a second sheet
            if two_sheets:
                ws2 = wb.create_sheet(title="Sheet2")
                # Different dimensions for Sheet2 (PG1 requirement: 5x2)
                # If args are customized we might need more logic, but for PG1 this is sufficient or we use defaults
                s2_rows = 5
                s2_cols = 2
                for r in range(1, s2_rows + 1):
                    for c in range(1, s2_cols + 1):
                         ws2.cell(row=r, column=c, value=f"S2_R{r}C{c}")

            wb.save(output_dir / name)

class SparseGridGenerator(BaseGenerator):
    def generate(self, output_dir: Path, output_names: Union[str, List[str]]):
        if isinstance(output_names, str):
            output_names = [output_names]
            
        for name in output_names:
            wb = openpyxl.Workbook()
            ws = wb.active
            ws.title = "Sparse"
            
            # Specifics for pg1_sparse_used_range
            ws['A1'] = "A1"
            ws['B2'] = "B2"
            ws['G10'] = "G10" # Forces extent
            # Row 5 and Col D are empty implicitly by not writing to them
            
            wb.save(output_dir / name)

class EdgeCaseGenerator(BaseGenerator):
    def generate(self, output_dir: Path, output_names: Union[str, List[str]]):
        if isinstance(output_names, str):
            output_names = [output_names]
        
        for name in output_names:
            wb = openpyxl.Workbook()
            # Remove default sheet
            default_ws = wb.active
            wb.remove(default_ws)
            
            # Empty Sheet
            wb.create_sheet("Empty")
            
            # Values Only
            ws_val = wb.create_sheet("ValuesOnly")
            for r in range(1, 11):
                for c in range(1, 11):
                    ws_val.cell(row=r, column=c, value=r*c)
            
            # Formulas Only
            ws_form = wb.create_sheet("FormulasOnly")
            for r in range(1, 11):
                for c in range(1, 11):
                    # Reference ValuesOnly sheet
                    col_letter = get_column_letter(c)
                    ws_form.cell(row=r, column=c, value=f"=ValuesOnly!{col_letter}{r}")
            
            wb.save(output_dir / name)

class AddressSanityGenerator(BaseGenerator):
    def generate(self, output_dir: Path, output_names: Union[str, List[str]]):
        if isinstance(output_names, str):
            output_names = [output_names]
            
        targets = self.args.get('targets', ["A1", "B2", "Z10"])
        
        for name in output_names:
            wb = openpyxl.Workbook()
            ws = wb.active
            ws.title = "Addresses"
            
            for addr in targets:
                ws[addr] = addr
                
            wb.save(output_dir / name)

class ValueFormulaGenerator(BaseGenerator):
    """PG3: Types, formulas, values"""
    def generate(self, output_dir: Path, output_names: Union[str, List[str]]):
        if isinstance(output_names, str):
            output_names = [output_names]
            
        for name in output_names:
            wb = openpyxl.Workbook()
            ws = wb.active
            ws.title = "Types"
            
            ws['A1'] = 42
            ws['A2'] = "hello"
            ws['A3'] = True
            # A4 empty
            
            ws['B1'] = "=A1+1"
            ws['B2'] = '="hello" & " world"'
            ws['B3'] = "=A1>0"
            
            output_path = output_dir / name
            wb.save(output_path)
            self._inject_formula_caches(output_path)

    def _inject_formula_caches(self, path: Path):
        ns = "http://schemas.openxmlformats.org/spreadsheetml/2006/main"
        with zipfile.ZipFile(path, "r") as zf:
            sheet_xml = zf.read("xl/worksheets/sheet1.xml")
            other_files = {
                info.filename: zf.read(info.filename)
                for info in zf.infolist()
                if info.filename != "xl/worksheets/sheet1.xml"
            }

        root = ET.fromstring(sheet_xml)

        def update_cell(ref: str, value: str, cell_type: str | None = None):
            cell = root.find(f".//{{{ns}}}c[@r='{ref}']")
            if cell is None:
                return
            if cell_type:
                cell.set("t", cell_type)
            v = cell.find(f"{{{ns}}}v")
            if v is None:
                v = ET.SubElement(cell, f"{{{ns}}}v")
            v.text = value

        update_cell("B1", "43")
        update_cell("B2", "hello world", "str")
        update_cell("B3", "1", "b")

        ET.register_namespace("", ns)
        updated_sheet = ET.tostring(root, encoding="utf-8", xml_declaration=False)
        with zipfile.ZipFile(path, "w", compression=zipfile.ZIP_DEFLATED) as zf:
            zf.writestr("xl/worksheets/sheet1.xml", updated_sheet)
            for name, data in other_files.items():
                zf.writestr(name, data)

class SingleCellDiffGenerator(BaseGenerator):
    """Generates a tiny pair of workbooks with a single differing cell."""
    def generate(self, output_dir: Path, output_names: Union[str, List[str]]):
        if isinstance(output_names, str):
            output_names = [output_names]

        if len(output_names) != 2:
            raise ValueError("single_cell_diff generator expects exactly two output filenames")

        rows = self.args.get('rows', 3)
        cols = self.args.get('cols', 3)
        sheet = self.args.get('sheet', "Sheet1")
        target_cell = self.args.get('target_cell', "C3")
        value_a = self.args.get('value_a', "1")
        value_b = self.args.get('value_b', "2")

        def create_workbook(value, name: str):
            wb = openpyxl.Workbook()
            ws = wb.active
            ws.title = sheet

            for r in range(1, rows + 1):
                for c in range(1, cols + 1):
                    ws.cell(row=r, column=c, value=f"R{r}C{c}")

            ws[target_cell] = value
            wb.save(output_dir / name)

        create_workbook(value_a, output_names[0])
        create_workbook(value_b, output_names[1])

class MultiCellDiffGenerator(BaseGenerator):
    """Generates workbook pairs that differ in multiple scattered cells."""
    def generate(self, output_dir: Path, output_names: Union[str, List[str]]):
        if isinstance(output_names, str):
            output_names = [output_names]

        if len(output_names) != 2:
            raise ValueError("multi_cell_diff generator expects exactly two output filenames")

        rows = self.args.get("rows", 20)
        cols = self.args.get("cols", 10)
        sheet = self.args.get("sheet", "Sheet1")
        edits: List[Dict[str, Any]] = self.args.get("edits", [])

        self._create_workbook(output_dir / output_names[0], sheet, rows, cols, edits, "a")
        self._create_workbook(output_dir / output_names[1], sheet, rows, cols, edits, "b")

    def _create_workbook(
        self,
        path: Path,
        sheet: str,
        rows: int,
        cols: int,
        edits: List[Dict[str, Any]],
        value_key: str,
    ):
        wb = openpyxl.Workbook()
        ws = wb.active
        ws.title = sheet

        self._fill_base_grid(ws, rows, cols)
        self._apply_edits(ws, edits, value_key)

        wb.save(path)

    def _fill_base_grid(self, ws, rows: int, cols: int):
        for r in range(1, rows + 1):
            for c in range(1, cols + 1):
                ws.cell(row=r, column=c, value=f"R{r}C{c}")

    def _apply_edits(self, ws, edits: List[Dict[str, Any]], value_key: str):
        value_field = f"value_{value_key}"

        for edit in edits:
            addr = edit.get("addr")
            if not addr:
                raise ValueError("multi_cell_diff edits require 'addr'")
            if value_field not in edit:
                raise ValueError(f"multi_cell_diff edits require '{value_field}'")
            ws[addr] = edit[value_field]

class GridTailDiffGenerator(BaseGenerator):
    """Generates workbook pairs for simple row/column tail append/delete scenarios."""
    def generate(self, output_dir: Path, output_names: Union[str, List[str]]):
        if isinstance(output_names, str):
            output_names = [output_names]

        if len(output_names) != 2:
            raise ValueError("grid_tail_diff generator expects exactly two output filenames")

        mode = self.args.get("mode")
        sheet = self.args.get("sheet", "Sheet1")

        if mode == "row_append_bottom":
            self._row_append_bottom(output_dir, output_names, sheet)
        elif mode == "row_delete_bottom":
            self._row_delete_bottom(output_dir, output_names, sheet)
        elif mode == "col_append_right":
            self._col_append_right(output_dir, output_names, sheet)
        elif mode == "col_delete_right":
            self._col_delete_right(output_dir, output_names, sheet)
        else:
            raise ValueError(f"Unsupported grid_tail_diff mode: {mode}")

    def _row_append_bottom(self, output_dir: Path, output_names: List[str], sheet: str):
        base_rows = self.args.get("base_rows", 10)
        tail_rows = self.args.get("tail_rows", 2)
        cols = self.args.get("cols", 3)

        self._write_rows(output_dir / output_names[0], sheet, base_rows, cols, 1)
        self._write_rows(
            output_dir / output_names[1],
            sheet,
            base_rows + tail_rows,
            cols,
            1,
        )

    def _row_delete_bottom(self, output_dir: Path, output_names: List[str], sheet: str):
        base_rows = self.args.get("base_rows", 10)
        tail_rows = self.args.get("tail_rows", 2)
        cols = self.args.get("cols", 3)

        self._write_rows(
            output_dir / output_names[0],
            sheet,
            base_rows + tail_rows,
            cols,
            1,
        )
        self._write_rows(output_dir / output_names[1], sheet, base_rows, cols, 1)

    def _col_append_right(self, output_dir: Path, output_names: List[str], sheet: str):
        base_cols = self.args.get("base_cols", 4)
        tail_cols = self.args.get("tail_cols", 2)
        rows = self.args.get("rows", 5)

        self._write_cols(output_dir / output_names[0], sheet, rows, base_cols)
        self._write_cols(
            output_dir / output_names[1],
            sheet,
            rows,
            base_cols + tail_cols,
        )

    def _col_delete_right(self, output_dir: Path, output_names: List[str], sheet: str):
        base_cols = self.args.get("base_cols", 4)
        tail_cols = self.args.get("tail_cols", 2)
        rows = self.args.get("rows", 5)

        self._write_cols(
            output_dir / output_names[0],
            sheet,
            rows,
            base_cols + tail_cols,
        )
        self._write_cols(output_dir / output_names[1], sheet, rows, base_cols)

    def _write_rows(self, path: Path, sheet: str, rows: int, cols: int, start_value: int):
        wb = openpyxl.Workbook()
        ws = wb.active
        ws.title = sheet

        for r in range(1, rows + 1):
            ws.cell(row=r, column=1, value=start_value + r - 1)
            for c in range(2, cols + 1):
                ws.cell(row=r, column=c, value=f"R{r}C{c}")

        wb.save(path)

    def _write_cols(self, path: Path, sheet: str, rows: int, cols: int):
        wb = openpyxl.Workbook()
        ws = wb.active
        ws.title = sheet

        for r in range(1, rows + 1):
            for c in range(1, cols + 1):
                ws.cell(row=r, column=c, value=f"R{r}C{c}")

        wb.save(path)

class RowAlignmentG8Generator(BaseGenerator):
    """Generates workbook pairs for G8-style middle row insert/delete scenarios."""
    def generate(self, output_dir: Path, output_names: Union[str, List[str]]):
        if isinstance(output_names, str):
            output_names = [output_names]

        if len(output_names) != 2:
            raise ValueError("row_alignment_g8 generator expects exactly two output filenames")

        mode = self.args.get("mode")
        sheet = self.args.get("sheet", "Sheet1")
        base_rows = self.args.get("base_rows", 10)
        cols = self.args.get("cols", 5)
        insert_at = self.args.get("insert_at", 6)  # 1-based position in B
        delete_row = self.args.get("delete_row", 6)  # 1-based position in A
        edit_row = self.args.get("edit_row")  # Optional extra edit row (1-based in B after insert)
        edit_col = self.args.get("edit_col", 2)  # 1-based column for extra edit

        base_data = [self._base_row_values(idx, cols) for idx in range(1, base_rows + 1)]

        if mode == "insert":
            data_a = base_data
            data_b = self._with_insert(base_data, insert_at, cols)
        elif mode == "delete":
            data_a = base_data
            data_b = self._with_delete(base_data, delete_row)
        elif mode == "insert_with_edit":
            data_a = base_data
            data_b = self._with_insert(base_data, insert_at, cols)
            target_row = edit_row or (insert_at + 2)
            if 1 <= target_row <= len(data_b):
                row_values = list(data_b[target_row - 1])
                col_index = max(1, min(edit_col, cols)) - 1
                row_values[col_index] = "EditedAfterInsert"
                data_b[target_row - 1] = row_values
        else:
            raise ValueError(f"Unsupported row_alignment_g8 mode: {mode}")

        self._write_workbook(output_dir / output_names[0], sheet, data_a)
        self._write_workbook(output_dir / output_names[1], sheet, data_b)

    def _base_row_values(self, row_number: int, cols: int) -> List[str]:
        return [f"Row{row_number}_Col{c}" for c in range(1, cols + 1)]

    def _insert_row_values(self, cols: int) -> List[str]:
        return [f"Inserted_Row_Col{c}" for c in range(1, cols + 1)]

    def _with_insert(self, base_data: List[List[str]], insert_at: int, cols: int) -> List[List[str]]:
        insert_idx = max(1, min(insert_at, len(base_data) + 1))
        insert_row = self._insert_row_values(cols)
        return base_data[: insert_idx - 1] + [insert_row] + base_data[insert_idx - 1 :]

    def _with_delete(self, base_data: List[List[str]], delete_row: int) -> List[List[str]]:
        if not (1 <= delete_row <= len(base_data)):
            raise ValueError(f"delete_row must be within 1..{len(base_data)}")
        return base_data[: delete_row - 1] + base_data[delete_row:]

    def _write_workbook(self, path: Path, sheet: str, rows: List[List[str]]):
        wb = openpyxl.Workbook()
        ws = wb.active
        ws.title = sheet

        for r_idx, row_values in enumerate(rows, start=1):
            for c_idx, value in enumerate(row_values, start=1):
                ws.cell(row=r_idx, column=c_idx, value=value)

        wb.save(path)

class RowAlignmentG10Generator(BaseGenerator):
    """Generates workbook pairs for G10 contiguous row block insert/delete scenarios."""
    def generate(self, output_dir: Path, output_names: Union[str, List[str]]):
        if isinstance(output_names, str):
            output_names = [output_names]

        if len(output_names) != 2:
            raise ValueError("row_alignment_g10 generator expects exactly two output filenames")

        mode = self.args.get("mode")
        sheet = self.args.get("sheet", "Sheet1")
        base_rows = self.args.get("base_rows", 10)
        cols = self.args.get("cols", 5)
        block_rows = self.args.get("block_rows", 4)
        insert_at = self.args.get("insert_at", 4)  # 1-based position of first inserted row in B
        delete_start = self.args.get("delete_start", 4)  # 1-based starting row in A to delete

        base_data = [self._row_values(idx, cols, 0) for idx in range(1, base_rows + 1)]

        if mode == "block_insert":
            data_a = base_data
            data_b = self._with_block_insert(base_data, insert_at, block_rows, cols)
        elif mode == "block_delete":
            data_a = base_data
            data_b = self._with_block_delete(base_data, delete_start, block_rows)
        else:
            raise ValueError(f"Unsupported row_alignment_g10 mode: {mode}")

        self._write_workbook(output_dir / output_names[0], sheet, data_a)
        self._write_workbook(output_dir / output_names[1], sheet, data_b)

    def _row_values(self, row_number: int, cols: int, offset: int) -> List[int]:
        row_id = row_number + offset
        values = [row_id]
        for c in range(1, cols):
            values.append(row_id * 10 + c)
        return values

    def _block_rows(self, count: int, cols: int) -> List[List[int]]:
        return [self._row_values(1000 + idx, cols, 0) for idx in range(1, count + 1)]

    def _with_block_insert(
        self, base_data: List[List[int]], insert_at: int, block_rows: int, cols: int
    ) -> List[List[int]]:
        insert_idx = max(1, min(insert_at, len(base_data) + 1)) - 1
        block = self._block_rows(block_rows, cols)
        return base_data[:insert_idx] + block + base_data[insert_idx:]

    def _with_block_delete(
        self, base_data: List[List[int]], delete_start: int, block_rows: int
    ) -> List[List[int]]:
        if not (1 <= delete_start <= len(base_data)):
            raise ValueError(f"delete_start must be within 1..{len(base_data)}")
        if delete_start - 1 + block_rows > len(base_data):
            raise ValueError("delete block exceeds base data length")

        delete_idx = delete_start - 1
        return base_data[:delete_idx] + base_data[delete_idx + block_rows :]

    def _write_workbook(self, path: Path, sheet: str, rows: List[List[int]]):
        wb = openpyxl.Workbook()
        ws = wb.active
        ws.title = sheet

        for r_idx, row_values in enumerate(rows, start=1):
            for c_idx, value in enumerate(row_values, start=1):
                ws.cell(row=r_idx, column=c_idx, value=value)

        wb.save(path)

class RowBlockMoveG11Generator(BaseGenerator):
    """Generates workbook pairs for G11 exact row block move scenarios."""
    def generate(self, output_dir: Path, output_names: Union[str, List[str]]):
        if isinstance(output_names, str):
            output_names = [output_names]

        if len(output_names) != 2:
            raise ValueError("row_block_move_g11 generator expects exactly two output filenames")

        sheet = self.args.get("sheet", "Sheet1")
        total_rows = self.args.get("total_rows", 20)
        cols = self.args.get("cols", 5)
        block_rows = self.args.get("block_rows", 4)
        src_start = self.args.get("src_start", 5)
        dst_start = self.args.get("dst_start", 13)

        if block_rows <= 0:
            raise ValueError("block_rows must be positive")
        if src_start < 1 or src_start + block_rows - 1 > total_rows:
            raise ValueError("source block must fit within total_rows")
        if dst_start < 1 or dst_start + block_rows - 1 > total_rows:
            raise ValueError("destination block must fit within total_rows")

        src_end = src_start + block_rows - 1
        dst_end = dst_start + block_rows - 1
        if not (src_end < dst_start or dst_end < src_start):
            raise ValueError("source and destination blocks must not overlap")

        rows_a = self._build_rows(total_rows, cols, src_start, block_rows)
        rows_b = self._move_block(rows_a, src_start, block_rows, dst_start)

        self._write_workbook(output_dir / output_names[0], sheet, rows_a)
        self._write_workbook(output_dir / output_names[1], sheet, rows_b)

    def _build_rows(self, total_rows: int, cols: int, src_start: int, block_rows: int) -> List[List[str]]:
        block_end = src_start + block_rows - 1
        rows: List[List[str]] = []
        for r in range(1, total_rows + 1):
            if src_start <= r <= block_end:
                rows.append([f"BLOCK_r{r}_c{c}" for c in range(1, cols + 1)])
            else:
                rows.append([f"R{r}_C{c}" for c in range(1, cols + 1)])
        return rows

    def _move_block(
        self, rows: List[List[str]], src_start: int, block_rows: int, dst_start: int
    ) -> List[List[str]]:
        rows_b = [list(r) for r in rows]
        src_idx = src_start - 1
        src_end = src_idx + block_rows
        block = rows_b[src_idx:src_end]
        del rows_b[src_idx:src_end]

        dst_idx = min(dst_start - 1, len(rows_b))

        rows_b[dst_idx:dst_idx] = block
        return rows_b

    def _write_workbook(self, path: Path, sheet: str, rows: List[List[str]]):
        wb = openpyxl.Workbook()
        ws = wb.active
        ws.title = sheet

        for r_idx, row_values in enumerate(rows, start=1):
            for c_idx, value in enumerate(row_values, start=1):
                ws.cell(row=r_idx, column=c_idx, value=value)

        wb.save(path)

class RowFuzzyMoveG13Generator(BaseGenerator):
    """Generates workbook pairs for G13 fuzzy row block move scenarios with internal edits."""
    def generate(self, output_dir: Path, output_names: Union[str, List[str]]):
        if isinstance(output_names, str):
            output_names = [output_names]

        if len(output_names) != 2:
            raise ValueError("row_fuzzy_move_g13 generator expects exactly two output filenames")

        sheet = self.args.get("sheet", "Data")
        total_rows = self.args.get("total_rows", 24)
        cols = self.args.get("cols", 6)
        block_rows = self.args.get("block_rows", 4)
        src_start = self.args.get("src_start", 5)
        dst_start = self.args.get("dst_start", 14)
        edits = self.args.get(
            "edits",
            [
                {"row_offset": 1, "col": 3, "delta": 1},
            ],
        )

        if block_rows <= 0:
            raise ValueError("block_rows must be positive")
        if src_start < 1 or src_start + block_rows - 1 > total_rows:
            raise ValueError("source block must fit within total_rows")
        if dst_start < 1 or dst_start + block_rows - 1 > total_rows:
            raise ValueError("destination block must fit within total_rows")

        src_end = src_start + block_rows - 1
        dst_end = dst_start + block_rows - 1
        if not (src_end < dst_start or dst_end < src_start):
            raise ValueError("source and destination blocks must not overlap")

        rows_a = self._build_rows(total_rows, cols, src_start, block_rows)
        rows_b = self._move_block(rows_a, src_start, block_rows, dst_start)
        self._apply_edits(rows_b, dst_start, block_rows, cols, edits)

        self._write_workbook(output_dir / output_names[0], sheet, rows_a)
        self._write_workbook(output_dir / output_names[1], sheet, rows_b)

    def _build_rows(self, total_rows: int, cols: int, block_start: int, block_rows: int) -> List[List[int]]:
        block_end = block_start + block_rows - 1
        rows: List[List[int]] = []
        for r in range(1, total_rows + 1):
            if block_start <= r <= block_end:
                row_id = 1_000 + (r - block_start)
            else:
                row_id = r
            row_values = [row_id]
            for c in range(1, cols):
                row_values.append(row_id * 10 + c)
            rows.append(row_values)
        return rows

    def _move_block(
        self, rows: List[List[int]], src_start: int, block_rows: int, dst_start: int
    ) -> List[List[int]]:
        rows_b = [list(r) for r in rows]
        src_idx = src_start - 1
        src_end = src_idx + block_rows
        block = rows_b[src_idx:src_end]
        del rows_b[src_idx:src_end]

        dst_idx = min(dst_start - 1, len(rows_b))
        rows_b[dst_idx:dst_idx] = block
        return rows_b

    def _apply_edits(
        self,
        rows: List[List[int]],
        dst_start: int,
        block_rows: int,
        cols: int,
        edits: List[Dict[str, Any]],
    ):
        dst_idx = dst_start - 1
        if dst_idx + block_rows > len(rows):
            return

        for edit in edits:
            row_offset = int(edit.get("row_offset", 0))
            col = int(edit.get("col", 1))
            delta = int(edit.get("delta", 1))

            if row_offset < 0 or row_offset >= block_rows:
                continue

            col_idx = max(1, min(col, cols)) - 1
            target_row = dst_idx + row_offset
            if col_idx >= len(rows[target_row]):
                continue
            rows[target_row][col_idx] += delta

    def _write_workbook(self, path: Path, sheet: str, rows: List[List[int]]):
        wb = openpyxl.Workbook()
        ws = wb.active
        ws.title = sheet

        for r_idx, row_values in enumerate(rows, start=1):
            for c_idx, value in enumerate(row_values, start=1):
                ws.cell(row=r_idx, column=c_idx, value=value)

        wb.save(path)

class ColumnMoveG12Generator(BaseGenerator):
    """Generates workbook pairs for G12 exact column move scenarios."""
    def generate(self, output_dir: Path, output_names: Union[str, List[str]]):
        if isinstance(output_names, str):
            output_names = [output_names]

        if len(output_names) != 2:
            raise ValueError("column_move_g12 generator expects exactly two output filenames")

        sheet = self.args.get("sheet", "Data")
        cols = self.args.get("cols", 8)
        data_rows = self.args.get("data_rows", 9)
        src_col = self.args.get("src_col", 3)
        dst_col = self.args.get("dst_col", 6)

        if not (1 <= src_col <= cols):
            raise ValueError("src_col must be within 1..cols")
        if not (1 <= dst_col <= cols):
            raise ValueError("dst_col must be within 1..cols")
        if src_col == dst_col:
            raise ValueError("src_col and dst_col must differ for a move")

        base_rows = self._build_rows(cols, data_rows, src_col)
        moved_rows = self._move_column(base_rows, src_col, dst_col)

        self._write_workbook(output_dir / output_names[0], sheet, base_rows)
        self._write_workbook(output_dir / output_names[1], sheet, moved_rows)

    def _build_rows(self, cols: int, data_rows: int, key_col: int) -> List[List[Any]]:
        header: List[Any] = []
        for c in range(1, cols + 1):
            if c == key_col:
                header.append("C_key")
            else:
                header.append(f"Col{c}")

        rows: List[List[Any]] = [header]
        for r in range(1, data_rows + 1):
            row: List[Any] = []
            for c in range(1, cols + 1):
                if c == key_col:
                    row.append(100 * r)
                else:
                    row.append(r * 10 + c)
            rows.append(row)

        return rows

    def _move_column(
        self, rows: List[List[Any]], src_col: int, dst_col: int
    ) -> List[List[Any]]:
        src_idx = src_col - 1
        dst_idx = dst_col - 1
        moved_rows: List[List[Any]] = []

        for row in rows:
            new_row = list(row)
            value = new_row.pop(src_idx)
            insert_at = max(0, min(dst_idx, len(new_row)))
            new_row.insert(insert_at, value)
            moved_rows.append(new_row)

        return moved_rows

    def _write_workbook(self, path: Path, sheet: str, rows: List[List[Any]]):
        wb = openpyxl.Workbook()
        ws = wb.active
        ws.title = sheet

        for r_idx, row_values in enumerate(rows, start=1):
            for c_idx, value in enumerate(row_values, start=1):
                ws.cell(row=r_idx, column=c_idx, value=value)

        wb.save(path)

class RectBlockMoveG12Generator(BaseGenerator):
    """Generates workbook pairs for G12 exact rectangular block move scenarios."""
    def generate(self, output_dir: Path, output_names: Union[str, List[str]]):
        if isinstance(output_names, str):
            output_names = [output_names]

        if len(output_names) != 2:
            raise ValueError("rect_block_move_g12 generator expects exactly two output filenames")

        sheet = self.args.get("sheet", "Data")
        rows = self.args.get("rows", 15)
        cols = self.args.get("cols", 15)
        src_top = self.args.get("src_top", 3)  # 1-based
        src_left = self.args.get("src_left", 2)  # 1-based (column B)
        dst_top = self.args.get("dst_top", 10)  # 1-based
        dst_left = self.args.get("dst_left", 7)  # 1-based (column G)
        block_rows = self.args.get("block_rows", 3)
        block_cols = self.args.get("block_cols", 3)

        self._write_workbook(
            output_dir / output_names[0],
            sheet,
            rows,
            cols,
            src_top,
            src_left,
            block_rows,
            block_cols,
        )
        self._write_workbook(
            output_dir / output_names[1],
            sheet,
            rows,
            cols,
            dst_top,
            dst_left,
            block_rows,
            block_cols,
        )

    def _write_workbook(
        self,
        path: Path,
        sheet: str,
        rows: int,
        cols: int,
        block_top: int,
        block_left: int,
        block_rows: int,
        block_cols: int,
    ):
        wb = openpyxl.Workbook()
        ws = wb.active
        ws.title = sheet

        self._fill_background(ws, rows, cols)
        self._write_block(ws, block_top, block_left, block_rows, block_cols)

        wb.save(path)

    def _fill_background(self, ws, rows: int, cols: int):
        for r in range(1, rows + 1):
            for c in range(1, cols + 1):
                ws.cell(row=r, column=c, value=self._background_value(r, c))

    def _background_value(self, row: int, col: int) -> int:
        return 1000 * row + col

    def _write_block(self, ws, top: int, left: int, block_rows: int, block_cols: int):
        for r_offset in range(block_rows):
            for c_offset in range(block_cols):
                value = 9000 + r_offset * 10 + c_offset
                ws.cell(row=top + r_offset, column=left + c_offset, value=value)

class ColumnAlignmentG9Generator(BaseGenerator):
    """Generates workbook pairs for G9-style middle column insert/delete scenarios."""
    def generate(self, output_dir: Path, output_names: Union[str, List[str]]):
        if isinstance(output_names, str):
            output_names = [output_names]

        if len(output_names) != 2:
            raise ValueError("column_alignment_g9 generator expects exactly two output filenames")

        mode = self.args.get("mode")
        sheet = self.args.get("sheet", "Data")
        base_cols = self.args.get("cols", 8)
        data_rows = self.args.get("data_rows", 9)  # excludes header
        insert_at = self.args.get("insert_at", 4)  # 1-based position in B after insert
        delete_col = self.args.get("delete_col", 4)
        edit_row = self.args.get("edit_row", 8)
        edit_col_after_insert = self.args.get("edit_col_after_insert", 7)

        base_table = self._base_table(base_cols, data_rows)

        if mode == "insert":
            data_a = self._clone_rows(base_table)
            data_b = self._with_insert(base_table, insert_at)
        elif mode == "delete":
            data_a = self._clone_rows(base_table)
            data_b = self._with_delete(base_table, delete_col)
        elif mode == "insert_with_edit":
            data_a = self._clone_rows(base_table)
            data_b = self._with_insert(base_table, insert_at)
            row_idx = max(2, min(edit_row, len(data_b))) - 1  # stay below header
            col_idx = max(1, min(edit_col_after_insert, len(data_b[row_idx]))) - 1
            data_b[row_idx][col_idx] = "EditedAfterInsert"
        else:
            raise ValueError(f"Unsupported column_alignment_g9 mode: {mode}")

        self._write_workbook(output_dir / output_names[0], sheet, data_a)
        self._write_workbook(output_dir / output_names[1], sheet, data_b)

    def _base_table(self, cols: int, data_rows: int) -> List[List[str]]:
        header = [f"Col{c}" for c in range(1, cols + 1)]
        rows = [header]
        for r in range(1, data_rows + 1):
            rows.append([f"R{r}_C{c}" for c in range(1, cols + 1)])
        return rows

    def _with_insert(self, base_data: List[List[str]], insert_at: int) -> List[List[str]]:
        insert_idx = max(1, min(insert_at, len(base_data[0]) + 1))
        result: List[List[str]] = []
        for row_idx, row in enumerate(base_data):
            new_row = list(row)
            value = "Inserted" if row_idx == 0 else f"Inserted_{row_idx}"
            new_row.insert(insert_idx - 1, value)
            result.append(new_row)
        return result

    def _with_delete(self, base_data: List[List[str]], delete_col: int) -> List[List[str]]:
        if not base_data:
            return []
        if not (1 <= delete_col <= len(base_data[0])):
            raise ValueError(f"delete_col must be within 1..{len(base_data[0])}")
        result: List[List[str]] = []
        for row in base_data:
            new_row = list(row)
            del new_row[delete_col - 1]
            result.append(new_row)
        return result

    def _clone_rows(self, rows: List[List[str]]) -> List[List[str]]:
        return [list(r) for r in rows]

    def _write_workbook(self, path: Path, sheet: str, rows: List[List[str]]):
        wb = openpyxl.Workbook()
        ws = wb.active
        ws.title = sheet

        for r_idx, row_values in enumerate(rows, start=1):
            for c_idx, value in enumerate(row_values, start=1):
                ws.cell(row=r_idx, column=c_idx, value=value)

        wb.save(path)

class SheetCaseRenameGenerator(BaseGenerator):
    """Generates a pair of workbooks that differ only by sheet name casing, with optional cell edit."""
    def generate(self, output_dir: Path, output_names: Union[str, List[str]]):
        if isinstance(output_names, str):
            output_names = [output_names]

        if len(output_names) != 2:
            raise ValueError("sheet_case_rename generator expects exactly two output filenames")

        sheet_a = self.args.get("sheet_a", "Sheet1")
        sheet_b = self.args.get("sheet_b", "sheet1")
        cell = self.args.get("cell", "A1")
        value_a = self.args.get("value_a", 1.0)
        value_b = self.args.get("value_b", value_a)

        def create_workbook(sheet_name: str, value, output_name: str):
            wb = openpyxl.Workbook()
            ws = wb.active
            ws.title = sheet_name
            ws[cell] = value
            wb.save(output_dir / output_name)

        create_workbook(sheet_a, value_a, output_names[0])
        create_workbook(sheet_b, value_b, output_names[1])

class Pg6SheetScenarioGenerator(BaseGenerator):
    """Generates workbook pairs for PG6 sheet add/remove/rename vs grid responsibilities."""
    def generate(self, output_dir: Path, output_names: Union[str, List[str]]):
        if isinstance(output_names, str):
            output_names = [output_names]

        if len(output_names) != 2:
            raise ValueError("pg6_sheet_scenario generator expects exactly two output filenames")

        mode = self.args.get("mode")
        a_path = output_dir / output_names[0]
        b_path = output_dir / output_names[1]

        if mode == "sheet_added":
            self._gen_sheet_added(a_path, b_path)
        elif mode == "sheet_removed":
            self._gen_sheet_removed(a_path, b_path)
        elif mode == "sheet_renamed":
            self._gen_sheet_renamed(a_path, b_path)
        elif mode == "sheet_and_grid_change":
            self._gen_sheet_and_grid_change(a_path, b_path)
        else:
            raise ValueError(f"Unsupported PG6 mode: {mode}")

    def _fill_grid(self, worksheet, rows: int, cols: int, prefix: str = "R"):
        for r in range(1, rows + 1):
            for c in range(1, cols + 1):
                worksheet.cell(row=r, column=c, value=f"{prefix}{r}C{c}")

    def _gen_sheet_added(self, a_path: Path, b_path: Path):
        wb_a = openpyxl.Workbook()
        ws_main_a = wb_a.active
        ws_main_a.title = "Main"
        self._fill_grid(ws_main_a, 5, 5)
        wb_a.save(a_path)

        wb_b = openpyxl.Workbook()
        ws_main_b = wb_b.active
        ws_main_b.title = "Main"
        self._fill_grid(ws_main_b, 5, 5)
        ws_new = wb_b.create_sheet("NewSheet")
        self._fill_grid(ws_new, 3, 3, prefix="N")
        wb_b.save(b_path)

    def _gen_sheet_removed(self, a_path: Path, b_path: Path):
        wb_a = openpyxl.Workbook()
        ws_main_a = wb_a.active
        ws_main_a.title = "Main"
        self._fill_grid(ws_main_a, 5, 5)
        ws_old = wb_a.create_sheet("OldSheet")
        self._fill_grid(ws_old, 3, 3, prefix="O")
        wb_a.save(a_path)

        wb_b = openpyxl.Workbook()
        ws_main_b = wb_b.active
        ws_main_b.title = "Main"
        self._fill_grid(ws_main_b, 5, 5)
        wb_b.save(b_path)

    def _gen_sheet_renamed(self, a_path: Path, b_path: Path):
        wb_a = openpyxl.Workbook()
        ws_old = wb_a.active
        ws_old.title = "OldName"
        self._fill_grid(ws_old, 3, 3)
        wb_a.save(a_path)

        wb_b = openpyxl.Workbook()
        ws_new = wb_b.active
        ws_new.title = "NewName"
        self._fill_grid(ws_new, 3, 3)
        wb_b.save(b_path)

    def _gen_sheet_and_grid_change(self, a_path: Path, b_path: Path):
        base_rows = 5
        base_cols = 5

        wb_a = openpyxl.Workbook()
        ws_main_a = wb_a.active
        ws_main_a.title = "Main"
        self._fill_grid(ws_main_a, base_rows, base_cols)
        ws_aux_a = wb_a.create_sheet("Aux")
        self._fill_grid(ws_aux_a, 3, 3, prefix="A")
        wb_a.save(a_path)

        wb_b = openpyxl.Workbook()
        ws_main_b = wb_b.active
        ws_main_b.title = "Main"
        self._fill_grid(ws_main_b, base_rows, base_cols)
        ws_main_b["A1"] = "Main changed 1"
        ws_main_b["B2"] = "Main changed 2"
        ws_main_b["C3"] = "Main changed 3"

        ws_aux_b = wb_b.create_sheet("Aux")
        self._fill_grid(ws_aux_b, 3, 3, prefix="A")

        ws_scratch = wb_b.create_sheet("Scratch")
        self._fill_grid(ws_scratch, 2, 2, prefix="S")
        wb_b.save(b_path)

```

---

### File: `fixtures\src\generators\mashup.py`

```python
import base64
import copy
import io
import random
import re
import struct
import zipfile
from pathlib import Path
from typing import Callable, List, Optional, Union
from xml.etree import ElementTree as ET
from lxml import etree
from .base import BaseGenerator

# XML Namespaces
NS = {'dm': 'http://schemas.microsoft.com/DataMashup'}

class MashupBaseGenerator(BaseGenerator):
    """Base class for handling the outer Excel container and finding DataMashup."""
    
    def _get_mashup_element(self, tree):
        if tree.tag.endswith("DataMashup"):
            return tree
        return tree.find('.//dm:DataMashup', namespaces=NS)

    def _process_excel_container(
        self,
        base_path,
        output_path,
        callback,
        text_mutator: Optional[Callable[[str], str]] = None,
    ):
        """
        Generic wrapper to open xlsx, find customXml, apply a callback to the 
        DataMashup bytes, and save the result.
        """
        # Copy base file structure to output
        with zipfile.ZipFile(base_path, 'r') as zin:
            with zipfile.ZipFile(output_path, 'w') as zout:
                for item in zin.infolist():
                    buffer = zin.read(item.filename)
                    
                    # We only care about the item containing DataMashup
                    # Usually customXml/item1.xml, but we check content to be safe
                    has_marker = b"DataMashup" in buffer or b"D\x00a\x00t\x00a\x00M\x00a\x00s\x00h\x00u\x00p" in buffer
                    if item.filename.startswith("customXml/item") and has_marker:
                        # Parse XML
                        root = etree.fromstring(buffer)
                        dm_node = self._get_mashup_element(root)
                        
                        if dm_node is not None:
                            # 1. Decode
                            # The text content might have whitespace/newlines, strip them
                            b64_text = dm_node.text.strip() if dm_node.text else ""
                            if b64_text:
                                raw_bytes = base64.b64decode(b64_text)
                                
                                # 2. Apply modification (The Callback)
                                new_bytes = callback(raw_bytes)
                                
                                # 3. Encode back
                                new_text = base64.b64encode(new_bytes).decode('utf-8')
                                if text_mutator is not None:
                                    new_text = text_mutator(new_text)
                                dm_node.text = new_text
                                buffer = etree.tostring(root, encoding='utf-8', xml_declaration=True)
                    
                    zout.writestr(item, buffer)

class MashupCorruptGenerator(MashupBaseGenerator):
    """Fuzzes the DataMashup bytes to test error handling."""
    
    def generate(self, output_dir: Path, output_names: Union[str, List[str]]):
        if isinstance(output_names, str):
            output_names = [output_names]
            
        base_file_arg = self.args.get('base_file')
        if not base_file_arg:
            raise ValueError("MashupCorruptGenerator requires 'base_file' argument")

        # Resolve base file relative to current working directory or fixtures/templates
        base = Path(base_file_arg)
        if not base.exists():
             # Try looking in fixtures/templates if a relative path was given
             candidate = Path("fixtures") / base_file_arg
             if candidate.exists():
                 base = candidate
             else:
                raise FileNotFoundError(f"Template {base} not found.")

        mode = self.args.get('mode', 'byte_flip')

        def corruptor(data):
            mutable = bytearray(data)
            if len(mutable) == 0:
                return bytes(mutable)

            if mode == 'byte_flip':
                # Flip a byte in the middle
                idx = len(mutable) // 2
                mutable[idx] = mutable[idx] ^ 0xFF
            elif mode == 'truncate':
                return mutable[:len(mutable)//2]
            return bytes(mutable)

        for name in output_names:
            # Convert Path objects to strings for resolve() to work correctly if there's a mix
            # Actually output_dir is a Path. name is str.
            # .resolve() resolves symlinks and relative paths to absolute
            target_path = (output_dir / name).resolve()
            text_mutator = self._garble_base64_text if mode == 'byte_flip' else None
            self._process_excel_container(
                base.resolve(),
                target_path,
                corruptor,
                text_mutator=text_mutator,
            )

    def _garble_base64_text(self, encoded: str) -> str:
        if not encoded:
            return "!!"
        chars = list(encoded)
        chars[0] = "!"
        return "".join(chars)


class MashupInjectGenerator(MashupBaseGenerator):
    """
    Peels the onion:
    1. Parses MS-QDEFF binary header.
    2. Unzips PackageParts.
    3. Injects new M-Code into Section1.m.
    4. Re-zips and fixes header lengths.
    """
    
    def generate(self, output_dir: Path, output_names: Union[str, List[str]]):
        if isinstance(output_names, str):
            output_names = [output_names]
            
        base_file_arg = self.args.get('base_file')
        new_m_code = self.args.get('m_code')

        if not base_file_arg:
             raise ValueError("MashupInjectGenerator requires 'base_file' argument")
        if new_m_code is None:
             raise ValueError("MashupInjectGenerator requires 'm_code' argument")

        base = Path(base_file_arg)
        if not base.exists():
             candidate = Path("fixtures") / base_file_arg
             if candidate.exists():
                 base = candidate
             else:
                raise FileNotFoundError(f"Template {base} not found.")

        def injector(raw_bytes):
            return self._inject_m_code(raw_bytes, new_m_code)

        for name in output_names:
            target_path = (output_dir / name).resolve()
            self._process_excel_container(base.resolve(), target_path, injector)

    def _inject_m_code(self, raw_bytes, m_code):
        # --- 1. Parse MS-QDEFF Header ---
        # Format: Version(4) + LenPP(4) + PackageParts(...) + LenPerm(4) + ...
        # We assume Version is 0 (first 4 bytes)
        
        if len(raw_bytes) < 8:
            return raw_bytes # Too short to handle

        offset = 4
        # Read PackageParts Length
        pp_len = struct.unpack('<I', raw_bytes[offset:offset+4])[0]
        offset += 4
        
        # Extract existing components
        pp_bytes = raw_bytes[offset : offset + pp_len]
        
        # Keep the rest of the stream (Permissions, Metadata, Bindings) intact
        # We just append it later
        remainder_bytes = raw_bytes[offset + pp_len :]

        # --- 2. Modify PackageParts (Inner ZIP) ---
        new_pp_bytes = self._replace_in_zip(pp_bytes, 'Formulas/Section1.m', m_code)

        # --- 3. Rebuild Stream ---
        # New Length for PackageParts
        new_pp_len = len(new_pp_bytes)
        
        # Reconstruct: Version(0) + NewLen + NewPP + Remainder
        header = raw_bytes[:4] # Version
        len_pack = struct.pack('<I', new_pp_len)
        
        return header + len_pack + new_pp_bytes + remainder_bytes

    def _replace_in_zip(self, zip_bytes, filename, new_content):
        """Opens a ZIP byte stream, replaces a file, returns new ZIP byte stream."""
        in_buffer = io.BytesIO(zip_bytes)
        out_buffer = io.BytesIO()
        
        try:
            with zipfile.ZipFile(in_buffer, 'r') as zin:
                with zipfile.ZipFile(out_buffer, 'w', compression=zipfile.ZIP_DEFLATED) as zout:
                    for item in zin.infolist():
                        if item.filename == filename:
                            # Write the new M code
                            zout.writestr(filename, new_content.encode('utf-8'))
                        else:
                            # Copy others
                            zout.writestr(item, zin.read(item.filename))
        except zipfile.BadZipFile:
            # Fallback if inner stream isn't a valid zip (shouldn't happen on valid QDEFF)
            return zip_bytes
            
        return out_buffer.getvalue()


class MashupPackagePartsGenerator(MashupBaseGenerator):
    """
    Generates PackageParts-focused fixtures starting from a base workbook.
    """

    variant: str = "one_query"

    def generate(self, output_dir: Path, output_names: Union[str, List[str]]):
        if isinstance(output_names, str):
            output_names = [output_names]

        base_file_arg = self.args.get("base_file", "templates/base_query.xlsx")
        base = Path(base_file_arg)
        if not base.exists():
            candidate = Path("fixtures") / base_file_arg
            if candidate.exists():
                base = candidate
            else:
                raise FileNotFoundError(f"Template {base} not found.")

        for name in output_names:
            target_path = (output_dir / name).resolve()
            self._process_excel_container(base.resolve(), target_path, self._rewrite_datamashup)

    def _rewrite_datamashup(self, raw_bytes: bytes) -> bytes:
        if self.variant == "one_query":
            return raw_bytes

        version, package_parts, permissions, metadata, bindings = self._split_sections(raw_bytes)
        package_xml, main_section_text, content_types = self._extract_package_parts(package_parts)

        embedded_guid = self.args.get(
            "embedded_guid", "{11111111-2222-3333-4444-555555555555}"
        )
        embedded_section_text = self.args.get(
            "embedded_section",
            self._default_embedded_section(),
        )
        updated_main_section = self._extend_main_section(main_section_text, embedded_guid)
        embedded_bytes = self._build_embedded_package(embedded_section_text, content_types)
        updated_package_parts = self._build_package_parts(
            package_xml,
            updated_main_section,
            content_types,
            embedded_guid,
            embedded_bytes,
        )

        return self._assemble_sections(
            version,
            updated_package_parts,
            permissions,
            metadata,
            bindings,
        )

    def _split_sections(self, raw_bytes: bytes):
        min_size = 4 + 4 * 4
        if len(raw_bytes) < min_size:
            raise ValueError("DataMashup stream too short")

        offset = 0
        version = struct.unpack_from("<I", raw_bytes, offset)[0]
        offset += 4

        package_parts_len = struct.unpack_from("<I", raw_bytes, offset)[0]
        offset += 4
        package_parts_end = offset + package_parts_len
        if package_parts_end > len(raw_bytes):
            raise ValueError("invalid PackageParts length")
        package_parts = raw_bytes[offset:package_parts_end]
        offset = package_parts_end

        permissions_len = struct.unpack_from("<I", raw_bytes, offset)[0]
        offset += 4
        permissions_end = offset + permissions_len
        if permissions_end > len(raw_bytes):
            raise ValueError("invalid permissions length")
        permissions = raw_bytes[offset:permissions_end]
        offset = permissions_end

        metadata_len = struct.unpack_from("<I", raw_bytes, offset)[0]
        offset += 4
        metadata_end = offset + metadata_len
        if metadata_end > len(raw_bytes):
            raise ValueError("invalid metadata length")
        metadata = raw_bytes[offset:metadata_end]
        offset = metadata_end

        bindings_len = struct.unpack_from("<I", raw_bytes, offset)[0]
        offset += 4
        bindings_end = offset + bindings_len
        if bindings_end > len(raw_bytes):
            raise ValueError("invalid bindings length")
        bindings = raw_bytes[offset:bindings_end]
        offset = bindings_end

        if offset != len(raw_bytes):
            raise ValueError("DataMashup trailing bytes mismatch")

        return version, package_parts, permissions, metadata, bindings

    def _assemble_sections(
        self,
        version: int,
        package_parts: bytes,
        permissions: bytes,
        metadata: bytes,
        bindings: bytes,
    ) -> bytes:
        return b"".join(
            [
                struct.pack("<I", version),
                struct.pack("<I", len(package_parts)),
                package_parts,
                struct.pack("<I", len(permissions)),
                permissions,
                struct.pack("<I", len(metadata)),
                metadata,
                struct.pack("<I", len(bindings)),
                bindings,
            ]
        )

    def _extract_package_parts(self, package_parts: bytes):
        with zipfile.ZipFile(io.BytesIO(package_parts), "r") as z:
            package_xml = z.read("Config/Package.xml")
            content_types = z.read("[Content_Types].xml")
            main_section = z.read("Formulas/Section1.m")
        return package_xml, main_section.decode("utf-8", errors="ignore"), content_types

    def _extend_main_section(self, base_section: str, embedded_guid: str) -> str:
        stripped = base_section.rstrip()
        lines = [
            stripped,
            "",
            "shared EmbeddedQuery = let",
            f'    Source = Embedded.Value("Content/{embedded_guid}.package")',
            "in",
            "    Source;",
        ]
        return "\n".join(lines)

    def _build_embedded_package(self, section_text: str, content_types_template: bytes) -> bytes:
        content_types = self._augment_content_types(content_types_template)
        buffer = io.BytesIO()
        with zipfile.ZipFile(buffer, "w", compression=zipfile.ZIP_DEFLATED) as z:
            z.writestr("[Content_Types].xml", content_types)
            z.writestr("Formulas/Section1.m", section_text)
        return buffer.getvalue()

    def _build_package_parts(
        self,
        package_xml: bytes,
        main_section: str,
        content_types_template: bytes,
        embedded_guid: str,
        embedded_package: bytes,
    ) -> bytes:
        content_types = self._augment_content_types(content_types_template)
        buffer = io.BytesIO()
        with zipfile.ZipFile(buffer, "w", compression=zipfile.ZIP_DEFLATED) as z:
            z.writestr("[Content_Types].xml", content_types)
            z.writestr("Config/Package.xml", package_xml)
            z.writestr("Formulas/Section1.m", main_section)
            z.writestr(f"Content/{embedded_guid}.package", embedded_package)
        return buffer.getvalue()

    def _augment_content_types(self, content_types_bytes: bytes) -> str:
        text = content_types_bytes.decode("utf-8", errors="ignore")
        if "Extension=\"package\"" not in text and "Extension='package'" not in text:
            text = text.replace(
                "</Types>",
                '<Default Extension="package" ContentType="application/octet-stream" /></Types>',
                1,
            )
        return text

    def _default_embedded_section(self) -> str:
        return "\n".join(
            [
                "section Section1;",
                "",
                "shared Inner = let",
                "    Source = 1",
                "in",
                "    Source;",
            ]
        )


class MashupOneQueryGenerator(MashupPackagePartsGenerator):
    variant = "one_query"


class MashupMultiEmbeddedGenerator(MashupPackagePartsGenerator):
    variant = "multi_query_with_embedded"


class MashupDuplicateGenerator(MashupBaseGenerator):
    """
    Duplicates the customXml part that contains DataMashup to produce two
    DataMashup occurrences in a single workbook.
    """

    def generate(self, output_dir: Path, output_names: Union[str, List[str]]):
        if isinstance(output_names, str):
            output_names = [output_names]

        base_file_arg = self.args.get('base_file')
        mode = self.args.get('mode', 'part')
        if not base_file_arg:
            raise ValueError("MashupDuplicateGenerator requires 'base_file' argument")

        base = Path(base_file_arg)
        if not base.exists():
            candidate = Path("fixtures") / base_file_arg
            if candidate.exists():
                base = candidate
            else:
                raise FileNotFoundError(f"Template {base} not found.")

        for name in output_names:
            target_path = (output_dir / name).resolve()
            if mode == 'part':
                self._duplicate_datamashup_part(base.resolve(), target_path)
            elif mode == 'element':
                self._duplicate_datamashup_element(base.resolve(), target_path)
            else:
                raise ValueError(f"Unsupported duplicate mode: {mode}")

    def _duplicate_datamashup_part(self, base_path: Path, output_path: Path):
        with zipfile.ZipFile(base_path, 'r') as zin:
            try:
                item1_xml = zin.read("customXml/item1.xml")
                item_props1 = zin.read("customXml/itemProps1.xml")
                item1_rels = zin.read("customXml/_rels/item1.xml.rels")
                content_types = zin.read("[Content_Types].xml")
                workbook_rels = zin.read("xl/_rels/workbook.xml.rels")
            except KeyError as e:
                raise FileNotFoundError(f"Required DataMashup part missing: {e}") from e

            updated_content_types = self._add_itemprops_override(content_types)
            updated_workbook_rels = self._add_workbook_relationship(workbook_rels)
            item2_rels = item1_rels.replace(b"itemProps1.xml", b"itemProps2.xml")
            item_props2 = item_props1.replace(
                b"{37E9CB8A-1D60-4852-BCC8-3140E13993BE}",
                b"{37E9CB8A-1D60-4852-BCC8-3140E13993BF}",
            )

            with zipfile.ZipFile(output_path, 'w') as zout:
                for info in zin.infolist():
                    data = zin.read(info.filename)
                    if info.filename == "[Content_Types].xml":
                        data = updated_content_types
                    elif info.filename == "xl/_rels/workbook.xml.rels":
                        data = updated_workbook_rels
                    zout.writestr(info, data)

                zout.writestr("customXml/item2.xml", item1_xml)
                zout.writestr("customXml/itemProps2.xml", item_props2)
                zout.writestr("customXml/_rels/item2.xml.rels", item2_rels)

    def _add_itemprops_override(self, content_types_bytes: bytes) -> bytes:
        ns = "http://schemas.openxmlformats.org/package/2006/content-types"
        root = ET.fromstring(content_types_bytes)
        override_tag = f"{{{ns}}}Override"
        if not any(
            elem.get("PartName") == "/customXml/itemProps2.xml"
            for elem in root.findall(override_tag)
        ):
            new_override = ET.SubElement(root, override_tag)
            new_override.set("PartName", "/customXml/itemProps2.xml")
            new_override.set(
                "ContentType",
                "application/vnd.openxmlformats-officedocument.customXmlProperties+xml",
            )
        return ET.tostring(root, xml_declaration=True, encoding="utf-8")

    def _add_workbook_relationship(self, rels_bytes: bytes) -> bytes:
        ns = "http://schemas.openxmlformats.org/package/2006/relationships"
        root = ET.fromstring(rels_bytes)
        rel_tag = f"{{{ns}}}Relationship"
        existing_ids = {elem.get("Id") for elem in root.findall(rel_tag)}
        next_id = 1
        while f"rId{next_id}" in existing_ids:
            next_id += 1
        new_rel = ET.SubElement(root, rel_tag)
        new_rel.set("Id", f"rId{next_id}")
        new_rel.set(
            "Type",
            "http://schemas.openxmlformats.org/officeDocument/2006/relationships/customXml",
        )
        new_rel.set("Target", "../customXml/item2.xml")
        return ET.tostring(root, xml_declaration=True, encoding="utf-8")

    def _duplicate_datamashup_element(self, base_path: Path, output_path: Path):
        with zipfile.ZipFile(base_path, 'r') as zin:
            with zipfile.ZipFile(output_path, 'w') as zout:
                for info in zin.infolist():
                    data = zin.read(info.filename)
                    if info.filename.startswith("customXml/item") and (
                        b"DataMashup" in data
                        or b"D\x00a\x00t\x00a\x00M\x00a\x00s\x00h\x00u\x00p" in data
                    ):
                        try:
                            root = etree.fromstring(data)
                            dm_node = self._get_mashup_element(root)
                            if dm_node is not None:
                                duplicate = copy.deepcopy(dm_node)
                                parent = dm_node.getparent()
                                if parent is not None:
                                    parent.append(duplicate)
                                    target_root = root
                                else:
                                    container = etree.Element("root", nsmap=root.nsmap)
                                    container.append(dm_node)
                                    container.append(duplicate)
                                    target_root = container
                                data = etree.tostring(
                                    target_root, encoding="utf-8", xml_declaration=True
                                )
                        except etree.XMLSyntaxError:
                            pass
                    zout.writestr(info, data)


class MashupEncodeGenerator(MashupBaseGenerator):
    """
    Re-encodes the DataMashup customXml stream to a target encoding and optionally
    inserts whitespace into the base64 payload.
    """

    def generate(self, output_dir: Path, output_names: Union[str, List[str]]):
        if isinstance(output_names, str):
            output_names = [output_names]

        base_file_arg = self.args.get('base_file')
        encoding = self.args.get('encoding', 'utf-8')
        whitespace = bool(self.args.get('whitespace', False))
        if not base_file_arg:
            raise ValueError("MashupEncodeGenerator requires 'base_file' argument")

        base = Path(base_file_arg)
        if not base.exists():
            candidate = Path("fixtures") / base_file_arg
            if candidate.exists():
                base = candidate
            else:
                raise FileNotFoundError(f"Template {base} not found.")

        for name in output_names:
            target_path = (output_dir / name).resolve()
            self._rewrite_datamashup_xml(base.resolve(), target_path, encoding, whitespace)

    def _rewrite_datamashup_xml(
        self,
        base_path: Path,
        output_path: Path,
        encoding: str,
        whitespace: bool,
    ):
        with zipfile.ZipFile(base_path, 'r') as zin:
            with zipfile.ZipFile(output_path, 'w') as zout:
                for info in zin.infolist():
                    data = zin.read(info.filename)
                    if info.filename.startswith("customXml/item") and (
                        b"DataMashup" in data
                        or b"D\x00a\x00t\x00a\x00M\x00a\x00s\x00h\x00u\x00p" in data
                    ):
                        try:
                            data = self._process_datamashup_stream(data, encoding, whitespace)
                        except etree.XMLSyntaxError:
                            pass
                    zout.writestr(info, data)

    def _process_datamashup_stream(
        self,
        xml_bytes: bytes,
        encoding: str,
        whitespace: bool,
    ) -> bytes:
        root = etree.fromstring(xml_bytes)
        dm_node = self._get_mashup_element(root)
        if dm_node is None:
            return xml_bytes

        if dm_node.text and whitespace:
            dm_node.text = self._with_whitespace(dm_node.text)

        xml_bytes = etree.tostring(root, encoding="utf-8", xml_declaration=True)
        return self._encode_bytes(xml_bytes, encoding)

    def _with_whitespace(self, text: str) -> str:
        cleaned = text.strip()
        if not cleaned:
            return text
        midpoint = max(1, len(cleaned) // 2)
        return f"\n  {cleaned[:midpoint]}\n  {cleaned[midpoint:]}\n"

    def _encode_bytes(self, xml_bytes: bytes, encoding: str) -> bytes:
        enc = encoding.lower()
        if enc == "utf-8":
            return xml_bytes
        if enc == "utf-16-le":
            return self._to_utf16(xml_bytes, little_endian=True)
        if enc == "utf-16-be":
            return self._to_utf16(xml_bytes, little_endian=False)
        raise ValueError(f"Unsupported encoding: {encoding}")

    def _to_utf16(self, xml_bytes: bytes, little_endian: bool) -> bytes:
        text = xml_bytes.decode("utf-8")
        text = self._rewrite_declaration(text)
        encoded = text.encode("utf-16-le" if little_endian else "utf-16-be")
        bom = b"\xff\xfe" if little_endian else b"\xfe\xff"
        return bom + encoded

    def _rewrite_declaration(self, text: str) -> str:
        pattern = r'encoding=["\'][^"\']+["\']'
        if re.search(pattern, text):
            return re.sub(pattern, 'encoding="UTF-16"', text, count=1)
        prefix = "<?xml version='1.0'?>"
        if text.startswith(prefix):
            return text.replace(prefix, "<?xml version='1.0' encoding='UTF-16'?>", 1)
        return text


class MashupPermissionsMetadataGenerator(MashupBaseGenerator):
    """
    Builds fixtures that exercise Permissions and Metadata parsing by rewriting
    the PackageParts Section1.m, Permissions XML, and Metadata XML inside
    the DataMashup stream.
    """

    def __init__(self, args):
        super().__init__(args)
        self.mode = args.get("mode")

    def generate(self, output_dir: Path, output_names: Union[str, List[str]]):
        if not self.mode:
            raise ValueError("MashupPermissionsMetadataGenerator requires 'mode' argument")

        if isinstance(output_names, str):
            output_names = [output_names]

        base_file_arg = self.args.get("base_file", "templates/base_query.xlsx")
        base = Path(base_file_arg)
        if not base.exists():
            candidate = Path("fixtures") / base_file_arg
            if candidate.exists():
                base = candidate
            else:
                raise FileNotFoundError(f"Template {base} not found.")

        for name in output_names:
            target_path = (output_dir / name).resolve()
            self._process_excel_container(base.resolve(), target_path, self._rewrite_datamashup)

    def _rewrite_datamashup(self, raw_bytes: bytes) -> bytes:
        version, package_parts, _, _, bindings = self._split_sections(raw_bytes)
        scenario = self._scenario_definition()

        updated_package_parts = self._replace_section(
            package_parts,
            scenario["section_text"],
        )
        permissions_bytes = self._permissions_bytes(**scenario["permissions"])
        metadata_bytes = self._metadata_bytes(scenario["metadata_entries"])

        return self._assemble_sections(
            version,
            updated_package_parts,
            permissions_bytes,
            metadata_bytes,
            bindings,
        )

    def _scenario_definition(self):
        shared_section_simple = "\n".join(
            [
                "section Section1;",
                "",
                "shared LoadToSheet = 1;",
                "shared LoadToModel = 2;",
            ]
        )

        def default_permissions():
            return {
                "can_eval": False,
                "firewall_enabled": True,
                "group_type": "Organizational",
            }

        def build_section_text(query_specs):
            lines = ["section Section1;", ""]
            for spec in query_specs:
                lines.append(f"shared {spec['name']} = {spec['body']};")
            return "\n".join(lines)

        def build_metadata_entries(query_specs):
            entries = []
            for spec in query_specs:
                stable_entries = []
                if spec.get("load_to_sheet"):
                    stable_entries.append(("FillEnabled", True))
                if spec.get("load_to_model"):
                    stable_entries.append(("FillToDataModelEnabled", True))
                entries.append(
                    {
                        "path": f"Section1/{spec['name']}",
                        "entries": stable_entries,
                    }
                )
            return entries

        def m_diff_scenario(query_specs):
            return {
                "section_text": build_section_text(query_specs),
                "permissions": default_permissions(),
                "metadata_entries": build_metadata_entries(query_specs),
            }

        if self.mode in ("permissions_defaults", "permissions_firewall_off", "metadata_simple"):
            return {
                "section_text": shared_section_simple,
                "permissions": {
                    "can_eval": False,
                    "firewall_enabled": self.mode != "permissions_firewall_off",
                    "group_type": "Organizational",
                },
                "metadata_entries": [
                    {
                        "path": "Section1/LoadToSheet",
                        "entries": [
                            ("FillEnabled", True),
                            ("FillToDataModelEnabled", False),
                        ],
                    },
                    {
                        "path": "Section1/LoadToModel",
                        "entries": [
                            ("FillEnabled", False),
                            ("FillToDataModelEnabled", True),
                        ],
                    },
                ],
            }

        if self.mode == "m_add_query_a":
            return m_diff_scenario(
                [
                    {"name": "Foo", "body": "1", "load_to_sheet": True, "load_to_model": False},
                ]
            )

        if self.mode == "m_add_query_b":
            return m_diff_scenario(
                [
                    {"name": "Foo", "body": "1", "load_to_sheet": True, "load_to_model": False},
                    {"name": "Bar", "body": "2", "load_to_sheet": True, "load_to_model": False},
                ]
            )

        if self.mode == "m_remove_query_a":
            return m_diff_scenario(
                [
                    {"name": "Foo", "body": "1", "load_to_sheet": True, "load_to_model": False},
                    {"name": "Bar", "body": "2", "load_to_sheet": True, "load_to_model": False},
                ]
            )

        if self.mode == "m_remove_query_b":
            return m_diff_scenario(
                [
                    {"name": "Foo", "body": "1", "load_to_sheet": True, "load_to_model": False},
                ]
            )

        if self.mode == "m_change_literal_a":
            return m_diff_scenario(
                [
                    {"name": "Foo", "body": "1", "load_to_sheet": True, "load_to_model": False},
                ]
            )

        if self.mode == "m_change_literal_b":
            return m_diff_scenario(
                [
                    {"name": "Foo", "body": "2", "load_to_sheet": True, "load_to_model": False},
                ]
            )

        if self.mode == "m_metadata_only_change_a":
            return m_diff_scenario(
                [
                    {"name": "Foo", "body": "1", "load_to_sheet": True, "load_to_model": False},
                ]
            )

        if self.mode == "m_metadata_only_change_b":
            return m_diff_scenario(
                [
                    {"name": "Foo", "body": "1", "load_to_sheet": False, "load_to_model": True},
                ]
            )

        if self.mode == "m_def_and_metadata_change_a":
            return m_diff_scenario(
                [
                    {"name": "Foo", "body": "1", "load_to_sheet": True, "load_to_model": False},
                ]
            )

        if self.mode == "m_def_and_metadata_change_b":
            return m_diff_scenario(
                [
                    {"name": "Foo", "body": "2", "load_to_sheet": False, "load_to_model": True},
                ]
            )

        if self.mode == "m_rename_query_a":
            return m_diff_scenario(
                [
                    {"name": "Foo", "body": "1", "load_to_sheet": True, "load_to_model": False},
                ]
            )

        if self.mode == "m_rename_query_b":
            return m_diff_scenario(
                [
                    {"name": "Bar", "body": "1", "load_to_sheet": True, "load_to_model": False},
                ]
            )

        if self.mode == "m_formatting_only_a":
            body = "let Source = 1, Foo = 2 in Source"
            return m_diff_scenario(
                [
                    {
                        "name": "FormatTest",
                        "body": body,
                        "load_to_sheet": True,
                        "load_to_model": False,
                    },
                ]
            )

        if self.mode == "m_formatting_only_b":
            body = "\n".join(
                [
                    "let",
                    "    // Same semantics as m_formatting_only_a with different formatting",
                    "    Source = 1,",
                    "    Foo = 2",
                    "in",
                    "    Source",
                ]
            )
            return m_diff_scenario(
                [
                    {
                        "name": "FormatTest",
                        "body": body,
                        "load_to_sheet": True,
                        "load_to_model": False,
                    },
                ]
            )

        if self.mode == "m_formatting_only_b_variant":
            body = "\n".join(
                [
                    "let",
                    "    Source = 1,",
                    "    Foo = 3",
                    "in",
                    "    Source",
                ]
            )
            return m_diff_scenario(
                [
                    {
                        "name": "FormatTest",
                        "body": body,
                        "load_to_sheet": True,
                        "load_to_model": False,
                    },
                ]
            )

        if self.mode == "m_record_equiv_a":
            return m_diff_scenario(
                [
                    {
                        "name": "RecordRoot",
                        "body": "[B=2, A=1]",
                        "load_to_sheet": True,
                        "load_to_model": False,
                    },
                ]
            )

        if self.mode == "m_record_equiv_b":
            return m_diff_scenario(
                [
                    {
                        "name": "RecordRoot",
                        "body": "[A=1, B=2]",
                        "load_to_sheet": True,
                        "load_to_model": False,
                    },
                ]
            )

        if self.mode == "m_list_formatting_a":
            return m_diff_scenario(
                [
                    {
                        "name": "ListRoot",
                        "body": "{1,2,3}",
                        "load_to_sheet": True,
                        "load_to_model": False,
                    },
                ]
            )

        if self.mode == "m_list_formatting_b":
            return m_diff_scenario(
                [
                    {
                        "name": "ListRoot",
                        "body": "{ 1, /*c*/ 2, 3 }",
                        "load_to_sheet": True,
                        "load_to_model": False,
                    },
                ]
            )

        if self.mode == "m_call_formatting_a":
            return m_diff_scenario(
                [
                    {
                        "name": "CallRoot",
                        "body": 'Table.FromRows({{1,2},{3,4}}, {"A","B"})',
                        "load_to_sheet": True,
                        "load_to_model": False,
                    },
                ]
            )

        if self.mode == "m_call_formatting_b":
            body = "\n".join(
                [
                    "Table.FromRows(",
                    "    {{1,2},{3,4}},",
                    "    {\"A\", \"B\"}",
                    ")",
                ]
            )
            return m_diff_scenario(
                [
                    {
                        "name": "CallRoot",
                        "body": body,
                        "load_to_sheet": True,
                        "load_to_model": False,
                    },
                ]
            )

        if self.mode == "m_primitive_formatting_a":
            return m_diff_scenario(
                [
                    {
                        "name": "PrimRoot",
                        "body": '"hello"',
                        "load_to_sheet": True,
                        "load_to_model": False,
                    },
                ]
            )

        if self.mode == "m_primitive_formatting_b":
            return m_diff_scenario(
                [
                    {
                        "name": "PrimRoot",
                        "body": '"hello" // formatting-only whitespace and comment',
                        "load_to_sheet": True,
                        "load_to_model": False,
                    },
                ]
            )

        if self.mode == "metadata_query_groups":
            section_text = "\n".join(
                [
                    "section Section1;",
                    "",
                    "shared RootQuery = 1;",
                    "shared GroupedFoo = 2;",
                    "shared NestedBar = 3;",
                ]
            )
            return {
                "section_text": section_text,
                "permissions": {
                    "can_eval": False,
                    "firewall_enabled": True,
                    "group_type": "Organizational",
                },
                "metadata_entries": [
                    {
                        "path": "Section1/RootQuery",
                        "entries": [("FillEnabled", True)],
                    },
                    {
                        "path": "Section1/GroupedFoo",
                        "entries": [
                            ("FillEnabled", True),
                            ("QueryGroupPath", "Inputs/DimTables"),
                        ],
                    },
                    {
                        "path": "Section1/NestedBar",
                        "entries": [
                            ("FillToDataModelEnabled", True),
                            ("QueryGroupPath", "Inputs/DimTables"),
                        ],
                    },
                ],
            }

        if self.mode == "metadata_hidden_queries":
            section_text = "\n".join(
                [
                    "section Section1;",
                    "",
                    "shared ConnectionOnly = 1;",
                    "shared VisibleLoad = 2;",
                ]
            )
            return {
                "section_text": section_text,
                "permissions": {
                    "can_eval": False,
                    "firewall_enabled": True,
                    "group_type": "Organizational",
                },
                "metadata_entries": [
                    {
                        "path": "Section1/ConnectionOnly",
                        "entries": [
                            ("FillEnabled", False),
                            ("FillToDataModelEnabled", False),
                        ],
                    },
                    {
                        "path": "Section1/VisibleLoad",
                        "entries": [
                            ("FillEnabled", True),
                            ("FillToDataModelEnabled", False),
                        ],
                    },
                ],
            }

        if self.mode == "metadata_missing_entry":
            section_text = "\n".join(
                [
                    "section Section1;",
                    "",
                    "shared MissingMetadata = 1;",
                ]
            )
            return {
                "section_text": section_text,
                "permissions": {
                    "can_eval": False,
                    "firewall_enabled": True,
                    "group_type": "Organizational",
                },
                "metadata_entries": [],
            }

        if self.mode == "metadata_url_encoding":
            section_text = "\n".join(
                [
                    "section Section1;",
                    "",
                    'shared #"Query with space & #" = 1;',
                ]
            )
            return {
                "section_text": section_text,
                "permissions": {
                    "can_eval": False,
                    "firewall_enabled": True,
                    "group_type": "Organizational",
                },
                "metadata_entries": [
                    {
                        "path": "Section1/Query%20with%20space%20%26%20%23",
                        "entries": [
                            ("FillEnabled", True),
                            ("FillToDataModelEnabled", False),
                        ],
                    },
                ],
            }

        if self.mode == "metadata_orphan_entries":
            section_text = "\n".join(
                [
                    "section Section1;",
                    "",
                    "shared Foo = 1;",
                ]
            )
            return {
                "section_text": section_text,
                "permissions": {
                    "can_eval": False,
                    "firewall_enabled": True,
                    "group_type": "Organizational",
                },
                "metadata_entries": [
                    {
                        "path": "Section1/Foo",
                        "entries": [("FillEnabled", True)],
                    },
                    {
                        "path": "Section1/Nonexistent",
                        "entries": [("FillEnabled", False)],
                    },
                ],
            }

        raise ValueError(f"Unsupported mode: {self.mode}")

    def _split_sections(self, raw_bytes: bytes):
        min_size = 4 + 4 * 4
        if len(raw_bytes) < min_size:
            raise ValueError("DataMashup stream too short")

        offset = 0
        version = struct.unpack_from("<I", raw_bytes, offset)[0]
        offset += 4

        package_parts_len = struct.unpack_from("<I", raw_bytes, offset)[0]
        offset += 4
        package_parts = raw_bytes[offset : offset + package_parts_len]
        offset += package_parts_len

        permissions_len = struct.unpack_from("<I", raw_bytes, offset)[0]
        offset += 4
        permissions = raw_bytes[offset : offset + permissions_len]
        offset += permissions_len

        metadata_len = struct.unpack_from("<I", raw_bytes, offset)[0]
        offset += 4
        metadata = raw_bytes[offset : offset + metadata_len]
        offset += metadata_len

        bindings_len = struct.unpack_from("<I", raw_bytes, offset)[0]
        offset += 4
        bindings = raw_bytes[offset : offset + bindings_len]

        return version, package_parts, permissions, metadata, bindings

    def _assemble_sections(
        self,
        version: int,
        package_parts: bytes,
        permissions: bytes,
        metadata: bytes,
        bindings: bytes,
    ) -> bytes:
        return b"".join(
            [
                struct.pack("<I", version),
                struct.pack("<I", len(package_parts)),
                package_parts,
                struct.pack("<I", len(permissions)),
                permissions,
                struct.pack("<I", len(metadata)),
                metadata,
                struct.pack("<I", len(bindings)),
                bindings,
            ]
        )

    def _replace_section(self, package_parts: bytes, section_text: str) -> bytes:
        return self._replace_in_zip(package_parts, "Formulas/Section1.m", section_text)

    def _replace_in_zip(self, zip_bytes: bytes, filename: str, new_content: str) -> bytes:
        in_buffer = io.BytesIO(zip_bytes)
        out_buffer = io.BytesIO()

        with zipfile.ZipFile(in_buffer, "r") as zin:
            with zipfile.ZipFile(out_buffer, "w", compression=zipfile.ZIP_DEFLATED) as zout:
                for item in zin.infolist():
                    if item.filename == filename:
                        zout.writestr(filename, new_content.encode("utf-8"))
                    else:
                        zout.writestr(item, zin.read(item.filename))
        return out_buffer.getvalue()

    def _permissions_bytes(self, can_eval: bool, firewall_enabled: bool, group_type: str) -> bytes:
        xml = (
            '<?xml version="1.0" encoding="utf-8"?>'
            "<PermissionList xmlns:xsd=\"http://www.w3.org/2001/XMLSchema\" "
            "xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\">"
            f"<CanEvaluateFuturePackages>{str(can_eval).lower()}</CanEvaluateFuturePackages>"
            f"<FirewallEnabled>{str(firewall_enabled).lower()}</FirewallEnabled>"
            f"<WorkbookGroupType>{group_type}</WorkbookGroupType>"
            "</PermissionList>"
        )
        return ("\ufeff" + xml).encode("utf-8")

    def _metadata_bytes(self, items: List[dict]) -> bytes:
        xml = self._metadata_xml(items)
        xml_bytes = ("\ufeff" + xml).encode("utf-8")
        header = struct.pack("<I", 0) + struct.pack("<I", len(xml_bytes))
        return header + xml_bytes

    def _metadata_xml(self, items: List[dict]) -> str:
        parts = [
            '<?xml version="1.0" encoding="utf-8"?>',
            '<LocalPackageMetadataFile xmlns:xsd="http://www.w3.org/2001/XMLSchema" '
            'xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance">',
            "<Items>",
            "<Item><ItemLocation><ItemType>AllFormulas</ItemType><ItemPath /></ItemLocation><StableEntries /></Item>",
        ]

        for item in items:
            parts.append("<Item>")
            parts.append("<ItemLocation>")
            parts.append("<ItemType>Formula</ItemType>")
            parts.append(f"<ItemPath>{item['path']}</ItemPath>")
            parts.append("</ItemLocation>")
            parts.append("<StableEntries>")
            for entry_name, entry_value in item.get("entries", []):
                value = self._format_entry_value(entry_value)
                parts.append(f'<Entry Type="{entry_name}" Value="{value}" />')
            parts.append("</StableEntries>")
            parts.append("</Item>")

        parts.append("</Items></LocalPackageMetadataFile>")
        return "".join(parts)

    def _format_entry_value(self, value):
        if isinstance(value, bool):
            return f"l{'1' if value else '0'}"
        return f"s{value}"

```

---

### File: `fixtures\src\generators\objects.py`

```python
import shutil
from pathlib import Path
from typing import Any, Dict, List, Union

import openpyxl
from openpyxl.chart import BarChart, LineChart, Reference
from openpyxl.workbook.defined_name import DefinedName

from .base import BaseGenerator


class NamedRangesGenerator(BaseGenerator):
    """Generates a workbook pair that exercises workbook- and sheet-scoped defined names."""

    def generate(self, output_dir: Path, output_names: Union[str, List[str]]):
        if isinstance(output_names, str):
            output_names = [output_names]

        if len(output_names) != 2:
            raise ValueError("named_ranges generator expects exactly two output filenames")

        sheet = self.args.get("sheet", "Sheet1")

        def create_workbook(global_names: List[DefinedName], local_name: DefinedName, path: Path):
            wb = openpyxl.Workbook()
            ws1 = wb.active
            ws1.title = sheet
            wb.create_sheet("Sheet2")

            ws1["A1"] = 1
            ws1["A2"] = 2
            ws1["A3"] = 3
            ws1["B1"] = 4
            ws1["C1"] = 5
            ws1["C2"] = 6
            ws1["D1"] = 7
            ws1["D2"] = 8

            for name in global_names:
                wb.defined_names.add(name)
            wb.defined_names.add(local_name)

            wb.save(path)

        global_keep = DefinedName("GlobalKeep", attr_text=f"{sheet}!$A$1:$A$3")
        global_remove = DefinedName("GlobalRemove", attr_text=f"{sheet}!$B$1")
        local_change_a = DefinedName("LocalChange", attr_text=f"{sheet}!$C$1", localSheetId=0)

        global_add = DefinedName("GlobalAdd", attr_text=f"{sheet}!$D$1:$D$2")
        local_change_b = DefinedName("LocalChange", attr_text=f"{sheet}!$C$2", localSheetId=0)

        create_workbook(
            global_names=[global_keep, global_remove],
            local_name=local_change_a,
            path=output_dir / output_names[0],
        )
        create_workbook(
            global_names=[global_keep, global_add],
            local_name=local_change_b,
            path=output_dir / output_names[1],
        )


class ChartsGenerator(BaseGenerator):
    """Generates a workbook pair that exercises chart add/remove/change detection."""

    def generate(self, output_dir: Path, output_names: Union[str, List[str]]):
        if isinstance(output_names, str):
            output_names = [output_names]

        if len(output_names) != 2:
            raise ValueError("charts generator expects exactly two output filenames")

        sheet = self.args.get("sheet", "Sheet1")

        def create_workbook(path: Path, chart1: Any, chart2: Any = None):
            wb = openpyxl.Workbook()
            ws = wb.active
            ws.title = sheet

            ws.append(["X", "Y"])
            for idx in range(1, 6):
                ws.append([idx, idx * 2])

            data = Reference(ws, min_col=2, min_row=1, max_row=6)
            cats = Reference(ws, min_col=1, min_row=2, max_row=6)

            chart1.add_data(data, titles_from_data=True)
            chart1.set_categories(cats)
            ws.add_chart(chart1, "E2")

            if chart2 is not None:
                chart2.add_data(data, titles_from_data=True)
                chart2.set_categories(cats)
                ws.add_chart(chart2, "E18")

            wb.save(path)

        create_workbook(output_dir / output_names[0], chart1=LineChart())
        create_workbook(output_dir / output_names[1], chart1=BarChart(), chart2=LineChart())


class CopyTemplateGenerator(BaseGenerator):
    """Copies a binary template file into the output directory."""

    def generate(self, output_dir: Path, output_names: Union[str, List[str]]):
        if isinstance(output_names, str):
            output_names = [output_names]

        template_arg = self.args.get("template")
        if not template_arg:
            raise ValueError("copy_template generator requires 'template' argument")

        template = Path(template_arg)
        if not template.exists():
            candidate = Path("fixtures") / template_arg
            if candidate.exists():
                template = candidate
            else:
                raise FileNotFoundError(f"Template {template} not found.")

        for name in output_names:
            shutil.copyfile(template, output_dir / name)

```

---

### File: `fixtures\src\generators\perf.py`

```python
import openpyxl
import random
from pathlib import Path
from typing import Union, List
from .base import BaseGenerator

class LargeGridGenerator(BaseGenerator):
    """
    Generates massive grids using WriteOnly mode to save memory.
    Targeting P1/P2/P3/P4/P5 milestones.
    """
    def generate(self, output_dir: Path, output_names: Union[str, List[str]]):
        if isinstance(output_names, str):
            output_names = [output_names]

        rows = self.args.get('rows', 1000)
        cols = self.args.get('cols', 10)
        mode = self.args.get('mode', 'dense')
        seed = self.args.get('seed', 0)
        pattern_length = self.args.get('pattern_length', 100)
        fill_percent = self.args.get('fill_percent', 100)

        rng = random.Random(seed)

        for name in output_names:
            wb = openpyxl.Workbook(write_only=True)
            ws = wb.create_sheet()
            ws.title = "Performance"

            header = [f"Col_{c}" for c in range(1, cols + 1)]
            ws.append(header)

            for r in range(1, rows + 1):
                row_data = []
                if mode == 'dense':
                    row_data = [f"R{r}C{c}" for c in range(1, cols + 1)]
                
                elif mode == 'noise':
                    row_data = [rng.random() for _ in range(cols)]
                
                elif mode == 'repetitive':
                    pattern_idx = (r - 1) % pattern_length
                    row_data = [f"P{pattern_idx}C{c}" for c in range(1, cols + 1)]
                
                elif mode == 'sparse':
                    row_data = []
                    for c in range(1, cols + 1):
                        if rng.randint(1, 100) <= fill_percent:
                            row_data.append(f"R{r}C{c}")
                        else:
                            row_data.append(None)
                
                ws.append(row_data)

            wb.save(output_dir / name)


```

---

### File: `fuzz\.gitignore`

```
target/
artifacts/
corpus/
**/*.profraw

```

---

### File: `fuzz\Cargo.toml`

```toml
[package]
name = "excel_diff-fuzz"
version = "0.0.0"
publish = false
edition = "2024"

[package.metadata]
cargo-fuzz = true

[dependencies]
libfuzzer-sys = "0.4"
excel_diff = { path = "../core" }

[profile.release]
debug = 1


```

---

### File: `fuzz\fuzz_targets\datamashup.rs`

```rust
#![no_main]

use libfuzzer_sys::fuzz_target;

fuzz_target!(|data: &[u8]| {
    let _ = excel_diff::parse_data_mashup(data);

    let limits = excel_diff::DataMashupLimits {
        max_inner_entries: 256,
        max_inner_part_bytes: 256 * 1024,
        max_inner_total_bytes: 2 * 1024 * 1024,
    };
    let _ = excel_diff::parse_package_parts_with_limits(data, limits);
});


```

---

### File: `fuzz\fuzz_targets\diff_engine.rs`

```rust
#![no_main]

use libfuzzer_sys::fuzz_target;

fuzz_target!(|data: &[u8]| {
    let rows = data.first().copied().unwrap_or(0) % 16;
    let cols = data.get(1).copied().unwrap_or(0) % 16;
    let rows = rows as u32;
    let cols = cols as u32;

    let mut pool = excel_diff::StringPool::new();
    let sheet_id = pool.intern("Sheet1");

    let mut grid_a = excel_diff::Grid::new(rows, cols);
    let mut grid_b = excel_diff::Grid::new(rows, cols);

    if rows > 0 && cols > 0 {
        let mut i = 2usize;
        let mut inserted = 0usize;
        while i + 3 < data.len() && inserted < 64 {
            let which = data[i] & 1;
            let r = (data[i + 1] as u32) % rows;
            let c = (data[i + 2] as u32) % cols;
            let v = data[i + 3] as f64;
            let value = Some(excel_diff::CellValue::Number(v));

            if which == 0 {
                grid_a.insert_cell(r, c, value, None);
            } else {
                grid_b.insert_cell(r, c, value, None);
            }

            inserted += 1;
            i += 4;
        }
    }

    let wb_a = excel_diff::Workbook {
        sheets: vec![excel_diff::Sheet {
            name: sheet_id,
            kind: excel_diff::SheetKind::Worksheet,
            grid: grid_a,
        }],
    };
    let wb_b = excel_diff::Workbook {
        sheets: vec![excel_diff::Sheet {
            name: sheet_id,
            kind: excel_diff::SheetKind::Worksheet,
            grid: grid_b,
        }],
    };

    let config = excel_diff::DiffConfig::default();
    let mut op_count = 0usize;
    let mut sink = excel_diff::CallbackSink::new(|_op| op_count = op_count.saturating_add(1));
    let _ = excel_diff::advanced::try_diff_workbooks_streaming(
        &wb_a,
        &wb_b,
        &mut pool,
        &config,
        &mut sink,
    );
});


```

---

### File: `fuzz\fuzz_targets\open_workbook.rs`

```rust
#![no_main]

use libfuzzer_sys::fuzz_target;

fuzz_target!(|data: &[u8]| {
    if data.len() > 1_000_000 {
        return;
    }

    let cursor = std::io::Cursor::new(data.to_vec());
    let _ = excel_diff::WorkbookPackage::open(cursor);
});


```

---

### File: `scripts\check_perf_thresholds.py`

```python
#!/usr/bin/env python3
"""
Performance threshold checker for excel_diff.

This script verifies that performance tests complete within acceptable time bounds.
It runs `cargo test --release --features perf-metrics perf_` and validates that
each test completes within its configured threshold.

Thresholds are based on the mini-spec table from next_sprint_plan.md:
| Fixture | Rows | Cols | Max Time | Max Memory |
|---------|------|------|----------|------------|
| p1_large_dense | 50,000 | 100 | 5s | 500MB |
| p2_large_noise | 50,000 | 100 | 10s | 600MB |
| p3_adversarial_repetitive | 50,000 | 50 | 15s | 400MB |
| p4_99_percent_blank | 50,000 | 100 | 2s | 200MB |
| p5_identical | 50,000 | 100 | 1s | 300MB |

Note: The Rust tests use smaller grids for CI speed, so these thresholds are
conservative. Memory tracking is planned for a future phase.

Environment variables for threshold configuration:
  EXCEL_DIFF_PERF_P1_MAX_TIME_S - Override max time for perf_p1_large_dense
  EXCEL_DIFF_PERF_P2_MAX_TIME_S - Override max time for perf_p2_large_noise
  EXCEL_DIFF_PERF_P3_MAX_TIME_S - Override max time for perf_p3_adversarial_repetitive
  EXCEL_DIFF_PERF_P4_MAX_TIME_S - Override max time for perf_p4_99_percent_blank
  EXCEL_DIFF_PERF_P5_MAX_TIME_S - Override max time for perf_p5_identical
  EXCEL_DIFF_PERF_SLACK_FACTOR - Multiply all thresholds by this factor (default: 1.0)
"""

import os
import re
import subprocess
import sys
import time
from pathlib import Path

PERF_TEST_TIMEOUT_SECONDS = 120

THRESHOLDS = {
    "perf_p1_large_dense": {"max_time_s": 5},
    "perf_p2_large_noise": {"max_time_s": 10},
    "perf_p3_adversarial_repetitive": {"max_time_s": 15},
    "perf_p4_99_percent_blank": {"max_time_s": 2},
    "perf_p5_identical": {"max_time_s": 1},
}

ENV_VAR_MAP = {
    "perf_p1_large_dense": "EXCEL_DIFF_PERF_P1_MAX_TIME_S",
    "perf_p2_large_noise": "EXCEL_DIFF_PERF_P2_MAX_TIME_S",
    "perf_p3_adversarial_repetitive": "EXCEL_DIFF_PERF_P3_MAX_TIME_S",
    "perf_p4_99_percent_blank": "EXCEL_DIFF_PERF_P4_MAX_TIME_S",
    "perf_p5_identical": "EXCEL_DIFF_PERF_P5_MAX_TIME_S",
}


def get_effective_thresholds():
    """Get thresholds with environment variable overrides applied."""
    effective = {}
    slack_factor = float(os.environ.get("EXCEL_DIFF_PERF_SLACK_FACTOR", "1.0"))

    for test_name, config in THRESHOLDS.items():
        max_time_s = config["max_time_s"]

        env_var = ENV_VAR_MAP.get(test_name)
        if env_var and env_var in os.environ:
            try:
                max_time_s = float(os.environ[env_var])
                print(f"  Override: {test_name} max_time_s={max_time_s} (from {env_var})")
            except ValueError:
                print(f"  WARNING: Invalid value for {env_var}, using default")

        effective[test_name] = {"max_time_s": max_time_s * slack_factor}

    if slack_factor != 1.0:
        print(f"  Slack factor: {slack_factor}x applied to all thresholds")

    return effective


def parse_perf_metrics(stdout: str) -> dict:
    """Parse PERF_METRIC lines from test output.

    Expected format: PERF_METRIC <test_name> total_time_ms=<value> [other_metrics...]

    Returns dict mapping test_name -> {"total_time_ms": int, ...}
    """
    metrics = {}
    pattern = re.compile(r"PERF_METRIC\s+(\S+)\s+(.*)")

    for line in stdout.split("\n"):
        match = pattern.search(line)
        if not match:
            continue

        test_name = match.group(1)
        rest = match.group(2)
        data = {key: int(val) for key, val in re.findall(r"(\w+)=([0-9]+)", rest)}
        data.setdefault("total_time_ms", 0)
        metrics[test_name] = data

    return metrics


def run_perf_tests():
    """Run the performance tests and verify they complete within thresholds."""
    print("=" * 60)
    print("Performance Threshold Check")
    print("=" * 60)

    print("\nLoading thresholds...")
    effective_thresholds = get_effective_thresholds()
    print()

    core_dir = Path(__file__).parent.parent / "core"
    if not core_dir.exists():
        core_dir = Path("core")

    start_time = time.time()
    try:
        result = subprocess.run(
            [
                "cargo",
                "test",
                "--release",
                "--features",
                "perf-metrics",
                "perf_",
                "--",
                "--nocapture",
            ],
            cwd=core_dir,
            capture_output=True,
            text=True,
            timeout=PERF_TEST_TIMEOUT_SECONDS,
        )
    except subprocess.TimeoutExpired:
        print(f"ERROR: Performance tests exceeded timeout of {PERF_TEST_TIMEOUT_SECONDS}s")
        return 1

    elapsed = time.time() - start_time
    print(f"Total perf suite time: {elapsed:.2f}s")
    print()

    if result.returncode != 0:
        print("ERROR: Performance tests failed!")
        print("STDOUT:", result.stdout)
        print("STDERR:", result.stderr)
        return 1

    passed_tests = []
    for line in result.stdout.split("\n"):
        if "test perf_" in line and "... ok" in line:
            test_name = line.split("test ")[1].split(" ...")[0].strip()
            passed_tests.append(test_name)

    print(f"Passed tests: {len(passed_tests)}")
    for test in passed_tests:
        print(f"   {test}")
    print()

    expected_tests = set(THRESHOLDS.keys())
    actual_tests = set(passed_tests)
    missing_tests = expected_tests - actual_tests

    if missing_tests:
        print(f"ERROR: Some expected perf tests did not run: {missing_tests}")
        return 1

    metrics = parse_perf_metrics(result.stdout)
    print(f"Parsed metrics for {len(metrics)} tests:")
    for test_name, data in metrics.items():
        total_time_s = data["total_time_ms"] / 1000.0
        print(f"  {test_name}: {total_time_s:.3f}s")
    print()

    missing_metrics = expected_tests - set(metrics.keys())
    if missing_metrics:
        print(f"ERROR: Missing PERF_METRIC output for tests: {missing_metrics}")
        return 1

    failures = []
    print("Threshold checks:")
    for test_name, threshold in effective_thresholds.items():
        max_time_s = threshold["max_time_s"]
        actual_time_ms = metrics[test_name]["total_time_ms"]
        actual_time_s = actual_time_ms / 1000.0

        if actual_time_s > max_time_s:
            status = "FAIL"
            failures.append((test_name, actual_time_s, max_time_s))
        else:
            status = "PASS"

        print(f"  {test_name}: {actual_time_s:.3f}s / {max_time_s:.1f}s [{status}]")

    print()

    if failures:
        print("=" * 60)
        print("THRESHOLD VIOLATIONS:")
        for test_name, actual, max_time in failures:
            print(f"  {test_name}: {actual:.3f}s exceeded max of {max_time:.1f}s")
        print("=" * 60)
        return 1

    print("=" * 60)
    print("All performance tests passed within thresholds!")
    print("=" * 60)
    return 0


if __name__ == "__main__":
    sys.exit(run_perf_tests())

```

---

### File: `scripts\combine_results_to_csv.py`

```python
#!/usr/bin/env python3
"""
Combine benchmark JSON results into a single CSV for comparison over time.

Usage:
    python scripts/combine_results_to_csv.py [--output FILE] [--results-dir DIR]

Options:
    --output      Output CSV file path (default: benchmarks/results/combined_results.csv)
    --results-dir Directory containing JSON results (default: benchmarks/results)
"""

import argparse
import csv
import json
import sys
from pathlib import Path


ALL_TEST_FIELDS = [
    "total_time_ms",
    "move_detection_time_ms",
    "alignment_time_ms",
    "cell_diff_time_ms",
    "rows_processed",
    "cells_compared",
    "anchors_found",
    "moves_detected",
]


def load_json_results(results_dir: Path) -> list[dict]:
    """Load all JSON result files from the results directory."""
    results = []
    for json_file in sorted(results_dir.glob("*.json")):
        try:
            with open(json_file) as f:
                data = json.load(f)
                data["_source_file"] = json_file.name
                results.append(data)
        except (json.JSONDecodeError, IOError) as e:
            print(f"Warning: Could not load {json_file}: {e}", file=sys.stderr)
    return results


def flatten_results(results: list[dict]) -> list[dict]:
    """Flatten nested test results into individual rows."""
    rows = []
    for result in results:
        timestamp = result.get("timestamp", "")
        git_commit = result.get("git_commit", "")
        git_branch = result.get("git_branch", "")
        full_scale = result.get("full_scale", False)
        source_file = result.get("_source_file", "")

        tests = result.get("tests", {})
        for test_name, test_data in tests.items():
            row = {
                "source_file": source_file,
                "timestamp": timestamp,
                "git_commit": git_commit,
                "git_branch": git_branch,
                "full_scale": full_scale,
                "test_name": test_name,
            }
            for field in ALL_TEST_FIELDS:
                row[field] = test_data.get(field, "")
            rows.append(row)

        summary = result.get("summary", {})
        if summary:
            row = {
                "source_file": source_file,
                "timestamp": timestamp,
                "git_commit": git_commit,
                "git_branch": git_branch,
                "full_scale": full_scale,
                "test_name": "_SUMMARY_",
                "total_time_ms": summary.get("total_time_ms", ""),
                "rows_processed": summary.get("total_rows_processed", ""),
                "cells_compared": summary.get("total_cells_compared", ""),
            }
            for field in ALL_TEST_FIELDS:
                if field not in row:
                    row[field] = ""
            rows.append(row)

    return rows


def write_csv(rows: list[dict], output_path: Path):
    """Write flattened results to CSV."""
    if not rows:
        print("No data to write.", file=sys.stderr)
        return

    fieldnames = [
        "source_file",
        "timestamp",
        "git_commit",
        "git_branch",
        "full_scale",
        "test_name",
    ] + ALL_TEST_FIELDS

    with open(output_path, "w", newline="", encoding="utf-8") as f:
        writer = csv.DictWriter(f, fieldnames=fieldnames)
        writer.writeheader()
        writer.writerows(rows)


def main():
    parser = argparse.ArgumentParser(
        description="Combine benchmark JSON results into a single CSV"
    )
    parser.add_argument(
        "--results-dir",
        type=Path,
        default=Path(__file__).parent.parent / "benchmarks" / "results",
        help="Directory containing JSON results",
    )
    parser.add_argument(
        "--output",
        type=Path,
        default=None,
        help="Output CSV file path",
    )
    args = parser.parse_args()

    if args.output is None:
        args.output = args.results_dir / "combined_results.csv"

    if not args.results_dir.exists():
        print(f"ERROR: Results directory not found: {args.results_dir}", file=sys.stderr)
        return 1

    print(f"Loading results from: {args.results_dir}")
    results = load_json_results(args.results_dir)

    if not results:
        print("ERROR: No JSON result files found.", file=sys.stderr)
        return 1

    print(f"Found {len(results)} result files")

    rows = flatten_results(results)
    print(f"Generated {len(rows)} rows")

    write_csv(rows, args.output)
    print(f"CSV written to: {args.output}")

    return 0


if __name__ == "__main__":
    sys.exit(main())


```

---

### File: `scripts\compare_perf_results.py`

```python
#!/usr/bin/env python3
"""
Compare performance results between two benchmark runs.

Usage:
    python scripts/compare_perf_results.py [baseline.json] [current.json]
    python scripts/compare_perf_results.py --latest  # Compare two most recent results

If no arguments provided, compares the two most recent results in benchmarks/results/.
"""

import argparse
import json
import sys
from pathlib import Path


def load_result(path: Path) -> dict:
    """Load a benchmark result JSON file."""
    with open(path) as f:
        return json.load(f)


def get_latest_results(results_dir: Path, n: int = 2) -> list[Path]:
    """Get the N most recent result files."""
    files = sorted(results_dir.glob("*.json"), key=lambda p: p.stat().st_mtime, reverse=True)
    return files[:n]


def format_delta(baseline: float, current: float) -> str:
    """Format a percentage delta with color indicator."""
    if baseline == 0:
        return "N/A"
    delta = ((current - baseline) / baseline) * 100
    if abs(delta) < 1:
        return f"  {delta:+.1f}%"
    elif delta < 0:
        return f"  {delta:+.1f}% (faster)"
    else:
        return f"  {delta:+.1f}% (SLOWER)"


def compare_results(baseline: dict, current: dict):
    """Compare two benchmark results and print a comparison table."""
    print("=" * 90)
    print("Performance Comparison")
    print("=" * 90)
    print(f"Baseline: {baseline.get('git_commit', 'unknown')} ({baseline.get('timestamp', 'unknown')[:19]})")
    print(f"Current:  {current.get('git_commit', 'unknown')} ({current.get('timestamp', 'unknown')[:19]})")
    print()

    baseline_tests = baseline.get("tests", {})
    current_tests = current.get("tests", {})

    all_tests = sorted(set(baseline_tests.keys()) | set(current_tests.keys()))

    if not all_tests:
        print("No tests found in either result file.")
        return

    print(f"{'Test':<35} {'Baseline':>10} {'Current':>10} {'Delta':>20}")
    print("-" * 90)

    regressions = []
    improvements = []

    for test_name in all_tests:
        base_data = baseline_tests.get(test_name, {})
        curr_data = current_tests.get(test_name, {})

        base_time = base_data.get("total_time_ms", 0)
        curr_time = curr_data.get("total_time_ms", 0)

        if base_time == 0:
            delta_str = "NEW"
        elif curr_time == 0:
            delta_str = "REMOVED"
        else:
            delta_pct = ((curr_time - base_time) / base_time) * 100
            delta_str = format_delta(base_time, curr_time)

            if delta_pct > 10:
                regressions.append((test_name, delta_pct))
            elif delta_pct < -10:
                improvements.append((test_name, delta_pct))

        base_str = f"{base_time:,}ms" if base_time else ""
        curr_str = f"{curr_time:,}ms" if curr_time else ""

        print(f"{test_name:<35} {base_str:>10} {curr_str:>10} {delta_str:>20}")

    print("-" * 90)

    base_total = baseline.get("summary", {}).get("total_time_ms", 0)
    curr_total = current.get("summary", {}).get("total_time_ms", 0)
    print(f"{'TOTAL':<35} {base_total:>10,}ms {curr_total:>10,}ms {format_delta(base_total, curr_total):>20}")
    print("=" * 90)

    if regressions:
        print("\n  REGRESSIONS (>10% slower):")
        for name, delta in sorted(regressions, key=lambda x: -x[1]):
            print(f"   {name}: +{delta:.1f}%")

    if improvements:
        print("\n IMPROVEMENTS (>10% faster):")
        for name, delta in sorted(improvements, key=lambda x: x[1]):
            print(f"   {name}: {delta:.1f}%")

    if not regressions and not improvements:
        print("\n No significant changes detected (within 10%)")


def main():
    parser = argparse.ArgumentParser(description="Compare performance benchmark results")
    parser.add_argument("baseline", nargs="?", type=Path, help="Baseline result JSON file")
    parser.add_argument("current", nargs="?", type=Path, help="Current result JSON file")
    parser.add_argument("--latest", action="store_true", help="Compare two most recent results")
    parser.add_argument(
        "--results-dir",
        type=Path,
        default=Path(__file__).parent.parent / "benchmarks" / "results",
        help="Results directory",
    )
    args = parser.parse_args()

    if args.latest or (args.baseline is None and args.current is None):
        files = get_latest_results(args.results_dir, 2)
        if len(files) < 2:
            print(f"ERROR: Need at least 2 result files in {args.results_dir}")
            print(f"Found: {len(files)} files")
            return 1
        baseline_path = files[1]
        current_path = files[0]
    else:
        if not args.baseline or not args.current:
            parser.error("Must provide both baseline and current files, or use --latest")
        baseline_path = args.baseline
        current_path = args.current

    if not baseline_path.exists():
        print(f"ERROR: Baseline file not found: {baseline_path}")
        return 1
    if not current_path.exists():
        print(f"ERROR: Current file not found: {current_path}")
        return 1

    baseline = load_result(baseline_path)
    current = load_result(current_path)

    compare_results(baseline, current)
    return 0


if __name__ == "__main__":
    sys.exit(main())


```

---

### File: `scripts\export_perf_metrics.py`

```python
#!/usr/bin/env python3
"""
Export performance metrics from excel_diff tests to JSON.

This script runs the performance test suite and captures the PERF_METRIC output,
saving timestamped results to benchmarks/results/ for historical tracking.

Usage:
    python scripts/export_perf_metrics.py [--full-scale] [--output-dir DIR]

Options:
    --full-scale    Run the 50K row tests (slower but comprehensive)
    --output-dir    Override the output directory (default: benchmarks/results)
"""

import argparse
import json
import os
import re
import subprocess
import sys
from datetime import datetime, timezone
from pathlib import Path


def get_git_commit():
    """Get the current git commit hash."""
    try:
        result = subprocess.run(
            ["git", "rev-parse", "HEAD"],
            capture_output=True,
            text=True,
            timeout=10,
        )
        if result.returncode == 0:
            return result.stdout.strip()[:12]
    except Exception:
        pass
    return "unknown"


def get_git_branch():
    """Get the current git branch name."""
    try:
        result = subprocess.run(
            ["git", "rev-parse", "--abbrev-ref", "HEAD"],
            capture_output=True,
            text=True,
            timeout=10,
        )
        if result.returncode == 0:
            return result.stdout.strip()
    except Exception:
        pass
    return "unknown"


def parse_perf_metrics(stdout: str) -> dict:
    """Parse PERF_METRIC lines from test output."""
    metrics = {}
    pattern = re.compile(r"PERF_METRIC\s+(\S+)\s+(.*)")

    for line in stdout.split("\n"):
        match = pattern.search(line)
        if not match:
            continue

        test_name = match.group(1)
        rest = match.group(2)
        data = {key: int(val) for key, val in re.findall(r"(\w+)=([0-9]+)", rest)}

        # Ensure required keys exist even if the output is partially missing.
        data.setdefault("total_time_ms", 0)
        data.setdefault("rows_processed", 0)
        data.setdefault("cells_compared", 0)

        metrics[test_name] = data

    return metrics


def run_perf_tests(full_scale: bool = False) -> tuple[dict, bool]:
    """Run performance tests and return parsed metrics."""
    core_dir = Path(__file__).parent.parent / "core"
    if not core_dir.exists():
        core_dir = Path("core")

    cmd = [
        "cargo",
        "test",
        "--release",
        "--features",
        "perf-metrics",
    ]

    if full_scale:
        cmd.extend(["--", "--ignored", "--nocapture"])
    else:
        cmd.extend(["perf_", "--", "--nocapture"])

    print(f"Running: {' '.join(cmd)}")
    print(f"Working directory: {core_dir}")
    print()

    try:
        result = subprocess.run(
            cmd,
            cwd=core_dir,
            capture_output=True,
            text=True,
            timeout=600 if full_scale else 120,
        )
    except subprocess.TimeoutExpired:
        print("ERROR: Tests timed out")
        return {}, False

    print(result.stdout)
    if result.stderr:
        print("STDERR:", result.stderr, file=sys.stderr)

    success = result.returncode == 0
    metrics = parse_perf_metrics(result.stdout)

    return metrics, success


def save_results(metrics: dict, output_dir: Path, full_scale: bool):
    """Save metrics to a timestamped JSON file."""
    timestamp = datetime.now(timezone.utc)
    filename = timestamp.strftime("%Y-%m-%d_%H%M%S")
    if full_scale:
        filename += "_fullscale"
    filename += ".json"

    output_dir.mkdir(parents=True, exist_ok=True)
    output_path = output_dir / filename

    result = {
        "timestamp": timestamp.isoformat(),
        "git_commit": get_git_commit(),
        "git_branch": get_git_branch(),
        "full_scale": full_scale,
        "tests": metrics,
        "summary": {
            "total_tests": len(metrics),
            "total_time_ms": sum(m["total_time_ms"] for m in metrics.values()),
            "total_rows_processed": sum(m["rows_processed"] for m in metrics.values()),
            "total_cells_compared": sum(m["cells_compared"] for m in metrics.values()),
        },
    }

    with open(output_path, "w") as f:
        json.dump(result, f, indent=2)

    print(f"\nResults saved to: {output_path}")
    return output_path


def print_summary(metrics: dict):
    """Print a summary table of metrics."""
    print("\n" + "=" * 70)
    print("Performance Metrics Summary")
    print("=" * 70)
    print(
        f"{'Test':<40} {'Total':>10} {'Move':>10} {'Align':>10} {'Cell':>10} {'Rows':>10} {'Cells':>12}"
    )
    print("-" * 70)

    for test_name, data in sorted(metrics.items()):
        move = data.get("move_detection_time_ms", 0)
        align = data.get("alignment_time_ms", 0)
        cell = data.get("cell_diff_time_ms", 0)
        print(
            f"{test_name:<40} {data['total_time_ms']:>10,} {move:>10,} {align:>10,} {cell:>10,} {data.get('rows_processed', 0):>10,} {data.get('cells_compared', 0):>12,}"
        )

    print("-" * 70)
    total_time = sum(m["total_time_ms"] for m in metrics.values())
    total_move = sum(m.get("move_detection_time_ms", 0) for m in metrics.values())
    total_align = sum(m.get("alignment_time_ms", 0) for m in metrics.values())
    total_cell = sum(m.get("cell_diff_time_ms", 0) for m in metrics.values())
    total_rows = sum(m["rows_processed"] for m in metrics.values())
    total_cells = sum(m["cells_compared"] for m in metrics.values())
    print(
        f"{'TOTAL':<40} {total_time:>10,} {total_move:>10,} {total_align:>10,} {total_cell:>10,} {total_rows:>10,} {total_cells:>12,}"
    )
    print("=" * 70)


def main():
    parser = argparse.ArgumentParser(
        description="Export performance metrics from excel_diff tests"
    )
    parser.add_argument(
        "--full-scale",
        action="store_true",
        help="Run the 50K row tests (slower but comprehensive)",
    )
    parser.add_argument(
        "--output-dir",
        type=Path,
        default=Path(__file__).parent.parent / "benchmarks" / "results",
        help="Output directory for JSON results",
    )
    args = parser.parse_args()

    print("=" * 70)
    print("Excel Diff Performance Metrics Export")
    print("=" * 70)
    print(f"Mode: {'Full-scale (50K rows)' if args.full_scale else 'Quick (1K rows)'}")
    print(f"Output: {args.output_dir}")
    print(f"Git commit: {get_git_commit()}")
    print(f"Git branch: {get_git_branch()}")
    print()

    metrics, success = run_perf_tests(args.full_scale)

    if not metrics:
        print("ERROR: No metrics captured from test output")
        return 1

    print_summary(metrics)
    save_results(metrics, args.output_dir, args.full_scale)

    if not success:
        print("\nWARNING: Some tests may have failed")
        return 1

    return 0


if __name__ == "__main__":
    sys.exit(main())


```

---

### File: `scripts\verify_release_versions.py`

```python
#!/usr/bin/env python3
"""
Verify that release tags match crate versions.

Branch 5 packaging expects releases to be tagged as `vX.Y.Z`, and for the
workspace crate versions to match `X.Y.Z` (without the leading `v`).

This script is designed to be used in GitHub Actions, but can also be run
locally:

  python scripts/verify_release_versions.py --tag v0.1.0
"""

from __future__ import annotations

import argparse
import os
import re
import sys
from pathlib import Path


TAG_RE = re.compile(
    r"^v(?P<version>[0-9]+\.[0-9]+\.[0-9]+(?:-[0-9A-Za-z.-]+)?(?:\+[0-9A-Za-z.-]+)?)$"
)


def _read_package_version(cargo_toml_path: Path) -> str:
    if not cargo_toml_path.exists():
        raise FileNotFoundError(f"Missing {cargo_toml_path}")

    if sys.version_info >= (3, 11):
        import tomllib  # type: ignore[import-not-found]
    else:
        raise RuntimeError("Python 3.11+ is required (tomllib)")

    data = tomllib.loads(cargo_toml_path.read_text(encoding="utf-8"))
    package = data.get("package")
    if not isinstance(package, dict):
        raise ValueError(f"{cargo_toml_path} has no [package] section")

    version = package.get("version")
    if not isinstance(version, str) or not version.strip():
        raise ValueError(f"{cargo_toml_path} has no valid package.version")

    return version.strip()


def _resolve_tag(tag_arg: str | None) -> str | None:
    if tag_arg:
        return tag_arg.strip()

    ref = os.environ.get("GITHUB_REF", "").strip()
    if ref.startswith("refs/tags/"):
        return ref.removeprefix("refs/tags/")

    return None


def main() -> int:
    parser = argparse.ArgumentParser(description="Verify tag/version consistency.")
    parser.add_argument("--tag", help="Tag like v0.1.0 (defaults to GITHUB_REF)")
    parser.add_argument(
        "--workspace-root",
        default=str(Path(__file__).resolve().parent.parent),
        help="Repository root (default: inferred from script location)",
    )
    parser.add_argument(
        "--crates",
        nargs="*",
        default=["core", "cli", "wasm"],
        help="Crate directories to check (default: core cli wasm)",
    )
    args = parser.parse_args()

    tag = _resolve_tag(args.tag)
    if tag is None:
        print("No tag detected (not running on refs/tags/*); skipping version check.")
        return 0

    match = TAG_RE.match(tag)
    if not match:
        print(f"ERROR: tag {tag!r} does not match expected format vX.Y.Z", file=sys.stderr)
        return 2

    expected = match.group("version")
    root = Path(args.workspace_root)

    mismatches: list[tuple[str, str]] = []
    for crate_dir in args.crates:
        cargo_toml = root / crate_dir / "Cargo.toml"
        actual = _read_package_version(cargo_toml)
        if actual != expected:
            mismatches.append((crate_dir, actual))

    if mismatches:
        print(
            f"ERROR: tag {tag} expects crate version {expected}, but found mismatches:",
            file=sys.stderr,
        )
        for crate_dir, actual in mismatches:
            print(f"  - {crate_dir}/Cargo.toml: {actual}", file=sys.stderr)
        return 1

    print(f"OK: tag {tag} matches crate versions ({expected}).")
    return 0


if __name__ == "__main__":
    raise SystemExit(main())


```

---

### File: `scripts\visualize_benchmarks.py`

```python
#!/usr/bin/env python3
"""
Visualize benchmark trends from combined_results.csv.

Usage:
    python scripts/visualize_benchmarks.py [--input FILE] [--output-dir DIR] [--show]

Options:
    --input       Input CSV file (default: benchmarks/results/combined_results.csv)
    --output-dir  Directory to save plots (default: benchmarks/results/plots)
    --show        Display plots interactively instead of saving
"""

import argparse
import sys
from datetime import datetime
from pathlib import Path

try:
    import matplotlib.pyplot as plt
    import matplotlib.dates as mdates
    import pandas as pd
except ImportError as e:
    print(f"Missing required dependency: {e}")
    print("Install with: pip install matplotlib pandas")
    sys.exit(1)


COLORS = [
    "#2ecc71", "#3498db", "#9b59b6", "#e74c3c", "#f39c12",
    "#1abc9c", "#e67e22", "#34495e", "#16a085", "#c0392b",
]


def load_data(csv_path: Path) -> pd.DataFrame:
    df = pd.read_csv(csv_path)
    df["timestamp"] = pd.to_datetime(df["timestamp"])
    df = df[df["test_name"] != "_SUMMARY_"]
    df = df.sort_values("timestamp")
    return df


def plot_time_trends(df: pd.DataFrame, output_dir: Path, show: bool = False):
    fig, ax = plt.subplots(figsize=(14, 8))

    quick_df = df[df["full_scale"] == False]
    full_df = df[df["full_scale"] == True]

    for i, (scale_df, scale_name) in enumerate([(quick_df, "Quick"), (full_df, "Full-Scale")]):
        if scale_df.empty:
            continue

        test_names = scale_df["test_name"].unique()
        for j, test_name in enumerate(test_names):
            test_data = scale_df[scale_df["test_name"] == test_name]
            color = COLORS[j % len(COLORS)]
            linestyle = "-" if scale_name == "Quick" else "--"
            marker = "o" if scale_name == "Quick" else "s"
            label = f"{test_name} ({scale_name})"
            ax.plot(
                test_data["timestamp"],
                test_data["total_time_ms"],
                marker=marker,
                linestyle=linestyle,
                color=color,
                label=label,
                markersize=6,
                linewidth=2,
                alpha=0.8,
            )

    ax.set_xlabel("Timestamp", fontsize=12)
    ax.set_ylabel("Total Time (ms)", fontsize=12)
    ax.set_title("Benchmark Performance Over Time", fontsize=14, fontweight="bold")
    ax.xaxis.set_major_formatter(mdates.DateFormatter("%m/%d %H:%M"))
    ax.tick_params(axis="x", rotation=45)
    ax.legend(bbox_to_anchor=(1.02, 1), loc="upper left", fontsize=9)
    ax.grid(True, alpha=0.3)
    ax.set_yscale("log")
    fig.tight_layout()

    if show:
        plt.show()
    else:
        fig.savefig(output_dir / "time_trends.png", dpi=150, bbox_inches="tight")
        print(f"Saved: {output_dir / 'time_trends.png'}")
    plt.close(fig)


def plot_speedup_heatmap(df: pd.DataFrame, output_dir: Path, show: bool = False):
    quick_df = df[df["full_scale"] == False].copy()
    if quick_df.empty:
        print("No quick-scale data for speedup heatmap")
        return

    runs = quick_df.groupby("source_file")["timestamp"].first().sort_values()
    if len(runs) < 2:
        print("Need at least 2 runs for speedup comparison")
        return

    pivot = quick_df.pivot_table(
        index="test_name",
        columns="source_file",
        values="total_time_ms",
        aggfunc="first",
    )
    pivot = pivot[runs.index]

    speedup = pd.DataFrame(index=pivot.index)
    run_files = list(pivot.columns)
    for i in range(1, len(run_files)):
        prev_run = run_files[i - 1]
        curr_run = run_files[i]
        col_name = f"{curr_run[:10]}"
        speedup[col_name] = ((pivot[prev_run] - pivot[curr_run]) / pivot[prev_run] * 100).round(1)

    if speedup.empty or speedup.shape[1] == 0:
        print("Not enough data for speedup heatmap")
        return

    fig, ax = plt.subplots(figsize=(max(10, len(speedup.columns) * 1.5), max(6, len(speedup) * 0.6)))

    im = ax.imshow(speedup.values, cmap="RdYlGn", aspect="auto", vmin=-50, vmax=50)

    ax.set_xticks(range(len(speedup.columns)))
    ax.set_xticklabels(speedup.columns, rotation=45, ha="right", fontsize=9)
    ax.set_yticks(range(len(speedup.index)))
    ax.set_yticklabels(speedup.index, fontsize=9)

    for i in range(len(speedup.index)):
        for j in range(len(speedup.columns)):
            val = speedup.iloc[i, j]
            if pd.notna(val):
                color = "white" if abs(val) > 25 else "black"
                text = f"{val:+.0f}%" if val != 0 else "0%"
                ax.text(j, i, text, ha="center", va="center", color=color, fontsize=8)

    cbar = fig.colorbar(im, ax=ax, shrink=0.8)
    cbar.set_label("Speedup % (positive = faster)", fontsize=10)

    ax.set_title("Performance Change Between Runs (Quick Tests)", fontsize=14, fontweight="bold")
    ax.set_xlabel("Run", fontsize=12)
    ax.set_ylabel("Test", fontsize=12)
    fig.tight_layout()

    if show:
        plt.show()
    else:
        fig.savefig(output_dir / "speedup_heatmap.png", dpi=150, bbox_inches="tight")
        print(f"Saved: {output_dir / 'speedup_heatmap.png'}")
    plt.close(fig)


def plot_latest_comparison(df: pd.DataFrame, output_dir: Path, show: bool = False):
    latest_runs = df.groupby("full_scale")["source_file"].apply(lambda x: x.iloc[-1] if len(x) > 0 else None)

    fig, axes = plt.subplots(1, 2, figsize=(14, 6))

    for idx, (full_scale, ax) in enumerate(zip([False, True], axes)):
        if full_scale not in latest_runs.index or latest_runs[full_scale] is None:
            ax.text(0.5, 0.5, "No data", ha="center", va="center", transform=ax.transAxes)
            ax.set_title(f"{'Full-Scale' if full_scale else 'Quick'} Tests - No Data")
            continue

        latest_file = latest_runs[full_scale]
        latest_data = df[(df["source_file"] == latest_file) & (df["full_scale"] == full_scale)]

        if latest_data.empty:
            continue

        tests = latest_data["test_name"].values
        times = latest_data["total_time_ms"].values

        colors = [COLORS[i % len(COLORS)] for i in range(len(tests))]
        bars = ax.barh(tests, times, color=colors, alpha=0.8)

        for bar, time in zip(bars, times):
            ax.text(
                bar.get_width() + max(times) * 0.01,
                bar.get_y() + bar.get_height() / 2,
                f"{time:,.0f}ms",
                va="center",
                fontsize=9,
            )

        scale_name = "Full-Scale (50K rows)" if full_scale else "Quick (1-2K rows)"
        timestamp = latest_data["timestamp"].iloc[0].strftime("%Y-%m-%d %H:%M")
        ax.set_title(f"{scale_name}\n{latest_file} ({timestamp})", fontsize=11, fontweight="bold")
        ax.set_xlabel("Time (ms)", fontsize=10)
        ax.set_xlim(0, max(times) * 1.15)
        ax.grid(True, axis="x", alpha=0.3)

    fig.suptitle("Latest Benchmark Results", fontsize=14, fontweight="bold", y=1.02)
    fig.tight_layout()

    if show:
        plt.show()
    else:
        fig.savefig(output_dir / "latest_comparison.png", dpi=150, bbox_inches="tight")
        print(f"Saved: {output_dir / 'latest_comparison.png'}")
    plt.close(fig)


def plot_metric_breakdown(df: pd.DataFrame, output_dir: Path, show: bool = False):
    metrics = ["move_detection_time_ms", "alignment_time_ms", "cell_diff_time_ms"]
    available_metrics = [m for m in metrics if m in df.columns and df[m].notna().any()]

    if not available_metrics:
        print("No detailed timing metrics available for breakdown chart")
        return

    latest_quick = df[df["full_scale"] == False].groupby("test_name").last().reset_index()
    latest_full = df[df["full_scale"] == True].groupby("test_name").last().reset_index()

    for scale_name, scale_df in [("Quick", latest_quick), ("Full-Scale", latest_full)]:
        if scale_df.empty:
            continue

        scale_df = scale_df[scale_df[available_metrics].notna().any(axis=1)]
        if scale_df.empty:
            continue

        fig, ax = plt.subplots(figsize=(12, 6))

        tests = scale_df["test_name"].values
        x = range(len(tests))
        width = 0.25

        metric_labels = {
            "move_detection_time_ms": "Fingerprinting + Move Detection",
            "alignment_time_ms": "Alignment (incl. diff)",
            "cell_diff_time_ms": "Cell Diff",
        }

        for i, metric in enumerate(available_metrics):
            values = scale_df[metric].fillna(0).values
            offset = (i - len(available_metrics) / 2 + 0.5) * width
            bars = ax.bar([xi + offset for xi in x], values, width, label=metric_labels.get(metric, metric), color=COLORS[i], alpha=0.8)

        ax.set_xlabel("Test", fontsize=12)
        ax.set_ylabel("Time (ms)", fontsize=12)
        ax.set_title(f"Timing Breakdown by Phase ({scale_name} Tests)", fontsize=14, fontweight="bold")
        ax.set_xticks(x)
        ax.set_xticklabels(tests, rotation=45, ha="right", fontsize=9)
        ax.legend()
        ax.grid(True, axis="y", alpha=0.3)
        fig.tight_layout()

        suffix = "quick" if scale_name == "Quick" else "fullscale"
        if show:
            plt.show()
        else:
            fig.savefig(output_dir / f"metric_breakdown_{suffix}.png", dpi=150, bbox_inches="tight")
            print(f"Saved: {output_dir / f'metric_breakdown_{suffix}.png'}")
        plt.close(fig)


def plot_commit_comparison(df: pd.DataFrame, output_dir: Path, show: bool = False):
    quick_df = df[df["full_scale"] == False].copy()
    if quick_df.empty:
        print("No quick-scale data for commit comparison")
        return

    commit_totals = quick_df.groupby(["git_commit", "source_file"])["total_time_ms"].sum().reset_index()
    commit_totals = commit_totals.sort_values("source_file")

    if len(commit_totals) < 2:
        print("Need at least 2 commits for comparison")
        return

    fig, ax = plt.subplots(figsize=(12, 6))

    commits = commit_totals["git_commit"].values
    totals = commit_totals["total_time_ms"].values
    files = commit_totals["source_file"].values

    colors = [COLORS[i % len(COLORS)] for i in range(len(commits))]
    bars = ax.bar(range(len(commits)), totals, color=colors, alpha=0.8)

    for i, (bar, total, commit, fname) in enumerate(zip(bars, totals, commits, files)):
        ax.text(
            bar.get_x() + bar.get_width() / 2,
            bar.get_height() + max(totals) * 0.01,
            f"{total:,.0f}ms",
            ha="center",
            va="bottom",
            fontsize=9,
        )

    ax.set_xlabel("Commit", fontsize=12)
    ax.set_ylabel("Total Time (ms)", fontsize=12)
    ax.set_title("Total Test Suite Time by Commit (Quick Tests)", fontsize=14, fontweight="bold")
    ax.set_xticks(range(len(commits)))
    labels = [f"{c[:8]}\n{f[:10]}" for c, f in zip(commits, files)]
    ax.set_xticklabels(labels, rotation=0, fontsize=8)
    ax.grid(True, axis="y", alpha=0.3)

    if len(totals) >= 2:
        first_total = totals[0]
        last_total = totals[-1]
        overall_change = ((last_total - first_total) / first_total) * 100
        direction = "faster" if overall_change < 0 else "slower"
        ax.text(
            0.98, 0.98,
            f"Overall: {abs(overall_change):.1f}% {direction}",
            transform=ax.transAxes,
            ha="right", va="top",
            fontsize=11,
            fontweight="bold",
            color="green" if overall_change < 0 else "red",
            bbox=dict(boxstyle="round", facecolor="white", alpha=0.8),
        )

    fig.tight_layout()

    if show:
        plt.show()
    else:
        fig.savefig(output_dir / "commit_comparison.png", dpi=150, bbox_inches="tight")
        print(f"Saved: {output_dir / 'commit_comparison.png'}")
    plt.close(fig)


def generate_summary_report(df: pd.DataFrame, output_dir: Path):
    lines = [
        "# Benchmark Trend Summary",
        "",
        f"Generated: {datetime.now().strftime('%Y-%m-%d %H:%M:%S')}",
        "",
        "## Overview",
        "",
        f"- Total benchmark runs: {df['source_file'].nunique()}",
        f"- Quick-scale runs: {df[df['full_scale'] == False]['source_file'].nunique()}",
        f"- Full-scale runs: {df[df['full_scale'] == True]['source_file'].nunique()}",
        f"- Unique tests: {df['test_name'].nunique()}",
        f"- Date range: {df['timestamp'].min().strftime('%Y-%m-%d')} to {df['timestamp'].max().strftime('%Y-%m-%d')}",
        "",
    ]

    for scale_name, full_scale in [("Quick", False), ("Full-Scale", True)]:
        scale_df = df[df["full_scale"] == full_scale]
        if scale_df.empty:
            continue

        lines.extend([f"## {scale_name} Tests Performance", ""])

        runs = scale_df.groupby("source_file")["timestamp"].first().sort_values()
        if len(runs) >= 2:
            first_run = runs.index[0]
            last_run = runs.index[-1]

            first_total = scale_df[scale_df["source_file"] == first_run]["total_time_ms"].sum()
            last_total = scale_df[scale_df["source_file"] == last_run]["total_time_ms"].sum()
            change = ((last_total - first_total) / first_total) * 100

            lines.extend([
                f"- First run total: {first_total:,.0f}ms ({first_run})",
                f"- Latest run total: {last_total:,.0f}ms ({last_run})",
                f"- Overall change: {change:+.1f}% ({'faster' if change < 0 else 'slower'})",
                "",
            ])

        lines.append("### Per-Test Trends")
        lines.append("")
        lines.append("| Test | First (ms) | Latest (ms) | Change |")
        lines.append("|:-----|----------:|------------:|-------:|")

        for test_name in scale_df["test_name"].unique():
            test_data = scale_df[scale_df["test_name"] == test_name].sort_values("timestamp")
            if len(test_data) >= 2:
                first_time = test_data.iloc[0]["total_time_ms"]
                last_time = test_data.iloc[-1]["total_time_ms"]
                pct_change = ((last_time - first_time) / first_time) * 100
                lines.append(f"| {test_name} | {first_time:,.0f} | {last_time:,.0f} | {pct_change:+.1f}% |")
            elif len(test_data) == 1:
                lines.append(f"| {test_name} | {test_data.iloc[0]['total_time_ms']:,.0f} | - | N/A |")

        lines.extend(["", ""])

    report_path = output_dir / "trend_summary.md"
    report_path.write_text("\n".join(lines), encoding="utf-8")
    print(f"Saved: {report_path}")


def main():
    parser = argparse.ArgumentParser(description="Visualize benchmark trends")
    parser.add_argument(
        "--input",
        type=Path,
        default=Path(__file__).parent.parent / "benchmarks" / "results" / "combined_results.csv",
        help="Input CSV file",
    )
    parser.add_argument(
        "--output-dir",
        type=Path,
        default=None,
        help="Output directory for plots",
    )
    parser.add_argument(
        "--show",
        action="store_true",
        help="Display plots interactively",
    )
    args = parser.parse_args()

    if not args.input.exists():
        print(f"ERROR: Input file not found: {args.input}")
        print("Run scripts/combine_results_to_csv.py first to generate the combined CSV.")
        return 1

    if args.output_dir is None:
        args.output_dir = args.input.parent / "plots"

    args.output_dir.mkdir(parents=True, exist_ok=True)

    print(f"Loading data from: {args.input}")
    df = load_data(args.input)
    print(f"Loaded {len(df)} data points from {df['source_file'].nunique()} benchmark runs")
    print()

    print("Generating visualizations...")
    plot_time_trends(df, args.output_dir, args.show)
    plot_speedup_heatmap(df, args.output_dir, args.show)
    plot_latest_comparison(df, args.output_dir, args.show)
    plot_metric_breakdown(df, args.output_dir, args.show)
    plot_commit_comparison(df, args.output_dir, args.show)
    generate_summary_report(df, args.output_dir)

    print()
    print(f"All outputs saved to: {args.output_dir}")
    return 0


if __name__ == "__main__":
    sys.exit(main())

```

---

### File: `tmp\openpyxl_sdist\openpyxl-3.1.5\openpyxl\__init__.py`

```python
# Copyright (c) 2010-2024 openpyxl

DEBUG = False

from openpyxl.compat.numbers import NUMPY
from openpyxl.xml import DEFUSEDXML, LXML
from openpyxl.workbook import Workbook
from openpyxl.reader.excel import load_workbook as open
from openpyxl.reader.excel import load_workbook
import openpyxl._constants as constants

# Expose constants especially the version number

__author__ = constants.__author__
__author_email__ = constants.__author_email__
__license__ = constants.__license__
__maintainer_email__ = constants.__maintainer_email__
__url__ = constants.__url__
__version__ = constants.__version__

```

---

### File: `tmp\openpyxl_sdist\openpyxl-3.1.5\openpyxl\_constants.py`

```python
# Copyright (c) 2010-2024 openpyxl

"""
Package metadata
"""

__author__ = "See AUTHORS"
__author_email__ = "charlie.clark@clark-consulting.eu"
__license__ = "MIT"
__maintainer_email__ = "openpyxl-users@googlegroups.com"
__url__ = "https://openpyxl.readthedocs.io"
__version__ = "3.1.5"
__python__ = "3.8"

```

---

### File: `tmp\openpyxl_sdist\openpyxl-3.1.5\openpyxl\cell\__init__.py`

```python
# Copyright (c) 2010-2024 openpyxl

from .cell import Cell, WriteOnlyCell, MergedCell
from .read_only import ReadOnlyCell

```

---

### File: `tmp\openpyxl_sdist\openpyxl-3.1.5\openpyxl\cell\_writer.py`

```python
# Copyright (c) 2010-2024 openpyxl

from openpyxl.compat import safe_string
from openpyxl.xml.functions import Element, SubElement, whitespace, XML_NS
from openpyxl import LXML
from openpyxl.utils.datetime import to_excel, to_ISO8601
from datetime import timedelta

from openpyxl.worksheet.formula import DataTableFormula, ArrayFormula
from openpyxl.cell.rich_text import CellRichText

def _set_attributes(cell, styled=None):
    """
    Set coordinate and datatype
    """
    coordinate = cell.coordinate
    attrs = {'r': coordinate}
    if styled:
        attrs['s'] = f"{cell.style_id}"

    if cell.data_type == "s":
        attrs['t'] = "inlineStr"
    elif cell.data_type != 'f':
        attrs['t'] = cell.data_type

    value = cell._value

    if cell.data_type == "d":
        if hasattr(value, "tzinfo") and value.tzinfo is not None:
            raise TypeError("Excel does not support timezones in datetimes. "
                    "The tzinfo in the datetime/time object must be set to None.")

        if cell.parent.parent.iso_dates and not isinstance(value, timedelta):
            value = to_ISO8601(value)
        else:
            attrs['t'] = "n"
            value = to_excel(value, cell.parent.parent.epoch)

    if cell.hyperlink:
        cell.parent._hyperlinks.append(cell.hyperlink)

    return value, attrs


def etree_write_cell(xf, worksheet, cell, styled=None):

    value, attributes = _set_attributes(cell, styled)

    el = Element("c", attributes)
    if value is None or value == "":
        xf.write(el)
        return

    if cell.data_type == 'f':
        attrib = {}

        if isinstance(value, ArrayFormula):
            attrib = dict(value)
            value = value.text

        elif isinstance(value, DataTableFormula):
            attrib = dict(value)
            value = None

        formula = SubElement(el, 'f', attrib)
        if value is not None and not attrib.get('t') == "dataTable":
            formula.text = value[1:]
            value = None

    if cell.data_type == 's':
        if isinstance(value, CellRichText):
            el.append(value.to_tree())
        else:
            inline_string = Element("is")
            text = Element('t')
            text.text = value
            whitespace(text)
            inline_string.append(text)
            el.append(inline_string)

    else:
        cell_content = SubElement(el, 'v')
        if value is not None:
            cell_content.text = safe_string(value)

    xf.write(el)


def lxml_write_cell(xf, worksheet, cell, styled=False):
    value, attributes = _set_attributes(cell, styled)

    if value == '' or value is None:
        with xf.element("c", attributes):
            return

    with xf.element('c', attributes):
        if cell.data_type == 'f':
            attrib = {}

            if isinstance(value, ArrayFormula):
                attrib = dict(value)
                value = value.text

            elif isinstance(value, DataTableFormula):
                attrib = dict(value)
                value = None

            with xf.element('f', attrib):
                if value is not None and not attrib.get('t') == "dataTable":
                    xf.write(value[1:])
                    value = None

        if cell.data_type == 's':
            if isinstance(value, CellRichText):
                el = value.to_tree()
                xf.write(el)
            else:
                with xf.element("is"):
                    if isinstance(value, str):
                        attrs = {}
                        if value != value.strip():
                            attrs["{%s}space" % XML_NS] = "preserve"
                        el = Element("t", attrs) # lxml can't handle xml-ns
                        el.text = value
                        xf.write(el)

        else:
            with xf.element("v"):
                if value is not None:
                    xf.write(safe_string(value))


if LXML:
    write_cell = lxml_write_cell
else:
    write_cell = etree_write_cell

```

---

### File: `tmp\openpyxl_sdist\openpyxl-3.1.5\openpyxl\cell\cell.py`

```python
# Copyright (c) 2010-2024 openpyxl

"""Manage individual cells in a spreadsheet.

The Cell class is required to know its value and type, display options,
and any other features of an Excel cell.  Utilities for referencing
cells using Excel's 'A1' column/row nomenclature are also provided.

"""

__docformat__ = "restructuredtext en"

# Python stdlib imports
from copy import copy
import datetime
import re


from openpyxl.compat import (
    NUMERIC_TYPES,
)

from openpyxl.utils.exceptions import IllegalCharacterError

from openpyxl.utils import get_column_letter
from openpyxl.styles import numbers, is_date_format
from openpyxl.styles.styleable import StyleableObject
from openpyxl.worksheet.hyperlink import Hyperlink
from openpyxl.worksheet.formula import DataTableFormula, ArrayFormula
from openpyxl.cell.rich_text import CellRichText

# constants

TIME_TYPES = (datetime.datetime, datetime.date, datetime.time, datetime.timedelta)
TIME_FORMATS = {
    datetime.datetime:numbers.FORMAT_DATE_DATETIME,
    datetime.date:numbers.FORMAT_DATE_YYYYMMDD2,
    datetime.time:numbers.FORMAT_DATE_TIME6,
    datetime.timedelta:numbers.FORMAT_DATE_TIMEDELTA,
                }

STRING_TYPES = (str, bytes, CellRichText)
KNOWN_TYPES = NUMERIC_TYPES + TIME_TYPES + STRING_TYPES + (bool, type(None))

ILLEGAL_CHARACTERS_RE = re.compile(r'[\000-\010]|[\013-\014]|[\016-\037]')
ERROR_CODES = ('#NULL!', '#DIV/0!', '#VALUE!', '#REF!', '#NAME?', '#NUM!',
               '#N/A')

TYPE_STRING = 's'
TYPE_FORMULA = 'f'
TYPE_NUMERIC = 'n'
TYPE_BOOL = 'b'
TYPE_NULL = 'n'
TYPE_INLINE = 'inlineStr'
TYPE_ERROR = 'e'
TYPE_FORMULA_CACHE_STRING = 'str'

VALID_TYPES = (TYPE_STRING, TYPE_FORMULA, TYPE_NUMERIC, TYPE_BOOL,
               TYPE_NULL, TYPE_INLINE, TYPE_ERROR, TYPE_FORMULA_CACHE_STRING)


_TYPES = {int:'n', float:'n', str:'s', bool:'b'}


def get_type(t, value):
    if isinstance(value, NUMERIC_TYPES):
        dt = 'n'
    elif isinstance(value, STRING_TYPES):
        dt = 's'
    elif isinstance(value, TIME_TYPES):
        dt = 'd'
    elif isinstance(value, (DataTableFormula, ArrayFormula)):
        dt = 'f'
    else:
        return
    _TYPES[t] = dt
    return dt


def get_time_format(t):
    value = TIME_FORMATS.get(t)
    if value:
        return value
    for base in t.mro()[1:]:
        value = TIME_FORMATS.get(base)
        if value:
            TIME_FORMATS[t] = value
            return value
    raise ValueError("Could not get time format for {0!r}".format(value))


class Cell(StyleableObject):
    """Describes cell associated properties.

    Properties of interest include style, type, value, and address.

    """
    __slots__ = (
        'row',
        'column',
        '_value',
        'data_type',
        'parent',
        '_hyperlink',
        '_comment',
                 )

    def __init__(self, worksheet, row=None, column=None, value=None, style_array=None):
        super().__init__(worksheet, style_array)
        self.row = row
        """Row number of this cell (1-based)"""
        self.column = column
        """Column number of this cell (1-based)"""
        # _value is the stored value, while value is the displayed value
        self._value = None
        self._hyperlink = None
        self.data_type = 'n'
        if value is not None:
            self.value = value
        self._comment = None


    @property
    def coordinate(self):
        """This cell's coordinate (ex. 'A5')"""
        col = get_column_letter(self.column)
        return f"{col}{self.row}"


    @property
    def col_idx(self):
        """The numerical index of the column"""
        return self.column


    @property
    def column_letter(self):
        return get_column_letter(self.column)


    @property
    def encoding(self):
        return self.parent.encoding

    @property
    def base_date(self):
        return self.parent.parent.epoch


    def __repr__(self):
        return "<Cell {0!r}.{1}>".format(self.parent.title, self.coordinate)

    def check_string(self, value):
        """Check string coding, length, and line break character"""
        if value is None:
            return
        # convert to str string
        if not isinstance(value, str):
            value = str(value, self.encoding)
        value = str(value)
        # string must never be longer than 32,767 characters
        # truncate if necessary
        value = value[:32767]
        if next(ILLEGAL_CHARACTERS_RE.finditer(value), None):
            raise IllegalCharacterError(f"{value} cannot be used in worksheets.")
        return value

    def check_error(self, value):
        """Tries to convert Error" else N/A"""
        try:
            return str(value)
        except UnicodeDecodeError:
            return u'#N/A'


    def _bind_value(self, value):
        """Given a value, infer the correct data type"""

        self.data_type = "n"
        t = type(value)
        try:
            dt = _TYPES[t]
        except KeyError:
            dt = get_type(t, value)

        if dt is None and value is not None:
            raise ValueError("Cannot convert {0!r} to Excel".format(value))

        if dt:
            self.data_type = dt

        if dt == 'd':
            if not is_date_format(self.number_format):
                self.number_format = get_time_format(t)

        elif dt == "s" and not isinstance(value, CellRichText):
            value = self.check_string(value)
            if len(value) > 1 and value.startswith("="):
                self.data_type = 'f'
            elif value in ERROR_CODES:
                self.data_type = 'e'

        self._value = value


    @property
    def value(self):
        """Get or set the value held in the cell.

        :type: depends on the value (string, float, int or
            :class:`datetime.datetime`)
        """
        return self._value

    @value.setter
    def value(self, value):
        """Set the value and infer type and display options."""
        self._bind_value(value)

    @property
    def internal_value(self):
        """Always returns the value for excel."""
        return self._value

    @property
    def hyperlink(self):
        """Return the hyperlink target or an empty string"""
        return self._hyperlink


    @hyperlink.setter
    def hyperlink(self, val):
        """Set value and display for hyperlinks in a cell.
        Automatically sets the `value` of the cell with link text,
        but you can modify it afterwards by setting the `value`
        property, and the hyperlink will remain.
        Hyperlink is removed if set to ``None``."""
        if val is None:
            self._hyperlink = None
        else:
            if not isinstance(val, Hyperlink):
                val = Hyperlink(ref="", target=val)
            val.ref = self.coordinate
            self._hyperlink = val
            if self._value is None:
                self.value = val.target or val.location


    @property
    def is_date(self):
        """True if the value is formatted as a date

        :type: bool
        """
        return self.data_type == 'd' or (
            self.data_type == 'n' and is_date_format(self.number_format)
            )


    def offset(self, row=0, column=0):
        """Returns a cell location relative to this cell.

        :param row: number of rows to offset
        :type row: int

        :param column: number of columns to offset
        :type column: int

        :rtype: :class:`openpyxl.cell.Cell`
        """
        offset_column = self.col_idx + column
        offset_row = self.row + row
        return self.parent.cell(column=offset_column, row=offset_row)


    @property
    def comment(self):
        """ Returns the comment associated with this cell

            :type: :class:`openpyxl.comments.Comment`
        """
        return self._comment


    @comment.setter
    def comment(self, value):
        """
        Assign a comment to a cell
        """

        if value is not None:
            if value.parent:
                value = copy(value)
            value.bind(self)
        elif value is None and self._comment:
            self._comment.unbind()
        self._comment = value


class MergedCell(StyleableObject):

    """
    Describes the properties of a cell in a merged cell and helps to
    display the borders of the merged cell.

    The value of a MergedCell is always None.
    """

    __slots__ = ('row', 'column')

    _value = None
    data_type = "n"
    comment = None
    hyperlink = None


    def __init__(self, worksheet, row=None, column=None):
        super().__init__(worksheet)
        self.row = row
        self.column = column


    def __repr__(self):
        return "<MergedCell {0!r}.{1}>".format(self.parent.title, self.coordinate)

    coordinate = Cell.coordinate
    _comment = comment
    value = _value


def WriteOnlyCell(ws=None, value=None):
    return Cell(worksheet=ws, column=1, row=1, value=value)

```

---

### File: `tmp\openpyxl_sdist\openpyxl-3.1.5\openpyxl\cell\read_only.py`

```python
# Copyright (c) 2010-2024 openpyxl

from openpyxl.cell import Cell
from openpyxl.utils import get_column_letter
from openpyxl.utils.datetime import from_excel
from openpyxl.styles import is_date_format
from openpyxl.styles.numbers import BUILTIN_FORMATS, BUILTIN_FORMATS_MAX_SIZE


class ReadOnlyCell:

    __slots__ =  ('parent', 'row', 'column', '_value', 'data_type', '_style_id')

    def __init__(self, sheet, row, column, value, data_type='n', style_id=0):
        self.parent = sheet
        self._value = None
        self.row = row
        self.column = column
        self.data_type = data_type
        self.value = value
        self._style_id = style_id


    def __eq__(self, other):
        for a in self.__slots__:
            if getattr(self, a) != getattr(other, a):
                return
        return True

    def __ne__(self, other):
        return not self.__eq__(other)


    def __repr__(self):
        return "<ReadOnlyCell {0!r}.{1}>".format(self.parent.title, self.coordinate)


    @property
    def coordinate(self):
        column = get_column_letter(self.column)
        return "{1}{0}".format(self.row, column)


    @property
    def coordinate(self):
        return Cell.coordinate.__get__(self)


    @property
    def column_letter(self):
        return Cell.column_letter.__get__(self)


    @property
    def style_array(self):
        return self.parent.parent._cell_styles[self._style_id]


    @property
    def has_style(self):
        return self._style_id != 0


    @property
    def number_format(self):
        _id = self.style_array.numFmtId
        if _id < BUILTIN_FORMATS_MAX_SIZE:
            return BUILTIN_FORMATS.get(_id, "General")
        else:
            return self.parent.parent._number_formats[
                _id - BUILTIN_FORMATS_MAX_SIZE]

    @property
    def font(self):
        _id = self.style_array.fontId
        return self.parent.parent._fonts[_id]

    @property
    def fill(self):
        _id = self.style_array.fillId
        return self.parent.parent._fills[_id]

    @property
    def border(self):
        _id = self.style_array.borderId
        return self.parent.parent._borders[_id]

    @property
    def alignment(self):
        _id = self.style_array.alignmentId
        return self.parent.parent._alignments[_id]

    @property
    def protection(self):
        _id = self.style_array.protectionId
        return self.parent.parent._protections[_id]


    @property
    def is_date(self):
        return Cell.is_date.__get__(self)


    @property
    def internal_value(self):
        return self._value

    @property
    def value(self):
        return self._value

    @value.setter
    def value(self, value):
        if self._value is not None:
            raise AttributeError("Cell is read only")
        self._value = value


class EmptyCell:

    __slots__ = ()

    value = None
    is_date = False
    font = None
    border = None
    fill = None
    number_format = None
    alignment = None
    data_type = 'n'


    def __repr__(self):
        return "<EmptyCell>"

EMPTY_CELL = EmptyCell()

```

---

### File: `tmp\openpyxl_sdist\openpyxl-3.1.5\openpyxl\cell\rich_text.py`

```python
# Copyright (c) 2010-2024 openpyxl

"""
RichText definition
"""
from copy import copy
from openpyxl.compat import NUMERIC_TYPES
from openpyxl.cell.text import InlineFont, Text
from openpyxl.descriptors import (
    Strict,
    String,
    Typed
)

from openpyxl.xml.functions import Element, whitespace

class TextBlock(Strict):
    """ Represents text string in a specific format

    This class is used as part of constructing a rich text strings.
    """
    font = Typed(expected_type=InlineFont)
    text = String()

    def __init__(self, font, text):
        self.font = font
        self.text = text


    def __eq__(self, other):
        return self.text == other.text and self.font == other.font


    def __str__(self):
        """Just retun the text"""
        return self.text


    def __repr__(self):
        font = self.font != InlineFont() and self.font or "default"
        return f"{self.__class__.__name__} text={self.text}, font={font}"


    def to_tree(self):
        el = Element("r")
        el.append(self.font.to_tree(tagname="rPr"))
        t = Element("t")
        t.text = self.text
        whitespace(t)
        el.append(t)
        return el

#
# Rich Text class.
# This class behaves just like a list whose members are either simple strings, or TextBlock() instances.
# In addition, it can be initialized in several ways:
# t = CellRFichText([...]) # initialize with a list.
# t = CellRFichText((...)) # initialize with a tuple.
# t = CellRichText(node) # where node is an Element() from either lxml or xml.etree (has a 'tag' element)
class CellRichText(list):
    """Represents a rich text string.

    Initialize with a list made of pure strings or :class:`TextBlock` elements
    Can index object to access or modify individual rich text elements
    it also supports the + and += operators between rich text strings
    There are no user methods for this class

    operations which modify the string will generally call an optimization pass afterwards,
    that merges text blocks with identical formats, consecutive pure text strings,
    and remove empty strings and empty text blocks
    """

    def __init__(self, *args):
        if len(args) == 1:
            args = args[0]
            if isinstance(args, (list, tuple)):
                CellRichText._check_rich_text(args)
            else:
                CellRichText._check_element(args)
                args = [args]
        else:
            CellRichText._check_rich_text(args)
        super().__init__(args)


    @classmethod
    def _check_element(cls, value):
        if not isinstance(value, (str, TextBlock, NUMERIC_TYPES)):
            raise TypeError(f"Illegal CellRichText element {value}")


    @classmethod
    def _check_rich_text(cls, rich_text):
        for t in rich_text:
            CellRichText._check_element(t)

    @classmethod
    def from_tree(cls, node):
        text = Text.from_tree(node)
        if text.t:
            return (text.t.replace('x005F_', ''),)
        s = []
        for r in text.r:
            t = ""
            if r.t:
                t = r.t.replace('x005F_', '')
            if r.rPr:
                s.append(TextBlock(r.rPr, t))
            else:
                s.append(t)
        return cls(s)

    # Merge TextBlocks with identical formatting
    # remove empty elements
    def _opt(self):
        last_t = None
        l = CellRichText(tuple())
        for t in self:
            if isinstance(t, str):
                if not t:
                    continue
            elif not t.text:
                continue
            if type(last_t) == type(t):
                if isinstance(t, str):
                    last_t += t
                    continue
                elif last_t.font == t.font:
                    last_t.text += t.text
                    continue
            if last_t:
                l.append(last_t)
            last_t = t
        if last_t:
            # Add remaining TextBlock at end of rich text
            l.append(last_t)
        super().__setitem__(slice(None), l)
        return self


    def __iadd__(self, arg):
        # copy used here to create new TextBlock() so we don't modify the right hand side in _opt()
        CellRichText._check_rich_text(arg)
        super().__iadd__([copy(e) for e in list(arg)])
        return self._opt()


    def __add__(self, arg):
        return CellRichText([copy(e) for e in list(self) + list(arg)])._opt()


    def __setitem__(self, indx, val):
        CellRichText._check_element(val)
        super().__setitem__(indx, val)
        self._opt()


    def append(self, arg):
        CellRichText._check_element(arg)
        super().append(arg)


    def extend(self, arg):
        CellRichText._check_rich_text(arg)
        super().extend(arg)


    def __repr__(self):
        return "CellRichText([{}])".format(', '.join((repr(s) for s in self)))


    def __str__(self):
        return ''.join([str(s) for s in self])


    def as_list(self):
        """
        Returns a list of the strings contained.
        The main reason for this is to make editing easier.
        """
        return [str(s) for s in self]


    def to_tree(self):
        """
        Return the full XML representation
        """
        container = Element("is")
        for obj in self:
            if isinstance(obj, TextBlock):
                container.append(obj.to_tree())

            else:
                el = Element("r")
                t = Element("t")
                t.text = obj
                whitespace(t)
                el.append(t)
                container.append(el)

        return container


```

---

### File: `tmp\openpyxl_sdist\openpyxl-3.1.5\openpyxl\cell\text.py`

```python
# Copyright (c) 2010-2024 openpyxl

"""
Richtext definition
"""

from openpyxl.descriptors.serialisable import Serialisable
from openpyxl.descriptors import (
    Alias,
    Typed,
    Integer,
    Set,
    NoneSet,
    Bool,
    String,
    Sequence,
)
from openpyxl.descriptors.nested import (
    NestedBool,
    NestedInteger,
    NestedString,
    NestedText,
)
from openpyxl.styles.fonts import Font


class PhoneticProperties(Serialisable):

    tagname = "phoneticPr"

    fontId = Integer()
    type = NoneSet(values=(['halfwidthKatakana', 'fullwidthKatakana',
                            'Hiragana', 'noConversion']))
    alignment = NoneSet(values=(['noControl', 'left', 'center', 'distributed']))

    def __init__(self,
                 fontId=None,
                 type=None,
                 alignment=None,
                ):
        self.fontId = fontId
        self.type = type
        self.alignment = alignment


class PhoneticText(Serialisable):

    tagname = "rPh"

    sb = Integer()
    eb = Integer()
    t = NestedText(expected_type=str)
    text = Alias('t')

    def __init__(self,
                 sb=None,
                 eb=None,
                 t=None,
                ):
        self.sb = sb
        self.eb = eb
        self.t = t


class InlineFont(Font):

    """
    Font for inline text because, yes what you need are different objects with the same elements but different constraints.
    """

    tagname = "RPrElt"

    rFont = NestedString(allow_none=True)
    charset = Font.charset
    family = Font.family
    b =Font.b
    i = Font.i
    strike = Font.strike
    outline = Font.outline
    shadow = Font.shadow
    condense = Font.condense
    extend = Font.extend
    color = Font.color
    sz = Font.sz
    u = Font.u
    vertAlign = Font.vertAlign
    scheme = Font.scheme

    __elements__ = ('rFont', 'charset', 'family', 'b', 'i', 'strike',
                    'outline', 'shadow', 'condense', 'extend', 'color', 'sz', 'u',
                    'vertAlign', 'scheme')

    def __init__(self,
                 rFont=None,
                 charset=None,
                 family=None,
                 b=None,
                 i=None,
                 strike=None,
                 outline=None,
                 shadow=None,
                 condense=None,
                 extend=None,
                 color=None,
                 sz=None,
                 u=None,
                 vertAlign=None,
                 scheme=None,
                ):
        self.rFont = rFont
        self.charset = charset
        self.family = family
        self.b = b
        self.i = i
        self.strike = strike
        self.outline = outline
        self.shadow = shadow
        self.condense = condense
        self.extend = extend
        self.color = color
        self.sz = sz
        self.u = u
        self.vertAlign = vertAlign
        self.scheme = scheme


class RichText(Serialisable):

    tagname = "RElt"

    rPr = Typed(expected_type=InlineFont, allow_none=True)
    font = Alias("rPr")
    t = NestedText(expected_type=str, allow_none=True)
    text = Alias("t")

    __elements__ = ('rPr', 't')

    def __init__(self,
                 rPr=None,
                 t=None,
                ):
        self.rPr = rPr
        self.t = t


class Text(Serialisable):

    tagname = "text"

    t = NestedText(allow_none=True, expected_type=str)
    plain = Alias("t")
    r = Sequence(expected_type=RichText, allow_none=True)
    formatted = Alias("r")
    rPh = Sequence(expected_type=PhoneticText, allow_none=True)
    phonetic = Alias("rPh")
    phoneticPr = Typed(expected_type=PhoneticProperties, allow_none=True)
    PhoneticProperties = Alias("phoneticPr")

    __elements__ = ('t', 'r', 'rPh', 'phoneticPr')

    def __init__(self,
                 t=None,
                 r=(),
                 rPh=(),
                 phoneticPr=None,
                ):
        self.t = t
        self.r = r
        self.rPh = rPh
        self.phoneticPr = phoneticPr


    @property
    def content(self):
        """
        Text stripped of all formatting
        """
        snippets = []
        if self.plain is not None:
            snippets.append(self.plain)
        for block in self.formatted:
            if block.t is not None:
                snippets.append(block.t)
        return u"".join(snippets)

```

---

### File: `tmp\openpyxl_sdist\openpyxl-3.1.5\openpyxl\chart\_3d.py`

```python
# Copyright (c) 2010-2024 openpyxl

from openpyxl.descriptors import Typed, Alias
from openpyxl.descriptors.serialisable import Serialisable
from openpyxl.descriptors.nested import (
    NestedBool,
    NestedInteger,
    NestedMinMax,
)
from openpyxl.descriptors.excel import ExtensionList
from .marker import PictureOptions
from .shapes import GraphicalProperties


class View3D(Serialisable):

    tagname = "view3D"

    rotX = NestedMinMax(min=-90, max=90, allow_none=True)
    x_rotation = Alias('rotX')
    hPercent = NestedMinMax(min=5, max=500, allow_none=True)
    height_percent = Alias('hPercent')
    rotY = NestedInteger(min=-90, max=90, allow_none=True)
    y_rotation = Alias('rotY')
    depthPercent = NestedInteger(allow_none=True)
    rAngAx = NestedBool(allow_none=True)
    right_angle_axes = Alias('rAngAx')
    perspective = NestedInteger(allow_none=True)
    extLst = Typed(expected_type=ExtensionList, allow_none=True)

    __elements__ = ('rotX', 'hPercent', 'rotY', 'depthPercent', 'rAngAx',
                    'perspective',)

    def __init__(self,
                 rotX=15,
                 hPercent=None,
                 rotY=20,
                 depthPercent=None,
                 rAngAx=True,
                 perspective=None,
                 extLst=None,
                ):
        self.rotX = rotX
        self.hPercent = hPercent
        self.rotY = rotY
        self.depthPercent = depthPercent
        self.rAngAx = rAngAx
        self.perspective = perspective


class Surface(Serialisable):

    tagname = "surface"

    thickness = NestedInteger(allow_none=True)
    spPr = Typed(expected_type=GraphicalProperties, allow_none=True)
    graphicalProperties = Alias('spPr')
    pictureOptions = Typed(expected_type=PictureOptions, allow_none=True)
    extLst = Typed(expected_type=ExtensionList, allow_none=True)

    __elements__ = ('thickness', 'spPr', 'pictureOptions',)

    def __init__(self,
                 thickness=None,
                 spPr=None,
                 pictureOptions=None,
                 extLst=None,
                ):
        self.thickness = thickness
        self.spPr = spPr
        self.pictureOptions = pictureOptions


class _3DBase(Serialisable):

    """
    Base class for 3D charts
    """

    tagname = "ChartBase"

    view3D = Typed(expected_type=View3D, allow_none=True)
    floor = Typed(expected_type=Surface, allow_none=True)
    sideWall = Typed(expected_type=Surface, allow_none=True)
    backWall = Typed(expected_type=Surface, allow_none=True)

    def __init__(self,
                 view3D=None,
                 floor=None,
                 sideWall=None,
                 backWall=None,
                 ):
        if view3D is None:
            view3D = View3D()
        self.view3D = view3D
        if floor is None:
            floor = Surface()
        self.floor = floor
        if sideWall is None:
            sideWall = Surface()
        self.sideWall = sideWall
        if backWall is None:
            backWall = Surface()
        self.backWall = backWall
        super(_3DBase, self).__init__()

```

---

### File: `tmp\openpyxl_sdist\openpyxl-3.1.5\openpyxl\chart\__init__.py`

```python
# Copyright (c) 2010-2024 openpyxl

from .area_chart import AreaChart, AreaChart3D
from .bar_chart import BarChart, BarChart3D
from .bubble_chart import BubbleChart
from .line_chart import LineChart, LineChart3D
from .pie_chart import (
    PieChart,
    PieChart3D,
    DoughnutChart,
    ProjectedPieChart
)
from .radar_chart import RadarChart
from .scatter_chart import ScatterChart
from .stock_chart import StockChart
from .surface_chart import SurfaceChart, SurfaceChart3D

from .series_factory import SeriesFactory as Series
from .reference import Reference

```

---

### File: `tmp\openpyxl_sdist\openpyxl-3.1.5\openpyxl\chart\_chart.py`

```python
# Copyright (c) 2010-2024 openpyxl

from collections import OrderedDict
from operator import attrgetter

from openpyxl.descriptors import (
    Typed,
    Integer,
    Alias,
    MinMax,
    Bool,
    Set,
)
from openpyxl.descriptors.sequence import ValueSequence
from openpyxl.descriptors.serialisable import Serialisable

from ._3d import _3DBase
from .data_source import AxDataSource, NumRef
from .layout import Layout
from .legend import Legend
from .reference import Reference
from .series_factory import SeriesFactory
from .series import attribute_mapping
from .shapes import GraphicalProperties
from .title import TitleDescriptor

class AxId(Serialisable):

    val = Integer()

    def __init__(self, val):
        self.val = val


def PlotArea():
    from .chartspace import PlotArea
    return PlotArea()


class ChartBase(Serialisable):

    """
    Base class for all charts
    """

    legend = Typed(expected_type=Legend, allow_none=True)
    layout = Typed(expected_type=Layout, allow_none=True)
    roundedCorners = Bool(allow_none=True)
    axId = ValueSequence(expected_type=int)
    visible_cells_only = Bool(allow_none=True)
    display_blanks = Set(values=['span', 'gap', 'zero'])
    graphical_properties = Typed(expected_type=GraphicalProperties, allow_none=True)

    _series_type = ""
    ser = ()
    series = Alias('ser')
    title = TitleDescriptor()
    anchor = "E15" # default anchor position
    width = 15 # in cm, approx 5 rows
    height = 7.5 # in cm, approx 14 rows
    _id = 1
    _path = "/xl/charts/chart{0}.xml"
    style = MinMax(allow_none=True, min=1, max=48)
    mime_type = "application/vnd.openxmlformats-officedocument.drawingml.chart+xml"
    graphical_properties = Typed(expected_type=GraphicalProperties, allow_none=True) # mapped to chartspace

    __elements__ = ()


    def __init__(self, axId=(), **kw):
        self._charts = [self]
        self.title = None
        self.layout = None
        self.roundedCorners = None
        self.legend = Legend()
        self.graphical_properties = None
        self.style = None
        self.plot_area = PlotArea()
        self.axId = axId
        self.display_blanks = 'gap'
        self.pivotSource = None
        self.pivotFormats = ()
        self.visible_cells_only = True
        self.idx_base = 0
        self.graphical_properties = None
        super().__init__()


    def __hash__(self):
        """
        Just need to check for identity
        """
        return id(self)

    def __iadd__(self, other):
        """
        Combine the chart with another one
        """
        if not isinstance(other, ChartBase):
            raise TypeError("Only other charts can be added")
        self._charts.append(other)
        return self


    def to_tree(self, namespace=None, tagname=None, idx=None):
        self.axId = [id for id in self._axes]
        if self.ser is not None:
            for s in self.ser:
                s.__elements__ = attribute_mapping[self._series_type]
        return super().to_tree(tagname, idx)


    def _reindex(self):
        """
        Normalise and rebase series: sort by order and then rebase order

        """
        # sort data series in order and rebase
        ds = sorted(self.series, key=attrgetter("order"))
        for idx, s in enumerate(ds):
            s.order = idx
        self.series = ds


    def _write(self):
        from .chartspace import ChartSpace, ChartContainer
        self.plot_area.layout = self.layout

        idx_base = self.idx_base
        for chart in self._charts:
            if chart not in self.plot_area._charts:
                chart.idx_base = idx_base
                idx_base += len(chart.series)
        self.plot_area._charts = self._charts

        container = ChartContainer(plotArea=self.plot_area, legend=self.legend, title=self.title)
        if isinstance(chart, _3DBase):
            container.view3D = chart.view3D
            container.floor = chart.floor
            container.sideWall = chart.sideWall
            container.backWall = chart.backWall
        container.plotVisOnly = self.visible_cells_only
        container.dispBlanksAs = self.display_blanks
        container.pivotFmts = self.pivotFormats
        cs = ChartSpace(chart=container)
        cs.style = self.style
        cs.roundedCorners = self.roundedCorners
        cs.pivotSource = self.pivotSource
        cs.spPr = self.graphical_properties
        return cs.to_tree()


    @property
    def _axes(self):
        x = getattr(self, "x_axis", None)
        y = getattr(self, "y_axis", None)
        z = getattr(self, "z_axis", None)
        return OrderedDict([(axis.axId, axis) for axis in (x, y, z) if axis])


    def set_categories(self, labels):
        """
        Set the categories / x-axis values
        """
        if not isinstance(labels, Reference):
            labels = Reference(range_string=labels)
        for s in self.ser:
            s.cat = AxDataSource(numRef=NumRef(f=labels))


    def add_data(self, data, from_rows=False, titles_from_data=False):
        """
        Add a range of data in a single pass.
        The default is to treat each column as a data series.
        """
        if not isinstance(data, Reference):
            data = Reference(range_string=data)

        if from_rows:
            values = data.rows

        else:
            values = data.cols

        for ref in values:
            series = SeriesFactory(ref, title_from_data=titles_from_data)
            self.series.append(series)


    def append(self, value):
        """Append a data series to the chart"""
        l = self.series[:]
        l.append(value)
        self.series = l


    @property
    def path(self):
        return self._path.format(self._id)

```

---

### File: `tmp\openpyxl_sdist\openpyxl-3.1.5\openpyxl\chart\area_chart.py`

```python
# Copyright (c) 2010-2024 openpyxl

from openpyxl.descriptors.serialisable import Serialisable
from openpyxl.descriptors import (
    Typed,
    Set,
    Bool,
    Integer,
    Sequence,
    Alias,
)

from openpyxl.descriptors.excel import ExtensionList
from openpyxl.descriptors.nested import (
    NestedMinMax,
    NestedSet,
    NestedBool,
)

from ._chart import ChartBase
from .descriptors import NestedGapAmount
from .axis import TextAxis, NumericAxis, SeriesAxis, ChartLines
from .label import DataLabelList
from .series import Series


class _AreaChartBase(ChartBase):

    grouping = NestedSet(values=(['percentStacked', 'standard', 'stacked']))
    varyColors = NestedBool(nested=True, allow_none=True)
    ser = Sequence(expected_type=Series, allow_none=True)
    dLbls = Typed(expected_type=DataLabelList, allow_none=True)
    dataLabels = Alias("dLbls")
    dropLines = Typed(expected_type=ChartLines, allow_none=True)

    _series_type = "area"

    __elements__ = ('grouping', 'varyColors', 'ser', 'dLbls', 'dropLines')

    def __init__(self,
                 grouping="standard",
                 varyColors=None,
                 ser=(),
                 dLbls=None,
                 dropLines=None,
                ):
        self.grouping = grouping
        self.varyColors = varyColors
        self.ser = ser
        self.dLbls = dLbls
        self.dropLines = dropLines
        super().__init__()


class AreaChart(_AreaChartBase):

    tagname = "areaChart"

    grouping = _AreaChartBase.grouping
    varyColors = _AreaChartBase.varyColors
    ser = _AreaChartBase.ser
    dLbls = _AreaChartBase.dLbls
    dropLines = _AreaChartBase.dropLines

    # chart properties actually used by containing classes
    x_axis = Typed(expected_type=TextAxis)
    y_axis = Typed(expected_type=NumericAxis)

    extLst = Typed(expected_type=ExtensionList, allow_none=True)

    __elements__ = _AreaChartBase.__elements__ + ('axId',)

    def __init__(self,
                 axId=None,
                 extLst=None,
                 **kw
                ):
        self.x_axis = TextAxis()
        self.y_axis = NumericAxis()
        super().__init__(**kw)


class AreaChart3D(AreaChart):

    tagname = "area3DChart"

    grouping = _AreaChartBase.grouping
    varyColors = _AreaChartBase.varyColors
    ser = _AreaChartBase.ser
    dLbls = _AreaChartBase.dLbls
    dropLines = _AreaChartBase.dropLines

    gapDepth = NestedGapAmount()

    x_axis = Typed(expected_type=TextAxis)
    y_axis = Typed(expected_type=NumericAxis)
    z_axis = Typed(expected_type=SeriesAxis, allow_none=True)

    __elements__ = AreaChart.__elements__ + ('gapDepth', )

    def __init__(self, gapDepth=None, **kw):
        self.gapDepth = gapDepth
        super(AreaChart3D, self).__init__(**kw)
        self.x_axis = TextAxis()
        self.y_axis = NumericAxis()
        self.z_axis = SeriesAxis()

```

---

### File: `tmp\openpyxl_sdist\openpyxl-3.1.5\openpyxl\chart\axis.py`

```python
# Copyright (c) 2010-2024 openpyxl

from openpyxl.descriptors.serialisable import Serialisable
from openpyxl.descriptors import (
    Typed,
    Float,
    NoneSet,
    Bool,
    Integer,
    MinMax,
    NoneSet,
    Set,
    String,
    Alias,
)

from openpyxl.descriptors.excel import (
    ExtensionList,
    Percentage,
    _explicit_none,
)
from openpyxl.descriptors.nested import (
    NestedValue,
    NestedSet,
    NestedBool,
    NestedNoneSet,
    NestedFloat,
    NestedInteger,
    NestedMinMax,
)
from openpyxl.xml.constants import CHART_NS

from .descriptors import NumberFormatDescriptor
from .layout import Layout
from .text import Text, RichText
from .shapes import GraphicalProperties
from .title import Title, TitleDescriptor


class ChartLines(Serialisable):

    tagname = "chartLines"

    spPr = Typed(expected_type=GraphicalProperties, allow_none=True)
    graphicalProperties = Alias('spPr')

    def __init__(self, spPr=None):
        self.spPr = spPr


class Scaling(Serialisable):

    tagname = "scaling"

    logBase = NestedFloat(allow_none=True)
    orientation = NestedSet(values=(['maxMin', 'minMax']))
    max = NestedFloat(allow_none=True)
    min = NestedFloat(allow_none=True)
    extLst = Typed(expected_type=ExtensionList, allow_none=True)

    __elements__ = ('logBase', 'orientation', 'max', 'min',)

    def __init__(self,
                 logBase=None,
                 orientation="minMax",
                 max=None,
                 min=None,
                 extLst=None,
                ):
        self.logBase = logBase
        self.orientation = orientation
        self.max = max
        self.min = min


class _BaseAxis(Serialisable):

    axId = NestedInteger(expected_type=int)
    scaling = Typed(expected_type=Scaling)
    delete = NestedBool(allow_none=True)
    axPos = NestedSet(values=(['b', 'l', 'r', 't']))
    majorGridlines = Typed(expected_type=ChartLines, allow_none=True)
    minorGridlines = Typed(expected_type=ChartLines, allow_none=True)
    title = TitleDescriptor()
    numFmt = NumberFormatDescriptor()
    number_format = Alias("numFmt")
    majorTickMark = NestedNoneSet(values=(['cross', 'in', 'out']), to_tree=_explicit_none)
    minorTickMark = NestedNoneSet(values=(['cross', 'in', 'out']), to_tree=_explicit_none)
    tickLblPos = NestedNoneSet(values=(['high', 'low', 'nextTo']))
    spPr = Typed(expected_type=GraphicalProperties, allow_none=True)
    graphicalProperties = Alias('spPr')
    txPr = Typed(expected_type=RichText, allow_none=True)
    textProperties = Alias('txPr')
    crossAx = NestedInteger(expected_type=int) # references other axis
    crosses = NestedNoneSet(values=(['autoZero', 'max', 'min']))
    crossesAt = NestedFloat(allow_none=True)

    # crosses & crossesAt are mutually exclusive

    __elements__ = ('axId', 'scaling', 'delete', 'axPos', 'majorGridlines',
                    'minorGridlines', 'title', 'numFmt', 'majorTickMark', 'minorTickMark',
                    'tickLblPos', 'spPr', 'txPr', 'crossAx', 'crosses', 'crossesAt')

    def __init__(self,
                 axId=None,
                 scaling=None,
                 delete=None,
                 axPos='l',
                 majorGridlines=None,
                 minorGridlines=None,
                 title=None,
                 numFmt=None,
                 majorTickMark=None,
                 minorTickMark=None,
                 tickLblPos=None,
                 spPr=None,
                 txPr= None,
                 crossAx=None,
                 crosses=None,
                 crossesAt=None,
                ):
        self.axId = axId
        if scaling is None:
            scaling = Scaling()
        self.scaling = scaling
        self.delete = delete
        self.axPos = axPos
        self.majorGridlines = majorGridlines
        self.minorGridlines = minorGridlines
        self.title = title
        self.numFmt = numFmt
        self.majorTickMark = majorTickMark
        self.minorTickMark = minorTickMark
        self.tickLblPos = tickLblPos
        self.spPr = spPr
        self.txPr = txPr
        self.crossAx = crossAx
        self.crosses = crosses
        self.crossesAt = crossesAt


class DisplayUnitsLabel(Serialisable):

    tagname = "dispUnitsLbl"

    layout = Typed(expected_type=Layout, allow_none=True)
    tx = Typed(expected_type=Text, allow_none=True)
    text = Alias("tx")
    spPr = Typed(expected_type=GraphicalProperties, allow_none=True)
    graphicalProperties = Alias("spPr")
    txPr = Typed(expected_type=RichText, allow_none=True)
    textPropertes = Alias("txPr")

    __elements__ = ('layout', 'tx', 'spPr', 'txPr')

    def __init__(self,
                 layout=None,
                 tx=None,
                 spPr=None,
                 txPr=None,
                ):
        self.layout = layout
        self.tx = tx
        self.spPr = spPr
        self.txPr = txPr


class DisplayUnitsLabelList(Serialisable):

    tagname = "dispUnits"

    custUnit = NestedFloat(allow_none=True)
    builtInUnit = NestedNoneSet(values=(['hundreds', 'thousands',
                                         'tenThousands', 'hundredThousands', 'millions', 'tenMillions',
                                         'hundredMillions', 'billions', 'trillions']))
    dispUnitsLbl = Typed(expected_type=DisplayUnitsLabel, allow_none=True)
    extLst = Typed(expected_type=ExtensionList, allow_none=True)

    __elements__ = ('custUnit', 'builtInUnit', 'dispUnitsLbl',)

    def __init__(self,
                 custUnit=None,
                 builtInUnit=None,
                 dispUnitsLbl=None,
                 extLst=None,
                ):
        self.custUnit = custUnit
        self.builtInUnit = builtInUnit
        self.dispUnitsLbl = dispUnitsLbl


class NumericAxis(_BaseAxis):

    tagname = "valAx"

    axId = _BaseAxis.axId
    scaling = _BaseAxis.scaling
    delete = _BaseAxis.delete
    axPos = _BaseAxis.axPos
    majorGridlines = _BaseAxis.majorGridlines
    minorGridlines = _BaseAxis.minorGridlines
    title = _BaseAxis.title
    numFmt = _BaseAxis.numFmt
    majorTickMark = _BaseAxis.majorTickMark
    minorTickMark = _BaseAxis.minorTickMark
    tickLblPos = _BaseAxis.tickLblPos
    spPr = _BaseAxis.spPr
    txPr = _BaseAxis.txPr
    crossAx = _BaseAxis.crossAx
    crosses = _BaseAxis.crosses
    crossesAt = _BaseAxis.crossesAt

    crossBetween = NestedNoneSet(values=(['between', 'midCat']))
    majorUnit = NestedFloat(allow_none=True)
    minorUnit = NestedFloat(allow_none=True)
    dispUnits = Typed(expected_type=DisplayUnitsLabelList, allow_none=True)
    extLst = Typed(expected_type=ExtensionList, allow_none=True)

    __elements__ = _BaseAxis.__elements__ + ('crossBetween', 'majorUnit',
                                             'minorUnit', 'dispUnits',)


    def __init__(self,
                 crossBetween=None,
                 majorUnit=None,
                 minorUnit=None,
                 dispUnits=None,
                 extLst=None,
                 **kw
                ):
        self.crossBetween = crossBetween
        self.majorUnit = majorUnit
        self.minorUnit = minorUnit
        self.dispUnits = dispUnits
        kw.setdefault('majorGridlines', ChartLines())
        kw.setdefault('axId', 100)
        kw.setdefault('crossAx', 10)
        super().__init__(**kw)


    @classmethod
    def from_tree(cls, node):
        """
        Special case value axes with no gridlines
        """
        self = super().from_tree(node)
        gridlines = node.find("{%s}majorGridlines" % CHART_NS)
        if gridlines is None:
            self.majorGridlines = None
        return self



class TextAxis(_BaseAxis):

    tagname = "catAx"

    axId = _BaseAxis.axId
    scaling = _BaseAxis.scaling
    delete = _BaseAxis.delete
    axPos = _BaseAxis.axPos
    majorGridlines = _BaseAxis.majorGridlines
    minorGridlines = _BaseAxis.minorGridlines
    title = _BaseAxis.title
    numFmt = _BaseAxis.numFmt
    majorTickMark = _BaseAxis.majorTickMark
    minorTickMark = _BaseAxis.minorTickMark
    tickLblPos = _BaseAxis.tickLblPos
    spPr = _BaseAxis.spPr
    txPr = _BaseAxis.txPr
    crossAx = _BaseAxis.crossAx
    crosses = _BaseAxis.crosses
    crossesAt = _BaseAxis.crossesAt

    auto = NestedBool(allow_none=True)
    lblAlgn = NestedNoneSet(values=(['ctr', 'l', 'r']))
    lblOffset = NestedMinMax(min=0, max=1000)
    tickLblSkip = NestedInteger(allow_none=True)
    tickMarkSkip = NestedInteger(allow_none=True)
    noMultiLvlLbl = NestedBool(allow_none=True)
    extLst = Typed(expected_type=ExtensionList, allow_none=True)

    __elements__ = _BaseAxis.__elements__ + ('auto', 'lblAlgn', 'lblOffset',
                                             'tickLblSkip', 'tickMarkSkip', 'noMultiLvlLbl')

    def __init__(self,
                 auto=None,
                 lblAlgn=None,
                 lblOffset=100,
                 tickLblSkip=None,
                 tickMarkSkip=None,
                 noMultiLvlLbl=None,
                 extLst=None,
                 **kw
                ):
        self.auto = auto
        self.lblAlgn = lblAlgn
        self.lblOffset = lblOffset
        self.tickLblSkip = tickLblSkip
        self.tickMarkSkip = tickMarkSkip
        self.noMultiLvlLbl = noMultiLvlLbl
        kw.setdefault('axId', 10)
        kw.setdefault('crossAx', 100)
        super().__init__(**kw)


class DateAxis(TextAxis):

    tagname = "dateAx"

    axId = _BaseAxis.axId
    scaling = _BaseAxis.scaling
    delete = _BaseAxis.delete
    axPos = _BaseAxis.axPos
    majorGridlines = _BaseAxis.majorGridlines
    minorGridlines = _BaseAxis.minorGridlines
    title = _BaseAxis.title
    numFmt = _BaseAxis.numFmt
    majorTickMark = _BaseAxis.majorTickMark
    minorTickMark = _BaseAxis.minorTickMark
    tickLblPos = _BaseAxis.tickLblPos
    spPr = _BaseAxis.spPr
    txPr = _BaseAxis.txPr
    crossAx = _BaseAxis.crossAx
    crosses = _BaseAxis.crosses
    crossesAt = _BaseAxis.crossesAt

    auto = NestedBool(allow_none=True)
    lblOffset = NestedInteger(allow_none=True)
    baseTimeUnit = NestedNoneSet(values=(['days', 'months', 'years']))
    majorUnit = NestedFloat(allow_none=True)
    majorTimeUnit = NestedNoneSet(values=(['days', 'months', 'years']))
    minorUnit = NestedFloat(allow_none=True)
    minorTimeUnit = NestedNoneSet(values=(['days', 'months', 'years']))
    extLst = Typed(expected_type=ExtensionList, allow_none=True)

    __elements__ = _BaseAxis.__elements__ + ('auto', 'lblOffset',
                                             'baseTimeUnit', 'majorUnit', 'majorTimeUnit', 'minorUnit',
                                             'minorTimeUnit')

    def __init__(self,
                 auto=None,
                 lblOffset=None,
                 baseTimeUnit=None,
                 majorUnit=None,
                 majorTimeUnit=None,
                 minorUnit=None,
                 minorTimeUnit=None,
                 extLst=None,
                 **kw
                ):
        self.auto = auto
        self.lblOffset = lblOffset
        self.baseTimeUnit = baseTimeUnit
        self.majorUnit = majorUnit
        self.majorTimeUnit = majorTimeUnit
        self.minorUnit = minorUnit
        self.minorTimeUnit = minorTimeUnit
        kw.setdefault('axId', 500)
        kw.setdefault('lblOffset', lblOffset)
        super().__init__(**kw)


class SeriesAxis(_BaseAxis):

    tagname = "serAx"

    axId = _BaseAxis.axId
    scaling = _BaseAxis.scaling
    delete = _BaseAxis.delete
    axPos = _BaseAxis.axPos
    majorGridlines = _BaseAxis.majorGridlines
    minorGridlines = _BaseAxis.minorGridlines
    title = _BaseAxis.title
    numFmt = _BaseAxis.numFmt
    majorTickMark = _BaseAxis.majorTickMark
    minorTickMark = _BaseAxis.minorTickMark
    tickLblPos = _BaseAxis.tickLblPos
    spPr = _BaseAxis.spPr
    txPr = _BaseAxis.txPr
    crossAx = _BaseAxis.crossAx
    crosses = _BaseAxis.crosses
    crossesAt = _BaseAxis.crossesAt

    tickLblSkip = NestedInteger(allow_none=True)
    tickMarkSkip = NestedInteger(allow_none=True)
    extLst = Typed(expected_type=ExtensionList, allow_none=True)

    __elements__ = _BaseAxis.__elements__ + ('tickLblSkip', 'tickMarkSkip')

    def __init__(self,
                 tickLblSkip=None,
                 tickMarkSkip=None,
                 extLst=None,
                 **kw
                ):
        self.tickLblSkip = tickLblSkip
        self.tickMarkSkip = tickMarkSkip
        kw.setdefault('axId', 1000)
        kw.setdefault('crossAx', 10)
        super().__init__(**kw)

```

---

### File: `tmp\openpyxl_sdist\openpyxl-3.1.5\openpyxl\chart\bar_chart.py`

```python
# Copyright (c) 2010-2024 openpyxl

from openpyxl.descriptors.serialisable import Serialisable
from openpyxl.descriptors import (
    Typed,
    Bool,
    Integer,
    Sequence,
    Alias,
)
from openpyxl.descriptors.excel import ExtensionList
from openpyxl.descriptors.nested import (
    NestedNoneSet,
    NestedSet,
    NestedBool,
    NestedInteger,
    NestedMinMax,
)

from .descriptors import (
    NestedGapAmount,
    NestedOverlap,
)
from ._chart import ChartBase
from ._3d import _3DBase
from .axis import TextAxis, NumericAxis, SeriesAxis, ChartLines
from .shapes import GraphicalProperties
from .series import Series
from .legend import Legend
from .label import DataLabelList


class _BarChartBase(ChartBase):

    barDir = NestedSet(values=(['bar', 'col']))
    type = Alias("barDir")
    grouping = NestedSet(values=(['percentStacked', 'clustered', 'standard',
                                  'stacked']))
    varyColors = NestedBool(nested=True, allow_none=True)
    ser = Sequence(expected_type=Series, allow_none=True)
    dLbls = Typed(expected_type=DataLabelList, allow_none=True)
    dataLabels = Alias("dLbls")

    __elements__ = ('barDir', 'grouping', 'varyColors', 'ser', 'dLbls')

    _series_type = "bar"

    def __init__(self,
                 barDir="col",
                 grouping="clustered",
                 varyColors=None,
                 ser=(),
                 dLbls=None,
                 **kw
                ):
        self.barDir = barDir
        self.grouping = grouping
        self.varyColors = varyColors
        self.ser = ser
        self.dLbls = dLbls
        super().__init__(**kw)


class BarChart(_BarChartBase):

    tagname = "barChart"

    barDir = _BarChartBase.barDir
    grouping = _BarChartBase.grouping
    varyColors = _BarChartBase.varyColors
    ser = _BarChartBase.ser
    dLbls = _BarChartBase.dLbls

    gapWidth = NestedGapAmount()
    overlap = NestedOverlap()
    serLines = Typed(expected_type=ChartLines, allow_none=True)
    extLst = Typed(expected_type=ExtensionList, allow_none=True)

    # chart properties actually used by containing classes
    x_axis = Typed(expected_type=TextAxis)
    y_axis = Typed(expected_type=NumericAxis)

    __elements__ = _BarChartBase.__elements__ + ('gapWidth', 'overlap', 'serLines', 'axId')

    def __init__(self,
                 gapWidth=150,
                 overlap=None,
                 serLines=None,
                 extLst=None,
                 **kw
                ):
        self.gapWidth = gapWidth
        self.overlap = overlap
        self.serLines = serLines
        self.x_axis = TextAxis()
        self.y_axis = NumericAxis()
        self.legend = Legend()
        super().__init__(**kw)


class BarChart3D(_BarChartBase, _3DBase):

    tagname = "bar3DChart"

    barDir = _BarChartBase.barDir
    grouping = _BarChartBase.grouping
    varyColors = _BarChartBase.varyColors
    ser = _BarChartBase.ser
    dLbls = _BarChartBase.dLbls

    view3D = _3DBase.view3D
    floor = _3DBase.floor
    sideWall = _3DBase.sideWall
    backWall = _3DBase.backWall

    gapWidth = NestedGapAmount()
    gapDepth = NestedGapAmount()
    shape = NestedNoneSet(values=(['cone', 'coneToMax', 'box', 'cylinder', 'pyramid', 'pyramidToMax']))
    serLines = Typed(expected_type=ChartLines, allow_none=True)
    extLst = Typed(expected_type=ExtensionList, allow_none=True)

    x_axis = Typed(expected_type=TextAxis)
    y_axis = Typed(expected_type=NumericAxis)
    z_axis = Typed(expected_type=SeriesAxis, allow_none=True)

    __elements__ = _BarChartBase.__elements__ + ('gapWidth', 'gapDepth', 'shape', 'serLines', 'axId')

    def __init__(self,
                 gapWidth=150,
                 gapDepth=150,
                 shape=None,
                 serLines=None,
                 extLst=None,
                 **kw
                ):
        self.gapWidth = gapWidth
        self.gapDepth = gapDepth
        self.shape = shape
        self.serLines = serLines
        self.x_axis = TextAxis()
        self.y_axis = NumericAxis()
        self.z_axis = SeriesAxis()

        super(BarChart3D, self).__init__(**kw)

```

---

### File: `tmp\openpyxl_sdist\openpyxl-3.1.5\openpyxl\chart\bubble_chart.py`

```python
#Autogenerated schema
from openpyxl.descriptors.serialisable import Serialisable
from openpyxl.descriptors import (
    Typed,
    Set,
    MinMax,
    Bool,
    Integer,
    Alias,
    Sequence,
)
from openpyxl.descriptors.excel import ExtensionList
from openpyxl.descriptors.nested import (
    NestedNoneSet,
    NestedMinMax,
    NestedBool,
)

from ._chart import ChartBase
from .axis import TextAxis, NumericAxis
from .series import XYSeries
from .label import DataLabelList


class BubbleChart(ChartBase):

    tagname = "bubbleChart"

    varyColors = NestedBool(allow_none=True)
    ser = Sequence(expected_type=XYSeries, allow_none=True)
    dLbls = Typed(expected_type=DataLabelList, allow_none=True)
    dataLabels = Alias("dLbls")
    bubble3D = NestedBool(allow_none=True)
    bubbleScale = NestedMinMax(min=0, max=300, allow_none=True)
    showNegBubbles = NestedBool(allow_none=True)
    sizeRepresents = NestedNoneSet(values=(['area', 'w']))
    extLst = Typed(expected_type=ExtensionList, allow_none=True)

    x_axis = Typed(expected_type=NumericAxis)
    y_axis = Typed(expected_type=NumericAxis)

    _series_type = "bubble"

    __elements__ = ('varyColors', 'ser', 'dLbls', 'bubble3D', 'bubbleScale',
                    'showNegBubbles', 'sizeRepresents', 'axId')

    def __init__(self,
                 varyColors=None,
                 ser=(),
                 dLbls=None,
                 bubble3D=None,
                 bubbleScale=None,
                 showNegBubbles=None,
                 sizeRepresents=None,
                 extLst=None,
                 **kw
                ):
        self.varyColors = varyColors
        self.ser = ser
        self.dLbls = dLbls
        self.bubble3D = bubble3D
        self.bubbleScale = bubbleScale
        self.showNegBubbles = showNegBubbles
        self.sizeRepresents = sizeRepresents
        self.x_axis = NumericAxis(axId=10, crossAx=20)
        self.y_axis = NumericAxis(axId=20, crossAx=10)
        super().__init__(**kw)

```

---

### File: `tmp\openpyxl_sdist\openpyxl-3.1.5\openpyxl\chart\chartspace.py`

```python

# Copyright (c) 2010-2024 openpyxl

"""
Enclosing chart object. The various chart types are actually child objects.
Will probably need to call this indirectly
"""

from openpyxl.descriptors.serialisable import Serialisable
from openpyxl.descriptors import (
    Typed,
    String,
    Alias,
)
from openpyxl.descriptors.excel import (
    ExtensionList,
    Relation
)
from openpyxl.descriptors.nested import (
    NestedBool,
    NestedNoneSet,
    NestedString,
    NestedMinMax,
)
from openpyxl.descriptors.sequence import NestedSequence
from openpyxl.xml.constants import CHART_NS

from openpyxl.drawing.colors import ColorMapping
from .text import RichText
from .shapes import GraphicalProperties
from .legend import Legend
from ._3d import _3DBase
from .plotarea import PlotArea
from .title import Title
from .pivot import (
    PivotFormat,
    PivotSource,
)
from .print_settings import PrintSettings


class ChartContainer(Serialisable):

    tagname = "chart"

    title = Typed(expected_type=Title, allow_none=True)
    autoTitleDeleted = NestedBool(allow_none=True)
    pivotFmts = NestedSequence(expected_type=PivotFormat)
    view3D = _3DBase.view3D
    floor = _3DBase.floor
    sideWall = _3DBase.sideWall
    backWall = _3DBase.backWall
    plotArea = Typed(expected_type=PlotArea, )
    legend = Typed(expected_type=Legend, allow_none=True)
    plotVisOnly = NestedBool()
    dispBlanksAs = NestedNoneSet(values=(['span', 'gap', 'zero']))
    showDLblsOverMax = NestedBool(allow_none=True)
    extLst = Typed(expected_type=ExtensionList, allow_none=True)

    __elements__ = ('title', 'autoTitleDeleted', 'pivotFmts', 'view3D',
                    'floor', 'sideWall', 'backWall', 'plotArea', 'legend', 'plotVisOnly',
                    'dispBlanksAs', 'showDLblsOverMax')

    def __init__(self,
                 title=None,
                 autoTitleDeleted=None,
                 pivotFmts=(),
                 view3D=None,
                 floor=None,
                 sideWall=None,
                 backWall=None,
                 plotArea=None,
                 legend=None,
                 plotVisOnly=True,
                 dispBlanksAs="gap",
                 showDLblsOverMax=None,
                 extLst=None,
                ):
        self.title = title
        self.autoTitleDeleted = autoTitleDeleted
        self.pivotFmts = pivotFmts
        self.view3D = view3D
        self.floor = floor
        self.sideWall = sideWall
        self.backWall = backWall
        if plotArea is None:
            plotArea = PlotArea()
        self.plotArea = plotArea
        self.legend = legend
        self.plotVisOnly = plotVisOnly
        self.dispBlanksAs = dispBlanksAs
        self.showDLblsOverMax = showDLblsOverMax


class Protection(Serialisable):

    tagname = "protection"

    chartObject = NestedBool(allow_none=True)
    data = NestedBool(allow_none=True)
    formatting = NestedBool(allow_none=True)
    selection = NestedBool(allow_none=True)
    userInterface = NestedBool(allow_none=True)

    __elements__ = ("chartObject", "data", "formatting", "selection", "userInterface")

    def __init__(self,
                 chartObject=None,
                 data=None,
                 formatting=None,
                 selection=None,
                 userInterface=None,
                ):
        self.chartObject = chartObject
        self.data = data
        self.formatting = formatting
        self.selection = selection
        self.userInterface = userInterface


class ExternalData(Serialisable):

    tagname = "externalData"

    autoUpdate = NestedBool(allow_none=True)
    id = String() # Needs namespace

    def __init__(self,
                 autoUpdate=None,
                 id=None
                ):
        self.autoUpdate = autoUpdate
        self.id = id


class ChartSpace(Serialisable):

    tagname = "chartSpace"

    date1904 = NestedBool(allow_none=True)
    lang = NestedString(allow_none=True)
    roundedCorners = NestedBool(allow_none=True)
    style = NestedMinMax(allow_none=True, min=1, max=48)
    clrMapOvr = Typed(expected_type=ColorMapping, allow_none=True)
    pivotSource = Typed(expected_type=PivotSource, allow_none=True)
    protection = Typed(expected_type=Protection, allow_none=True)
    chart = Typed(expected_type=ChartContainer)
    spPr = Typed(expected_type=GraphicalProperties, allow_none=True)
    graphical_properties = Alias("spPr")
    txPr = Typed(expected_type=RichText, allow_none=True)
    textProperties = Alias("txPr")
    externalData = Typed(expected_type=ExternalData, allow_none=True)
    printSettings = Typed(expected_type=PrintSettings, allow_none=True)
    userShapes = Relation()
    extLst = Typed(expected_type=ExtensionList, allow_none=True)

    __elements__ = ('date1904', 'lang', 'roundedCorners', 'style',
                    'clrMapOvr', 'pivotSource', 'protection', 'chart', 'spPr', 'txPr',
                    'externalData', 'printSettings', 'userShapes')

    def __init__(self,
                 date1904=None,
                 lang=None,
                 roundedCorners=None,
                 style=None,
                 clrMapOvr=None,
                 pivotSource=None,
                 protection=None,
                 chart=None,
                 spPr=None,
                 txPr=None,
                 externalData=None,
                 printSettings=None,
                 userShapes=None,
                 extLst=None,
                ):
        self.date1904 = date1904
        self.lang = lang
        self.roundedCorners = roundedCorners
        self.style = style
        self.clrMapOvr = clrMapOvr
        self.pivotSource = pivotSource
        self.protection = protection
        self.chart = chart
        self.spPr = spPr
        self.txPr = txPr
        self.externalData = externalData
        self.printSettings = printSettings
        self.userShapes = userShapes


    def to_tree(self, tagname=None, idx=None, namespace=None):
        tree = super().to_tree()
        tree.set("xmlns", CHART_NS)
        return tree

```

---

### File: `tmp\openpyxl_sdist\openpyxl-3.1.5\openpyxl\chart\data_source.py`

```python
"""
Collection of utility primitives for charts.
"""

from openpyxl.descriptors.serialisable import Serialisable
from openpyxl.descriptors import (
    Bool,
    Typed,
    Alias,
    String,
    Integer,
    Sequence,
)
from openpyxl.descriptors.excel import ExtensionList
from openpyxl.descriptors.nested import (
    NestedString,
    NestedText,
    NestedInteger,
)


class NumFmt(Serialisable):

    formatCode = String()
    sourceLinked = Bool()

    def __init__(self,
                 formatCode=None,
                 sourceLinked=False
                ):
        self.formatCode = formatCode
        self.sourceLinked = sourceLinked


class NumberValueDescriptor(NestedText):
    """
    Data should be numerical but isn't always :-/
    """

    allow_none = True

    def __set__(self, instance, value):
        if value == "#N/A":
            self.expected_type = str
        else:
            self.expected_type = float
        super().__set__(instance, value)


class NumVal(Serialisable):

    idx = Integer()
    formatCode = NestedText(allow_none=True, expected_type=str)
    v = NumberValueDescriptor()

    def __init__(self,
                 idx=None,
                 formatCode=None,
                 v=None,
                ):
        self.idx = idx
        self.formatCode = formatCode
        self.v = v


class NumData(Serialisable):

    formatCode = NestedText(expected_type=str, allow_none=True)
    ptCount = NestedInteger(allow_none=True)
    pt = Sequence(expected_type=NumVal)
    extLst = Typed(expected_type=ExtensionList, allow_none=True)

    __elements__ = ('formatCode', 'ptCount', 'pt')

    def __init__(self,
                 formatCode=None,
                 ptCount=None,
                 pt=(),
                 extLst=None,
                ):
        self.formatCode = formatCode
        self.ptCount = ptCount
        self.pt = pt


class NumRef(Serialisable):

    f = NestedText(expected_type=str)
    ref = Alias('f')
    numCache = Typed(expected_type=NumData, allow_none=True)
    extLst = Typed(expected_type=ExtensionList, allow_none=True)

    __elements__ = ('f', 'numCache')

    def __init__(self,
                 f=None,
                 numCache=None,
                 extLst=None,
                ):
        self.f = f
        self.numCache = numCache


class StrVal(Serialisable):

    tagname = "strVal"

    idx = Integer()
    v = NestedText(expected_type=str)

    def __init__(self,
                 idx=0,
                 v=None,
                ):
        self.idx = idx
        self.v = v


class StrData(Serialisable):

    tagname = "strData"

    ptCount = NestedInteger(allow_none=True)
    pt = Sequence(expected_type=StrVal)
    extLst = Typed(expected_type=ExtensionList, allow_none=True)

    __elements__ = ('ptCount', 'pt')

    def __init__(self,
                 ptCount=None,
                 pt=(),
                 extLst=None,
                ):
        self.ptCount = ptCount
        self.pt = pt


class StrRef(Serialisable):

    tagname = "strRef"

    f = NestedText(expected_type=str, allow_none=True)
    strCache = Typed(expected_type=StrData, allow_none=True)
    extLst = Typed(expected_type=ExtensionList, allow_none=True)

    __elements__ = ('f', 'strCache')

    def __init__(self,
                 f=None,
                 strCache=None,
                 extLst=None,
                ):
        self.f = f
        self.strCache = strCache


class NumDataSource(Serialisable):

    numRef = Typed(expected_type=NumRef, allow_none=True)
    numLit = Typed(expected_type=NumData, allow_none=True)


    def __init__(self,
                 numRef=None,
                 numLit=None,
                 ):
        self.numRef = numRef
        self.numLit = numLit


class Level(Serialisable):

    tagname = "lvl"

    pt = Sequence(expected_type=StrVal)

    __elements__ = ('pt',)

    def __init__(self,
                 pt=(),
                ):
        self.pt = pt


class MultiLevelStrData(Serialisable):

    tagname = "multiLvlStrData"

    ptCount = Integer(allow_none=True)
    lvl = Sequence(expected_type=Level)
    extLst = Typed(expected_type=ExtensionList, allow_none=True)

    __elements__ = ('ptCount', 'lvl',)

    def __init__(self,
                 ptCount=None,
                 lvl=(),
                 extLst=None,
                ):
        self.ptCount = ptCount
        self.lvl = lvl


class MultiLevelStrRef(Serialisable):

    tagname = "multiLvlStrRef"

    f = NestedText(expected_type=str)
    multiLvlStrCache = Typed(expected_type=MultiLevelStrData, allow_none=True)
    extLst = Typed(expected_type=ExtensionList, allow_none=True)

    __elements__ = ('multiLvlStrCache', 'f')

    def __init__(self,
                 f=None,
                 multiLvlStrCache=None,
                 extLst=None,
                ):
        self.f = f
        self.multiLvlStrCache = multiLvlStrCache


class AxDataSource(Serialisable):

    tagname = "cat"

    numRef = Typed(expected_type=NumRef, allow_none=True)
    numLit = Typed(expected_type=NumData, allow_none=True)
    strRef = Typed(expected_type=StrRef, allow_none=True)
    strLit = Typed(expected_type=StrData, allow_none=True)
    multiLvlStrRef = Typed(expected_type=MultiLevelStrRef, allow_none=True)

    def __init__(self,
                 numRef=None,
                 numLit=None,
                 strRef=None,
                 strLit=None,
                 multiLvlStrRef=None,
                 ):
        if not any([numLit, numRef, strRef, strLit, multiLvlStrRef]):
            raise TypeError("A data source must be provided")
        self.numRef = numRef
        self.numLit = numLit
        self.strRef = strRef
        self.strLit = strLit
        self.multiLvlStrRef = multiLvlStrRef

```

---

### File: `tmp\openpyxl_sdist\openpyxl-3.1.5\openpyxl\chart\descriptors.py`

```python
# Copyright (c) 2010-2024 openpyxl



from openpyxl.descriptors.nested import (
    NestedMinMax
    )

from openpyxl.descriptors import Typed

from .data_source import NumFmt

"""
Utility descriptors for the chart module.
For convenience but also clarity.
"""

class NestedGapAmount(NestedMinMax):

    allow_none = True
    min = 0
    max = 500


class NestedOverlap(NestedMinMax):

    allow_none = True
    min = -100
    max = 100


class NumberFormatDescriptor(Typed):
    """
    Allow direct assignment of format code
    """

    expected_type = NumFmt
    allow_none = True

    def __set__(self, instance, value):
        if isinstance(value, str):
            value = NumFmt(value)
        super().__set__(instance, value)

```

---

### File: `tmp\openpyxl_sdist\openpyxl-3.1.5\openpyxl\chart\error_bar.py`

```python
# Copyright (c) 2010-2024 openpyxl

from openpyxl.descriptors.serialisable import Serialisable
from openpyxl.descriptors import (
    Typed,
    Float,
    Set,
    Alias
)

from openpyxl.descriptors.excel import ExtensionList
from openpyxl.descriptors.nested import (
    NestedNoneSet,
    NestedSet,
    NestedBool,
    NestedFloat,
)

from .data_source import NumDataSource
from .shapes import GraphicalProperties


class ErrorBars(Serialisable):

    tagname = "errBars"

    errDir = NestedNoneSet(values=(['x', 'y']))
    direction = Alias("errDir")
    errBarType = NestedSet(values=(['both', 'minus', 'plus']))
    style = Alias("errBarType")
    errValType = NestedSet(values=(['cust', 'fixedVal', 'percentage', 'stdDev', 'stdErr']))
    size = Alias("errValType")
    noEndCap = NestedBool(nested=True, allow_none=True)
    plus = Typed(expected_type=NumDataSource, allow_none=True)
    minus = Typed(expected_type=NumDataSource, allow_none=True)
    val = NestedFloat(allow_none=True)
    spPr = Typed(expected_type=GraphicalProperties, allow_none=True)
    graphicalProperties = Alias("spPr")
    extLst = Typed(expected_type=ExtensionList, allow_none=True)

    __elements__ = ('errDir','errBarType', 'errValType', 'noEndCap','minus', 'plus', 'val', 'spPr')


    def __init__(self,
                 errDir=None,
                 errBarType="both",
                 errValType="fixedVal",
                 noEndCap=None,
                 plus=None,
                 minus=None,
                 val=None,
                 spPr=None,
                 extLst=None,
                ):
        self.errDir = errDir
        self.errBarType = errBarType
        self.errValType = errValType
        self.noEndCap = noEndCap
        self.plus = plus
        self.minus = minus
        self.val = val
        self.spPr = spPr

```

---

### File: `tmp\openpyxl_sdist\openpyxl-3.1.5\openpyxl\chart\label.py`

```python
# Copyright (c) 2010-2024 openpyxl

from openpyxl.descriptors.serialisable import Serialisable
from openpyxl.descriptors import (
    Sequence,
    Alias,
    Typed
)
from openpyxl.descriptors.excel import ExtensionList
from openpyxl.descriptors.nested import (
    NestedNoneSet,
    NestedBool,
    NestedString,
    NestedInteger,
    )

from .shapes import GraphicalProperties
from .text import RichText


class _DataLabelBase(Serialisable):

    numFmt = NestedString(allow_none=True, attribute="formatCode")
    spPr = Typed(expected_type=GraphicalProperties, allow_none=True)
    graphicalProperties = Alias('spPr')
    txPr = Typed(expected_type=RichText, allow_none=True)
    textProperties = Alias('txPr')
    dLblPos = NestedNoneSet(values=['bestFit', 'b', 'ctr', 'inBase', 'inEnd',
                                    'l', 'outEnd', 'r', 't'])
    position = Alias('dLblPos')
    showLegendKey = NestedBool(allow_none=True)
    showVal = NestedBool(allow_none=True)
    showCatName = NestedBool(allow_none=True)
    showSerName = NestedBool(allow_none=True)
    showPercent = NestedBool(allow_none=True)
    showBubbleSize = NestedBool(allow_none=True)
    showLeaderLines = NestedBool(allow_none=True)
    separator = NestedString(allow_none=True)
    extLst = Typed(expected_type=ExtensionList, allow_none=True)

    __elements__ = ("numFmt", "spPr", "txPr", "dLblPos", "showLegendKey",
                    "showVal", "showCatName", "showSerName", "showPercent", "showBubbleSize",
                    "showLeaderLines", "separator")

    def __init__(self,
                 numFmt=None,
                 spPr=None,
                 txPr=None,
                 dLblPos=None,
                 showLegendKey=None,
                 showVal=None,
                 showCatName=None,
                 showSerName=None,
                 showPercent=None,
                 showBubbleSize=None,
                 showLeaderLines=None,
                 separator=None,
                 extLst=None,
                 ):
        self.numFmt = numFmt
        self.spPr = spPr
        self.txPr = txPr
        self.dLblPos = dLblPos
        self.showLegendKey = showLegendKey
        self.showVal = showVal
        self.showCatName = showCatName
        self.showSerName = showSerName
        self.showPercent = showPercent
        self.showBubbleSize = showBubbleSize
        self.showLeaderLines = showLeaderLines
        self.separator = separator


class DataLabel(_DataLabelBase):

    tagname = "dLbl"

    idx = NestedInteger()

    numFmt = _DataLabelBase.numFmt
    spPr = _DataLabelBase.spPr
    txPr = _DataLabelBase.txPr
    dLblPos = _DataLabelBase.dLblPos
    showLegendKey = _DataLabelBase.showLegendKey
    showVal = _DataLabelBase.showVal
    showCatName = _DataLabelBase.showCatName
    showSerName = _DataLabelBase.showSerName
    showPercent = _DataLabelBase.showPercent
    showBubbleSize = _DataLabelBase.showBubbleSize
    showLeaderLines = _DataLabelBase.showLeaderLines
    separator = _DataLabelBase.separator
    extLst = _DataLabelBase.extLst

    __elements__ = ("idx",)  + _DataLabelBase.__elements__

    def __init__(self, idx=0, **kw ):
        self.idx = idx
        super().__init__(**kw)


class DataLabelList(_DataLabelBase):

    tagname = "dLbls"

    dLbl = Sequence(expected_type=DataLabel, allow_none=True)

    delete = NestedBool(allow_none=True)
    numFmt = _DataLabelBase.numFmt
    spPr = _DataLabelBase.spPr
    txPr = _DataLabelBase.txPr
    dLblPos = _DataLabelBase.dLblPos
    showLegendKey = _DataLabelBase.showLegendKey
    showVal = _DataLabelBase.showVal
    showCatName = _DataLabelBase.showCatName
    showSerName = _DataLabelBase.showSerName
    showPercent = _DataLabelBase.showPercent
    showBubbleSize = _DataLabelBase.showBubbleSize
    showLeaderLines = _DataLabelBase.showLeaderLines
    separator = _DataLabelBase.separator
    extLst = _DataLabelBase.extLst

    __elements__ = ("delete", "dLbl",) + _DataLabelBase.__elements__

    def __init__(self, dLbl=(), delete=None,  **kw):
        self.dLbl = dLbl
        self.delete = delete
        super().__init__(**kw)

```

---

### File: `tmp\openpyxl_sdist\openpyxl-3.1.5\openpyxl\chart\layout.py`

```python
# Copyright (c) 2010-2024 openpyxl

from openpyxl.descriptors.serialisable import Serialisable
from openpyxl.descriptors import (
    NoneSet,
    Float,
    Typed,
    Alias,
)

from openpyxl.descriptors.excel import ExtensionList
from openpyxl.descriptors.nested import (
    NestedNoneSet,
    NestedSet,
    NestedMinMax,
)

class ManualLayout(Serialisable):

    tagname = "manualLayout"

    layoutTarget = NestedNoneSet(values=(['inner', 'outer']))
    xMode = NestedNoneSet(values=(['edge', 'factor']))
    yMode = NestedNoneSet(values=(['edge', 'factor']))
    wMode = NestedSet(values=(['edge', 'factor']))
    hMode = NestedSet(values=(['edge', 'factor']))
    x = NestedMinMax(min=-1, max=1, allow_none=True)
    y = NestedMinMax(min=-1, max=1, allow_none=True)
    w = NestedMinMax(min=0, max=1, allow_none=True)
    width = Alias('w')
    h = NestedMinMax(min=0, max=1,  allow_none=True)
    height = Alias('h')
    extLst = Typed(expected_type=ExtensionList, allow_none=True)

    __elements__ = ('layoutTarget', 'xMode', 'yMode', 'wMode', 'hMode', 'x',
                    'y', 'w', 'h')

    def __init__(self,
                 layoutTarget=None,
                 xMode=None,
                 yMode=None,
                 wMode="factor",
                 hMode="factor",
                 x=None,
                 y=None,
                 w=None,
                 h=None,
                 extLst=None,
                ):
        self.layoutTarget = layoutTarget
        self.xMode = xMode
        self.yMode = yMode
        self.wMode = wMode
        self.hMode = hMode
        self.x = x
        self.y = y
        self.w = w
        self.h = h


class Layout(Serialisable):

    tagname = "layout"

    manualLayout = Typed(expected_type=ManualLayout, allow_none=True)
    extLst = Typed(expected_type=ExtensionList, allow_none=True)

    __elements__ = ('manualLayout',)

    def __init__(self,
                 manualLayout=None,
                 extLst=None,
                ):
        self.manualLayout = manualLayout

```

---

### File: `tmp\openpyxl_sdist\openpyxl-3.1.5\openpyxl\chart\legend.py`

```python
# Copyright (c) 2010-2024 openpyxl

from openpyxl.descriptors.serialisable import Serialisable
from openpyxl.descriptors import (
    Typed,
    Integer,
    Alias,
    Sequence,
)
from openpyxl.descriptors.excel import ExtensionList
from openpyxl.descriptors.nested import (
    NestedBool,
    NestedSet,
    NestedInteger
)

from .layout import Layout
from .shapes import GraphicalProperties
from .text import RichText


class LegendEntry(Serialisable):

    tagname = "legendEntry"

    idx = NestedInteger()
    delete = NestedBool()
    txPr = Typed(expected_type=RichText, allow_none=True)
    extLst = Typed(expected_type=ExtensionList, allow_none=True)

    __elements__ = ('idx', 'delete', 'txPr')

    def __init__(self,
                 idx=0,
                 delete=False,
                 txPr=None,
                 extLst=None,
                ):
        self.idx = idx
        self.delete = delete
        self.txPr = txPr


class Legend(Serialisable):

    tagname = "legend"

    legendPos = NestedSet(values=(['b', 'tr', 'l', 'r', 't']))
    position = Alias('legendPos')
    legendEntry = Sequence(expected_type=LegendEntry)
    layout = Typed(expected_type=Layout, allow_none=True)
    overlay = NestedBool(allow_none=True)
    spPr = Typed(expected_type=GraphicalProperties, allow_none=True)
    graphicalProperties = Alias('spPr')
    txPr = Typed(expected_type=RichText, allow_none=True)
    textProperties = Alias('txPr')
    extLst = Typed(expected_type=ExtensionList, allow_none=True)

    __elements__ = ('legendPos', 'legendEntry', 'layout', 'overlay', 'spPr', 'txPr',)

    def __init__(self,
                 legendPos="r",
                 legendEntry=(),
                 layout=None,
                 overlay=None,
                 spPr=None,
                 txPr=None,
                 extLst=None,
                ):
        self.legendPos = legendPos
        self.legendEntry = legendEntry
        self.layout = layout
        self.overlay = overlay
        self.spPr = spPr
        self.txPr = txPr

```

---

### File: `tmp\openpyxl_sdist\openpyxl-3.1.5\openpyxl\chart\line_chart.py`

```python
#Autogenerated schema
from openpyxl.descriptors import (
    Typed,
    Sequence,
    Alias,
    )
from openpyxl.descriptors.excel import ExtensionList
from openpyxl.descriptors.nested import (
    NestedSet,
    NestedBool,
)

from ._chart import ChartBase
from .updown_bars import UpDownBars
from .descriptors import NestedGapAmount
from .axis import TextAxis, NumericAxis, SeriesAxis, ChartLines, _BaseAxis
from .label import DataLabelList
from .series import Series


class _LineChartBase(ChartBase):

    grouping = NestedSet(values=(['percentStacked', 'standard', 'stacked']))
    varyColors = NestedBool(allow_none=True)
    ser = Sequence(expected_type=Series, allow_none=True)
    dLbls = Typed(expected_type=DataLabelList, allow_none=True)
    dataLabels = Alias("dLbls")
    dropLines = Typed(expected_type=ChartLines, allow_none=True)

    _series_type = "line"

    __elements__ = ('grouping', 'varyColors', 'ser', 'dLbls', 'dropLines')

    def __init__(self,
                 grouping="standard",
                 varyColors=None,
                 ser=(),
                 dLbls=None,
                 dropLines=None,
                 **kw
                ):
        self.grouping = grouping
        self.varyColors = varyColors
        self.ser = ser
        self.dLbls = dLbls
        self.dropLines = dropLines
        super().__init__(**kw)


class LineChart(_LineChartBase):

    tagname = "lineChart"

    grouping = _LineChartBase.grouping
    varyColors = _LineChartBase.varyColors
    ser = _LineChartBase.ser
    dLbls = _LineChartBase.dLbls
    dropLines =_LineChartBase.dropLines

    hiLowLines = Typed(expected_type=ChartLines, allow_none=True)
    upDownBars = Typed(expected_type=UpDownBars, allow_none=True)
    marker = NestedBool(allow_none=True)
    smooth = NestedBool(allow_none=True)
    extLst = Typed(expected_type=ExtensionList, allow_none=True)

    x_axis = Typed(expected_type=_BaseAxis)
    y_axis = Typed(expected_type=NumericAxis)

    __elements__ = _LineChartBase.__elements__ + ('hiLowLines', 'upDownBars', 'marker', 'smooth', 'axId')

    def __init__(self,
                 hiLowLines=None,
                 upDownBars=None,
                 marker=None,
                 smooth=None,
                 extLst=None,
                 **kw
                ):
        self.hiLowLines = hiLowLines
        self.upDownBars = upDownBars
        self.marker = marker
        self.smooth = smooth
        self.x_axis = TextAxis()
        self.y_axis = NumericAxis()

        super().__init__(**kw)


class LineChart3D(_LineChartBase):

    tagname = "line3DChart"

    grouping = _LineChartBase.grouping
    varyColors = _LineChartBase.varyColors
    ser = _LineChartBase.ser
    dLbls = _LineChartBase.dLbls
    dropLines =_LineChartBase.dropLines

    gapDepth = NestedGapAmount()
    hiLowLines = Typed(expected_type=ChartLines, allow_none=True)
    upDownBars = Typed(expected_type=UpDownBars, allow_none=True)
    marker = NestedBool(allow_none=True)
    smooth = NestedBool(allow_none=True)
    extLst = Typed(expected_type=ExtensionList, allow_none=True)

    x_axis = Typed(expected_type=TextAxis)
    y_axis = Typed(expected_type=NumericAxis)
    z_axis = Typed(expected_type=SeriesAxis)

    __elements__ = _LineChartBase.__elements__ + ('gapDepth', 'hiLowLines',
                                                  'upDownBars', 'marker', 'smooth', 'axId')

    def __init__(self,
                 gapDepth=None,
                 hiLowLines=None,
                 upDownBars=None,
                 marker=None,
                 smooth=None,
                 **kw
                ):
        self.gapDepth = gapDepth
        self.hiLowLines = hiLowLines
        self.upDownBars = upDownBars
        self.marker = marker
        self.smooth = smooth
        self.x_axis = TextAxis()
        self.y_axis = NumericAxis()
        self.z_axis = SeriesAxis()
        super(LineChart3D, self).__init__(**kw)

```

---

### File: `tmp\openpyxl_sdist\openpyxl-3.1.5\openpyxl\chart\marker.py`

```python
# Copyright (c) 2010-2024 openpyxl

from openpyxl.descriptors.serialisable import Serialisable
from openpyxl.descriptors import (
    Typed,
    Alias,
)

from openpyxl.descriptors.excel import(
    ExtensionList,
    _explicit_none,
)

from openpyxl.descriptors.nested import (
    NestedBool,
    NestedInteger,
    NestedMinMax,
    NestedNoneSet,
)

from .layout import Layout
from .picture import PictureOptions
from .shapes import *
from .text import *
from .error_bar import *


class Marker(Serialisable):

    tagname = "marker"

    symbol = NestedNoneSet(values=(['circle', 'dash', 'diamond', 'dot', 'picture',
                              'plus', 'square', 'star', 'triangle', 'x', 'auto']),
                           to_tree=_explicit_none)
    size = NestedMinMax(min=2, max=72, allow_none=True)
    spPr = Typed(expected_type=GraphicalProperties, allow_none=True)
    graphicalProperties = Alias('spPr')
    extLst = Typed(expected_type=ExtensionList, allow_none=True)

    __elements__ = ('symbol', 'size', 'spPr')

    def __init__(self,
                 symbol=None,
                 size=None,
                 spPr=None,
                 extLst=None,
                ):
        self.symbol = symbol
        self.size = size
        if spPr is None:
            spPr = GraphicalProperties()
        self.spPr = spPr


class DataPoint(Serialisable):

    tagname = "dPt"

    idx = NestedInteger()
    invertIfNegative = NestedBool(allow_none=True)
    marker = Typed(expected_type=Marker, allow_none=True)
    bubble3D = NestedBool(allow_none=True)
    explosion = NestedInteger(allow_none=True)
    spPr = Typed(expected_type=GraphicalProperties, allow_none=True)
    graphicalProperties = Alias('spPr')
    pictureOptions = Typed(expected_type=PictureOptions, allow_none=True)
    extLst = Typed(expected_type=ExtensionList, allow_none=True)

    __elements__ = ('idx', 'invertIfNegative', 'marker', 'bubble3D',
                    'explosion', 'spPr', 'pictureOptions')

    def __init__(self,
                 idx=None,
                 invertIfNegative=None,
                 marker=None,
                 bubble3D=None,
                 explosion=None,
                 spPr=None,
                 pictureOptions=None,
                 extLst=None,
                ):
        self.idx = idx
        self.invertIfNegative = invertIfNegative
        self.marker = marker
        self.bubble3D = bubble3D
        self.explosion = explosion
        if spPr is None:
            spPr = GraphicalProperties()
        self.spPr = spPr
        self.pictureOptions = pictureOptions

```

---

### File: `tmp\openpyxl_sdist\openpyxl-3.1.5\openpyxl\chart\picture.py`

```python
# Copyright (c) 2010-2024 openpyxl

from openpyxl.descriptors.serialisable import Serialisable

from openpyxl.descriptors.nested import (
    NestedBool,
    NestedFloat,
    NestedMinMax,
    NestedNoneSet,
)

class PictureOptions(Serialisable):

    tagname = "pictureOptions"

    applyToFront = NestedBool(allow_none=True, nested=True)
    applyToSides = NestedBool(allow_none=True, nested=True)
    applyToEnd = NestedBool(allow_none=True, nested=True)
    pictureFormat = NestedNoneSet(values=(['stretch', 'stack', 'stackScale']), nested=True)
    pictureStackUnit = NestedFloat(allow_none=True, nested=True)

    __elements__ = ('applyToFront', 'applyToSides', 'applyToEnd', 'pictureFormat', 'pictureStackUnit')

    def __init__(self,
                 applyToFront=None,
                 applyToSides=None,
                 applyToEnd=None,
                 pictureFormat=None,
                 pictureStackUnit=None,
                ):
        self.applyToFront = applyToFront
        self.applyToSides = applyToSides
        self.applyToEnd = applyToEnd
        self.pictureFormat = pictureFormat
        self.pictureStackUnit = pictureStackUnit

```

---

### File: `tmp\openpyxl_sdist\openpyxl-3.1.5\openpyxl\chart\pie_chart.py`

```python
#Autogenerated schema
from openpyxl.descriptors.serialisable import Serialisable
from openpyxl.descriptors import (
    Typed,
    Bool,
    MinMax,
    Integer,
    NoneSet,
    Float,
    Alias,
    Sequence,
)
from openpyxl.descriptors.excel import ExtensionList, Percentage
from openpyxl.descriptors.nested import (
    NestedBool,
    NestedMinMax,
    NestedInteger,
    NestedFloat,
    NestedNoneSet,
    NestedSet,
)
from openpyxl.descriptors.sequence import ValueSequence

from ._chart import ChartBase
from .axis import ChartLines
from .descriptors import NestedGapAmount
from .series import Series
from .label import DataLabelList


class _PieChartBase(ChartBase):

    varyColors = NestedBool(allow_none=True)
    ser = Sequence(expected_type=Series, allow_none=True)
    dLbls = Typed(expected_type=DataLabelList, allow_none=True)
    dataLabels = Alias("dLbls")

    _series_type = "pie"

    __elements__ = ('varyColors', 'ser', 'dLbls')

    def __init__(self,
                 varyColors=True,
                 ser=(),
                 dLbls=None,
                ):
        self.varyColors = varyColors
        self.ser = ser
        self.dLbls = dLbls
        super().__init__()



class PieChart(_PieChartBase):

    tagname = "pieChart"

    varyColors = _PieChartBase.varyColors
    ser = _PieChartBase.ser
    dLbls = _PieChartBase.dLbls

    firstSliceAng = NestedMinMax(min=0, max=360)
    extLst = Typed(expected_type=ExtensionList, allow_none=True)

    __elements__ = _PieChartBase.__elements__ + ('firstSliceAng', )

    def __init__(self,
                 firstSliceAng=0,
                 extLst=None,
                 **kw
                ):
        self.firstSliceAng = firstSliceAng
        super().__init__(**kw)


class PieChart3D(_PieChartBase):

    tagname = "pie3DChart"

    varyColors = _PieChartBase.varyColors
    ser = _PieChartBase.ser
    dLbls = _PieChartBase.dLbls

    extLst = Typed(expected_type=ExtensionList, allow_none=True)

    __elements__ = _PieChartBase.__elements__


class DoughnutChart(_PieChartBase):

    tagname = "doughnutChart"

    varyColors = _PieChartBase.varyColors
    ser = _PieChartBase.ser
    dLbls = _PieChartBase.dLbls

    firstSliceAng = NestedMinMax(min=0, max=360)
    holeSize = NestedMinMax(min=1, max=90, allow_none=True)
    extLst = Typed(expected_type=ExtensionList, allow_none=True)

    __elements__ = _PieChartBase.__elements__ + ('firstSliceAng', 'holeSize')

    def __init__(self,
                 firstSliceAng=0,
                 holeSize=10,
                 extLst=None,
                 **kw
                ):
        self.firstSliceAng = firstSliceAng
        self.holeSize = holeSize
        super().__init__(**kw)


class CustomSplit(Serialisable):

    tagname = "custSplit"

    secondPiePt = ValueSequence(expected_type=int)

    __elements__ = ('secondPiePt',)

    def __init__(self,
                 secondPiePt=(),
                ):
        self.secondPiePt = secondPiePt


class ProjectedPieChart(_PieChartBase):

    """
    From the spec 21.2.2.126

    This element contains the pie of pie or bar of pie series on this
    chart. Only the first series shall be displayed. The splitType element
    shall determine whether the splitPos and custSplit elements apply.
    """

    tagname = "ofPieChart"

    varyColors = _PieChartBase.varyColors
    ser = _PieChartBase.ser
    dLbls = _PieChartBase.dLbls

    ofPieType = NestedSet(values=(['pie', 'bar']))
    type = Alias('ofPieType')
    gapWidth = NestedGapAmount()
    splitType = NestedNoneSet(values=(['auto', 'cust', 'percent', 'pos', 'val']))
    splitPos = NestedFloat(allow_none=True)
    custSplit = Typed(expected_type=CustomSplit, allow_none=True)
    secondPieSize = NestedMinMax(min=5, max=200, allow_none=True)
    serLines = Typed(expected_type=ChartLines, allow_none=True)
    join_lines = Alias('serLines')
    extLst = Typed(expected_type=ExtensionList, allow_none=True)

    __elements__ = _PieChartBase.__elements__ + ('ofPieType', 'gapWidth',
                                                 'splitType', 'splitPos', 'custSplit', 'secondPieSize', 'serLines')

    def __init__(self,
                 ofPieType="pie",
                 gapWidth=None,
                 splitType="auto",
                 splitPos=None,
                 custSplit=None,
                 secondPieSize=75,
                 serLines=None,
                 extLst=None,
                 **kw
                ):
        self.ofPieType = ofPieType
        self.gapWidth = gapWidth
        self.splitType = splitType
        self.splitPos = splitPos
        self.custSplit = custSplit
        self.secondPieSize = secondPieSize
        if serLines is None:
            self.serLines = ChartLines()
        super().__init__(**kw)

```

---

### File: `tmp\openpyxl_sdist\openpyxl-3.1.5\openpyxl\chart\pivot.py`

```python

# Copyright (c) 2010-2024 openpyxl

from openpyxl.descriptors.serialisable import Serialisable
from openpyxl.descriptors import (
    Alias,
    Typed,
)
from openpyxl.descriptors.nested import NestedInteger, NestedText
from openpyxl.descriptors.excel import ExtensionList

from .label import DataLabel
from .marker import Marker
from .shapes import GraphicalProperties
from .text import RichText


class PivotSource(Serialisable):

    tagname = "pivotSource"

    name = NestedText(expected_type=str)
    fmtId = NestedInteger(expected_type=int)
    extLst = Typed(expected_type=ExtensionList, allow_none=True)

    __elements__ = ('name', 'fmtId')

    def __init__(self,
                 name=None,
                 fmtId=None,
                 extLst=None,
                ):
        self.name = name
        self.fmtId = fmtId


class PivotFormat(Serialisable):

    tagname = "pivotFmt"

    idx = NestedInteger(nested=True)
    spPr = Typed(expected_type=GraphicalProperties, allow_none=True)
    graphicalProperties = Alias("spPr")
    txPr = Typed(expected_type=RichText, allow_none=True)
    TextBody = Alias("txPr")
    marker = Typed(expected_type=Marker, allow_none=True)
    dLbl = Typed(expected_type=DataLabel, allow_none=True)
    DataLabel = Alias("dLbl")
    extLst = Typed(expected_type=ExtensionList, allow_none=True)

    __elements__ = ('idx', 'spPr', 'txPr', 'marker', 'dLbl')

    def __init__(self,
                 idx=0,
                 spPr=None,
                 txPr=None,
                 marker=None,
                 dLbl=None,
                 extLst=None,
                ):
        self.idx = idx
        self.spPr = spPr
        self.txPr = txPr
        self.marker = marker
        self.dLbl = dLbl

```

---

### File: `tmp\openpyxl_sdist\openpyxl-3.1.5\openpyxl\chart\plotarea.py`

```python
# Copyright (c) 2010-2024 openpyxl

from openpyxl.descriptors.serialisable import Serialisable
from openpyxl.descriptors import (
    Typed,
    Alias,
)
from openpyxl.descriptors.excel import (
    ExtensionList,
)
from openpyxl.descriptors.sequence import (
    MultiSequence,
    MultiSequencePart,
)
from openpyxl.descriptors.nested import (
    NestedBool,
)

from ._3d import _3DBase
from .area_chart import AreaChart, AreaChart3D
from .bar_chart import BarChart, BarChart3D
from .bubble_chart import BubbleChart
from .line_chart import LineChart, LineChart3D
from .pie_chart import PieChart, PieChart3D, ProjectedPieChart, DoughnutChart
from .radar_chart import RadarChart
from .scatter_chart import ScatterChart
from .stock_chart import StockChart
from .surface_chart import SurfaceChart, SurfaceChart3D
from .layout import Layout
from .shapes import GraphicalProperties
from .text import RichText

from .axis import (
    NumericAxis,
    TextAxis,
    SeriesAxis,
    DateAxis,
)


class DataTable(Serialisable):

    tagname = "dTable"

    showHorzBorder = NestedBool(allow_none=True)
    showVertBorder = NestedBool(allow_none=True)
    showOutline = NestedBool(allow_none=True)
    showKeys = NestedBool(allow_none=True)
    spPr = Typed(expected_type=GraphicalProperties, allow_none=True)
    graphicalProperties = Alias('spPr')
    txPr = Typed(expected_type=RichText, allow_none=True)
    extLst = Typed(expected_type=ExtensionList, allow_none=True)

    __elements__ = ('showHorzBorder', 'showVertBorder', 'showOutline',
                    'showKeys', 'spPr', 'txPr')

    def __init__(self,
                 showHorzBorder=None,
                 showVertBorder=None,
                 showOutline=None,
                 showKeys=None,
                 spPr=None,
                 txPr=None,
                 extLst=None,
                ):
        self.showHorzBorder = showHorzBorder
        self.showVertBorder = showVertBorder
        self.showOutline = showOutline
        self.showKeys = showKeys
        self.spPr = spPr
        self.txPr = txPr


class PlotArea(Serialisable):

    tagname = "plotArea"

    layout = Typed(expected_type=Layout, allow_none=True)
    dTable = Typed(expected_type=DataTable, allow_none=True)
    spPr = Typed(expected_type=GraphicalProperties, allow_none=True)
    graphicalProperties = Alias("spPr")
    extLst = Typed(expected_type=ExtensionList, allow_none=True)

    # at least one chart
    _charts = MultiSequence()
    areaChart = MultiSequencePart(expected_type=AreaChart, store="_charts")
    area3DChart = MultiSequencePart(expected_type=AreaChart3D, store="_charts")
    lineChart = MultiSequencePart(expected_type=LineChart, store="_charts")
    line3DChart = MultiSequencePart(expected_type=LineChart3D, store="_charts")
    stockChart = MultiSequencePart(expected_type=StockChart, store="_charts")
    radarChart = MultiSequencePart(expected_type=RadarChart, store="_charts")
    scatterChart = MultiSequencePart(expected_type=ScatterChart, store="_charts")
    pieChart = MultiSequencePart(expected_type=PieChart, store="_charts")
    pie3DChart = MultiSequencePart(expected_type=PieChart3D, store="_charts")
    doughnutChart = MultiSequencePart(expected_type=DoughnutChart, store="_charts")
    barChart = MultiSequencePart(expected_type=BarChart, store="_charts")
    bar3DChart = MultiSequencePart(expected_type=BarChart3D, store="_charts")
    ofPieChart = MultiSequencePart(expected_type=ProjectedPieChart, store="_charts")
    surfaceChart = MultiSequencePart(expected_type=SurfaceChart, store="_charts")
    surface3DChart = MultiSequencePart(expected_type=SurfaceChart3D, store="_charts")
    bubbleChart = MultiSequencePart(expected_type=BubbleChart, store="_charts")

    # axes
    _axes = MultiSequence()
    valAx = MultiSequencePart(expected_type=NumericAxis, store="_axes")
    catAx = MultiSequencePart(expected_type=TextAxis, store="_axes")
    dateAx = MultiSequencePart(expected_type=DateAxis, store="_axes")
    serAx = MultiSequencePart(expected_type=SeriesAxis, store="_axes")

    __elements__ = ('layout', '_charts', '_axes', 'dTable', 'spPr')

    def __init__(self,
                 layout=None,
                 dTable=None,
                 spPr=None,
                 _charts=(),
                 _axes=(),
                 extLst=None,
                ):
        self.layout = layout
        self.dTable = dTable
        self.spPr = spPr
        self._charts = _charts
        self._axes = _axes


    def to_tree(self, tagname=None, idx=None, namespace=None):
        axIds = {ax.axId for ax in self._axes}
        for chart in self._charts:
            for id, axis in chart._axes.items():
                if id not in axIds:
                    setattr(self, axis.tagname, axis)
                    axIds.add(id)

        return super().to_tree(tagname)


    @classmethod
    def from_tree(cls, node):
        self = super().from_tree(node)
        axes = dict((axis.axId, axis) for axis in self._axes)
        for chart in self._charts:
            if isinstance(chart, (ScatterChart, BubbleChart)):
                x, y = (axes[axId] for axId in chart.axId)
                chart.x_axis = x
                chart.y_axis = y
                continue

            for axId in chart.axId:
                axis = axes.get(axId)
                if axis is None and isinstance(chart, _3DBase):
                    # Series Axis can be optional
                    chart.z_axis = None
                    continue
                if axis.tagname in ("catAx", "dateAx"):
                    chart.x_axis = axis
                elif axis.tagname == "valAx":
                    chart.y_axis = axis
                elif axis.tagname == "serAx":
                    chart.z_axis = axis

        return self

```

---

### File: `tmp\openpyxl_sdist\openpyxl-3.1.5\openpyxl\chart\print_settings.py`

```python
# Copyright (c) 2010-2024 openpyxl

from openpyxl.descriptors.serialisable import Serialisable
from openpyxl.descriptors import (
    Float,
    Typed,
    Alias,
)

from openpyxl.worksheet.page import PrintPageSetup
from openpyxl.worksheet.header_footer import HeaderFooter


class PageMargins(Serialisable):
    """
    Identical to openpyxl.worksheet.page.Pagemargins but element names are different :-/
    """
    tagname = "pageMargins"

    l = Float()
    left = Alias('l')
    r = Float()
    right = Alias('r')
    t = Float()
    top = Alias('t')
    b = Float()
    bottom = Alias('b')
    header = Float()
    footer = Float()

    def __init__(self, l=0.75, r=0.75, t=1, b=1, header=0.5, footer=0.5):
        self.l = l
        self.r = r
        self.t = t
        self.b = b
        self.header = header
        self.footer = footer


class PrintSettings(Serialisable):

    tagname = "printSettings"

    headerFooter = Typed(expected_type=HeaderFooter, allow_none=True)
    pageMargins = Typed(expected_type=PageMargins, allow_none=True)
    pageSetup = Typed(expected_type=PrintPageSetup, allow_none=True)

    __elements__ = ("headerFooter", "pageMargins", "pageMargins")

    def __init__(self,
                 headerFooter=None,
                 pageMargins=None,
                 pageSetup=None,
                ):
        self.headerFooter = headerFooter
        self.pageMargins = pageMargins
        self.pageSetup = pageSetup

```

---

### File: `tmp\openpyxl_sdist\openpyxl-3.1.5\openpyxl\chart\radar_chart.py`

```python
# Copyright (c) 2010-2024 openpyxl

from openpyxl.descriptors.serialisable import Serialisable
from openpyxl.descriptors import (
    Sequence,
    Typed,
    Alias,
)
from openpyxl.descriptors.excel import ExtensionList
from openpyxl.descriptors.nested import (
    NestedBool,
    NestedInteger,
    NestedSet
)

from ._chart import ChartBase
from .axis import TextAxis, NumericAxis
from .series import Series
from .label import DataLabelList


class RadarChart(ChartBase):

    tagname = "radarChart"

    radarStyle = NestedSet(values=(['standard', 'marker', 'filled']))
    type = Alias("radarStyle")
    varyColors = NestedBool(nested=True, allow_none=True)
    ser = Sequence(expected_type=Series, allow_none=True)
    dLbls = Typed(expected_type=DataLabelList, allow_none=True)
    dataLabels = Alias("dLbls")
    extLst = Typed(expected_type=ExtensionList, allow_none=True)

    _series_type = "radar"

    x_axis = Typed(expected_type=TextAxis)
    y_axis = Typed(expected_type=NumericAxis)

    __elements__ = ('radarStyle', 'varyColors', 'ser', 'dLbls', 'axId')

    def __init__(self,
                 radarStyle="standard",
                 varyColors=None,
                 ser=(),
                 dLbls=None,
                 extLst=None,
                 **kw
                ):
        self.radarStyle = radarStyle
        self.varyColors = varyColors
        self.ser = ser
        self.dLbls = dLbls
        self.x_axis = TextAxis()
        self.y_axis = NumericAxis()
        super().__init__(**kw)

```

---

### File: `tmp\openpyxl_sdist\openpyxl-3.1.5\openpyxl\chart\reader.py`

```python
# Copyright (c) 2010-2024 openpyxl

"""
Read a chart
"""

def read_chart(chartspace):
    cs = chartspace
    plot = cs.chart.plotArea

    chart = plot._charts[0]
    chart._charts = plot._charts

    chart.title = cs.chart.title
    chart.display_blanks = cs.chart.dispBlanksAs
    chart.visible_cells_only = cs.chart.plotVisOnly
    chart.layout = plot.layout
    chart.legend = cs.chart.legend

    # 3d attributes
    chart.floor = cs.chart.floor
    chart.sideWall = cs.chart.sideWall
    chart.backWall = cs.chart.backWall
    chart.pivotSource = cs.pivotSource
    chart.pivotFormats = cs.chart.pivotFmts
    chart.idx_base = min((s.idx for s in chart.series), default=0)
    chart._reindex()

    # Border, fill, etc.
    chart.graphical_properties = cs.graphical_properties

    return chart

```

---

### File: `tmp\openpyxl_sdist\openpyxl-3.1.5\openpyxl\chart\reference.py`

```python
# Copyright (c) 2010-2024 openpyxl

from itertools import chain

from openpyxl.descriptors.serialisable import Serialisable
from openpyxl.descriptors import (
    MinMax,
    Typed,
    String,
    Strict,
)
from openpyxl.worksheet.worksheet import Worksheet
from openpyxl.utils import (
    get_column_letter,
    range_to_tuple,
    quote_sheetname
)


class DummyWorksheet:


    def __init__(self, title):
        self.title = title


class Reference(Strict):

    """
    Normalise cell range references
    """

    min_row = MinMax(min=1, max=1000000, expected_type=int)
    max_row = MinMax(min=1, max=1000000, expected_type=int)
    min_col = MinMax(min=1, max=16384, expected_type=int)
    max_col = MinMax(min=1, max=16384, expected_type=int)
    range_string = String(allow_none=True)

    def __init__(self,
                 worksheet=None,
                 min_col=None,
                 min_row=None,
                 max_col=None,
                 max_row=None,
                 range_string=None
                 ):
        if range_string is not None:
            sheetname, boundaries = range_to_tuple(range_string)
            min_col, min_row, max_col, max_row = boundaries
            worksheet = DummyWorksheet(sheetname)

        self.worksheet = worksheet
        self.min_col = min_col
        self.min_row = min_row
        if max_col is None:
            max_col = min_col
        self.max_col = max_col
        if max_row is None:
            max_row = min_row
        self.max_row = max_row


    def __repr__(self):
        return str(self)


    def __str__(self):
        fmt = u"{0}!${1}${2}:${3}${4}"
        if (self.min_col == self.max_col
            and self.min_row == self.max_row):
            fmt = u"{0}!${1}${2}"
        return fmt.format(self.sheetname,
                          get_column_letter(self.min_col), self.min_row,
                          get_column_letter(self.max_col), self.max_row
                          )


    __str__ = __str__



    def __len__(self):
        if self.min_row == self.max_row:
            return 1 + self.max_col - self.min_col
        return 1 + self.max_row - self.min_row


    def __eq__(self, other):
        return str(self) == str(other)


    @property
    def rows(self):
        """
        Return all rows in the range
        """
        for row in range(self.min_row, self.max_row+1):
            yield Reference(self.worksheet, self.min_col, row, self.max_col, row)


    @property
    def cols(self):
        """
        Return all columns in the range
        """
        for col in range(self.min_col, self.max_col+1):
            yield Reference(self.worksheet, col, self.min_row, col, self.max_row)


    def pop(self):
        """
        Return and remove the first cell
        """
        cell = "{0}{1}".format(get_column_letter(self.min_col), self.min_row)
        if self.min_row == self.max_row:
            self.min_col += 1
        else:
            self.min_row += 1
        return cell


    @property
    def sheetname(self):
        return quote_sheetname(self.worksheet.title)

```

---

### File: `tmp\openpyxl_sdist\openpyxl-3.1.5\openpyxl\chart\scatter_chart.py`

```python
# Copyright (c) 2010-2024 openpyxl

from openpyxl.descriptors.serialisable import Serialisable
from openpyxl.descriptors import (
    Typed,
    Sequence,
    Alias
)
from openpyxl.descriptors.excel import ExtensionList
from openpyxl.descriptors.nested import (
    NestedNoneSet,
    NestedBool,
)

from ._chart import ChartBase
from .axis import NumericAxis, TextAxis
from .series import XYSeries
from .label import DataLabelList


class ScatterChart(ChartBase):

    tagname = "scatterChart"

    scatterStyle = NestedNoneSet(values=(['line', 'lineMarker', 'marker', 'smooth', 'smoothMarker']))
    varyColors = NestedBool(allow_none=True)
    ser = Sequence(expected_type=XYSeries, allow_none=True)
    dLbls = Typed(expected_type=DataLabelList, allow_none=True)
    dataLabels = Alias("dLbls")
    extLst = Typed(expected_type=ExtensionList, allow_none=True)

    x_axis = Typed(expected_type=(NumericAxis, TextAxis))
    y_axis = Typed(expected_type=NumericAxis)

    _series_type = "scatter"

    __elements__ = ('scatterStyle', 'varyColors', 'ser', 'dLbls', 'axId',)

    def __init__(self,
                 scatterStyle=None,
                 varyColors=None,
                 ser=(),
                 dLbls=None,
                 extLst=None,
                 **kw
                ):
        self.scatterStyle = scatterStyle
        self.varyColors = varyColors
        self.ser = ser
        self.dLbls = dLbls
        self.x_axis = NumericAxis(axId=10, crossAx=20)
        self.y_axis = NumericAxis(axId=20, crossAx=10)
        super().__init__(**kw)

```

---

### File: `tmp\openpyxl_sdist\openpyxl-3.1.5\openpyxl\chart\series.py`

```python
# Copyright (c) 2010-2024 openpyxl


from openpyxl.descriptors.serialisable import Serialisable
from openpyxl.descriptors import (
    Typed,
    String,
    Integer,
    Bool,
    Alias,
    Sequence,
)
from openpyxl.descriptors.excel import ExtensionList
from openpyxl.descriptors.nested import (
    NestedInteger,
    NestedBool,
    NestedNoneSet,
    NestedText,
)

from .shapes import GraphicalProperties
from .data_source import (
    AxDataSource,
    NumDataSource,
    NumRef,
    StrRef,
)
from .error_bar import ErrorBars
from .label import DataLabelList
from .marker import DataPoint, PictureOptions, Marker
from .trendline import Trendline

attribute_mapping = {
    'area': ('idx', 'order', 'tx', 'spPr', 'pictureOptions', 'dPt', 'dLbls', 'errBars',
             'trendline', 'cat', 'val',),
    'bar':('idx', 'order','tx', 'spPr', 'invertIfNegative', 'pictureOptions', 'dPt',
           'dLbls', 'trendline', 'errBars', 'cat', 'val', 'shape'),
    'bubble':('idx','order', 'tx', 'spPr', 'invertIfNegative', 'dPt', 'dLbls',
              'trendline', 'errBars', 'xVal', 'yVal', 'bubbleSize', 'bubble3D'),
    'line':('idx', 'order', 'tx', 'spPr', 'marker', 'dPt', 'dLbls', 'trendline',
            'errBars', 'cat', 'val', 'smooth'),
    'pie':('idx', 'order', 'tx', 'spPr', 'explosion', 'dPt', 'dLbls', 'cat', 'val'),
    'radar':('idx', 'order', 'tx', 'spPr', 'marker', 'dPt', 'dLbls', 'cat', 'val'),
    'scatter':('idx', 'order', 'tx', 'spPr', 'marker', 'dPt', 'dLbls', 'trendline',
               'errBars', 'xVal', 'yVal', 'smooth'),
    'surface':('idx', 'order', 'tx', 'spPr', 'cat', 'val'),
                     }


class SeriesLabel(Serialisable):

    tagname = "tx"

    strRef = Typed(expected_type=StrRef, allow_none=True)
    v = NestedText(expected_type=str, allow_none=True)
    value = Alias('v')

    __elements__ = ('strRef', 'v')

    def __init__(self,
                 strRef=None,
                 v=None):
        self.strRef = strRef
        self.v = v


class Series(Serialisable):

    """
    Generic series object. Should not be instantiated directly.
    User the chart.Series factory instead.
    """

    tagname = "ser"

    idx = NestedInteger()
    order = NestedInteger()
    tx = Typed(expected_type=SeriesLabel, allow_none=True)
    title = Alias('tx')
    spPr = Typed(expected_type=GraphicalProperties, allow_none=True)
    graphicalProperties = Alias('spPr')

    # area chart
    pictureOptions = Typed(expected_type=PictureOptions, allow_none=True)
    dPt = Sequence(expected_type=DataPoint, allow_none=True)
    data_points = Alias("dPt")
    dLbls = Typed(expected_type=DataLabelList, allow_none=True)
    labels = Alias("dLbls")
    trendline = Typed(expected_type=Trendline, allow_none=True)
    errBars = Typed(expected_type=ErrorBars, allow_none=True)
    cat = Typed(expected_type=AxDataSource, allow_none=True)
    identifiers = Alias("cat")
    val = Typed(expected_type=NumDataSource, allow_none=True)
    extLst = Typed(expected_type=ExtensionList, allow_none=True)

    #bar chart
    invertIfNegative = NestedBool(allow_none=True)
    shape = NestedNoneSet(values=(['cone', 'coneToMax', 'box', 'cylinder', 'pyramid', 'pyramidToMax']))

    #bubble chart
    xVal = Typed(expected_type=AxDataSource, allow_none=True)
    yVal = Typed(expected_type=NumDataSource, allow_none=True)
    bubbleSize = Typed(expected_type=NumDataSource, allow_none=True)
    zVal = Alias("bubbleSize")
    bubble3D = NestedBool(allow_none=True)

    #line chart
    marker = Typed(expected_type=Marker, allow_none=True)
    smooth = NestedBool(allow_none=True)

    #pie chart
    explosion = NestedInteger(allow_none=True)

    __elements__ = ()


    def __init__(self,
                 idx=0,
                 order=0,
                 tx=None,
                 spPr=None,
                 pictureOptions=None,
                 dPt=(),
                 dLbls=None,
                 trendline=None,
                 errBars=None,
                 cat=None,
                 val=None,
                 invertIfNegative=None,
                 shape=None,
                 xVal=None,
                 yVal=None,
                 bubbleSize=None,
                 bubble3D=None,
                 marker=None,
                 smooth=None,
                 explosion=None,
                 extLst=None,
                ):
        self.idx = idx
        self.order = order
        self.tx = tx
        if spPr is None:
            spPr = GraphicalProperties()
        self.spPr = spPr
        self.pictureOptions = pictureOptions
        self.dPt = dPt
        self.dLbls = dLbls
        self.trendline = trendline
        self.errBars = errBars
        self.cat = cat
        self.val = val
        self.invertIfNegative = invertIfNegative
        self.shape = shape
        self.xVal = xVal
        self.yVal = yVal
        self.bubbleSize = bubbleSize
        self.bubble3D = bubble3D
        if marker is None:
            marker = Marker()
        self.marker = marker
        self.smooth = smooth
        self.explosion = explosion


    def to_tree(self, tagname=None, idx=None):
        """The index can need rebasing"""
        if idx is not None:
            if self.order == self.idx:
                self.order = idx # rebase the order if the index has been rebased
            self.idx = idx
        return super().to_tree(tagname)


class XYSeries(Series):

    """Dedicated series for charts that have x and y series"""

    idx = Series.idx
    order = Series.order
    tx = Series.tx
    spPr = Series.spPr

    dPt = Series.dPt
    dLbls = Series.dLbls
    trendline = Series.trendline
    errBars = Series.errBars
    xVal = Series.xVal
    yVal = Series.yVal

    invertIfNegative = Series.invertIfNegative

    bubbleSize = Series.bubbleSize
    bubble3D = Series.bubble3D

    marker = Series.marker
    smooth = Series.smooth

```

---

### File: `tmp\openpyxl_sdist\openpyxl-3.1.5\openpyxl\chart\series_factory.py`

```python
# Copyright (c) 2010-2024 openpyxl

from .data_source import NumDataSource, NumRef, AxDataSource
from .reference import Reference
from .series import Series, XYSeries, SeriesLabel, StrRef
from  openpyxl.utils import rows_from_range, quote_sheetname


def SeriesFactory(values, xvalues=None, zvalues=None, title=None, title_from_data=False):
    """
    Convenience Factory for creating chart data series.
    """

    if not isinstance(values, Reference):
        values = Reference(range_string=values)

    if title_from_data:
        cell = values.pop()
        title = u"{0}!{1}".format(values.sheetname, cell)
        title = SeriesLabel(strRef=StrRef(title))
    elif title is not None:
        title = SeriesLabel(v=title)

    source = NumDataSource(numRef=NumRef(f=values))
    if xvalues is not None:
        if not isinstance(xvalues, Reference):
            xvalues = Reference(range_string=xvalues)
        series = XYSeries()
        series.yVal = source
        series.xVal = AxDataSource(numRef=NumRef(f=xvalues))
        if zvalues is not None:
            if not isinstance(zvalues, Reference):
                zvalues = Reference(range_string=zvalues)
            series.zVal = NumDataSource(NumRef(f=zvalues))
    else:
        series = Series()
        series.val = source

    if title is not None:
        series.title = title
    return series

```

---

### File: `tmp\openpyxl_sdist\openpyxl-3.1.5\openpyxl\chart\shapes.py`

```python
# Copyright (c) 2010-2024 openpyxl

from openpyxl.descriptors.serialisable import Serialisable
from openpyxl.descriptors import (
    Typed,
    Alias
)
from openpyxl.descriptors.nested import (
    EmptyTag
)
from openpyxl.drawing.colors import ColorChoiceDescriptor
from openpyxl.drawing.fill import *
from openpyxl.drawing.line import LineProperties
from openpyxl.drawing.geometry import (
    Shape3D,
    Scene3D,
    Transform2D,
    CustomGeometry2D,
    PresetGeometry2D,
)


class GraphicalProperties(Serialisable):

    """
    Somewhat vaguely 21.2.2.197 says this:

    This element specifies the formatting for the parent chart element. The
    custGeom, prstGeom, scene3d, and xfrm elements are not supported. The
    bwMode attribute is not supported.

    This doesn't leave much. And the element is used in different places.
    """

    tagname = "spPr"

    bwMode = NoneSet(values=(['clr', 'auto', 'gray', 'ltGray', 'invGray',
                          'grayWhite', 'blackGray', 'blackWhite', 'black', 'white', 'hidden']
                         )
                 )

    xfrm = Typed(expected_type=Transform2D, allow_none=True)
    transform = Alias('xfrm')
    custGeom = Typed(expected_type=CustomGeometry2D, allow_none=True) # either or
    prstGeom = Typed(expected_type=PresetGeometry2D, allow_none=True)

    # fills one of
    noFill = EmptyTag(namespace=DRAWING_NS)
    solidFill = ColorChoiceDescriptor()
    gradFill = Typed(expected_type=GradientFillProperties, allow_none=True)
    pattFill = Typed(expected_type=PatternFillProperties, allow_none=True)

    ln = Typed(expected_type=LineProperties, allow_none=True)
    line = Alias('ln')
    scene3d = Typed(expected_type=Scene3D, allow_none=True)
    sp3d = Typed(expected_type=Shape3D, allow_none=True)
    shape3D = Alias('sp3d')
    extLst = Typed(expected_type=OfficeArtExtensionList, allow_none=True)

    __elements__ = ('xfrm', 'prstGeom', 'noFill', 'solidFill', 'gradFill', 'pattFill',
                    'ln', 'scene3d', 'sp3d')

    def __init__(self,
                 bwMode=None,
                 xfrm=None,
                 noFill=None,
                 solidFill=None,
                 gradFill=None,
                 pattFill=None,
                 ln=None,
                 scene3d=None,
                 custGeom=None,
                 prstGeom=None,
                 sp3d=None,
                 extLst=None,
                ):
        self.bwMode = bwMode
        self.xfrm = xfrm
        self.noFill = noFill
        self.solidFill = solidFill
        self.gradFill = gradFill
        self.pattFill = pattFill
        if ln is None:
            ln = LineProperties()
        self.ln = ln
        self.custGeom = custGeom
        self.prstGeom = prstGeom
        self.scene3d = scene3d
        self.sp3d = sp3d

```

---

### File: `tmp\openpyxl_sdist\openpyxl-3.1.5\openpyxl\chart\stock_chart.py`

```python
# Copyright (c) 2010-2024 openpyxl

from openpyxl.descriptors.serialisable import Serialisable
from openpyxl.descriptors import (
    Typed,
    Sequence,
    Alias,
)
from openpyxl.descriptors.excel import ExtensionList

from ._chart import ChartBase
from .axis import TextAxis, NumericAxis, ChartLines
from .updown_bars import UpDownBars
from .label import DataLabelList
from .series import Series


class StockChart(ChartBase):

    tagname = "stockChart"

    ser = Sequence(expected_type=Series) #min 3, max4
    dLbls = Typed(expected_type=DataLabelList, allow_none=True)
    dataLabels = Alias('dLbls')
    dropLines = Typed(expected_type=ChartLines, allow_none=True)
    hiLowLines = Typed(expected_type=ChartLines, allow_none=True)
    upDownBars = Typed(expected_type=UpDownBars, allow_none=True)
    extLst = Typed(expected_type=ExtensionList, allow_none=True)

    x_axis = Typed(expected_type=TextAxis)
    y_axis = Typed(expected_type=NumericAxis)

    _series_type = "line"

    __elements__ = ('ser', 'dLbls', 'dropLines', 'hiLowLines', 'upDownBars',
                    'axId')

    def __init__(self,
                 ser=(),
                 dLbls=None,
                 dropLines=None,
                 hiLowLines=None,
                 upDownBars=None,
                 extLst=None,
                 **kw
                ):
        self.ser = ser
        self.dLbls = dLbls
        self.dropLines = dropLines
        self.hiLowLines = hiLowLines
        self.upDownBars = upDownBars
        self.x_axis = TextAxis()
        self.y_axis = NumericAxis()
        super().__init__(**kw)

```

---

### File: `tmp\openpyxl_sdist\openpyxl-3.1.5\openpyxl\chart\surface_chart.py`

```python
# Copyright (c) 2010-2024 openpyxl

from openpyxl.descriptors.serialisable import Serialisable
from openpyxl.descriptors import (
    Typed,
    Integer,
    Bool,
    Alias,
    Sequence,
)
from openpyxl.descriptors.excel import ExtensionList
from openpyxl.descriptors.nested import (
    NestedInteger,
    NestedBool,
)

from ._chart import ChartBase
from ._3d import _3DBase
from .axis import TextAxis, NumericAxis, SeriesAxis
from .shapes import GraphicalProperties
from .series import Series


class BandFormat(Serialisable):

    tagname = "bandFmt"

    idx = NestedInteger()
    spPr = Typed(expected_type=GraphicalProperties, allow_none=True)
    graphicalProperties = Alias("spPr")

    __elements__ = ('idx', 'spPr')

    def __init__(self,
                 idx=0,
                 spPr=None,
                ):
        self.idx = idx
        self.spPr = spPr


class BandFormatList(Serialisable):

    tagname = "bandFmts"

    bandFmt = Sequence(expected_type=BandFormat, allow_none=True)

    __elements__ = ('bandFmt',)

    def __init__(self,
                 bandFmt=(),
                ):
        self.bandFmt = bandFmt


class _SurfaceChartBase(ChartBase):

    wireframe = NestedBool(allow_none=True)
    ser = Sequence(expected_type=Series, allow_none=True)
    bandFmts = Typed(expected_type=BandFormatList, allow_none=True)

    _series_type = "surface"

    __elements__ = ('wireframe', 'ser', 'bandFmts')

    def __init__(self,
                 wireframe=None,
                 ser=(),
                 bandFmts=None,
                 **kw
                ):
        self.wireframe = wireframe
        self.ser = ser
        self.bandFmts = bandFmts
        super().__init__(**kw)


class SurfaceChart3D(_SurfaceChartBase, _3DBase):

    tagname = "surface3DChart"

    wireframe = _SurfaceChartBase.wireframe
    ser = _SurfaceChartBase.ser
    bandFmts = _SurfaceChartBase.bandFmts

    extLst = Typed(expected_type=ExtensionList, allow_none=True)

    x_axis = Typed(expected_type=TextAxis)
    y_axis = Typed(expected_type=NumericAxis)
    z_axis = Typed(expected_type=SeriesAxis)

    __elements__ = _SurfaceChartBase.__elements__ + ('axId',)

    def __init__(self, **kw):
        self.x_axis = TextAxis()
        self.y_axis = NumericAxis()
        self.z_axis = SeriesAxis()
        super(SurfaceChart3D, self).__init__(**kw)


class SurfaceChart(SurfaceChart3D):

    tagname = "surfaceChart"

    wireframe = _SurfaceChartBase.wireframe
    ser = _SurfaceChartBase.ser
    bandFmts = _SurfaceChartBase.bandFmts

    extLst = Typed(expected_type=ExtensionList, allow_none=True)

    __elements__ = SurfaceChart3D.__elements__

    def __init__(self, **kw):
        super().__init__(**kw)
        self.y_axis.delete = True
        self.view3D.x_rotation = 90
        self.view3D.y_rotation = 0
        self.view3D.perspective = False
        self.view3D.right_angle_axes = False

```

---

### File: `tmp\openpyxl_sdist\openpyxl-3.1.5\openpyxl\chart\text.py`

```python
# Copyright (c) 2010-2024 openpyxl
from openpyxl.descriptors.serialisable import Serialisable
from openpyxl.descriptors import (
    Typed,
    Alias,
    Sequence,
)


from openpyxl.drawing.text import (
    RichTextProperties,
    ListStyle,
    Paragraph,
)

from .data_source import StrRef


class RichText(Serialisable):

    """
    From the specification: 21.2.2.216

    This element specifies text formatting. The lstStyle element is not supported.
    """

    tagname = "rich"

    bodyPr = Typed(expected_type=RichTextProperties)
    properties = Alias("bodyPr")
    lstStyle = Typed(expected_type=ListStyle, allow_none=True)
    p = Sequence(expected_type=Paragraph)
    paragraphs = Alias('p')

    __elements__ = ("bodyPr", "lstStyle", "p")

    def __init__(self,
                 bodyPr=None,
                 lstStyle=None,
                 p=None,
                ):
        if bodyPr is None:
            bodyPr = RichTextProperties()
        self.bodyPr = bodyPr
        self.lstStyle = lstStyle
        if p is None:
            p = [Paragraph()]
        self.p = p


class Text(Serialisable):

    """
    The value can be either a cell reference or a text element
    If both are present then the reference will be used.
    """

    tagname = "tx"

    strRef = Typed(expected_type=StrRef, allow_none=True)
    rich = Typed(expected_type=RichText, allow_none=True)

    __elements__ = ("strRef", "rich")

    def __init__(self,
                 strRef=None,
                 rich=None
                 ):
        self.strRef = strRef
        if rich is None:
            rich = RichText()
        self.rich = rich


    def to_tree(self, tagname=None, idx=None, namespace=None):
        if self.strRef and self.rich:
            self.rich = None # can only have one
        return super().to_tree(tagname, idx, namespace)

```

---

### File: `tmp\openpyxl_sdist\openpyxl-3.1.5\openpyxl\chart\title.py`

```python
# Copyright (c) 2010-2024 openpyxl

from openpyxl.descriptors.serialisable import Serialisable
from openpyxl.descriptors import (
    Typed,
    Alias,
)

from openpyxl.descriptors.excel import ExtensionList
from openpyxl.descriptors.nested import NestedBool

from .text import Text, RichText
from .layout import Layout
from .shapes import GraphicalProperties

from openpyxl.drawing.text import (
    Paragraph,
    RegularTextRun,
    LineBreak,
    ParagraphProperties,
    CharacterProperties,
)


class Title(Serialisable):
    tagname = "title"

    tx = Typed(expected_type=Text, allow_none=True)
    text = Alias('tx')
    layout = Typed(expected_type=Layout, allow_none=True)
    overlay = NestedBool(allow_none=True)
    spPr = Typed(expected_type=GraphicalProperties, allow_none=True)
    graphicalProperties = Alias('spPr')
    txPr = Typed(expected_type=RichText, allow_none=True)
    body = Alias('txPr')
    extLst = Typed(expected_type=ExtensionList, allow_none=True)

    __elements__ = ('tx', 'layout', 'overlay', 'spPr', 'txPr')

    def __init__(self,
                 tx=None,
                 layout=None,
                 overlay=None,
                 spPr=None,
                 txPr=None,
                 extLst=None,
                ):
        if tx is None:
            tx = Text()
        self.tx = tx
        self.layout = layout
        self.overlay = overlay
        self.spPr = spPr
        self.txPr = txPr



def title_maker(text):
    title = Title()
    paraprops = ParagraphProperties()
    paraprops.defRPr = CharacterProperties()
    paras = [Paragraph(r=[RegularTextRun(t=s)], pPr=paraprops) for s in text.split("\n")]

    title.tx.rich.paragraphs = paras
    return title


class TitleDescriptor(Typed):

    expected_type = Title
    allow_none = True

    def __set__(self, instance, value):
        if isinstance(value, str):
            value = title_maker(value)
        super().__set__(instance, value)

```

---

### File: `tmp\openpyxl_sdist\openpyxl-3.1.5\openpyxl\chart\trendline.py`

```python
# Copyright (c) 2010-2024 openpyxl

from openpyxl.descriptors.serialisable import Serialisable
from openpyxl.descriptors import (
    Typed,
    String,
    Alias
)
from openpyxl.descriptors.excel import ExtensionList
from openpyxl.descriptors.nested import (
    NestedBool,
    NestedInteger,
    NestedFloat,
    NestedSet
)

from .data_source import NumFmt
from .shapes import GraphicalProperties
from .text import RichText, Text
from .layout import Layout


class TrendlineLabel(Serialisable):

    tagname = "trendlineLbl"

    layout = Typed(expected_type=Layout, allow_none=True)
    tx = Typed(expected_type=Text, allow_none=True)
    numFmt = Typed(expected_type=NumFmt, allow_none=True)
    spPr = Typed(expected_type=GraphicalProperties, allow_none=True)
    graphicalProperties = Alias("spPr")
    txPr = Typed(expected_type=RichText, allow_none=True)
    textProperties = Alias("txPr")
    extLst = Typed(expected_type=ExtensionList, allow_none=True)

    __elements__ = ('layout', 'tx', 'numFmt', 'spPr', 'txPr')

    def __init__(self,
                 layout=None,
                 tx=None,
                 numFmt=None,
                 spPr=None,
                 txPr=None,
                 extLst=None,
                ):
        self.layout = layout
        self.tx = tx
        self.numFmt = numFmt
        self.spPr = spPr
        self.txPr = txPr


class Trendline(Serialisable):

    tagname = "trendline"

    name = String(allow_none=True)
    spPr = Typed(expected_type=GraphicalProperties, allow_none=True)
    graphicalProperties = Alias('spPr')
    trendlineType = NestedSet(values=(['exp', 'linear', 'log', 'movingAvg', 'poly', 'power']))
    order = NestedInteger(allow_none=True)
    period = NestedInteger(allow_none=True)
    forward = NestedFloat(allow_none=True)
    backward = NestedFloat(allow_none=True)
    intercept = NestedFloat(allow_none=True)
    dispRSqr = NestedBool(allow_none=True)
    dispEq = NestedBool(allow_none=True)
    trendlineLbl = Typed(expected_type=TrendlineLabel, allow_none=True)
    extLst = Typed(expected_type=ExtensionList, allow_none=True)

    __elements__ = ('spPr', 'trendlineType', 'order', 'period', 'forward',
                    'backward', 'intercept', 'dispRSqr', 'dispEq', 'trendlineLbl')

    def __init__(self,
                 name=None,
                 spPr=None,
                 trendlineType='linear',
                 order=None,
                 period=None,
                 forward=None,
                 backward=None,
                 intercept=None,
                 dispRSqr=None,
                 dispEq=None,
                 trendlineLbl=None,
                 extLst=None,
                ):
        self.name = name
        self.spPr = spPr
        self.trendlineType = trendlineType
        self.order = order
        self.period = period
        self.forward = forward
        self.backward = backward
        self.intercept = intercept
        self.dispRSqr = dispRSqr
        self.dispEq = dispEq
        self.trendlineLbl = trendlineLbl

```

---

### File: `tmp\openpyxl_sdist\openpyxl-3.1.5\openpyxl\chart\updown_bars.py`

```python
# Copyright (c) 2010-2024 openpyxl

from openpyxl.descriptors.serialisable import Serialisable
from openpyxl.descriptors import Typed
from openpyxl.descriptors.excel import ExtensionList

from .shapes import GraphicalProperties
from .axis import ChartLines
from .descriptors import NestedGapAmount


class UpDownBars(Serialisable):

    tagname = "upbars"

    gapWidth = NestedGapAmount()
    upBars = Typed(expected_type=ChartLines, allow_none=True)
    downBars = Typed(expected_type=ChartLines, allow_none=True)
    extLst = Typed(expected_type=ExtensionList, allow_none=True)

    __elements__ = ('gapWidth', 'upBars', 'downBars')

    def __init__(self,
                 gapWidth=150,
                 upBars=None,
                 downBars=None,
                 extLst=None,
                ):
        self.gapWidth = gapWidth
        self.upBars = upBars
        self.downBars = downBars

```

---

### File: `tmp\openpyxl_sdist\openpyxl-3.1.5\openpyxl\chartsheet\__init__.py`

```python
# Copyright (c) 2010-2024 openpyxl

from .chartsheet import Chartsheet

```

---

### File: `tmp\openpyxl_sdist\openpyxl-3.1.5\openpyxl\chartsheet\chartsheet.py`

```python
# Copyright (c) 2010-2024 openpyxl


from openpyxl.descriptors import Typed, Set, Alias
from openpyxl.descriptors.excel import ExtensionList
from openpyxl.descriptors.serialisable import Serialisable
from openpyxl.drawing.spreadsheet_drawing import (
    AbsoluteAnchor,
    SpreadsheetDrawing,
)
from openpyxl.worksheet.page import (
    PageMargins,
    PrintPageSetup
)
from openpyxl.worksheet.drawing import Drawing
from openpyxl.worksheet.header_footer import HeaderFooter
from openpyxl.workbook.child import _WorkbookChild
from openpyxl.xml.constants import SHEET_MAIN_NS, REL_NS

from .relation import DrawingHF, SheetBackgroundPicture
from .properties import ChartsheetProperties
from .protection import ChartsheetProtection
from .views import ChartsheetViewList
from .custom import CustomChartsheetViews
from .publish import WebPublishItems


class Chartsheet(_WorkbookChild, Serialisable):

    tagname = "chartsheet"
    _default_title = "Chart"
    _rel_type = "chartsheet"
    _path = "/xl/chartsheets/sheet{0}.xml"
    mime_type = "application/vnd.openxmlformats-officedocument.spreadsheetml.chartsheet+xml"

    sheetPr = Typed(expected_type=ChartsheetProperties, allow_none=True)
    sheetViews = Typed(expected_type=ChartsheetViewList)
    sheetProtection = Typed(expected_type=ChartsheetProtection, allow_none=True)
    customSheetViews = Typed(expected_type=CustomChartsheetViews, allow_none=True)
    pageMargins = Typed(expected_type=PageMargins, allow_none=True)
    pageSetup = Typed(expected_type=PrintPageSetup, allow_none=True)
    drawing = Typed(expected_type=Drawing, allow_none=True)
    drawingHF = Typed(expected_type=DrawingHF, allow_none=True)
    picture = Typed(expected_type=SheetBackgroundPicture, allow_none=True)
    webPublishItems = Typed(expected_type=WebPublishItems, allow_none=True)
    extLst = Typed(expected_type=ExtensionList, allow_none=True)
    sheet_state = Set(values=('visible', 'hidden', 'veryHidden'))
    headerFooter = Typed(expected_type=HeaderFooter)
    HeaderFooter = Alias('headerFooter')

    __elements__ = (
        'sheetPr', 'sheetViews', 'sheetProtection', 'customSheetViews',
        'pageMargins', 'pageSetup', 'headerFooter', 'drawing', 'drawingHF',
        'picture', 'webPublishItems')

    __attrs__ = ()

    def __init__(self,
                 sheetPr=None,
                 sheetViews=None,
                 sheetProtection=None,
                 customSheetViews=None,
                 pageMargins=None,
                 pageSetup=None,
                 headerFooter=None,
                 drawing=None,
                 drawingHF=None,
                 picture=None,
                 webPublishItems=None,
                 extLst=None,
                 parent=None,
                 title="",
                 sheet_state='visible',
                 ):
        super().__init__(parent, title)
        self._charts = []
        self.sheetPr = sheetPr
        if sheetViews is None:
            sheetViews = ChartsheetViewList()
        self.sheetViews = sheetViews
        self.sheetProtection = sheetProtection
        self.customSheetViews = customSheetViews
        self.pageMargins = pageMargins
        self.pageSetup = pageSetup
        if headerFooter is not None:
            self.headerFooter = headerFooter
        self.drawing = Drawing("rId1")
        self.drawingHF = drawingHF
        self.picture = picture
        self.webPublishItems = webPublishItems
        self.sheet_state = sheet_state


    def add_chart(self, chart):
        chart.anchor = AbsoluteAnchor()
        self._charts.append(chart)


    def to_tree(self):
        self._drawing = SpreadsheetDrawing()
        self._drawing.charts = self._charts
        tree = super().to_tree()
        if not self.headerFooter:
            el = tree.find('headerFooter')
            tree.remove(el)
        tree.set("xmlns", SHEET_MAIN_NS)
        return tree

```

---

### File: `tmp\openpyxl_sdist\openpyxl-3.1.5\openpyxl\chartsheet\custom.py`

```python
# Copyright (c) 2010-2024 openpyxl

from openpyxl.worksheet.header_footer import HeaderFooter

from openpyxl.descriptors import (
    Bool,
    Integer,
    Set,
    Typed,
    Sequence
)
from openpyxl.descriptors.excel import Guid
from openpyxl.descriptors.serialisable import Serialisable
from openpyxl.worksheet.page import (
    PageMargins,
    PrintPageSetup
)


class CustomChartsheetView(Serialisable):
    tagname = "customSheetView"

    guid = Guid()
    scale = Integer()
    state = Set(values=(['visible', 'hidden', 'veryHidden']))
    zoomToFit = Bool(allow_none=True)
    pageMargins = Typed(expected_type=PageMargins, allow_none=True)
    pageSetup = Typed(expected_type=PrintPageSetup, allow_none=True)
    headerFooter = Typed(expected_type=HeaderFooter, allow_none=True)

    __elements__ = ('pageMargins', 'pageSetup', 'headerFooter')

    def __init__(self,
                 guid=None,
                 scale=None,
                 state='visible',
                 zoomToFit=None,
                 pageMargins=None,
                 pageSetup=None,
                 headerFooter=None,
                 ):
        self.guid = guid
        self.scale = scale
        self.state = state
        self.zoomToFit = zoomToFit
        self.pageMargins = pageMargins
        self.pageSetup = pageSetup
        self.headerFooter = headerFooter


class CustomChartsheetViews(Serialisable):
    tagname = "customSheetViews"

    customSheetView = Sequence(expected_type=CustomChartsheetView, allow_none=True)

    __elements__ = ('customSheetView',)

    def __init__(self,
                 customSheetView=None,
                 ):
        self.customSheetView = customSheetView

```

---

### File: `tmp\openpyxl_sdist\openpyxl-3.1.5\openpyxl\chartsheet\properties.py`

```python
# Copyright (c) 2010-2024 openpyxl

from openpyxl.descriptors import (
    Bool,
    String,
    Typed
)
from openpyxl.descriptors.serialisable import Serialisable
from openpyxl.styles import Color


class ChartsheetProperties(Serialisable):
    tagname = "sheetPr"

    published = Bool(allow_none=True)
    codeName = String(allow_none=True)
    tabColor = Typed(expected_type=Color, allow_none=True)

    __elements__ = ('tabColor',)

    def __init__(self,
                 published=None,
                 codeName=None,
                 tabColor=None,
                 ):
        self.published = published
        self.codeName = codeName
        self.tabColor = tabColor

```

---

### File: `tmp\openpyxl_sdist\openpyxl-3.1.5\openpyxl\chartsheet\protection.py`

```python
import hashlib

from openpyxl.descriptors import (Bool, Integer, String)
from openpyxl.descriptors.excel import Base64Binary
from openpyxl.descriptors.serialisable import Serialisable

from openpyxl.worksheet.protection import (
    hash_password,
    _Protected
)


class ChartsheetProtection(Serialisable, _Protected):
    tagname = "sheetProtection"

    algorithmName = String(allow_none=True)
    hashValue = Base64Binary(allow_none=True)
    saltValue = Base64Binary(allow_none=True)
    spinCount = Integer(allow_none=True)
    content = Bool(allow_none=True)
    objects = Bool(allow_none=True)

    __attrs__ = ("content", "objects", "password", "hashValue", "spinCount", "saltValue", "algorithmName")

    def __init__(self,
                 content=None,
                 objects=None,
                 hashValue=None,
                 spinCount=None,
                 saltValue=None,
                 algorithmName=None,
                 password=None,
                 ):
        self.content = content
        self.objects = objects
        self.hashValue = hashValue
        self.spinCount = spinCount
        self.saltValue = saltValue
        self.algorithmName = algorithmName
        if password is not None:
            self.password = password

```

---

### File: `tmp\openpyxl_sdist\openpyxl-3.1.5\openpyxl\chartsheet\publish.py`

```python
# Copyright (c) 2010-2024 openpyxl

from openpyxl.descriptors import (
    Bool,
    Integer,
    String,
    Set,
    Sequence
)
from openpyxl.descriptors.serialisable import Serialisable


class WebPublishItem(Serialisable):
    tagname = "webPublishItem"

    id = Integer()
    divId = String()
    sourceType = Set(values=(['sheet', 'printArea', 'autoFilter', 'range', 'chart', 'pivotTable', 'query', 'label']))
    sourceRef = String()
    sourceObject = String(allow_none=True)
    destinationFile = String()
    title = String(allow_none=True)
    autoRepublish = Bool(allow_none=True)

    def __init__(self,
                 id=None,
                 divId=None,
                 sourceType=None,
                 sourceRef=None,
                 sourceObject=None,
                 destinationFile=None,
                 title=None,
                 autoRepublish=None,
                 ):
        self.id = id
        self.divId = divId
        self.sourceType = sourceType
        self.sourceRef = sourceRef
        self.sourceObject = sourceObject
        self.destinationFile = destinationFile
        self.title = title
        self.autoRepublish = autoRepublish


class WebPublishItems(Serialisable):
    tagname = "WebPublishItems"

    count = Integer(allow_none=True)
    webPublishItem = Sequence(expected_type=WebPublishItem, )

    __elements__ = ('webPublishItem',)

    def __init__(self,
                 count=None,
                 webPublishItem=None,
                 ):
        self.count = len(webPublishItem)
        self.webPublishItem = webPublishItem

```

---

### File: `tmp\openpyxl_sdist\openpyxl-3.1.5\openpyxl\chartsheet\relation.py`

```python
# Copyright (c) 2010-2024 openpyxl

from openpyxl.descriptors import (
    Integer,
    Alias
)
from openpyxl.descriptors.excel import Relation
from openpyxl.descriptors.serialisable import Serialisable


class SheetBackgroundPicture(Serialisable):
    tagname = "picture"
    id = Relation()

    def __init__(self, id):
        self.id = id


class DrawingHF(Serialisable):
    id = Relation()
    lho = Integer(allow_none=True)
    leftHeaderOddPages = Alias('lho')
    lhe = Integer(allow_none=True)
    leftHeaderEvenPages = Alias('lhe')
    lhf = Integer(allow_none=True)
    leftHeaderFirstPage = Alias('lhf')
    cho = Integer(allow_none=True)
    centerHeaderOddPages = Alias('cho')
    che = Integer(allow_none=True)
    centerHeaderEvenPages = Alias('che')
    chf = Integer(allow_none=True)
    centerHeaderFirstPage = Alias('chf')
    rho = Integer(allow_none=True)
    rightHeaderOddPages = Alias('rho')
    rhe = Integer(allow_none=True)
    rightHeaderEvenPages = Alias('rhe')
    rhf = Integer(allow_none=True)
    rightHeaderFirstPage = Alias('rhf')
    lfo = Integer(allow_none=True)
    leftFooterOddPages = Alias('lfo')
    lfe = Integer(allow_none=True)
    leftFooterEvenPages = Alias('lfe')
    lff = Integer(allow_none=True)
    leftFooterFirstPage = Alias('lff')
    cfo = Integer(allow_none=True)
    centerFooterOddPages = Alias('cfo')
    cfe = Integer(allow_none=True)
    centerFooterEvenPages = Alias('cfe')
    cff = Integer(allow_none=True)
    centerFooterFirstPage = Alias('cff')
    rfo = Integer(allow_none=True)
    rightFooterOddPages = Alias('rfo')
    rfe = Integer(allow_none=True)
    rightFooterEvenPages = Alias('rfe')
    rff = Integer(allow_none=True)
    rightFooterFirstPage = Alias('rff')

    def __init__(self,
                 id=None,
                 lho=None,
                 lhe=None,
                 lhf=None,
                 cho=None,
                 che=None,
                 chf=None,
                 rho=None,
                 rhe=None,
                 rhf=None,
                 lfo=None,
                 lfe=None,
                 lff=None,
                 cfo=None,
                 cfe=None,
                 cff=None,
                 rfo=None,
                 rfe=None,
                 rff=None,
                 ):
        self.id = id
        self.lho = lho
        self.lhe = lhe
        self.lhf = lhf
        self.cho = cho
        self.che = che
        self.chf = chf
        self.rho = rho
        self.rhe = rhe
        self.rhf = rhf
        self.lfo = lfo
        self.lfe = lfe
        self.lff = lff
        self.cfo = cfo
        self.cfe = cfe
        self.cff = cff
        self.rfo = rfo
        self.rfe = rfe
        self.rff = rff

```

---

### File: `tmp\openpyxl_sdist\openpyxl-3.1.5\openpyxl\chartsheet\views.py`

```python
# Copyright (c) 2010-2024 openpyxl

from openpyxl.descriptors import (
    Bool,
    Integer,
    Typed,
    Sequence
)
from openpyxl.descriptors.excel import ExtensionList
from openpyxl.descriptors.serialisable import Serialisable


class ChartsheetView(Serialisable):
    tagname = "sheetView"

    tabSelected = Bool(allow_none=True)
    zoomScale = Integer(allow_none=True)
    workbookViewId = Integer()
    zoomToFit = Bool(allow_none=True)
    extLst = Typed(expected_type=ExtensionList, allow_none=True)

    __elements__ = ()

    def __init__(self,
                 tabSelected=None,
                 zoomScale=None,
                 workbookViewId=0,
                 zoomToFit=True,
                 extLst=None,
                 ):
        self.tabSelected = tabSelected
        self.zoomScale = zoomScale
        self.workbookViewId = workbookViewId
        self.zoomToFit = zoomToFit


class ChartsheetViewList(Serialisable):
    tagname = "sheetViews"

    sheetView = Sequence(expected_type=ChartsheetView, )
    extLst = Typed(expected_type=ExtensionList, allow_none=True)

    __elements__ = ('sheetView',)

    def __init__(self,
                 sheetView=None,
                 extLst=None,
                 ):
        if sheetView is None:
            sheetView = [ChartsheetView()]
        self.sheetView = sheetView

```

---

### File: `tmp\openpyxl_sdist\openpyxl-3.1.5\openpyxl\comments\__init__.py`

```python
# Copyright (c) 2010-2024 openpyxl


from .comments import Comment

```

---

### File: `tmp\openpyxl_sdist\openpyxl-3.1.5\openpyxl\comments\author.py`

```python
# Copyright (c) 2010-2024 openpyxl


from openpyxl.descriptors.serialisable import Serialisable
from openpyxl.descriptors import (
    Sequence,
    Alias
)


class AuthorList(Serialisable):

    tagname = "authors"

    author = Sequence(expected_type=str)
    authors = Alias("author")

    def __init__(self,
                 author=(),
                ):
        self.author = author

```

---

### File: `tmp\openpyxl_sdist\openpyxl-3.1.5\openpyxl\comments\comment_sheet.py`

```python
# Copyright (c) 2010-2024 openpyxl

## Incomplete!
from openpyxl.descriptors.serialisable import Serialisable
from openpyxl.descriptors import (
    Typed,
    Integer,
    Set,
    String,
    Bool,
)
from openpyxl.descriptors.excel import Guid, ExtensionList
from openpyxl.descriptors.sequence import NestedSequence

from openpyxl.utils.indexed_list import IndexedList
from openpyxl.xml.constants import SHEET_MAIN_NS

from openpyxl.cell.text import Text
from .author import AuthorList
from .comments import Comment
from .shape_writer import ShapeWriter


class Properties(Serialisable):

    locked = Bool(allow_none=True)
    defaultSize = Bool(allow_none=True)
    _print = Bool(allow_none=True)
    disabled = Bool(allow_none=True)
    uiObject = Bool(allow_none=True)
    autoFill = Bool(allow_none=True)
    autoLine = Bool(allow_none=True)
    altText = String(allow_none=True)
    textHAlign = Set(values=(['left', 'center', 'right', 'justify', 'distributed']))
    textVAlign = Set(values=(['top', 'center', 'bottom', 'justify', 'distributed']))
    lockText = Bool(allow_none=True)
    justLastX = Bool(allow_none=True)
    autoScale = Bool(allow_none=True)
    rowHidden = Bool(allow_none=True)
    colHidden = Bool(allow_none=True)
    # anchor = Typed(expected_type=ObjectAnchor, )

    __elements__ = ('anchor',)

    def __init__(self,
                 locked=None,
                 defaultSize=None,
                 _print=None,
                 disabled=None,
                 uiObject=None,
                 autoFill=None,
                 autoLine=None,
                 altText=None,
                 textHAlign=None,
                 textVAlign=None,
                 lockText=None,
                 justLastX=None,
                 autoScale=None,
                 rowHidden=None,
                 colHidden=None,
                 anchor=None,
                ):
        self.locked = locked
        self.defaultSize = defaultSize
        self._print = _print
        self.disabled = disabled
        self.uiObject = uiObject
        self.autoFill = autoFill
        self.autoLine = autoLine
        self.altText = altText
        self.textHAlign = textHAlign
        self.textVAlign = textVAlign
        self.lockText = lockText
        self.justLastX = justLastX
        self.autoScale = autoScale
        self.rowHidden = rowHidden
        self.colHidden = colHidden
        self.anchor = anchor


class CommentRecord(Serialisable):

    tagname = "comment"

    ref = String()
    authorId = Integer()
    guid = Guid(allow_none=True)
    shapeId = Integer(allow_none=True)
    text = Typed(expected_type=Text)
    commentPr = Typed(expected_type=Properties, allow_none=True)
    author = String(allow_none=True)

    __elements__ = ('text', 'commentPr')
    __attrs__ = ('ref', 'authorId', 'guid', 'shapeId')

    def __init__(self,
                 ref="",
                 authorId=0,
                 guid=None,
                 shapeId=0,
                 text=None,
                 commentPr=None,
                 author=None,
                 height=79,
                 width=144
                ):
        self.ref = ref
        self.authorId = authorId
        self.guid = guid
        self.shapeId = shapeId
        if text is None:
            text = Text()
        self.text = text
        self.commentPr = commentPr
        self.author = author
        self.height = height
        self.width = width


    @classmethod
    def from_cell(cls, cell):
        """
        Class method to convert cell comment
        """
        comment = cell._comment
        ref = cell.coordinate
        self = cls(ref=ref, author=comment.author)
        self.text.t = comment.content
        self.height = comment.height
        self.width = comment.width
        return self


    @property
    def content(self):
        """
        Remove all inline formatting and stuff
        """
        return self.text.content


class CommentSheet(Serialisable):

    tagname = "comments"

    authors = Typed(expected_type=AuthorList)
    commentList = NestedSequence(expected_type=CommentRecord, count=0)
    extLst = Typed(expected_type=ExtensionList, allow_none=True)

    _id = None
    _path = "/xl/comments/comment{0}.xml"
    mime_type = "application/vnd.openxmlformats-officedocument.spreadsheetml.comments+xml"
    _rel_type = "comments"
    _rel_id = None

    __elements__ = ('authors', 'commentList')

    def __init__(self,
                 authors=None,
                 commentList=None,
                 extLst=None,
                ):
        self.authors = authors
        self.commentList = commentList


    def to_tree(self):
        tree = super().to_tree()
        tree.set("xmlns", SHEET_MAIN_NS)
        return tree


    @property
    def comments(self):
        """
        Return a dictionary of comments keyed by coord
        """
        authors = self.authors.author

        for c in self.commentList:
            yield c.ref, Comment(c.content, authors[c.authorId], c.height, c.width)


    @classmethod
    def from_comments(cls, comments):
        """
        Create a comment sheet from a list of comments for a particular worksheet
        """
        authors = IndexedList()

        # dedupe authors and get indexes
        for comment in comments:
            comment.authorId = authors.add(comment.author)

        return cls(authors=AuthorList(authors), commentList=comments)


    def write_shapes(self, vml=None):
        """
        Create the VML for comments
        """
        sw = ShapeWriter(self.comments)
        return sw.write(vml)


    @property
    def path(self):
        """
        Return path within the archive
        """
        return self._path.format(self._id)

```

---

### File: `tmp\openpyxl_sdist\openpyxl-3.1.5\openpyxl\comments\comments.py`

```python
# Copyright (c) 2010-2024 openpyxl


class Comment:

    _parent = None

    def __init__(self, text, author, height=79, width=144):
        self.content = text
        self.author = author
        self.height = height
        self.width = width


    @property
    def parent(self):
        return self._parent


    def __eq__(self, other):
        return (
            self.content == other.content
            and self.author == other.author
        )

    def __repr__(self):
        return "Comment: {0} by {1}".format(self.content, self.author)


    def __copy__(self):
        """Create a detached copy of this comment."""
        clone = self.__class__(self.content, self.author, self.height, self.width)
        return clone


    def bind(self, cell):
        """
        Bind comment to a particular cell
        """
        if cell is not None and self._parent is not None and self._parent != cell:
            fmt = "Comment already assigned to {0} in worksheet {1}. Cannot assign a comment to more than one cell"
            raise AttributeError(fmt.format(cell.coordinate, cell.parent.title))
        self._parent = cell


    def unbind(self):
        """
        Unbind a comment from a cell
        """
        self._parent = None


    @property
    def text(self):
        """
        Any comment text stripped of all formatting.
        """
        return self.content

    @text.setter
    def text(self, value):
        self.content = value

```

---

### File: `tmp\openpyxl_sdist\openpyxl-3.1.5\openpyxl\comments\shape_writer.py`

```python
# Copyright (c) 2010-2024 openpyxl

from openpyxl.xml.functions import (
    Element,
    SubElement,
    tostring,
)

from openpyxl.utils import coordinate_to_tuple

vmlns = "urn:schemas-microsoft-com:vml"
officens = "urn:schemas-microsoft-com:office:office"
excelns = "urn:schemas-microsoft-com:office:excel"


class ShapeWriter:
    """
    Create VML for comments
    """

    vml = None
    vml_path = None


    def __init__(self, comments):
        self.comments = comments


    def add_comment_shapetype(self, root):
        shape_layout = SubElement(root, "{%s}shapelayout" % officens,
                                  {"{%s}ext" % vmlns: "edit"})
        SubElement(shape_layout,
                   "{%s}idmap" % officens,
                   {"{%s}ext" % vmlns: "edit", "data": "1"})
        shape_type = SubElement(root,
                                "{%s}shapetype" % vmlns,
                                {"id": "_x0000_t202",
                                 "coordsize": "21600,21600",
                                 "{%s}spt" % officens: "202",
                                 "path": "m,l,21600r21600,l21600,xe"})
        SubElement(shape_type, "{%s}stroke" % vmlns, {"joinstyle": "miter"})
        SubElement(shape_type,
                   "{%s}path" % vmlns,
                   {"gradientshapeok": "t",
                    "{%s}connecttype" % officens: "rect"})


    def add_comment_shape(self, root, idx, coord, height, width):
        row, col = coordinate_to_tuple(coord)
        row -= 1
        col -= 1
        shape = _shape_factory(row, col, height, width)

        shape.set('id', "_x0000_s%04d" % idx)
        root.append(shape)


    def write(self, root):

        if not hasattr(root, "findall"):
            root = Element("xml")

        # Remove any existing comment shapes
        comments = root.findall("{%s}shape[@type='#_x0000_t202']" % vmlns)
        for c in comments:
            root.remove(c)

        # check whether comments shape type already exists
        shape_types = root.find("{%s}shapetype[@id='_x0000_t202']" % vmlns)
        if shape_types is None:
            self.add_comment_shapetype(root)

        for idx, (coord, comment) in enumerate(self.comments, 1026):
            self.add_comment_shape(root, idx, coord, comment.height, comment.width)

        return tostring(root)


def _shape_factory(row, column, height, width):
    style = ("position:absolute; "
             "margin-left:59.25pt;"
             "margin-top:1.5pt;"
             "width:{width}px;"
             "height:{height}px;"
             "z-index:1;"
             "visibility:hidden").format(height=height,
                                         width=width)
    attrs = {
        "type": "#_x0000_t202",
        "style": style,
        "fillcolor": "#ffffe1",
        "{%s}insetmode" % officens: "auto"
    }
    shape = Element("{%s}shape" % vmlns, attrs)

    SubElement(shape, "{%s}fill" % vmlns,
               {"color2": "#ffffe1"})
    SubElement(shape, "{%s}shadow" % vmlns,
               {"color": "black", "obscured": "t"})
    SubElement(shape, "{%s}path" % vmlns,
               {"{%s}connecttype" % officens: "none"})
    textbox = SubElement(shape, "{%s}textbox" % vmlns,
                         {"style": "mso-direction-alt:auto"})
    SubElement(textbox, "div", {"style": "text-align:left"})
    client_data = SubElement(shape, "{%s}ClientData" % excelns,
                             {"ObjectType": "Note"})
    SubElement(client_data, "{%s}MoveWithCells" % excelns)
    SubElement(client_data, "{%s}SizeWithCells" % excelns)
    SubElement(client_data, "{%s}AutoFill" % excelns).text = "False"
    SubElement(client_data, "{%s}Row" % excelns).text = str(row)
    SubElement(client_data, "{%s}Column" % excelns).text = str(column)
    return shape

```

---

### File: `tmp\openpyxl_sdist\openpyxl-3.1.5\openpyxl\compat\__init__.py`

```python
# Copyright (c) 2010-2024 openpyxl

from .numbers import NUMERIC_TYPES
from .strings import safe_string

import warnings
from functools import wraps
import inspect


class DummyCode:

    pass


# from https://github.com/tantale/deprecated/blob/master/deprecated/__init__.py
# with an enhancement to update docstrings of deprecated functions
string_types = (type(b''), type(u''))
def deprecated(reason):

    if isinstance(reason, string_types):

        def decorator(func1):

            if inspect.isclass(func1):
                fmt1 = "Call to deprecated class {name} ({reason})."
            else:
                fmt1 = "Call to deprecated function {name} ({reason})."

            @wraps(func1)
            def new_func1(*args, **kwargs):
                #warnings.simplefilter('default', DeprecationWarning)
                warnings.warn(
                    fmt1.format(name=func1.__name__, reason=reason),
                    category=DeprecationWarning,
                    stacklevel=2
                )
                return func1(*args, **kwargs)

            # Enhance docstring with a deprecation note
            deprecationNote = "\n\n.. note::\n    Deprecated: " + reason
            if new_func1.__doc__:
                new_func1.__doc__ += deprecationNote
            else:
                new_func1.__doc__ = deprecationNote
            return new_func1

        return decorator

    elif inspect.isclass(reason) or inspect.isfunction(reason):
        raise TypeError("Reason for deprecation must be supplied")

    else:
        raise TypeError(repr(type(reason)))

```

---

### File: `tmp\openpyxl_sdist\openpyxl-3.1.5\openpyxl\compat\abc.py`

```python
# Copyright (c) 2010-2024 openpyxl


try:
    from abc import ABC
except ImportError:
    from abc import ABCMeta
    ABC = ABCMeta('ABC', (object, ), {})

```

---

### File: `tmp\openpyxl_sdist\openpyxl-3.1.5\openpyxl\compat\numbers.py`

```python
# Copyright (c) 2010-2024 openpyxl

from decimal import Decimal

NUMERIC_TYPES = (int, float, Decimal)


try:
    import numpy
    NUMPY = True
except ImportError:
    NUMPY = False


if NUMPY:
    NUMERIC_TYPES = NUMERIC_TYPES + (numpy.short,
                                     numpy.ushort,
                                     numpy.intc,
                                     numpy.uintc,
                                     numpy.int_,
                                     numpy.uint,
                                     numpy.longlong,
                                     numpy.ulonglong,
                                     numpy.half,
                                     numpy.float16,
                                     numpy.single,
                                     numpy.double,
                                     numpy.longdouble,
                                     numpy.int8,
                                     numpy.int16,
                                     numpy.int32,
                                     numpy.int64,
                                     numpy.uint8,
                                     numpy.uint16,
                                     numpy.uint32,
                                     numpy.uint64,
                                     numpy.intp,
                                     numpy.uintp,
                                     numpy.float32,
                                     numpy.float64,
                                     numpy.bool_,
                                     numpy.floating,
                                     numpy.integer)

```

---

### File: `tmp\openpyxl_sdist\openpyxl-3.1.5\openpyxl\compat\product.py`

```python
# Copyright (c) 2010-2024 openpyxl

"""
math.prod equivalent for < Python 3.8
"""

import functools
import operator

def product(sequence):
    return functools.reduce(operator.mul, sequence)


try:
    from math import prod
except ImportError:
    prod = product

```

---

### File: `tmp\openpyxl_sdist\openpyxl-3.1.5\openpyxl\compat\singleton.py`

```python
# Copyright (c) 2010-2024 openpyxl

import weakref


class Singleton(type):
    """
    Singleton metaclass
    Based on Python Cookbook 3rd Edition Recipe 9.13
    Only one instance of a class can exist. Does not work with __slots__
    """

    def __init__(self, *args, **kw):
        super().__init__(*args, **kw)
        self.__instance = None

    def __call__(self, *args, **kw):
        if self.__instance is None:
            self.__instance = super().__call__(*args, **kw)
        return self.__instance


class Cached(type):
    """
    Caching metaclass
    Child classes will only create new instances of themselves if
    one doesn't already exist. Does not work with __slots__
    """

    def __init__(self, *args, **kw):
        super().__init__(*args, **kw)
        self.__cache = weakref.WeakValueDictionary()

    def __call__(self, *args):
        if args in self.__cache:
            return self.__cache[args]

        obj = super().__call__(*args)
        self.__cache[args] = obj
        return obj

```

---

### File: `tmp\openpyxl_sdist\openpyxl-3.1.5\openpyxl\compat\strings.py`

```python
# Copyright (c) 2010-2024 openpyxl

from datetime import datetime
from math import isnan, isinf
import sys

VER = sys.version_info

from .numbers import NUMERIC_TYPES


def safe_string(value):
    """Safely and consistently format numeric values"""
    if isinstance(value, NUMERIC_TYPES):
        if isnan(value) or isinf(value):
            value = ""
        else:
            value = "%.16g" % value
    elif value is None:
        value = "none"
    elif isinstance(value, datetime):
        value = value.isoformat()
    elif not isinstance(value, str):
        value = str(value)
    return value

```

---

### File: `tmp\openpyxl_sdist\openpyxl-3.1.5\openpyxl\descriptors\__init__.py`

```python
# Copyright (c) 2010-2024 openpyxl

from .base import *
from .sequence import Sequence


class MetaStrict(type):

    def __new__(cls, clsname, bases, methods):
        for k, v in methods.items():
            if isinstance(v, Descriptor):
                v.name = k
        return type.__new__(cls, clsname, bases, methods)


class Strict(metaclass=MetaStrict):

    pass


class MetaSerialisable(type):

    def __new__(cls, clsname, bases, methods):
        attrs = []
        nested = []
        elements = []
        namespaced = []
        for k, v in methods.items():
            if isinstance(v, Descriptor):
                ns= getattr(v, 'namespace', None)
                if ns:
                    namespaced.append((k, "{%s}%s" % (ns, k)))
                if getattr(v, 'nested', False):
                    nested.append(k)
                    elements.append(k)
                elif isinstance(v, Sequence):
                    elements.append(k)
                elif isinstance(v, Typed):
                    if hasattr(v.expected_type, 'to_tree'):
                        elements.append(k)
                    elif isinstance(v.expected_type, tuple):
                        if any((hasattr(el, "to_tree") for el in v.expected_type)):
                            # don't bind elements as attrs
                            continue
                    else:
                        attrs.append(k)
                else:
                    if not isinstance(v, Alias):
                        attrs.append(k)

        if methods.get('__attrs__') is None:
            methods['__attrs__'] = tuple(attrs)
        methods['__namespaced__'] = tuple(namespaced)
        if methods.get('__nested__') is None:
            methods['__nested__'] = tuple(sorted(nested))
        if methods.get('__elements__') is None:
            methods['__elements__'] = tuple(sorted(elements))
        return MetaStrict.__new__(cls, clsname, bases, methods)

```

---

### File: `tmp\openpyxl_sdist\openpyxl-3.1.5\openpyxl\descriptors\base.py`

```python
# Copyright (c) 2010-2024 openpyxl


"""
Based on Python Cookbook 3rd Edition, 8.13
http://chimera.labs.oreilly.com/books/1230000000393/ch08.html#_discussiuncion_130
"""

import datetime
import re

from openpyxl import DEBUG
from openpyxl.utils.datetime import from_ISO8601

from .namespace import namespaced

class Descriptor:

    def __init__(self, name=None, **kw):
        self.name = name
        for k, v in kw.items():
            setattr(self, k, v)

    def __set__(self, instance, value):
        instance.__dict__[self.name] = value


class Typed(Descriptor):
    """Values must of a particular type"""

    expected_type = type(None)
    allow_none = False
    nested = False

    def __init__(self, *args, **kw):
        super().__init__(*args, **kw)
        self.__doc__ = f"Values must be of type {self.expected_type}"

    def __set__(self, instance, value):
        if not isinstance(value, self.expected_type):
            if (not self.allow_none
                or (self.allow_none and value is not None)):
                msg = f"{instance.__class__}.{self.name} should be {self.expected_type} but value is {type(value)}"
                if DEBUG:
                    msg = f"{instance.__class__}.{self.name} should be {self.expected_type} but {value} is {type(value)}"
                raise TypeError(msg)
        super().__set__(instance, value)

    def __repr__(self):
        return  self.__doc__


def _convert(expected_type, value):
    """
    Check value is of or can be converted to expected type.
    """
    if not isinstance(value, expected_type):
        try:
            value = expected_type(value)
        except:
            raise TypeError('expected ' + str(expected_type))
    return value


class Convertible(Typed):
    """Values must be convertible to a particular type"""

    def __set__(self, instance, value):
        if ((self.allow_none and value is not None)
            or not self.allow_none):
            value = _convert(self.expected_type, value)
        super().__set__(instance, value)


class Max(Convertible):
    """Values must be less than a `max` value"""

    expected_type = float
    allow_none = False

    def __init__(self, **kw):
        if 'max' not in kw and not hasattr(self, 'max'):
            raise TypeError('missing max value')
        super().__init__(**kw)

    def __set__(self, instance, value):
        if ((self.allow_none and value is not None)
            or not self.allow_none):
            value = _convert(self.expected_type, value)
            if value > self.max:
                raise ValueError('Max value is {0}'.format(self.max))
        super().__set__(instance, value)


class Min(Convertible):
    """Values must be greater than a `min` value"""

    expected_type = float
    allow_none = False

    def __init__(self, **kw):
        if 'min' not in kw and not hasattr(self, 'min'):
            raise TypeError('missing min value')
        super().__init__(**kw)

    def __set__(self, instance, value):
        if ((self.allow_none and value is not None)
            or not self.allow_none):
            value = _convert(self.expected_type, value)
            if value < self.min:
                raise ValueError('Min value is {0}'.format(self.min))
        super().__set__(instance, value)


class MinMax(Min, Max):
    """Values must be greater than `min` value and less than a `max` one"""
    pass


class Set(Descriptor):
    """Value can only be from a set of know values"""

    def __init__(self, name=None, **kw):
        if not 'values' in kw:
            raise TypeError("missing set of values")
        kw['values'] = set(kw['values'])
        super().__init__(name, **kw)
        self.__doc__ = "Value must be one of {0}".format(self.values)

    def __set__(self, instance, value):
        if value not in self.values:
            raise ValueError(self.__doc__)
        super().__set__(instance, value)


class NoneSet(Set):

    """'none' will be treated as None"""

    def __init__(self, name=None, **kw):
        super().__init__(name, **kw)
        self.values.add(None)

    def __set__(self, instance, value):
        if value == 'none':
            value = None
        super().__set__(instance, value)


class Integer(Convertible):

    expected_type = int


class Float(Convertible):

    expected_type = float


class Bool(Convertible):

    expected_type = bool

    def __set__(self, instance, value):
        if isinstance(value, str):
            if value in ('false', 'f', '0'):
                value = False
        super().__set__(instance, value)


class String(Typed):

    expected_type = str


class Text(String, Convertible):

    pass


class ASCII(Typed):

    expected_type = bytes


class Tuple(Typed):

    expected_type = tuple


class Length(Descriptor):

    def __init__(self, name=None, **kw):
        if "length" not in kw:
            raise TypeError("value length must be supplied")
        super().__init__(**kw)


    def __set__(self, instance, value):
        if len(value) != self.length:
            raise ValueError("Value must be length {0}".format(self.length))
        super().__set__(instance, value)


class Default(Typed):
    """
    When called returns an instance of the expected type.
    Additional default values can be passed in to the descriptor
    """

    def __init__(self, name=None, **kw):
        if "defaults" not in kw:
            kw['defaults'] = {}
        super().__init__(**kw)

    def __call__(self):
        return self.expected_type()


class Alias(Descriptor):
    """
    Aliases can be used when either the desired attribute name is not allowed
    or confusing in Python (eg. "type") or a more descriptive name is desired
    (eg. "underline" for "u")
    """

    def __init__(self, alias):
        self.alias = alias

    def __set__(self, instance, value):
        setattr(instance, self.alias, value)

    def __get__(self, instance, cls):
        return getattr(instance, self.alias)


class MatchPattern(Descriptor):
    """Values must match a regex pattern """
    allow_none = False

    def __init__(self, name=None, **kw):
        if 'pattern' not in kw and not hasattr(self, 'pattern'):
            raise TypeError('missing pattern value')

        super().__init__(name, **kw)
        self.test_pattern = re.compile(self.pattern, re.VERBOSE)


    def __set__(self, instance, value):

        if value is None and not self.allow_none:
            raise ValueError("Value must not be none")

        if ((self.allow_none and value is not None)
            or not self.allow_none):
            if not self.test_pattern.match(value):
                raise ValueError('Value does not match pattern {0}'.format(self.pattern))

        super().__set__(instance, value)


class DateTime(Typed):

    expected_type = datetime.datetime

    def __set__(self, instance, value):
        if value is not None and isinstance(value, str):
            try:
                value = from_ISO8601(value)
            except ValueError:
                raise ValueError("Value must be ISO datetime format")
        super().__set__(instance, value)

```

---

### File: `tmp\openpyxl_sdist\openpyxl-3.1.5\openpyxl\descriptors\container.py`

```python
# Copyright (c) 2010-2024 openpyxl

"""
Utility list for top level containers that contain one type of element

Provides the necessary API to read and write XML
"""

from openpyxl.xml.functions import Element


class ElementList(list):


    @property
    def tagname(self):
        raise NotImplementedError


    @property
    def expected_type(self):
        raise NotImplementedError


    @classmethod
    def from_tree(cls, tree):
        l = [cls.expected_type.from_tree(el) for el in tree]
        return cls(l)


    def to_tree(self):
        container = Element(self.tagname)
        for el in self:
            container.append(el.to_tree())
        return container


    def append(self, value):
        if not isinstance(value, self.expected_type):
            raise TypeError(f"Value must of type {self.expected_type} {type(value)} provided")
        super().append(value)

```

---

### File: `tmp\openpyxl_sdist\openpyxl-3.1.5\openpyxl\descriptors\excel.py`

```python
# Copyright (c) 2010-2024 openpyxl

"""
Excel specific descriptors
"""

from openpyxl.xml.constants import REL_NS
from openpyxl.compat import safe_string
from openpyxl.xml.functions import Element

from . import (
    MatchPattern,
    MinMax,
    Integer,
    String,
    Sequence,
)
from .serialisable import Serialisable


class HexBinary(MatchPattern):

    pattern = "[0-9a-fA-F]+$"


class UniversalMeasure(MatchPattern):

    pattern = r"[0-9]+(\.[0-9]+)?(mm|cm|in|pt|pc|pi)"


class TextPoint(MinMax):
    """
    Size in hundredths of points.
    In theory other units of measurement can be used but these are unbounded
    """
    expected_type = int

    min = -400000
    max = 400000


Coordinate = Integer


class Percentage(MinMax):

    pattern = r"((100)|([0-9][0-9]?))(\.[0-9][0-9]?)?%" # strict
    min = -1000000
    max = 1000000

    def __set__(self, instance, value):
        if isinstance(value, str) and "%" in value:
            value = value.replace("%", "")
            value = int(float(value) * 1000)
        super().__set__(instance, value)


class Extension(Serialisable):

    uri = String()

    def __init__(self,
                 uri=None,
                ):
        self.uri = uri


class ExtensionList(Serialisable):

    ext = Sequence(expected_type=Extension)

    def __init__(self,
                 ext=(),
                ):
        self.ext = ext


class Relation(String):

    namespace = REL_NS
    allow_none = True


class Base64Binary(MatchPattern):
    # http://www.w3.org/TR/xmlschema11-2/#nt-Base64Binary
    pattern = "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=|[A-Za-z0-9+/]{4})$"


class Guid(MatchPattern):
    # https://msdn.microsoft.com/en-us/library/dd946381(v=office.12).aspx
    pattern = r"{[0-9A-F]{8}-[0-9A-F]{4}-[0-9A-F]{4}-[0-9A-F]{4}-[0-9A-F]{12}\}"


class CellRange(MatchPattern):

    pattern = r"^[$]?([A-Za-z]{1,3})[$]?(\d+)(:[$]?([A-Za-z]{1,3})[$]?(\d+)?)?$|^[A-Za-z]{1,3}:[A-Za-z]{1,3}$"
    allow_none = True

    def __set__(self, instance, value):

        if value is not None:
            value = value.upper()
        super().__set__(instance, value)


def _explicit_none(tagname, value, namespace=None):
    """
    Override serialisation because explicit none required
    """
    if namespace is not None:
        tagname = "{%s}%s" % (namespace, tagname)
    return Element(tagname, val=safe_string(value))

```

---

### File: `tmp\openpyxl_sdist\openpyxl-3.1.5\openpyxl\descriptors\namespace.py`

```python
# Copyright (c) 2010-2024 openpyxl


def namespaced(obj, tagname, namespace=None):
    """
    Utility to create a namespaced tag for an object
    """

    namespace = getattr(obj, "namespace", None) or namespace
    if namespace is not None:
        tagname = "{%s}%s" % (namespace, tagname)
    return tagname

```

---

### File: `tmp\openpyxl_sdist\openpyxl-3.1.5\openpyxl\descriptors\nested.py`

```python
# Copyright (c) 2010-2024 openpyxl

"""
Generic serialisable classes
"""
from .base import (
    Convertible,
    Bool,
    Descriptor,
    NoneSet,
    MinMax,
    Set,
    Float,
    Integer,
    String,
    )
from openpyxl.compat import safe_string
from openpyxl.xml.functions import Element, localname, whitespace


class Nested(Descriptor):

    nested = True
    attribute = "val"

    def __set__(self, instance, value):
        if hasattr(value, "tag"):
            tag = localname(value)
            if tag != self.name:
                raise ValueError("Tag does not match attribute")

            value = self.from_tree(value)
        super().__set__(instance, value)


    def from_tree(self, node):
        return node.get(self.attribute)


    def to_tree(self, tagname=None, value=None, namespace=None):
        namespace = getattr(self, "namespace", namespace)
        if value is not None:
            if namespace is not None:
                tagname = "{%s}%s" % (namespace, tagname)
            value = safe_string(value)
            return Element(tagname, {self.attribute:value})


class NestedValue(Nested, Convertible):
    """
    Nested tag storing the value on the 'val' attribute
    """
    pass


class NestedText(NestedValue):
    """
    Represents any nested tag with the value as the contents of the tag
    """


    def from_tree(self, node):
        return node.text


    def to_tree(self, tagname=None, value=None, namespace=None):
        namespace = getattr(self, "namespace", namespace)
        if value is not None:
            if namespace is not None:
                tagname = "{%s}%s" % (namespace, tagname)
            el = Element(tagname)
            el.text = safe_string(value)
            whitespace(el)
            return el


class NestedFloat(NestedValue, Float):

    pass


class NestedInteger(NestedValue, Integer):

    pass


class NestedString(NestedValue, String):

    pass


class NestedBool(NestedValue, Bool):


    def from_tree(self, node):
        return node.get("val", True)


class NestedNoneSet(Nested, NoneSet):

    pass


class NestedSet(Nested, Set):

    pass


class NestedMinMax(Nested, MinMax):

    pass


class EmptyTag(Nested, Bool):

    """
    Boolean if a tag exists or not.
    """

    def from_tree(self, node):
        return True


    def to_tree(self, tagname=None, value=None, namespace=None):
        if value:
            namespace = getattr(self, "namespace", namespace)
            if namespace is not None:
                tagname = "{%s}%s" % (namespace, tagname)
            return Element(tagname)

```

---

### File: `tmp\openpyxl_sdist\openpyxl-3.1.5\openpyxl\descriptors\sequence.py`

```python
# Copyright (c) 2010-2024 openpyxl

from openpyxl.compat import safe_string
from openpyxl.xml.functions import Element
from openpyxl.utils.indexed_list import IndexedList

from .base import Descriptor, Alias, _convert
from .namespace import namespaced


class Sequence(Descriptor):
    """
    A sequence (list or tuple) that may only contain objects of the declared
    type
    """

    expected_type = type(None)
    seq_types = (list, tuple)
    idx_base = 0
    unique = False
    container = list


    def __set__(self, instance, seq):
        if not isinstance(seq, self.seq_types):
            raise TypeError("Value must be a sequence")
        seq = self.container(_convert(self.expected_type, value) for value in seq)
        if self.unique:
            seq = IndexedList(seq)

        super().__set__(instance, seq)


    def to_tree(self, tagname, obj, namespace=None):
        """
        Convert the sequence represented by the descriptor to an XML element
        """
        for idx, v in enumerate(obj, self.idx_base):
            if hasattr(v, "to_tree"):
                el = v.to_tree(tagname, idx)
            else:
                tagname = namespaced(obj, tagname, namespace)
                el = Element(tagname)
                el.text = safe_string(v)
            yield el


class UniqueSequence(Sequence):
    """
    Use a set to keep values unique
    """
    seq_types = (list, tuple, set)
    container = set


class ValueSequence(Sequence):
    """
    A sequence of primitive types that are stored as a single attribute.
    "val" is the default attribute
    """

    attribute = "val"


    def to_tree(self, tagname, obj, namespace=None):
        tagname = namespaced(self, tagname, namespace)
        for v in obj:
            yield Element(tagname, {self.attribute:safe_string(v)})


    def from_tree(self, node):

        return node.get(self.attribute)


class NestedSequence(Sequence):
    """
    Wrap a sequence in an containing object
    """

    count = False

    def to_tree(self, tagname, obj, namespace=None):
        tagname = namespaced(self, tagname, namespace)
        container = Element(tagname)
        if self.count:
            container.set('count', str(len(obj)))
        for v in obj:
            container.append(v.to_tree())
        return container


    def from_tree(self, node):
        return [self.expected_type.from_tree(el) for el in node]


class MultiSequence(Sequence):
    """
    Sequences can contain objects with different tags
    """

    def __set__(self, instance, seq):
        if not isinstance(seq, (tuple, list)):
            raise ValueError("Value must be a sequence")
        seq = list(seq)
        Descriptor.__set__(self, instance, seq)


    def to_tree(self, tagname, obj, namespace=None):
        """
        Convert the sequence represented by the descriptor to an XML element
        """
        for v in obj:
            el = v.to_tree(namespace=namespace)
            yield el


class MultiSequencePart(Alias):
    """
    Allow a multisequence to be built up from parts

    Excluded from the instance __elements__ or __attrs__ as is effectively an Alias
    """

    def __init__(self, expected_type, store):
        self.expected_type = expected_type
        self.store = store


    def __set__(self, instance, value):
        value = _convert(self.expected_type, value)
        instance.__dict__[self.store].append(value)


    def __get__(self, instance, cls):
        return self

```

---

### File: `tmp\openpyxl_sdist\openpyxl-3.1.5\openpyxl\descriptors\serialisable.py`

```python
# Copyright (c) 2010-2024 openpyxl

from copy import copy
from keyword import kwlist
KEYWORDS = frozenset(kwlist)

from . import Descriptor
from . import MetaSerialisable
from .sequence import (
    Sequence,
    NestedSequence,
    MultiSequencePart,
)
from .namespace import namespaced

from openpyxl.compat import safe_string
from openpyxl.xml.functions import (
    Element,
    localname,
)

seq_types = (list, tuple)

class Serialisable(metaclass=MetaSerialisable):
    """
    Objects can serialise to XML their attributes and child objects.
    The following class attributes are created by the metaclass at runtime:
    __attrs__ = attributes
    __nested__ = single-valued child treated as an attribute
    __elements__ = child elements
    """

    __attrs__ = None
    __nested__ = None
    __elements__ = None
    __namespaced__ = None

    idx_base = 0

    @property
    def tagname(self):
        raise(NotImplementedError)

    namespace = None

    @classmethod
    def from_tree(cls, node):
        """
        Create object from XML
        """
        # strip known namespaces from attributes
        attrib = dict(node.attrib)
        for key, ns in cls.__namespaced__:
            if ns in attrib:
                attrib[key] = attrib[ns]
                del attrib[ns]

        # strip attributes with unknown namespaces
        for key in list(attrib):
            if key.startswith('{'):
                del attrib[key]
            elif key in KEYWORDS:
                attrib["_" + key] = attrib[key]
                del attrib[key]
            elif "-" in key:
                n = key.replace("-", "_")
                attrib[n] = attrib[key]
                del attrib[key]

        if node.text and "attr_text" in cls.__attrs__:
            attrib["attr_text"] = node.text

        for el in node:
            tag = localname(el)
            if tag in KEYWORDS:
                tag = "_" + tag
            desc = getattr(cls, tag, None)
            if desc is None or isinstance(desc, property):
                continue

            if hasattr(desc, 'from_tree'):
                #descriptor manages conversion
                obj = desc.from_tree(el)
            else:
                if hasattr(desc.expected_type, "from_tree"):
                    #complex type
                    obj = desc.expected_type.from_tree(el)
                else:
                    #primitive
                    obj = el.text

            if isinstance(desc, NestedSequence):
                attrib[tag] = obj
            elif isinstance(desc, Sequence):
                attrib.setdefault(tag, [])
                attrib[tag].append(obj)
            elif isinstance(desc, MultiSequencePart):
                attrib.setdefault(desc.store, [])
                attrib[desc.store].append(obj)
            else:
                attrib[tag] = obj

        return cls(**attrib)


    def to_tree(self, tagname=None, idx=None, namespace=None):

        if tagname is None:
            tagname = self.tagname

        # keywords have to be masked
        if tagname.startswith("_"):
            tagname = tagname[1:]

        tagname = namespaced(self, tagname, namespace)
        namespace = getattr(self, "namespace", namespace)

        attrs = dict(self)
        for key, ns in self.__namespaced__:
            if key in attrs:
                attrs[ns] = attrs[key]
                del attrs[key]

        el = Element(tagname, attrs)
        if "attr_text" in self.__attrs__:
            el.text = safe_string(getattr(self, "attr_text"))

        for child_tag in self.__elements__:
            desc = getattr(self.__class__, child_tag, None)
            obj = getattr(self, child_tag)
            if hasattr(desc, "namespace") and hasattr(obj, 'namespace'):
                obj.namespace = desc.namespace

            if isinstance(obj, seq_types):
                if isinstance(desc, NestedSequence):
                    # wrap sequence in container
                    if not obj:
                        continue
                    nodes = [desc.to_tree(child_tag, obj, namespace)]
                elif isinstance(desc, Sequence):
                    # sequence
                    desc.idx_base = self.idx_base
                    nodes = (desc.to_tree(child_tag, obj, namespace))
                else: # property
                    nodes = (v.to_tree(child_tag, namespace) for v in obj)
                for node in nodes:
                    el.append(node)
            else:
                if child_tag in self.__nested__:
                    node = desc.to_tree(child_tag, obj, namespace)
                elif obj is None:
                    continue
                else:
                    node = obj.to_tree(child_tag)
                if node is not None:
                    el.append(node)
        return el


    def __iter__(self):
        for attr in self.__attrs__:
            value = getattr(self, attr)
            if attr.startswith("_"):
                attr = attr[1:]
            elif attr != "attr_text" and "_" in attr:
                desc = getattr(self.__class__, attr)
                if getattr(desc, "hyphenated", False):
                    attr = attr.replace("_", "-")
            if attr != "attr_text" and value is not None:
                yield attr, safe_string(value)


    def __eq__(self, other):
        if not self.__class__ == other.__class__:
            return False
        elif not dict(self) == dict(other):
            return False
        for el in self.__elements__:
            if getattr(self, el) != getattr(other, el):
                return False
        return True


    def __ne__(self, other):
        return not self == other


    def __repr__(self):
        s = u"<{0}.{1} object>\nParameters:".format(
            self.__module__,
            self.__class__.__name__
        )
        args = []
        for k in self.__attrs__ + self.__elements__:
            v = getattr(self, k)
            if isinstance(v, Descriptor):
                v = None
            args.append(u"{0}={1}".format(k, repr(v)))
        args = u", ".join(args)

        return u"\n".join([s, args])


    def __hash__(self):
        fields = []
        for attr in self.__attrs__ + self.__elements__:
            val = getattr(self, attr)
            if isinstance(val, list):
                val = tuple(val)
            fields.append(val)

        return hash(tuple(fields))


    def __add__(self, other):
        if type(self) != type(other):
            raise TypeError("Cannot combine instances of different types")
        vals = {}
        for attr in self.__attrs__:
            vals[attr] = getattr(self, attr) or getattr(other, attr)
        for el in self.__elements__:
            a = getattr(self, el)
            b = getattr(other, el)
            if a and b:
                vals[el] = a + b
            else:
                vals[el] = a or b
        return self.__class__(**vals)


    def __copy__(self):
        # serialise to xml and back to avoid shallow copies
        xml = self.to_tree(tagname="dummy")
        cp = self.__class__.from_tree(xml)
        # copy any non-persisted attributed
        for k in self.__dict__:
            if k not in self.__attrs__ + self.__elements__:
                v = copy(getattr(self, k))
                setattr(cp, k, v)
        return cp

```

---

### File: `tmp\openpyxl_sdist\openpyxl-3.1.5\openpyxl\descriptors\slots.py`

```python
# Metaclass for mixing slots and descriptors
# From "Programming in Python 3" by Mark Summerfield Ch.8 p. 383

class AutoSlotProperties(type):

    def __new__(mcl, classname, bases, dictionary):
        slots = list(dictionary.get("__slots__", []))
        for getter_name in [key for key in dictionary if key.startswith("get_")]:
            name = getter_name
            slots.append("__" + name)
            getter = dictionary.pop(getter_name)
            setter = dictionary.get(setter_name, None)
            if (setter is not None
                and isinstance(setter, collections.Callable)):
                del dictionary[setter_name]
            dictionary[name] = property(getter. setter)
            dictionary["__slots__"] = tuple(slots)
            return super().__new__(mcl, classname, bases, dictionary)

```

---

### File: `tmp\openpyxl_sdist\openpyxl-3.1.5\openpyxl\drawing\__init__.py`

```python
# Copyright (c) 2010-2024 openpyxl


from .drawing import Drawing

```

---

### File: `tmp\openpyxl_sdist\openpyxl-3.1.5\openpyxl\drawing\colors.py`

```python
# Copyright (c) 2010-2024 openpyxl

from openpyxl.descriptors.serialisable import Serialisable
from openpyxl.descriptors import (
    Alias,
    Typed,
    Integer,
    Set,
    MinMax,
)
from openpyxl.descriptors.excel import Percentage
from openpyxl.descriptors.nested import (
    NestedNoneSet,
    NestedValue,
    NestedInteger,
    EmptyTag,
)

from openpyxl.styles.colors import RGB
from openpyxl.xml.constants import DRAWING_NS

from openpyxl.descriptors.excel import ExtensionList as OfficeArtExtensionList

PRESET_COLORS = [
        'aliceBlue', 'antiqueWhite', 'aqua', 'aquamarine',
        'azure', 'beige', 'bisque', 'black', 'blanchedAlmond', 'blue',
        'blueViolet', 'brown', 'burlyWood', 'cadetBlue', 'chartreuse',
        'chocolate', 'coral', 'cornflowerBlue', 'cornsilk', 'crimson', 'cyan',
        'darkBlue', 'darkCyan', 'darkGoldenrod', 'darkGray', 'darkGrey',
        'darkGreen', 'darkKhaki', 'darkMagenta', 'darkOliveGreen', 'darkOrange',
        'darkOrchid', 'darkRed', 'darkSalmon', 'darkSeaGreen', 'darkSlateBlue',
        'darkSlateGray', 'darkSlateGrey', 'darkTurquoise', 'darkViolet',
        'dkBlue', 'dkCyan', 'dkGoldenrod', 'dkGray', 'dkGrey', 'dkGreen',
        'dkKhaki', 'dkMagenta', 'dkOliveGreen', 'dkOrange', 'dkOrchid', 'dkRed',
        'dkSalmon', 'dkSeaGreen', 'dkSlateBlue', 'dkSlateGray', 'dkSlateGrey',
        'dkTurquoise', 'dkViolet', 'deepPink', 'deepSkyBlue', 'dimGray',
        'dimGrey', 'dodgerBlue', 'firebrick', 'floralWhite', 'forestGreen',
        'fuchsia', 'gainsboro', 'ghostWhite', 'gold', 'goldenrod', 'gray',
        'grey', 'green', 'greenYellow', 'honeydew', 'hotPink', 'indianRed',
        'indigo', 'ivory', 'khaki', 'lavender', 'lavenderBlush', 'lawnGreen',
        'lemonChiffon', 'lightBlue', 'lightCoral', 'lightCyan',
        'lightGoldenrodYellow', 'lightGray', 'lightGrey', 'lightGreen',
        'lightPink', 'lightSalmon', 'lightSeaGreen', 'lightSkyBlue',
        'lightSlateGray', 'lightSlateGrey', 'lightSteelBlue', 'lightYellow',
        'ltBlue', 'ltCoral', 'ltCyan', 'ltGoldenrodYellow', 'ltGray', 'ltGrey',
        'ltGreen', 'ltPink', 'ltSalmon', 'ltSeaGreen', 'ltSkyBlue',
        'ltSlateGray', 'ltSlateGrey', 'ltSteelBlue', 'ltYellow', 'lime',
        'limeGreen', 'linen', 'magenta', 'maroon', 'medAquamarine', 'medBlue',
        'medOrchid', 'medPurple', 'medSeaGreen', 'medSlateBlue',
        'medSpringGreen', 'medTurquoise', 'medVioletRed', 'mediumAquamarine',
        'mediumBlue', 'mediumOrchid', 'mediumPurple', 'mediumSeaGreen',
        'mediumSlateBlue', 'mediumSpringGreen', 'mediumTurquoise',
        'mediumVioletRed', 'midnightBlue', 'mintCream', 'mistyRose', 'moccasin',
        'navajoWhite', 'navy', 'oldLace', 'olive', 'oliveDrab', 'orange',
        'orangeRed', 'orchid', 'paleGoldenrod', 'paleGreen', 'paleTurquoise',
        'paleVioletRed', 'papayaWhip', 'peachPuff', 'peru', 'pink', 'plum',
        'powderBlue', 'purple', 'red', 'rosyBrown', 'royalBlue', 'saddleBrown',
        'salmon', 'sandyBrown', 'seaGreen', 'seaShell', 'sienna', 'silver',
        'skyBlue', 'slateBlue', 'slateGray', 'slateGrey', 'snow', 'springGreen',
        'steelBlue', 'tan', 'teal', 'thistle', 'tomato', 'turquoise', 'violet',
        'wheat', 'white', 'whiteSmoke', 'yellow', 'yellowGreen'
    ]


SCHEME_COLORS= ['bg1', 'tx1', 'bg2', 'tx2', 'accent1', 'accent2', 'accent3',
                'accent4', 'accent5', 'accent6', 'hlink', 'folHlink', 'phClr', 'dk1', 'lt1',
                'dk2', 'lt2'
                ]


class Transform(Serialisable):

    pass


class SystemColor(Serialisable):

    tagname = "sysClr"
    namespace = DRAWING_NS

    # color transform options
    tint = NestedInteger(allow_none=True)
    shade = NestedInteger(allow_none=True)
    comp = Typed(expected_type=Transform, allow_none=True)
    inv = Typed(expected_type=Transform, allow_none=True)
    gray = Typed(expected_type=Transform, allow_none=True)
    alpha = NestedInteger(allow_none=True)
    alphaOff = NestedInteger(allow_none=True)
    alphaMod = NestedInteger(allow_none=True)
    hue = NestedInteger(allow_none=True)
    hueOff = NestedInteger(allow_none=True)
    hueMod = NestedInteger(allow_none=True)
    sat = NestedInteger(allow_none=True)
    satOff = NestedInteger(allow_none=True)
    satMod = NestedInteger(allow_none=True)
    lum = NestedInteger(allow_none=True)
    lumOff = NestedInteger(allow_none=True)
    lumMod = NestedInteger(allow_none=True)
    red = NestedInteger(allow_none=True)
    redOff = NestedInteger(allow_none=True)
    redMod = NestedInteger(allow_none=True)
    green = NestedInteger(allow_none=True)
    greenOff = NestedInteger(allow_none=True)
    greenMod = NestedInteger(allow_none=True)
    blue = NestedInteger(allow_none=True)
    blueOff = NestedInteger(allow_none=True)
    blueMod = NestedInteger(allow_none=True)
    gamma = Typed(expected_type=Transform, allow_none=True)
    invGamma = Typed(expected_type=Transform, allow_none=True)

    val = Set(values=( ['scrollBar', 'background', 'activeCaption',
                        'inactiveCaption', 'menu', 'window', 'windowFrame', 'menuText',
                        'windowText', 'captionText', 'activeBorder', 'inactiveBorder',
                        'appWorkspace', 'highlight', 'highlightText', 'btnFace', 'btnShadow',
                        'grayText', 'btnText', 'inactiveCaptionText', 'btnHighlight',
                        '3dDkShadow', '3dLight', 'infoText', 'infoBk', 'hotLight',
                        'gradientActiveCaption', 'gradientInactiveCaption', 'menuHighlight',
                        'menuBar'] )
              )
    lastClr = RGB(allow_none=True)

    __elements__ = ('tint', 'shade', 'comp', 'inv', 'gray', "alpha",
                    "alphaOff", "alphaMod", "hue", "hueOff", "hueMod", "hueOff", "sat",
                    "satOff", "satMod", "lum", "lumOff", "lumMod", "red", "redOff", "redMod",
                    "green", "greenOff", "greenMod", "blue", "blueOff", "blueMod", "gamma",
                    "invGamma")

    def __init__(self,
                 val="windowText",
                 lastClr=None,
                 tint=None,
                 shade=None,
                 comp=None,
                 inv=None,
                 gray=None,
                 alpha=None,
                 alphaOff=None,
                 alphaMod=None,
                 hue=None,
                 hueOff=None,
                 hueMod=None,
                 sat=None,
                 satOff=None,
                 satMod=None,
                 lum=None,
                 lumOff=None,
                 lumMod=None,
                 red=None,
                 redOff=None,
                 redMod=None,
                 green=None,
                 greenOff=None,
                 greenMod=None,
                 blue=None,
                 blueOff=None,
                 blueMod=None,
                 gamma=None,
                 invGamma=None
                ):
        self.val = val
        self.lastClr = lastClr
        self.tint = tint
        self.shade = shade
        self.comp = comp
        self.inv = inv
        self.gray = gray
        self.alpha = alpha
        self.alphaOff = alphaOff
        self.alphaMod = alphaMod
        self.hue = hue
        self.hueOff = hueOff
        self.hueMod = hueMod
        self.sat = sat
        self.satOff = satOff
        self.satMod = satMod
        self.lum = lum
        self.lumOff = lumOff
        self.lumMod = lumMod
        self.red = red
        self.redOff = redOff
        self.redMod = redMod
        self.green = green
        self.greenOff = greenOff
        self.greenMod = greenMod
        self.blue = blue
        self.blueOff = blueOff
        self.blueMod = blueMod
        self.gamma = gamma
        self.invGamma = invGamma


class HSLColor(Serialisable):

    tagname = "hslClr"

    hue = Integer()
    sat = MinMax(min=0, max=100)
    lum = MinMax(min=0, max=100)

    #TODO add color transform options

    def __init__(self,
                 hue=None,
                 sat=None,
                 lum=None,
                ):
        self.hue = hue
        self.sat = sat
        self.lum = lum



class RGBPercent(Serialisable):

    tagname = "rgbClr"

    r = MinMax(min=0, max=100)
    g = MinMax(min=0, max=100)
    b = MinMax(min=0, max=100)

    #TODO add color transform options

    def __init__(self,
                 r=None,
                 g=None,
                 b=None,
                ):
        self.r = r
        self.g = g
        self.b = b


class SchemeColor(Serialisable):

    tagname = "schemeClr"
    namespace = DRAWING_NS

    tint = NestedInteger(allow_none=True)
    shade = NestedInteger(allow_none=True)
    comp = EmptyTag(allow_none=True)
    inv = NestedInteger(allow_none=True)
    gray = NestedInteger(allow_none=True)
    alpha = NestedInteger(allow_none=True)
    alphaOff = NestedInteger(allow_none=True)
    alphaMod = NestedInteger(allow_none=True)
    hue = NestedInteger(allow_none=True)
    hueOff = NestedInteger(allow_none=True)
    hueMod = NestedInteger(allow_none=True)
    sat = NestedInteger(allow_none=True)
    satOff = NestedInteger(allow_none=True)
    satMod = NestedInteger(allow_none=True)
    lum = NestedInteger(allow_none=True)
    lumOff = NestedInteger(allow_none=True)
    lumMod = NestedInteger(allow_none=True)
    red = NestedInteger(allow_none=True)
    redOff = NestedInteger(allow_none=True)
    redMod = NestedInteger(allow_none=True)
    green = NestedInteger(allow_none=True)
    greenOff = NestedInteger(allow_none=True)
    greenMod = NestedInteger(allow_none=True)
    blue = NestedInteger(allow_none=True)
    blueOff = NestedInteger(allow_none=True)
    blueMod = NestedInteger(allow_none=True)
    gamma = EmptyTag(allow_none=True)
    invGamma = EmptyTag(allow_none=True)
    val = Set(values=(['bg1', 'tx1', 'bg2', 'tx2', 'accent1', 'accent2',
                       'accent3', 'accent4', 'accent5', 'accent6', 'hlink', 'folHlink', 'phClr',
                       'dk1', 'lt1', 'dk2', 'lt2']))

    __elements__ = ('tint', 'shade', 'comp', 'inv', 'gray', 'alpha',
                    'alphaOff', 'alphaMod', 'hue', 'hueOff', 'hueMod', 'sat', 'satOff',
                    'satMod', 'lum', 'lumMod', 'lumOff', 'red', 'redOff', 'redMod', 'green',
                    'greenOff', 'greenMod', 'blue', 'blueOff', 'blueMod', 'gamma',
                    'invGamma')

    def __init__(self,
                 tint=None,
                 shade=None,
                 comp=None,
                 inv=None,
                 gray=None,
                 alpha=None,
                 alphaOff=None,
                 alphaMod=None,
                 hue=None,
                 hueOff=None,
                 hueMod=None,
                 sat=None,
                 satOff=None,
                 satMod=None,
                 lum=None,
                 lumOff=None,
                 lumMod=None,
                 red=None,
                 redOff=None,
                 redMod=None,
                 green=None,
                 greenOff=None,
                 greenMod=None,
                 blue=None,
                 blueOff=None,
                 blueMod=None,
                 gamma=None,
                 invGamma=None,
                 val=None,
                ):
        self.tint = tint
        self.shade = shade
        self.comp = comp
        self.inv = inv
        self.gray = gray
        self.alpha = alpha
        self.alphaOff = alphaOff
        self.alphaMod = alphaMod
        self.hue = hue
        self.hueOff = hueOff
        self.hueMod = hueMod
        self.sat = sat
        self.satOff = satOff
        self.satMod = satMod
        self.lum = lum
        self.lumOff = lumOff
        self.lumMod = lumMod
        self.red = red
        self.redOff = redOff
        self.redMod = redMod
        self.green = green
        self.greenOff = greenOff
        self.greenMod = greenMod
        self.blue = blue
        self.blueOff = blueOff
        self.blueMod = blueMod
        self.gamma = gamma
        self.invGamma = invGamma
        self.val = val

class ColorChoice(Serialisable):

    tagname = "colorChoice"
    namespace = DRAWING_NS

    scrgbClr = Typed(expected_type=RGBPercent, allow_none=True)
    RGBPercent = Alias('scrgbClr')
    srgbClr = NestedValue(expected_type=str, allow_none=True) # needs pattern and can have transform
    RGB = Alias('srgbClr')
    hslClr = Typed(expected_type=HSLColor, allow_none=True)
    sysClr = Typed(expected_type=SystemColor, allow_none=True)
    schemeClr = Typed(expected_type=SchemeColor, allow_none=True)
    prstClr = NestedNoneSet(values=PRESET_COLORS)

    __elements__ = ('scrgbClr', 'srgbClr', 'hslClr', 'sysClr', 'schemeClr', 'prstClr')

    def __init__(self,
                 scrgbClr=None,
                 srgbClr=None,
                 hslClr=None,
                 sysClr=None,
                 schemeClr=None,
                 prstClr=None,
                ):
        self.scrgbClr = scrgbClr
        self.srgbClr = srgbClr
        self.hslClr = hslClr
        self.sysClr = sysClr
        self.schemeClr = schemeClr
        self.prstClr = prstClr

_COLOR_SET = ('dk1', 'lt1', 'dk2', 'lt2', 'accent1', 'accent2', 'accent3',
               'accent4', 'accent5', 'accent6', 'hlink', 'folHlink')


class ColorMapping(Serialisable):

    tagname = "clrMapOvr"

    bg1 = Set(values=_COLOR_SET)
    tx1 = Set(values=_COLOR_SET)
    bg2 = Set(values=_COLOR_SET)
    tx2 = Set(values=_COLOR_SET)
    accent1 = Set(values=_COLOR_SET)
    accent2 = Set(values=_COLOR_SET)
    accent3 = Set(values=_COLOR_SET)
    accent4 = Set(values=_COLOR_SET)
    accent5 = Set(values=_COLOR_SET)
    accent6 = Set(values=_COLOR_SET)
    hlink = Set(values=_COLOR_SET)
    folHlink = Set(values=_COLOR_SET)
    extLst = Typed(expected_type=OfficeArtExtensionList, allow_none=True)

    def __init__(self,
                 bg1="lt1",
                 tx1="dk1",
                 bg2="lt2",
                 tx2="dk2",
                 accent1="accent1",
                 accent2="accent2",
                 accent3="accent3",
                 accent4="accent4",
                 accent5="accent5",
                 accent6="accent6",
                 hlink="hlink",
                 folHlink="folHlink",
                 extLst=None,
                ):
        self.bg1 = bg1
        self.tx1 = tx1
        self.bg2 = bg2
        self.tx2 = tx2
        self.accent1 = accent1
        self.accent2 = accent2
        self.accent3 = accent3
        self.accent4 = accent4
        self.accent5 = accent5
        self.accent6 = accent6
        self.hlink = hlink
        self.folHlink = folHlink
        self.extLst = extLst


class ColorChoiceDescriptor(Typed):
    """
    Objects can choose from 7 different kinds of color system.
    Assume RGBHex if a string is passed in.
    """

    expected_type = ColorChoice
    allow_none = True

    def __set__(self, instance, value):
        if isinstance(value, str):
            value = ColorChoice(srgbClr=value)
        else:
            if hasattr(self, "namespace") and value is not None:
                value.namespace = self.namespace
        super().__set__(instance, value)

```

---

### File: `tmp\openpyxl_sdist\openpyxl-3.1.5\openpyxl\drawing\connector.py`

```python
# Copyright (c) 2010-2024 openpyxl

from openpyxl.descriptors.serialisable import Serialisable
from openpyxl.descriptors import (
    Typed,
    Bool,
    Integer,
    String,
    Alias,
)
from openpyxl.descriptors.excel import ExtensionList as OfficeArtExtensionList
from openpyxl.chart.shapes import GraphicalProperties
from openpyxl.chart.text import RichText

from .properties import (
    NonVisualDrawingProps,
    NonVisualDrawingShapeProps,
)
from .geometry import ShapeStyle

class Connection(Serialisable):

    id = Integer()
    idx = Integer()

    def __init__(self,
                 id=None,
                 idx=None,
                ):
        self.id = id
        self.idx = idx


class ConnectorLocking(Serialisable):

    extLst = Typed(expected_type=OfficeArtExtensionList, allow_none=True)

    def __init__(self,
                 extLst=None,
                ):
        self.extLst = extLst


class NonVisualConnectorProperties(Serialisable):

    cxnSpLocks = Typed(expected_type=ConnectorLocking, allow_none=True)
    stCxn = Typed(expected_type=Connection, allow_none=True)
    endCxn = Typed(expected_type=Connection, allow_none=True)
    extLst = Typed(expected_type=OfficeArtExtensionList, allow_none=True)

    def __init__(self,
                 cxnSpLocks=None,
                 stCxn=None,
                 endCxn=None,
                 extLst=None,
                ):
        self.cxnSpLocks = cxnSpLocks
        self.stCxn = stCxn
        self.endCxn = endCxn
        self.extLst = extLst


class ConnectorNonVisual(Serialisable):

    cNvPr = Typed(expected_type=NonVisualDrawingProps, )
    cNvCxnSpPr = Typed(expected_type=NonVisualConnectorProperties, )

    __elements__ = ("cNvPr", "cNvCxnSpPr",)

    def __init__(self,
                 cNvPr=None,
                 cNvCxnSpPr=None,
                ):
        self.cNvPr = cNvPr
        self.cNvCxnSpPr = cNvCxnSpPr


class ConnectorShape(Serialisable):

    tagname = "cxnSp"

    nvCxnSpPr = Typed(expected_type=ConnectorNonVisual)
    spPr = Typed(expected_type=GraphicalProperties)
    style = Typed(expected_type=ShapeStyle, allow_none=True)
    macro = String(allow_none=True)
    fPublished = Bool(allow_none=True)

    def __init__(self,
                 nvCxnSpPr=None,
                 spPr=None,
                 style=None,
                 macro=None,
                 fPublished=None,
                 ):
        self.nvCxnSpPr = nvCxnSpPr
        self.spPr = spPr
        self.style = style
        self.macro = macro
        self.fPublished = fPublished


class ShapeMeta(Serialisable):

    tagname = "nvSpPr"

    cNvPr = Typed(expected_type=NonVisualDrawingProps)
    cNvSpPr = Typed(expected_type=NonVisualDrawingShapeProps)

    def __init__(self, cNvPr=None, cNvSpPr=None):
        self.cNvPr = cNvPr
        self.cNvSpPr = cNvSpPr


class Shape(Serialisable):

    macro = String(allow_none=True)
    textlink = String(allow_none=True)
    fPublished = Bool(allow_none=True)
    fLocksText = Bool(allow_none=True)
    nvSpPr = Typed(expected_type=ShapeMeta, allow_none=True)
    meta = Alias("nvSpPr")
    spPr = Typed(expected_type=GraphicalProperties)
    graphicalProperties = Alias("spPr")
    style = Typed(expected_type=ShapeStyle, allow_none=True)
    txBody = Typed(expected_type=RichText, allow_none=True)

    def __init__(self,
                 macro=None,
                 textlink=None,
                 fPublished=None,
                 fLocksText=None,
                 nvSpPr=None,
                 spPr=None,
                 style=None,
                 txBody=None,
                ):
        self.macro = macro
        self.textlink = textlink
        self.fPublished = fPublished
        self.fLocksText = fLocksText
        self.nvSpPr = nvSpPr
        self.spPr = spPr
        self.style = style
        self.txBody = txBody

```

---

### File: `tmp\openpyxl_sdist\openpyxl-3.1.5\openpyxl\drawing\drawing.py`

```python

# Copyright (c) 2010-2024 openpyxl

import math

from openpyxl.utils.units import pixels_to_EMU


class Drawing:
    """ a drawing object - eg container for shapes or charts
        we assume user specifies dimensions in pixels; units are
        converted to EMU in the drawing part
    """

    count = 0

    def __init__(self):

        self.name = ''
        self.description = ''
        self.coordinates = ((1, 2), (16, 8))
        self.left = 0
        self.top = 0
        self._width = 21 # default in px
        self._height = 192 #default in px
        self.resize_proportional = False
        self.rotation = 0
        self.anchortype = "absolute"
        self.anchorcol = 0 # left cell
        self.anchorrow = 0 # top row


    @property
    def width(self):
        return self._width


    @width.setter
    def width(self, w):
        if self.resize_proportional and w:
            ratio = self._height / self._width
            self._height = round(ratio * w)
        self._width = w


    @property
    def height(self):
        return self._height


    @height.setter
    def height(self, h):
        if self.resize_proportional and h:
            ratio = self._width / self._height
            self._width = round(ratio * h)
        self._height = h


    def set_dimension(self, w=0, h=0):

        xratio = w / self._width
        yratio = h / self._height

        if self.resize_proportional and w and h:
            if (xratio * self._height) < h:
                self._height = math.ceil(xratio * self._height)
                self._width = w
            else:
                self._width = math.ceil(yratio * self._width)
                self._height = h


    @property
    def anchor(self):
        from .spreadsheet_drawing import (
            OneCellAnchor,
            TwoCellAnchor,
            AbsoluteAnchor)
        if self.anchortype == "absolute":
            anchor = AbsoluteAnchor()
            anchor.pos.x = pixels_to_EMU(self.left)
            anchor.pos.y = pixels_to_EMU(self.top)

        elif self.anchortype == "oneCell":
            anchor = OneCellAnchor()
            anchor._from.col = self.anchorcol
            anchor._from.row = self.anchorrow

        anchor.ext.width = pixels_to_EMU(self._width)
        anchor.ext.height = pixels_to_EMU(self._height)

        return anchor

```

---

### File: `tmp\openpyxl_sdist\openpyxl-3.1.5\openpyxl\drawing\effect.py`

```python
# Copyright (c) 2010-2024 openpyxl

from openpyxl.descriptors.serialisable import Serialisable
from openpyxl.descriptors import (
    Typed,
    String,
    Set,
    Bool,
    Integer,
    Float,
)

from .colors import ColorChoice


class TintEffect(Serialisable):

    tagname = "tint"

    hue = Integer()
    amt = Integer()

    def __init__(self,
                 hue=0,
                 amt=0,
                ):
        self.hue = hue
        self.amt = amt


class LuminanceEffect(Serialisable):

    tagname = "lum"

    bright = Integer() #Pct ?
    contrast = Integer() #Pct#

    def __init__(self,
                 bright=0,
                 contrast=0,
                ):
        self.bright = bright
        self.contrast = contrast


class HSLEffect(Serialisable):

    hue = Integer()
    sat = Integer()
    lum = Integer()

    def __init__(self,
                 hue=None,
                 sat=None,
                 lum=None,
                ):
        self.hue = hue
        self.sat = sat
        self.lum = lum


class GrayscaleEffect(Serialisable):

    tagname = "grayscl"


class FillOverlayEffect(Serialisable):

    blend = Set(values=(['over', 'mult', 'screen', 'darken', 'lighten']))

    def __init__(self,
                 blend=None,
                ):
        self.blend = blend


class DuotoneEffect(Serialisable):

    pass

class ColorReplaceEffect(Serialisable):

    pass

class Color(Serialisable):

    pass

class ColorChangeEffect(Serialisable):

    useA = Bool(allow_none=True)
    clrFrom = Typed(expected_type=Color, )
    clrTo = Typed(expected_type=Color, )

    def __init__(self,
                 useA=None,
                 clrFrom=None,
                 clrTo=None,
                ):
        self.useA = useA
        self.clrFrom = clrFrom
        self.clrTo = clrTo


class BlurEffect(Serialisable):

    rad = Float()
    grow = Bool(allow_none=True)

    def __init__(self,
                 rad=None,
                 grow=None,
                ):
        self.rad = rad
        self.grow = grow


class BiLevelEffect(Serialisable):

    thresh = Integer()

    def __init__(self,
                 thresh=None,
                ):
        self.thresh = thresh


class AlphaReplaceEffect(Serialisable):

    a = Integer()

    def __init__(self,
                 a=None,
                ):
        self.a = a


class AlphaModulateFixedEffect(Serialisable):

    amt = Integer()

    def __init__(self,
                 amt=None,
                ):
        self.amt = amt


class EffectContainer(Serialisable):

    type = Set(values=(['sib', 'tree']))
    name = String(allow_none=True)

    def __init__(self,
                 type=None,
                 name=None,
                ):
        self.type = type
        self.name = name


class AlphaModulateEffect(Serialisable):

    cont = Typed(expected_type=EffectContainer, )

    def __init__(self,
                 cont=None,
                ):
        self.cont = cont


class AlphaInverseEffect(Serialisable):

    pass

class AlphaFloorEffect(Serialisable):

    pass

class AlphaCeilingEffect(Serialisable):

    pass

class AlphaBiLevelEffect(Serialisable):

    thresh = Integer()

    def __init__(self,
                 thresh=None,
                ):
        self.thresh = thresh


class GlowEffect(ColorChoice):

    rad = Float()
    # uses element group EG_ColorChoice
    scrgbClr = ColorChoice.scrgbClr
    srgbClr = ColorChoice.srgbClr
    hslClr = ColorChoice.hslClr
    sysClr = ColorChoice.sysClr
    schemeClr = ColorChoice.schemeClr
    prstClr = ColorChoice.prstClr

    __elements__ = ('scrgbClr', 'srgbClr', 'hslClr', 'sysClr', 'schemeClr', 'prstClr')

    def __init__(self,
                 rad=None,
                 **kw
                ):
        self.rad = rad
        super().__init__(**kw)


class InnerShadowEffect(ColorChoice):

    blurRad = Float()
    dist = Float()
    dir = Integer()
    # uses element group EG_ColorChoice
    scrgbClr = ColorChoice.scrgbClr
    srgbClr = ColorChoice.srgbClr
    hslClr = ColorChoice.hslClr
    sysClr = ColorChoice.sysClr
    schemeClr = ColorChoice.schemeClr
    prstClr = ColorChoice.prstClr

    __elements__ = ('scrgbClr', 'srgbClr', 'hslClr', 'sysClr', 'schemeClr', 'prstClr')

    def __init__(self,
                 blurRad=None,
                 dist=None,
                 dir=None,
                 **kw
                 ):
        self.blurRad = blurRad
        self.dist = dist
        self.dir = dir
        super().__init__(**kw)


class OuterShadow(ColorChoice):

    tagname = "outerShdw"

    blurRad = Float(allow_none=True)
    dist = Float(allow_none=True)
    dir = Integer(allow_none=True)
    sx = Integer(allow_none=True)
    sy = Integer(allow_none=True)
    kx = Integer(allow_none=True)
    ky = Integer(allow_none=True)
    algn = Set(values=['tl', 't', 'tr', 'l', 'ctr', 'r', 'bl', 'b', 'br'])
    rotWithShape = Bool(allow_none=True)
    # uses element group EG_ColorChoice
    scrgbClr = ColorChoice.scrgbClr
    srgbClr = ColorChoice.srgbClr
    hslClr = ColorChoice.hslClr
    sysClr = ColorChoice.sysClr
    schemeClr = ColorChoice.schemeClr
    prstClr = ColorChoice.prstClr

    __elements__ = ('scrgbClr', 'srgbClr', 'hslClr', 'sysClr', 'schemeClr', 'prstClr')

    def __init__(self,
                 blurRad=None,
                 dist=None,
                 dir=None,
                 sx=None,
                 sy=None,
                 kx=None,
                 ky=None,
                 algn=None,
                 rotWithShape=None,
                 **kw
                ):
        self.blurRad = blurRad
        self.dist = dist
        self.dir = dir
        self.sx = sx
        self.sy = sy
        self.kx = kx
        self.ky = ky
        self.algn = algn
        self.rotWithShape = rotWithShape
        super().__init__(**kw)


class PresetShadowEffect(ColorChoice):

    prst = Set(values=(['shdw1', 'shdw2', 'shdw3', 'shdw4', 'shdw5', 'shdw6',
                        'shdw7', 'shdw8', 'shdw9', 'shdw10', 'shdw11', 'shdw12', 'shdw13',
                        'shdw14', 'shdw15', 'shdw16', 'shdw17', 'shdw18', 'shdw19', 'shdw20']))
    dist = Float()
    dir = Integer()
    # uses element group EG_ColorChoice
    scrgbClr = ColorChoice.scrgbClr
    srgbClr = ColorChoice.srgbClr
    hslClr = ColorChoice.hslClr
    sysClr = ColorChoice.sysClr
    schemeClr = ColorChoice.schemeClr
    prstClr = ColorChoice.prstClr

    __elements__ = ('scrgbClr', 'srgbClr', 'hslClr', 'sysClr', 'schemeClr', 'prstClr')

    def __init__(self,
                 prst=None,
                 dist=None,
                 dir=None,
                 **kw
                ):
        self.prst = prst
        self.dist = dist
        self.dir = dir
        super().__init__(**kw)


class ReflectionEffect(Serialisable):

    blurRad = Float()
    stA = Integer()
    stPos = Integer()
    endA = Integer()
    endPos = Integer()
    dist = Float()
    dir = Integer()
    fadeDir = Integer()
    sx = Integer()
    sy = Integer()
    kx = Integer()
    ky = Integer()
    algn = Set(values=(['tl', 't', 'tr', 'l', 'ctr', 'r', 'bl', 'b', 'br']))
    rotWithShape = Bool(allow_none=True)

    def __init__(self,
                 blurRad=None,
                 stA=None,
                 stPos=None,
                 endA=None,
                 endPos=None,
                 dist=None,
                 dir=None,
                 fadeDir=None,
                 sx=None,
                 sy=None,
                 kx=None,
                 ky=None,
                 algn=None,
                 rotWithShape=None,
                ):
        self.blurRad = blurRad
        self.stA = stA
        self.stPos = stPos
        self.endA = endA
        self.endPos = endPos
        self.dist = dist
        self.dir = dir
        self.fadeDir = fadeDir
        self.sx = sx
        self.sy = sy
        self.kx = kx
        self.ky = ky
        self.algn = algn
        self.rotWithShape = rotWithShape


class SoftEdgesEffect(Serialisable):

    rad = Float()

    def __init__(self,
                 rad=None,
                ):
        self.rad = rad


class EffectList(Serialisable):

    blur = Typed(expected_type=BlurEffect, allow_none=True)
    fillOverlay = Typed(expected_type=FillOverlayEffect, allow_none=True)
    glow = Typed(expected_type=GlowEffect, allow_none=True)
    innerShdw = Typed(expected_type=InnerShadowEffect, allow_none=True)
    outerShdw = Typed(expected_type=OuterShadow, allow_none=True)
    prstShdw = Typed(expected_type=PresetShadowEffect, allow_none=True)
    reflection = Typed(expected_type=ReflectionEffect, allow_none=True)
    softEdge = Typed(expected_type=SoftEdgesEffect, allow_none=True)

    __elements__ = ('blur', 'fillOverlay', 'glow', 'innerShdw', 'outerShdw',
                    'prstShdw', 'reflection', 'softEdge')

    def __init__(self,
                 blur=None,
                 fillOverlay=None,
                 glow=None,
                 innerShdw=None,
                 outerShdw=None,
                 prstShdw=None,
                 reflection=None,
                 softEdge=None,
                ):
        self.blur = blur
        self.fillOverlay = fillOverlay
        self.glow = glow
        self.innerShdw = innerShdw
        self.outerShdw = outerShdw
        self.prstShdw = prstShdw
        self.reflection = reflection
        self.softEdge = softEdge

```

---

### File: `tmp\openpyxl_sdist\openpyxl-3.1.5\openpyxl\drawing\fill.py`

```python
# Copyright (c) 2010-2024 openpyxl

from openpyxl.descriptors.serialisable import Serialisable
from openpyxl.descriptors import (
    Alias,
    Bool,
    Integer,
    Set,
    NoneSet,
    Typed,
    MinMax,
)
from openpyxl.descriptors.excel import (
    Relation,
    Percentage,
)
from openpyxl.descriptors.nested import NestedNoneSet, NestedValue
from openpyxl.descriptors.sequence import NestedSequence
from openpyxl.descriptors.excel import ExtensionList as OfficeArtExtensionList
from openpyxl.xml.constants import DRAWING_NS

from .colors import (
    ColorChoice,
    HSLColor,
    SystemColor,
    SchemeColor,
    PRESET_COLORS,
    RGBPercent,
)

from .effect import (
    AlphaBiLevelEffect,
    AlphaCeilingEffect,
    AlphaFloorEffect,
    AlphaInverseEffect,
    AlphaModulateEffect,
    AlphaModulateFixedEffect,
    AlphaReplaceEffect,
    BiLevelEffect,
    BlurEffect,
    ColorChangeEffect,
    ColorReplaceEffect,
    DuotoneEffect,
    FillOverlayEffect,
    GrayscaleEffect,
    HSLEffect,
    LuminanceEffect,
    TintEffect,
)

"""
Fill elements from drawing main schema
"""

class PatternFillProperties(Serialisable):

    tagname = "pattFill"
    namespace = DRAWING_NS

    prst = NoneSet(values=(['pct5', 'pct10', 'pct20', 'pct25', 'pct30',
                            'pct40', 'pct50', 'pct60', 'pct70', 'pct75', 'pct80', 'pct90', 'horz',
                            'vert', 'ltHorz', 'ltVert', 'dkHorz', 'dkVert', 'narHorz', 'narVert',
                            'dashHorz', 'dashVert', 'cross', 'dnDiag', 'upDiag', 'ltDnDiag',
                            'ltUpDiag', 'dkDnDiag', 'dkUpDiag', 'wdDnDiag', 'wdUpDiag', 'dashDnDiag',
                            'dashUpDiag', 'diagCross', 'smCheck', 'lgCheck', 'smGrid', 'lgGrid',
                            'dotGrid', 'smConfetti', 'lgConfetti', 'horzBrick', 'diagBrick',
                            'solidDmnd', 'openDmnd', 'dotDmnd', 'plaid', 'sphere', 'weave', 'divot',
                            'shingle', 'wave', 'trellis', 'zigZag']))
    preset = Alias("prst")
    fgClr = Typed(expected_type=ColorChoice, allow_none=True)
    foreground = Alias("fgClr")
    bgClr = Typed(expected_type=ColorChoice, allow_none=True)
    background = Alias("bgClr")

    __elements__ = ("fgClr", "bgClr")

    def __init__(self,
                 prst=None,
                 fgClr=None,
                 bgClr=None,
                ):
        self.prst = prst
        self.fgClr = fgClr
        self.bgClr = bgClr


class RelativeRect(Serialisable):

    tagname = "rect"
    namespace = DRAWING_NS

    l = Percentage(allow_none=True)
    left = Alias('l')
    t = Percentage(allow_none=True)
    top = Alias('t')
    r = Percentage(allow_none=True)
    right = Alias('r')
    b = Percentage(allow_none=True)
    bottom = Alias('b')

    def __init__(self,
                 l=None,
                 t=None,
                 r=None,
                 b=None,
                ):
        self.l = l
        self.t = t
        self.r = r
        self.b = b


class StretchInfoProperties(Serialisable):

    tagname = "stretch"
    namespace = DRAWING_NS

    fillRect = Typed(expected_type=RelativeRect, allow_none=True)

    def __init__(self,
                 fillRect=RelativeRect(),
                ):
        self.fillRect = fillRect


class GradientStop(Serialisable):

    tagname = "gs"
    namespace = DRAWING_NS

    pos = MinMax(min=0, max=100000, allow_none=True)
    # Color Choice Group
    scrgbClr = Typed(expected_type=RGBPercent, allow_none=True)
    RGBPercent = Alias('scrgbClr')
    srgbClr = NestedValue(expected_type=str, allow_none=True) # needs pattern and can have transform
    RGB = Alias('srgbClr')
    hslClr = Typed(expected_type=HSLColor, allow_none=True)
    sysClr = Typed(expected_type=SystemColor, allow_none=True)
    schemeClr = Typed(expected_type=SchemeColor, allow_none=True)
    prstClr = NestedNoneSet(values=PRESET_COLORS)

    __elements__ = ('scrgbClr', 'srgbClr', 'hslClr', 'sysClr', 'schemeClr', 'prstClr')

    def __init__(self,
                 pos=None,
                 scrgbClr=None,
                 srgbClr=None,
                 hslClr=None,
                 sysClr=None,
                 schemeClr=None,
                 prstClr=None,
                ):
        if pos is None:
            pos = 0
        self.pos = pos

        self.scrgbClr = scrgbClr
        self.srgbClr = srgbClr
        self.hslClr = hslClr
        self.sysClr = sysClr
        self.schemeClr = schemeClr
        self.prstClr = prstClr


class LinearShadeProperties(Serialisable):

    tagname = "lin"
    namespace = DRAWING_NS

    ang = Integer()
    scaled = Bool(allow_none=True)

    def __init__(self,
                 ang=None,
                 scaled=None,
                ):
        self.ang = ang
        self.scaled = scaled


class PathShadeProperties(Serialisable):

    tagname = "path"
    namespace = DRAWING_NS

    path = Set(values=(['shape', 'circle', 'rect']))
    fillToRect = Typed(expected_type=RelativeRect, allow_none=True)

    def __init__(self,
                 path=None,
                 fillToRect=None,
                ):
        self.path = path
        self.fillToRect = fillToRect


class GradientFillProperties(Serialisable):

    tagname = "gradFill"
    namespace = DRAWING_NS

    flip = NoneSet(values=(['x', 'y', 'xy']))
    rotWithShape = Bool(allow_none=True)

    gsLst = NestedSequence(expected_type=GradientStop, count=False)
    stop_list = Alias("gsLst")

    lin = Typed(expected_type=LinearShadeProperties, allow_none=True)
    linear = Alias("lin")
    path = Typed(expected_type=PathShadeProperties, allow_none=True)

    tileRect = Typed(expected_type=RelativeRect, allow_none=True)

    __elements__ = ('gsLst', 'lin', 'path', 'tileRect')

    def __init__(self,
                 flip=None,
                 rotWithShape=None,
                 gsLst=(),
                 lin=None,
                 path=None,
                 tileRect=None,
                ):
        self.flip = flip
        self.rotWithShape = rotWithShape
        self.gsLst = gsLst
        self.lin = lin
        self.path = path
        self.tileRect = tileRect


class SolidColorFillProperties(Serialisable):

    tagname = "solidFill"

    # uses element group EG_ColorChoice
    scrgbClr = Typed(expected_type=RGBPercent, allow_none=True)
    RGBPercent = Alias('scrgbClr')
    srgbClr = NestedValue(expected_type=str, allow_none=True) # needs pattern and can have transform
    RGB = Alias('srgbClr')
    hslClr = Typed(expected_type=HSLColor, allow_none=True)
    sysClr = Typed(expected_type=SystemColor, allow_none=True)
    schemeClr = Typed(expected_type=SchemeColor, allow_none=True)
    prstClr = NestedNoneSet(values=PRESET_COLORS)

    __elements__ = ('scrgbClr', 'srgbClr', 'hslClr', 'sysClr', 'schemeClr', 'prstClr')

    def __init__(self,
                 scrgbClr=None,
                 srgbClr=None,
                 hslClr=None,
                 sysClr=None,
                 schemeClr=None,
                 prstClr=None,
                ):
        self.scrgbClr = scrgbClr
        self.srgbClr = srgbClr
        self.hslClr = hslClr
        self.sysClr = sysClr
        self.schemeClr = schemeClr
        self.prstClr = prstClr


class Blip(Serialisable):

    tagname = "blip"
    namespace = DRAWING_NS

    # Using attribute groupAG_Blob
    cstate = NoneSet(values=(['email', 'screen', 'print', 'hqprint']))
    embed = Relation() # rId
    link = Relation() # hyperlink
    noGrp = Bool(allow_none=True)
    noSelect = Bool(allow_none=True)
    noRot = Bool(allow_none=True)
    noChangeAspect = Bool(allow_none=True)
    noMove = Bool(allow_none=True)
    noResize = Bool(allow_none=True)
    noEditPoints = Bool(allow_none=True)
    noAdjustHandles = Bool(allow_none=True)
    noChangeArrowheads = Bool(allow_none=True)
    noChangeShapeType = Bool(allow_none=True)
    # some elements are choice
    extLst = Typed(expected_type=OfficeArtExtensionList, allow_none=True)
    alphaBiLevel = Typed(expected_type=AlphaBiLevelEffect, allow_none=True)
    alphaCeiling = Typed(expected_type=AlphaCeilingEffect, allow_none=True)
    alphaFloor = Typed(expected_type=AlphaFloorEffect, allow_none=True)
    alphaInv = Typed(expected_type=AlphaInverseEffect, allow_none=True)
    alphaMod = Typed(expected_type=AlphaModulateEffect, allow_none=True)
    alphaModFix = Typed(expected_type=AlphaModulateFixedEffect, allow_none=True)
    alphaRepl = Typed(expected_type=AlphaReplaceEffect, allow_none=True)
    biLevel = Typed(expected_type=BiLevelEffect, allow_none=True)
    blur = Typed(expected_type=BlurEffect, allow_none=True)
    clrChange = Typed(expected_type=ColorChangeEffect, allow_none=True)
    clrRepl = Typed(expected_type=ColorReplaceEffect, allow_none=True)
    duotone = Typed(expected_type=DuotoneEffect, allow_none=True)
    fillOverlay = Typed(expected_type=FillOverlayEffect, allow_none=True)
    grayscl = Typed(expected_type=GrayscaleEffect, allow_none=True)
    hsl = Typed(expected_type=HSLEffect, allow_none=True)
    lum = Typed(expected_type=LuminanceEffect, allow_none=True)
    tint = Typed(expected_type=TintEffect, allow_none=True)

    __elements__ = ('alphaBiLevel', 'alphaCeiling', 'alphaFloor', 'alphaInv',
                    'alphaMod', 'alphaModFix', 'alphaRepl', 'biLevel', 'blur', 'clrChange',
                    'clrRepl', 'duotone', 'fillOverlay', 'grayscl', 'hsl', 'lum', 'tint')

    def __init__(self,
                 cstate=None,
                 embed=None,
                 link=None,
                 noGrp=None,
                 noSelect=None,
                 noRot=None,
                 noChangeAspect=None,
                 noMove=None,
                 noResize=None,
                 noEditPoints=None,
                 noAdjustHandles=None,
                 noChangeArrowheads=None,
                 noChangeShapeType=None,
                 extLst=None,
                 alphaBiLevel=None,
                 alphaCeiling=None,
                 alphaFloor=None,
                 alphaInv=None,
                 alphaMod=None,
                 alphaModFix=None,
                 alphaRepl=None,
                 biLevel=None,
                 blur=None,
                 clrChange=None,
                 clrRepl=None,
                 duotone=None,
                 fillOverlay=None,
                 grayscl=None,
                 hsl=None,
                 lum=None,
                 tint=None,
                ):
        self.cstate = cstate
        self.embed = embed
        self.link = link
        self.noGrp = noGrp
        self.noSelect = noSelect
        self.noRot = noRot
        self.noChangeAspect = noChangeAspect
        self.noMove = noMove
        self.noResize = noResize
        self.noEditPoints = noEditPoints
        self.noAdjustHandles = noAdjustHandles
        self.noChangeArrowheads = noChangeArrowheads
        self.noChangeShapeType = noChangeShapeType
        self.extLst = extLst
        self.alphaBiLevel = alphaBiLevel
        self.alphaCeiling = alphaCeiling
        self.alphaFloor = alphaFloor
        self.alphaInv = alphaInv
        self.alphaMod = alphaMod
        self.alphaModFix = alphaModFix
        self.alphaRepl = alphaRepl
        self.biLevel = biLevel
        self.blur = blur
        self.clrChange = clrChange
        self.clrRepl = clrRepl
        self.duotone = duotone
        self.fillOverlay = fillOverlay
        self.grayscl = grayscl
        self.hsl = hsl
        self.lum = lum
        self.tint = tint


class TileInfoProperties(Serialisable):

    tx = Integer(allow_none=True)
    ty = Integer(allow_none=True)
    sx = Integer(allow_none=True)
    sy = Integer(allow_none=True)
    flip = NoneSet(values=(['x', 'y', 'xy']))
    algn = Set(values=(['tl', 't', 'tr', 'l', 'ctr', 'r', 'bl', 'b', 'br']))

    def __init__(self,
                 tx=None,
                 ty=None,
                 sx=None,
                 sy=None,
                 flip=None,
                 algn=None,
                ):
        self.tx = tx
        self.ty = ty
        self.sx = sx
        self.sy = sy
        self.flip = flip
        self.algn = algn


class BlipFillProperties(Serialisable):

    tagname = "blipFill"

    dpi = Integer(allow_none=True)
    rotWithShape = Bool(allow_none=True)

    blip = Typed(expected_type=Blip, allow_none=True)
    srcRect = Typed(expected_type=RelativeRect, allow_none=True)
    tile = Typed(expected_type=TileInfoProperties, allow_none=True)
    stretch = Typed(expected_type=StretchInfoProperties, allow_none=True)

    __elements__ = ("blip", "srcRect", "tile", "stretch")

    def __init__(self,
                 dpi=None,
                 rotWithShape=None,
                 blip=None,
                 tile=None,
                 stretch=StretchInfoProperties(),
                 srcRect=None,
                ):
        self.dpi = dpi
        self.rotWithShape = rotWithShape
        self.blip = blip
        self.tile = tile
        self.stretch = stretch
        self.srcRect = srcRect

```

---

### File: `tmp\openpyxl_sdist\openpyxl-3.1.5\openpyxl\drawing\geometry.py`

```python
# Copyright (c) 2010-2024 openpyxl

from openpyxl.descriptors.serialisable import Serialisable
from openpyxl.descriptors import (
    Typed,
    Float,
    Integer,
    Bool,
    MinMax,
    Set,
    NoneSet,
    String,
    Alias,
)
from openpyxl.descriptors.excel import Coordinate, Percentage
from openpyxl.descriptors.excel import ExtensionList as OfficeArtExtensionList
from .line import LineProperties

from openpyxl.styles.colors import Color
from openpyxl.xml.constants import DRAWING_NS


class Point2D(Serialisable):

    tagname = "off"
    namespace = DRAWING_NS

    x = Coordinate()
    y = Coordinate()

    def __init__(self,
                 x=None,
                 y=None,
                ):
        self.x = x
        self.y = y


class PositiveSize2D(Serialisable):

    tagname = "ext"
    namespace = DRAWING_NS

    """
    Dimensions in EMUs
    """

    cx = Integer()
    width = Alias('cx')
    cy = Integer()
    height = Alias('cy')

    def __init__(self,
                 cx=None,
                 cy=None,
                ):
        self.cx = cx
        self.cy = cy


class Transform2D(Serialisable):

    tagname = "xfrm"
    namespace = DRAWING_NS

    rot = Integer(allow_none=True)
    flipH = Bool(allow_none=True)
    flipV = Bool(allow_none=True)
    off = Typed(expected_type=Point2D, allow_none=True)
    ext = Typed(expected_type=PositiveSize2D, allow_none=True)
    chOff = Typed(expected_type=Point2D, allow_none=True)
    chExt = Typed(expected_type=PositiveSize2D, allow_none=True)

    __elements__ = ('off', 'ext', 'chOff', 'chExt')

    def __init__(self,
                 rot=None,
                 flipH=None,
                 flipV=None,
                 off=None,
                 ext=None,
                 chOff=None,
                 chExt=None,
                ):
        self.rot = rot
        self.flipH = flipH
        self.flipV = flipV
        self.off = off
        self.ext = ext
        self.chOff = chOff
        self.chExt = chExt


class GroupTransform2D(Serialisable):

    tagname = "xfrm"
    namespace = DRAWING_NS

    rot = Integer(allow_none=True)
    flipH = Bool(allow_none=True)
    flipV = Bool(allow_none=True)
    off = Typed(expected_type=Point2D, allow_none=True)
    ext = Typed(expected_type=PositiveSize2D, allow_none=True)
    chOff = Typed(expected_type=Point2D, allow_none=True)
    chExt = Typed(expected_type=PositiveSize2D, allow_none=True)

    __elements__ = ("off", "ext", "chOff", "chExt")

    def __init__(self,
                 rot=0,
                 flipH=None,
                 flipV=None,
                 off=None,
                 ext=None,
                 chOff=None,
                 chExt=None,
                ):
        self.rot = rot
        self.flipH = flipH
        self.flipV = flipV
        self.off = off
        self.ext = ext
        self.chOff = chOff
        self.chExt = chExt


class SphereCoords(Serialisable):

    tagname = "sphereCoords" # usually

    lat = Integer()
    lon = Integer()
    rev = Integer()

    def __init__(self,
                 lat=None,
                 lon=None,
                 rev=None,
                ):
        self.lat = lat
        self.lon = lon
        self.rev = rev


class Camera(Serialisable):

    tagname = "camera"

    prst = Set(values=[
        'legacyObliqueTopLeft', 'legacyObliqueTop', 'legacyObliqueTopRight', 'legacyObliqueLeft',
         'legacyObliqueFront', 'legacyObliqueRight', 'legacyObliqueBottomLeft',
         'legacyObliqueBottom', 'legacyObliqueBottomRight', 'legacyPerspectiveTopLeft',
         'legacyPerspectiveTop', 'legacyPerspectiveTopRight', 'legacyPerspectiveLeft',
         'legacyPerspectiveFront', 'legacyPerspectiveRight', 'legacyPerspectiveBottomLeft',
         'legacyPerspectiveBottom', 'legacyPerspectiveBottomRight', 'orthographicFront',
         'isometricTopUp', 'isometricTopDown', 'isometricBottomUp', 'isometricBottomDown',
         'isometricLeftUp', 'isometricLeftDown', 'isometricRightUp', 'isometricRightDown',
         'isometricOffAxis1Left', 'isometricOffAxis1Right', 'isometricOffAxis1Top',
         'isometricOffAxis2Left', 'isometricOffAxis2Right', 'isometricOffAxis2Top',
         'isometricOffAxis3Left', 'isometricOffAxis3Right', 'isometricOffAxis3Bottom',
         'isometricOffAxis4Left', 'isometricOffAxis4Right', 'isometricOffAxis4Bottom',
         'obliqueTopLeft',  'obliqueTop', 'obliqueTopRight', 'obliqueLeft', 'obliqueRight',
         'obliqueBottomLeft', 'obliqueBottom', 'obliqueBottomRight', 'perspectiveFront',
         'perspectiveLeft', 'perspectiveRight', 'perspectiveAbove', 'perspectiveBelow',
         'perspectiveAboveLeftFacing', 'perspectiveAboveRightFacing',
         'perspectiveContrastingLeftFacing', 'perspectiveContrastingRightFacing',
         'perspectiveHeroicLeftFacing', 'perspectiveHeroicRightFacing',
         'perspectiveHeroicExtremeLeftFacing', 'perspectiveHeroicExtremeRightFacing',
         'perspectiveRelaxed', 'perspectiveRelaxedModerately'])
    fov = Integer(allow_none=True)
    zoom = Typed(expected_type=Percentage, allow_none=True)
    rot = Typed(expected_type=SphereCoords, allow_none=True)


    def __init__(self,
                 prst=None,
                 fov=None,
                 zoom=None,
                 rot=None,
                ):
        self.prst = prst
        self.fov = fov
        self.zoom = zoom
        self.rot = rot


class LightRig(Serialisable):

    tagname = "lightRig"

    rig = Set(values=['legacyFlat1', 'legacyFlat2', 'legacyFlat3', 'legacyFlat4', 'legacyNormal1',
         'legacyNormal2', 'legacyNormal3', 'legacyNormal4', 'legacyHarsh1',
         'legacyHarsh2', 'legacyHarsh3', 'legacyHarsh4', 'threePt', 'balanced',
         'soft', 'harsh', 'flood', 'contrasting', 'morning', 'sunrise', 'sunset',
         'chilly', 'freezing', 'flat', 'twoPt', 'glow', 'brightRoom']
    )
    dir = Set(values=(['tl', 't', 'tr', 'l', 'r', 'bl', 'b', 'br']))
    rot = Typed(expected_type=SphereCoords, allow_none=True)

    def __init__(self,
                 rig=None,
                 dir=None,
                 rot=None,
                ):
        self.rig = rig
        self.dir = dir
        self.rot = rot


class Vector3D(Serialisable):

    tagname = "vector"

    dx = Integer() # can be in or universl measure :-/
    dy = Integer()
    dz = Integer()

    def __init__(self,
                 dx=None,
                 dy=None,
                 dz=None,
                ):
        self.dx = dx
        self.dy = dy
        self.dz = dz


class Point3D(Serialisable):

    tagname = "anchor"

    x = Integer()
    y = Integer()
    z = Integer()

    def __init__(self,
                 x=None,
                 y=None,
                 z=None,
                ):
        self.x = x
        self.y = y
        self.z = z


class Backdrop(Serialisable):

    anchor = Typed(expected_type=Point3D, )
    norm = Typed(expected_type=Vector3D, )
    up = Typed(expected_type=Vector3D, )
    extLst = Typed(expected_type=OfficeArtExtensionList, allow_none=True)

    def __init__(self,
                 anchor=None,
                 norm=None,
                 up=None,
                 extLst=None,
                ):
        self.anchor = anchor
        self.norm = norm
        self.up = up
        self.extLst = extLst


class Scene3D(Serialisable):

    camera = Typed(expected_type=Camera, )
    lightRig = Typed(expected_type=LightRig, )
    backdrop = Typed(expected_type=Backdrop, allow_none=True)
    extLst = Typed(expected_type=OfficeArtExtensionList, allow_none=True)

    def __init__(self,
                 camera=None,
                 lightRig=None,
                 backdrop=None,
                 extLst=None,
                ):
        self.camera = camera
        self.lightRig = lightRig
        self.backdrop = backdrop
        self.extLst = extLst


class Bevel(Serialisable):

    tagname = "bevel"

    w = Integer()
    h = Integer()
    prst = NoneSet(values=
               ['relaxedInset', 'circle', 'slope', 'cross', 'angle',
                'softRound', 'convex', 'coolSlant', 'divot', 'riblet',
                 'hardEdge', 'artDeco']
               )

    def __init__(self,
                 w=None,
                 h=None,
                 prst=None,
                ):
        self.w = w
        self.h = h
        self.prst = prst


class Shape3D(Serialisable):

    namespace = DRAWING_NS

    z = Typed(expected_type=Coordinate, allow_none=True)
    extrusionH = Integer(allow_none=True)
    contourW = Integer(allow_none=True)
    prstMaterial = NoneSet(values=[
        'legacyMatte','legacyPlastic', 'legacyMetal', 'legacyWireframe', 'matte', 'plastic',
        'metal', 'warmMatte', 'translucentPowder', 'powder', 'dkEdge',
        'softEdge', 'clear', 'flat', 'softmetal']
                       )
    bevelT = Typed(expected_type=Bevel, allow_none=True)
    bevelB = Typed(expected_type=Bevel, allow_none=True)
    extrusionClr = Typed(expected_type=Color, allow_none=True)
    contourClr = Typed(expected_type=Color, allow_none=True)
    extLst = Typed(expected_type=OfficeArtExtensionList, allow_none=True)

    def __init__(self,
                 z=None,
                 extrusionH=None,
                 contourW=None,
                 prstMaterial=None,
                 bevelT=None,
                 bevelB=None,
                 extrusionClr=None,
                 contourClr=None,
                 extLst=None,
                ):
        self.z = z
        self.extrusionH = extrusionH
        self.contourW = contourW
        self.prstMaterial = prstMaterial
        self.bevelT = bevelT
        self.bevelB = bevelB
        self.extrusionClr = extrusionClr
        self.contourClr = contourClr
        self.extLst = extLst


class Path2D(Serialisable):

    w = Float()
    h = Float()
    fill = NoneSet(values=(['norm', 'lighten', 'lightenLess', 'darken', 'darkenLess']))
    stroke = Bool(allow_none=True)
    extrusionOk = Bool(allow_none=True)

    def __init__(self,
                 w=None,
                 h=None,
                 fill=None,
                 stroke=None,
                 extrusionOk=None,
                ):
        self.w = w
        self.h = h
        self.fill = fill
        self.stroke = stroke
        self.extrusionOk = extrusionOk


class Path2DList(Serialisable):

    path = Typed(expected_type=Path2D, allow_none=True)

    def __init__(self,
                 path=None,
                ):
        self.path = path


class GeomRect(Serialisable):

    l = Coordinate()
    t = Coordinate()
    r = Coordinate()
    b = Coordinate()

    def __init__(self,
                 l=None,
                 t=None,
                 r=None,
                 b=None,
                ):
        self.l = l
        self.t = t
        self.r = r
        self.b = b


class AdjPoint2D(Serialisable):

    x = Coordinate()
    y = Coordinate()

    def __init__(self,
                 x=None,
                 y=None,
                ):
        self.x = x
        self.y = y


class ConnectionSite(Serialisable):

    ang = MinMax(min=0, max=360) # guess work, can also be a name
    pos = Typed(expected_type=AdjPoint2D, )

    def __init__(self,
                 ang=None,
                 pos=None,
                ):
        self.ang = ang
        self.pos = pos


class ConnectionSiteList(Serialisable):

    cxn = Typed(expected_type=ConnectionSite, allow_none=True)

    def __init__(self,
                 cxn=None,
                ):
        self.cxn = cxn


class AdjustHandleList(Serialisable):

    pass

class GeomGuide(Serialisable):

    name = String()
    fmla = String()

    def __init__(self,
                 name=None,
                 fmla=None,
                ):
        self.name = name
        self.fmla = fmla


class GeomGuideList(Serialisable):

    gd = Typed(expected_type=GeomGuide, allow_none=True)

    def __init__(self,
                 gd=None,
                ):
        self.gd = gd


class CustomGeometry2D(Serialisable):

    avLst = Typed(expected_type=GeomGuideList, allow_none=True)
    gdLst = Typed(expected_type=GeomGuideList, allow_none=True)
    ahLst = Typed(expected_type=AdjustHandleList, allow_none=True)
    cxnLst = Typed(expected_type=ConnectionSiteList, allow_none=True)
    #rect = Typed(expected_type=GeomRect, allow_none=True)
    pathLst = Typed(expected_type=Path2DList, )

    def __init__(self,
                 avLst=None,
                 gdLst=None,
                 ahLst=None,
                 cxnLst=None,
                 rect=None,
                 pathLst=None,
                ):
        self.avLst = avLst
        self.gdLst = gdLst
        self.ahLst = ahLst
        self.cxnLst = cxnLst
        self.rect = None
        self.pathLst = pathLst


class PresetGeometry2D(Serialisable):

    namespace = DRAWING_NS

    prst = Set(values=(
        ['line', 'lineInv', 'triangle', 'rtTriangle', 'rect',
         'diamond', 'parallelogram', 'trapezoid', 'nonIsoscelesTrapezoid',
         'pentagon', 'hexagon', 'heptagon', 'octagon', 'decagon', 'dodecagon',
         'star4', 'star5', 'star6', 'star7', 'star8', 'star10', 'star12',
         'star16', 'star24', 'star32', 'roundRect', 'round1Rect',
         'round2SameRect', 'round2DiagRect', 'snipRoundRect', 'snip1Rect',
         'snip2SameRect', 'snip2DiagRect', 'plaque', 'ellipse', 'teardrop',
         'homePlate', 'chevron', 'pieWedge', 'pie', 'blockArc', 'donut',
         'noSmoking', 'rightArrow', 'leftArrow', 'upArrow', 'downArrow',
         'stripedRightArrow', 'notchedRightArrow', 'bentUpArrow',
         'leftRightArrow', 'upDownArrow', 'leftUpArrow', 'leftRightUpArrow',
         'quadArrow', 'leftArrowCallout', 'rightArrowCallout', 'upArrowCallout',
         'downArrowCallout', 'leftRightArrowCallout', 'upDownArrowCallout',
         'quadArrowCallout', 'bentArrow', 'uturnArrow', 'circularArrow',
         'leftCircularArrow', 'leftRightCircularArrow', 'curvedRightArrow',
         'curvedLeftArrow', 'curvedUpArrow', 'curvedDownArrow', 'swooshArrow',
         'cube', 'can', 'lightningBolt', 'heart', 'sun', 'moon', 'smileyFace',
         'irregularSeal1', 'irregularSeal2', 'foldedCorner', 'bevel', 'frame',
         'halfFrame', 'corner', 'diagStripe', 'chord', 'arc', 'leftBracket',
         'rightBracket', 'leftBrace', 'rightBrace', 'bracketPair', 'bracePair',
         'straightConnector1', 'bentConnector2', 'bentConnector3',
         'bentConnector4', 'bentConnector5', 'curvedConnector2',
         'curvedConnector3', 'curvedConnector4', 'curvedConnector5', 'callout1',
         'callout2', 'callout3', 'accentCallout1', 'accentCallout2',
         'accentCallout3', 'borderCallout1', 'borderCallout2', 'borderCallout3',
         'accentBorderCallout1', 'accentBorderCallout2', 'accentBorderCallout3',
         'wedgeRectCallout', 'wedgeRoundRectCallout', 'wedgeEllipseCallout',
         'cloudCallout', 'cloud', 'ribbon', 'ribbon2', 'ellipseRibbon',
         'ellipseRibbon2', 'leftRightRibbon', 'verticalScroll',
         'horizontalScroll', 'wave', 'doubleWave', 'plus', 'flowChartProcess',
         'flowChartDecision', 'flowChartInputOutput',
         'flowChartPredefinedProcess', 'flowChartInternalStorage',
         'flowChartDocument', 'flowChartMultidocument', 'flowChartTerminator',
         'flowChartPreparation', 'flowChartManualInput',
         'flowChartManualOperation', 'flowChartConnector', 'flowChartPunchedCard',
         'flowChartPunchedTape', 'flowChartSummingJunction', 'flowChartOr',
         'flowChartCollate', 'flowChartSort', 'flowChartExtract',
         'flowChartMerge', 'flowChartOfflineStorage', 'flowChartOnlineStorage',
         'flowChartMagneticTape', 'flowChartMagneticDisk',
         'flowChartMagneticDrum', 'flowChartDisplay', 'flowChartDelay',
         'flowChartAlternateProcess', 'flowChartOffpageConnector',
         'actionButtonBlank', 'actionButtonHome', 'actionButtonHelp',
         'actionButtonInformation', 'actionButtonForwardNext',
         'actionButtonBackPrevious', 'actionButtonEnd', 'actionButtonBeginning',
         'actionButtonReturn', 'actionButtonDocument', 'actionButtonSound',
         'actionButtonMovie', 'gear6', 'gear9', 'funnel', 'mathPlus', 'mathMinus',
         'mathMultiply', 'mathDivide', 'mathEqual', 'mathNotEqual', 'cornerTabs',
         'squareTabs', 'plaqueTabs', 'chartX', 'chartStar', 'chartPlus']))
    avLst = Typed(expected_type=GeomGuideList, allow_none=True)

    def __init__(self,
                 prst=None,
                 avLst=None,
                ):
        self.prst = prst
        self.avLst = avLst


class FontReference(Serialisable):

    idx = NoneSet(values=(['major', 'minor']))

    def __init__(self,
                 idx=None,
                ):
        self.idx = idx


class StyleMatrixReference(Serialisable):

    idx = Integer()

    def __init__(self,
                 idx=None,
                ):
        self.idx = idx


class ShapeStyle(Serialisable):

    lnRef = Typed(expected_type=StyleMatrixReference, )
    fillRef = Typed(expected_type=StyleMatrixReference, )
    effectRef = Typed(expected_type=StyleMatrixReference, )
    fontRef = Typed(expected_type=FontReference, )

    def __init__(self,
                 lnRef=None,
                 fillRef=None,
                 effectRef=None,
                 fontRef=None,
                ):
        self.lnRef = lnRef
        self.fillRef = fillRef
        self.effectRef = effectRef
        self.fontRef = fontRef

```

---

### File: `tmp\openpyxl_sdist\openpyxl-3.1.5\openpyxl\drawing\graphic.py`

```python
# Copyright (c) 2010-2024 openpyxl

from openpyxl.xml.constants import CHART_NS, DRAWING_NS
from openpyxl.descriptors.serialisable import Serialisable
from openpyxl.descriptors import (
    Typed,
    Bool,
    String,
    Alias,
)
from openpyxl.descriptors.excel import ExtensionList as OfficeArtExtensionList

from .effect import (
    EffectList,
    EffectContainer,
)
from .fill import (
    Blip,
    GradientFillProperties,
    BlipFillProperties,
)
from .picture import PictureFrame
from .properties import (
    NonVisualDrawingProps,
    NonVisualGroupShape,
    GroupShapeProperties,
)
from .relation import ChartRelation
from .xdr import XDRTransform2D


class GraphicFrameLocking(Serialisable):

    noGrp = Bool(allow_none=True)
    noDrilldown = Bool(allow_none=True)
    noSelect = Bool(allow_none=True)
    noChangeAspect = Bool(allow_none=True)
    noMove = Bool(allow_none=True)
    noResize = Bool(allow_none=True)
    extLst = Typed(expected_type=OfficeArtExtensionList, allow_none=True)

    def __init__(self,
                 noGrp=None,
                 noDrilldown=None,
                 noSelect=None,
                 noChangeAspect=None,
                 noMove=None,
                 noResize=None,
                 extLst=None,
                ):
        self.noGrp = noGrp
        self.noDrilldown = noDrilldown
        self.noSelect = noSelect
        self.noChangeAspect = noChangeAspect
        self.noMove = noMove
        self.noResize = noResize
        self.extLst = extLst


class NonVisualGraphicFrameProperties(Serialisable):

    tagname = "cNvGraphicFramePr"

    graphicFrameLocks = Typed(expected_type=GraphicFrameLocking, allow_none=True)
    extLst = Typed(expected_type=OfficeArtExtensionList, allow_none=True)

    def __init__(self,
                 graphicFrameLocks=None,
                 extLst=None,
                ):
        self.graphicFrameLocks = graphicFrameLocks
        self.extLst = extLst


class NonVisualGraphicFrame(Serialisable):

    tagname = "nvGraphicFramePr"

    cNvPr = Typed(expected_type=NonVisualDrawingProps)
    cNvGraphicFramePr = Typed(expected_type=NonVisualGraphicFrameProperties)

    __elements__ = ('cNvPr', 'cNvGraphicFramePr')

    def __init__(self,
                 cNvPr=None,
                 cNvGraphicFramePr=None,
                ):
        if cNvPr is None:
            cNvPr = NonVisualDrawingProps(id=0, name="Chart 0")
        self.cNvPr = cNvPr
        if cNvGraphicFramePr is None:
            cNvGraphicFramePr = NonVisualGraphicFrameProperties()
        self.cNvGraphicFramePr = cNvGraphicFramePr


class GraphicData(Serialisable):

    tagname = "graphicData"
    namespace = DRAWING_NS

    uri = String()
    chart = Typed(expected_type=ChartRelation, allow_none=True)


    def __init__(self,
                 uri=CHART_NS,
                 chart=None,
                ):
        self.uri = uri
        self.chart = chart


class GraphicObject(Serialisable):

    tagname = "graphic"
    namespace = DRAWING_NS

    graphicData = Typed(expected_type=GraphicData)

    def __init__(self,
                 graphicData=None,
                ):
        if graphicData is None:
            graphicData = GraphicData()
        self.graphicData = graphicData


class GraphicFrame(Serialisable):

    tagname = "graphicFrame"

    nvGraphicFramePr = Typed(expected_type=NonVisualGraphicFrame)
    xfrm = Typed(expected_type=XDRTransform2D)
    graphic = Typed(expected_type=GraphicObject)
    macro = String(allow_none=True)
    fPublished = Bool(allow_none=True)

    __elements__ = ('nvGraphicFramePr', 'xfrm', 'graphic', 'macro', 'fPublished')

    def __init__(self,
                 nvGraphicFramePr=None,
                 xfrm=None,
                 graphic=None,
                 macro=None,
                 fPublished=None,
                 ):
        if nvGraphicFramePr is None:
            nvGraphicFramePr = NonVisualGraphicFrame()
        self.nvGraphicFramePr = nvGraphicFramePr
        if xfrm is None:
            xfrm = XDRTransform2D()
        self.xfrm = xfrm
        if graphic is None:
            graphic = GraphicObject()
        self.graphic = graphic
        self.macro = macro
        self.fPublished = fPublished


class GroupShape(Serialisable):

    nvGrpSpPr = Typed(expected_type=NonVisualGroupShape)
    nonVisualProperties = Alias("nvGrpSpPr")
    grpSpPr = Typed(expected_type=GroupShapeProperties)
    visualProperties = Alias("grpSpPr")
    pic = Typed(expected_type=PictureFrame, allow_none=True)

    __elements__ = ["nvGrpSpPr", "grpSpPr", "pic"]

    def __init__(self,
                 nvGrpSpPr=None,
                 grpSpPr=None,
                 pic=None,
                ):
        self.nvGrpSpPr = nvGrpSpPr
        self.grpSpPr = grpSpPr
        self.pic = pic

```

---

### File: `tmp\openpyxl_sdist\openpyxl-3.1.5\openpyxl\drawing\image.py`

```python
# Copyright (c) 2010-2024 openpyxl

from io import BytesIO

try:
    from PIL import Image as PILImage
except ImportError:
    PILImage = False


def _import_image(img):
    if not PILImage:
        raise ImportError('You must install Pillow to fetch image objects')

    if not isinstance(img, PILImage.Image):
        img = PILImage.open(img)

    return img


class Image:
    """Image in a spreadsheet"""

    _id = 1
    _path = "/xl/media/image{0}.{1}"
    anchor = "A1"

    def __init__(self, img):

        self.ref = img
        mark_to_close = isinstance(img, str)
        image = _import_image(img)
        self.width, self.height = image.size

        try:
            self.format = image.format.lower()
        except AttributeError:
            self.format = "png"
        if mark_to_close:
            # PIL instances created for metadata should be closed.
            image.close()


    def _data(self):
        """
        Return image data, convert to supported types if necessary
        """
        img = _import_image(self.ref)
        # don't convert these file formats
        if self.format in ['gif', 'jpeg', 'png']:
            img.fp.seek(0)
            fp = img.fp
        else:
            fp = BytesIO()
            img.save(fp, format="png")
            fp.seek(0)

        data = fp.read()
        fp.close()
        return data


    @property
    def path(self):
        return self._path.format(self._id, self.format)

```

---

### File: `tmp\openpyxl_sdist\openpyxl-3.1.5\openpyxl\drawing\line.py`

```python
# Copyright (c) 2010-2024 openpyxl

from openpyxl.descriptors.serialisable import Serialisable
from openpyxl.descriptors import (
    Typed,
    Integer,
    MinMax,
    NoneSet,
    Alias,
    Sequence
)

from openpyxl.descriptors.nested import (
    NestedInteger,
    NestedNoneSet,
    EmptyTag,
)
from openpyxl.xml.constants import DRAWING_NS

from .colors import ColorChoiceDescriptor
from .fill import GradientFillProperties, PatternFillProperties
from openpyxl.descriptors.excel import ExtensionList as OfficeArtExtensionList

"""
Line elements from drawing main schema
"""


class LineEndProperties(Serialisable):

    tagname = "end"
    namespace = DRAWING_NS

    type = NoneSet(values=(['none', 'triangle', 'stealth', 'diamond', 'oval', 'arrow']))
    w = NoneSet(values=(['sm', 'med', 'lg']))
    len = NoneSet(values=(['sm', 'med', 'lg']))

    def __init__(self,
                 type=None,
                 w=None,
                 len=None,
                ):
        self.type = type
        self.w = w
        self.len = len


class DashStop(Serialisable):

    tagname = "ds"
    namespace = DRAWING_NS

    d = Integer()
    length = Alias('d')
    sp = Integer()
    space = Alias('sp')

    def __init__(self,
                 d=0,
                 sp=0,
                ):
        self.d = d
        self.sp = sp


class DashStopList(Serialisable):

    ds = Sequence(expected_type=DashStop, allow_none=True)

    def __init__(self,
                 ds=None,
                ):
        self.ds = ds


class LineProperties(Serialisable):

    tagname = "ln"
    namespace = DRAWING_NS

    w = MinMax(min=0, max=20116800, allow_none=True) # EMU
    width = Alias('w')
    cap = NoneSet(values=(['rnd', 'sq', 'flat']))
    cmpd = NoneSet(values=(['sng', 'dbl', 'thickThin', 'thinThick', 'tri']))
    algn = NoneSet(values=(['ctr', 'in']))

    noFill = EmptyTag()
    solidFill = ColorChoiceDescriptor()
    gradFill = Typed(expected_type=GradientFillProperties, allow_none=True)
    pattFill = Typed(expected_type=PatternFillProperties, allow_none=True)

    prstDash = NestedNoneSet(values=(['solid', 'dot', 'dash', 'lgDash', 'dashDot',
                       'lgDashDot', 'lgDashDotDot', 'sysDash', 'sysDot', 'sysDashDot',
                       'sysDashDotDot']), namespace=namespace)
    dashStyle = Alias('prstDash')

    custDash = Typed(expected_type=DashStop, allow_none=True)

    round = EmptyTag()
    bevel = EmptyTag()
    miter = NestedInteger(allow_none=True, attribute="lim")

    headEnd = Typed(expected_type=LineEndProperties, allow_none=True)
    tailEnd = Typed(expected_type=LineEndProperties, allow_none=True)
    extLst = Typed(expected_type=OfficeArtExtensionList, allow_none=True)

    __elements__ = ('noFill', 'solidFill', 'gradFill', 'pattFill',
                    'prstDash', 'custDash', 'round', 'bevel', 'miter', 'headEnd', 'tailEnd')

    def __init__(self,
                 w=None,
                 cap=None,
                 cmpd=None,
                 algn=None,
                 noFill=None,
                 solidFill=None,
                 gradFill=None,
                 pattFill=None,
                 prstDash=None,
                 custDash=None,
                 round=None,
                 bevel=None,
                 miter=None,
                 headEnd=None,
                 tailEnd=None,
                 extLst=None,
                ):
        self.w = w
        self.cap = cap
        self.cmpd = cmpd
        self.algn = algn
        self.noFill = noFill
        self.solidFill = solidFill
        self.gradFill = gradFill
        self.pattFill = pattFill
        if prstDash is None:
            prstDash = "solid"
        self.prstDash = prstDash
        self.custDash = custDash
        self.round = round
        self.bevel = bevel
        self.miter = miter
        self.headEnd = headEnd
        self.tailEnd = tailEnd

```

---

### File: `tmp\openpyxl_sdist\openpyxl-3.1.5\openpyxl\drawing\picture.py`

```python
# Copyright (c) 2010-2024 openpyxl

from openpyxl.xml.constants import DRAWING_NS

from openpyxl.descriptors.serialisable import Serialisable
from openpyxl.descriptors import (
    Typed,
    Bool,
    String,
    Alias,
)
from openpyxl.descriptors.excel import ExtensionList as OfficeArtExtensionList

from openpyxl.chart.shapes import GraphicalProperties

from .fill import BlipFillProperties
from .properties import NonVisualDrawingProps
from .geometry import ShapeStyle


class PictureLocking(Serialisable):

    tagname = "picLocks"
    namespace = DRAWING_NS

    # Using attribute group AG_Locking
    noCrop = Bool(allow_none=True)
    noGrp = Bool(allow_none=True)
    noSelect = Bool(allow_none=True)
    noRot = Bool(allow_none=True)
    noChangeAspect = Bool(allow_none=True)
    noMove = Bool(allow_none=True)
    noResize = Bool(allow_none=True)
    noEditPoints = Bool(allow_none=True)
    noAdjustHandles = Bool(allow_none=True)
    noChangeArrowheads = Bool(allow_none=True)
    noChangeShapeType = Bool(allow_none=True)
    extLst = Typed(expected_type=OfficeArtExtensionList, allow_none=True)

    __elements__ = ()

    def __init__(self,
                 noCrop=None,
                 noGrp=None,
                 noSelect=None,
                 noRot=None,
                 noChangeAspect=None,
                 noMove=None,
                 noResize=None,
                 noEditPoints=None,
                 noAdjustHandles=None,
                 noChangeArrowheads=None,
                 noChangeShapeType=None,
                 extLst=None,
                ):
        self.noCrop = noCrop
        self.noGrp = noGrp
        self.noSelect = noSelect
        self.noRot = noRot
        self.noChangeAspect = noChangeAspect
        self.noMove = noMove
        self.noResize = noResize
        self.noEditPoints = noEditPoints
        self.noAdjustHandles = noAdjustHandles
        self.noChangeArrowheads = noChangeArrowheads
        self.noChangeShapeType = noChangeShapeType


class NonVisualPictureProperties(Serialisable):

    tagname = "cNvPicPr"

    preferRelativeResize = Bool(allow_none=True)
    picLocks = Typed(expected_type=PictureLocking, allow_none=True)
    extLst = Typed(expected_type=OfficeArtExtensionList, allow_none=True)

    __elements__ = ("picLocks",)

    def __init__(self,
                 preferRelativeResize=None,
                 picLocks=None,
                 extLst=None,
                ):
        self.preferRelativeResize = preferRelativeResize
        self.picLocks = picLocks


class PictureNonVisual(Serialisable):

    tagname = "nvPicPr"

    cNvPr = Typed(expected_type=NonVisualDrawingProps, )
    cNvPicPr = Typed(expected_type=NonVisualPictureProperties, )

    __elements__ = ("cNvPr", "cNvPicPr")

    def __init__(self,
                 cNvPr=None,
                 cNvPicPr=None,
                ):
        if cNvPr is None:
            cNvPr = NonVisualDrawingProps(id=0, name="Image 1", descr="Name of file")
        self.cNvPr = cNvPr
        if cNvPicPr is None:
            cNvPicPr = NonVisualPictureProperties()
        self.cNvPicPr = cNvPicPr




class PictureFrame(Serialisable):

    tagname = "pic"

    macro = String(allow_none=True)
    fPublished = Bool(allow_none=True)
    nvPicPr = Typed(expected_type=PictureNonVisual, )
    blipFill = Typed(expected_type=BlipFillProperties, )
    spPr = Typed(expected_type=GraphicalProperties, )
    graphicalProperties = Alias('spPr')
    style = Typed(expected_type=ShapeStyle, allow_none=True)

    __elements__ = ("nvPicPr", "blipFill", "spPr", "style")

    def __init__(self,
                 macro=None,
                 fPublished=None,
                 nvPicPr=None,
                 blipFill=None,
                 spPr=None,
                 style=None,
                ):
        self.macro = macro
        self.fPublished = fPublished
        if nvPicPr is None:
            nvPicPr = PictureNonVisual()
        self.nvPicPr = nvPicPr
        if blipFill is None:
            blipFill = BlipFillProperties()
        self.blipFill = blipFill
        if spPr is None:
            spPr = GraphicalProperties()
        self.spPr = spPr
        self.style = style

```

---

### File: `tmp\openpyxl_sdist\openpyxl-3.1.5\openpyxl\drawing\properties.py`

```python
# Copyright (c) 2010-2024 openpyxl

from openpyxl.xml.constants import DRAWING_NS
from openpyxl.descriptors.serialisable import Serialisable
from openpyxl.descriptors import (
    Typed,
    Bool,
    Integer,
    Set,
    String,
    Alias,
    NoneSet,
)
from openpyxl.descriptors.excel import ExtensionList as OfficeArtExtensionList

from .geometry import GroupTransform2D, Scene3D
from .text import Hyperlink


class GroupShapeProperties(Serialisable):

    tagname = "grpSpPr"

    bwMode = NoneSet(values=(['clr', 'auto', 'gray', 'ltGray', 'invGray',
                          'grayWhite', 'blackGray', 'blackWhite', 'black', 'white', 'hidden']))
    xfrm = Typed(expected_type=GroupTransform2D, allow_none=True)
    scene3d = Typed(expected_type=Scene3D, allow_none=True)
    extLst = Typed(expected_type=OfficeArtExtensionList, allow_none=True)

    def __init__(self,
                 bwMode=None,
                 xfrm=None,
                 scene3d=None,
                 extLst=None,
                ):
        self.bwMode = bwMode
        self.xfrm = xfrm
        self.scene3d = scene3d
        self.extLst = extLst


class GroupLocking(Serialisable):

    tagname = "grpSpLocks"
    namespace = DRAWING_NS

    noGrp = Bool(allow_none=True)
    noUngrp = Bool(allow_none=True)
    noSelect = Bool(allow_none=True)
    noRot = Bool(allow_none=True)
    noChangeAspect = Bool(allow_none=True)
    noMove = Bool(allow_none=True)
    noResize = Bool(allow_none=True)
    noChangeArrowheads = Bool(allow_none=True)
    noEditPoints = Bool(allow_none=True)
    noAdjustHandles = Bool(allow_none=True)
    noChangeArrowheads = Bool(allow_none=True)
    noChangeShapeType = Bool(allow_none=True)
    extLst = Typed(expected_type=OfficeArtExtensionList, allow_none=True)

    __elements__ = ()

    def __init__(self,
                 noGrp=None,
                 noUngrp=None,
                 noSelect=None,
                 noRot=None,
                 noChangeAspect=None,
                 noChangeArrowheads=None,
                 noMove=None,
                 noResize=None,
                 noEditPoints=None,
                 noAdjustHandles=None,
                 noChangeShapeType=None,
                 extLst=None,
                ):
        self.noGrp = noGrp
        self.noUngrp = noUngrp
        self.noSelect = noSelect
        self.noRot = noRot
        self.noChangeAspect = noChangeAspect
        self.noChangeArrowheads = noChangeArrowheads
        self.noMove = noMove
        self.noResize = noResize
        self.noEditPoints = noEditPoints
        self.noAdjustHandles = noAdjustHandles
        self.noChangeShapeType = noChangeShapeType


class NonVisualGroupDrawingShapeProps(Serialisable):

    tagname = "cNvGrpSpPr"

    grpSpLocks = Typed(expected_type=GroupLocking, allow_none=True)
    extLst = Typed(expected_type=OfficeArtExtensionList, allow_none=True)

    __elements__ = ("grpSpLocks",)

    def __init__(self,
                 grpSpLocks=None,
                 extLst=None,
                ):
        self.grpSpLocks = grpSpLocks


class NonVisualDrawingShapeProps(Serialisable):

    tagname = "cNvSpPr"

    spLocks = Typed(expected_type=GroupLocking, allow_none=True)
    txBax = Bool(allow_none=True)
    extLst = Typed(expected_type=OfficeArtExtensionList, allow_none=True)

    __elements__ = ("spLocks", "txBax")

    def __init__(self,
                 spLocks=None,
                 txBox=None,
                 extLst=None,
                ):
        self.spLocks = spLocks
        self.txBox = txBox


class NonVisualDrawingProps(Serialisable):

    tagname = "cNvPr"

    id = Integer()
    name = String()
    descr = String(allow_none=True)
    hidden = Bool(allow_none=True)
    title = String(allow_none=True)
    hlinkClick = Typed(expected_type=Hyperlink, allow_none=True)
    hlinkHover = Typed(expected_type=Hyperlink, allow_none=True)
    extLst = Typed(expected_type=OfficeArtExtensionList, allow_none=True)

    __elements__ = ["hlinkClick", "hlinkHover"]

    def __init__(self,
                 id=None,
                 name=None,
                 descr=None,
                 hidden=None,
                 title=None,
                 hlinkClick=None,
                 hlinkHover=None,
                 extLst=None,
                ):
        self.id = id
        self.name = name
        self.descr = descr
        self.hidden = hidden
        self.title = title
        self.hlinkClick = hlinkClick
        self.hlinkHover = hlinkHover
        self.extLst = extLst

class NonVisualGroupShape(Serialisable):

    tagname = "nvGrpSpPr"

    cNvPr = Typed(expected_type=NonVisualDrawingProps)
    cNvGrpSpPr = Typed(expected_type=NonVisualGroupDrawingShapeProps)

    __elements__ = ("cNvPr", "cNvGrpSpPr")

    def __init__(self,
                 cNvPr=None,
                 cNvGrpSpPr=None,
                ):
        self.cNvPr = cNvPr
        self.cNvGrpSpPr = cNvGrpSpPr


```

---

### File: `tmp\openpyxl_sdist\openpyxl-3.1.5\openpyxl\drawing\relation.py`

```python
# Copyright (c) 2010-2024 openpyxl

from openpyxl.xml.constants import CHART_NS

from openpyxl.descriptors.serialisable import Serialisable
from openpyxl.descriptors.excel import Relation


class ChartRelation(Serialisable):

    tagname = "chart"
    namespace = CHART_NS

    id = Relation()

    def __init__(self, id):
        self.id = id

```

---

### File: `tmp\openpyxl_sdist\openpyxl-3.1.5\openpyxl\drawing\spreadsheet_drawing.py`

```python
# Copyright (c) 2010-2024 openpyxl

from openpyxl.descriptors.serialisable import Serialisable
from openpyxl.descriptors import (
    Typed,
    Bool,
    NoneSet,
    Integer,
    Sequence,
    Alias,
)
from openpyxl.descriptors.nested import (
    NestedText,
    NestedNoneSet,
)
from openpyxl.descriptors.excel import Relation

from openpyxl.packaging.relationship import (
    Relationship,
    RelationshipList,
)
from openpyxl.utils import coordinate_to_tuple
from openpyxl.utils.units import (
    cm_to_EMU,
    pixels_to_EMU,
)
from openpyxl.drawing.image import Image

from openpyxl.xml.constants import SHEET_DRAWING_NS

from openpyxl.chart._chart import ChartBase
from .xdr import (
    XDRPoint2D,
    XDRPositiveSize2D,
)
from .fill import Blip
from .connector import Shape
from .graphic import (
    GroupShape,
    GraphicFrame,
    )
from .geometry import PresetGeometry2D
from .picture import PictureFrame
from .relation import ChartRelation


class AnchorClientData(Serialisable):

    fLocksWithSheet = Bool(allow_none=True)
    fPrintsWithSheet = Bool(allow_none=True)

    def __init__(self,
                 fLocksWithSheet=None,
                 fPrintsWithSheet=None,
                 ):
        self.fLocksWithSheet = fLocksWithSheet
        self.fPrintsWithSheet = fPrintsWithSheet


class AnchorMarker(Serialisable):

    tagname = "marker"

    col = NestedText(expected_type=int)
    colOff = NestedText(expected_type=int)
    row = NestedText(expected_type=int)
    rowOff = NestedText(expected_type=int)

    def __init__(self,
                 col=0,
                 colOff=0,
                 row=0,
                 rowOff=0,
                 ):
        self.col = col
        self.colOff = colOff
        self.row = row
        self.rowOff = rowOff


class _AnchorBase(Serialisable):

    #one of
    sp = Typed(expected_type=Shape, allow_none=True)
    shape = Alias("sp")
    grpSp = Typed(expected_type=GroupShape, allow_none=True)
    groupShape = Alias("grpSp")
    graphicFrame = Typed(expected_type=GraphicFrame, allow_none=True)
    cxnSp = Typed(expected_type=Shape, allow_none=True)
    connectionShape = Alias("cxnSp")
    pic = Typed(expected_type=PictureFrame, allow_none=True)
    contentPart = Relation()

    clientData = Typed(expected_type=AnchorClientData)

    __elements__ = ('sp', 'grpSp', 'graphicFrame',
                    'cxnSp', 'pic', 'contentPart', 'clientData')

    def __init__(self,
                 clientData=None,
                 sp=None,
                 grpSp=None,
                 graphicFrame=None,
                 cxnSp=None,
                 pic=None,
                 contentPart=None
                 ):
        if clientData is None:
            clientData = AnchorClientData()
        self.clientData = clientData
        self.sp = sp
        self.grpSp = grpSp
        self.graphicFrame = graphicFrame
        self.cxnSp = cxnSp
        self.pic = pic
        self.contentPart = contentPart


class AbsoluteAnchor(_AnchorBase):

    tagname = "absoluteAnchor"

    pos = Typed(expected_type=XDRPoint2D)
    ext = Typed(expected_type=XDRPositiveSize2D)

    sp = _AnchorBase.sp
    grpSp = _AnchorBase.grpSp
    graphicFrame = _AnchorBase.graphicFrame
    cxnSp = _AnchorBase.cxnSp
    pic = _AnchorBase.pic
    contentPart = _AnchorBase.contentPart
    clientData = _AnchorBase.clientData

    __elements__ = ('pos', 'ext') + _AnchorBase.__elements__

    def __init__(self,
                 pos=None,
                 ext=None,
                 **kw
                ):
        if pos is None:
            pos = XDRPoint2D(0, 0)
        self.pos = pos
        if ext is None:
            ext = XDRPositiveSize2D(0, 0)
        self.ext = ext
        super().__init__(**kw)


class OneCellAnchor(_AnchorBase):

    tagname = "oneCellAnchor"

    _from = Typed(expected_type=AnchorMarker)
    ext = Typed(expected_type=XDRPositiveSize2D)

    sp = _AnchorBase.sp
    grpSp = _AnchorBase.grpSp
    graphicFrame = _AnchorBase.graphicFrame
    cxnSp = _AnchorBase.cxnSp
    pic = _AnchorBase.pic
    contentPart = _AnchorBase.contentPart
    clientData = _AnchorBase.clientData

    __elements__ = ('_from', 'ext') + _AnchorBase.__elements__


    def __init__(self,
                 _from=None,
                 ext=None,
                 **kw
                ):
        if _from is None:
            _from = AnchorMarker()
        self._from = _from
        if ext is None:
            ext = XDRPositiveSize2D(0, 0)
        self.ext = ext
        super().__init__(**kw)


class TwoCellAnchor(_AnchorBase):

    tagname = "twoCellAnchor"

    editAs = NoneSet(values=(['twoCell', 'oneCell', 'absolute']))
    _from = Typed(expected_type=AnchorMarker)
    to = Typed(expected_type=AnchorMarker)

    sp = _AnchorBase.sp
    grpSp = _AnchorBase.grpSp
    graphicFrame = _AnchorBase.graphicFrame
    cxnSp = _AnchorBase.cxnSp
    pic = _AnchorBase.pic
    contentPart = _AnchorBase.contentPart
    clientData = _AnchorBase.clientData

    __elements__ = ('_from', 'to') + _AnchorBase.__elements__

    def __init__(self,
                 editAs=None,
                 _from=None,
                 to=None,
                 **kw
                 ):
        self.editAs = editAs
        if _from is None:
            _from = AnchorMarker()
        self._from = _from
        if to is None:
            to = AnchorMarker()
        self.to = to
        super().__init__(**kw)


def _check_anchor(obj):
    """
    Check whether an object has an existing Anchor object
    If not create a OneCellAnchor using the provided coordinate
    """
    anchor = obj.anchor
    if not isinstance(anchor, _AnchorBase):
        row, col = coordinate_to_tuple(anchor.upper())
        anchor = OneCellAnchor()
        anchor._from.row = row -1
        anchor._from.col = col -1
        if isinstance(obj, ChartBase):
            anchor.ext.width = cm_to_EMU(obj.width)
            anchor.ext.height = cm_to_EMU(obj.height)
        elif isinstance(obj, Image):
            anchor.ext.width = pixels_to_EMU(obj.width)
            anchor.ext.height = pixels_to_EMU(obj.height)
    return anchor


class SpreadsheetDrawing(Serialisable):

    tagname = "wsDr"
    mime_type = "application/vnd.openxmlformats-officedocument.drawing+xml"
    _rel_type = "http://schemas.openxmlformats.org/officeDocument/2006/relationships/drawing"
    _path = PartName="/xl/drawings/drawing{0}.xml"
    _id = None

    twoCellAnchor = Sequence(expected_type=TwoCellAnchor, allow_none=True)
    oneCellAnchor = Sequence(expected_type=OneCellAnchor, allow_none=True)
    absoluteAnchor = Sequence(expected_type=AbsoluteAnchor, allow_none=True)

    __elements__ = ("twoCellAnchor", "oneCellAnchor", "absoluteAnchor")

    def __init__(self,
                 twoCellAnchor=(),
                 oneCellAnchor=(),
                 absoluteAnchor=(),
                 ):
        self.twoCellAnchor = twoCellAnchor
        self.oneCellAnchor = oneCellAnchor
        self.absoluteAnchor = absoluteAnchor
        self.charts = []
        self.images = []
        self._rels = []


    def __hash__(self):
        """
        Just need to check for identity
        """
        return id(self)


    def __bool__(self):
        return bool(self.charts) or bool(self.images)



    def _write(self):
        """
        create required structure and the serialise
        """
        anchors = []
        for idx, obj in enumerate(self.charts + self.images, 1):
            anchor = _check_anchor(obj)
            if isinstance(obj, ChartBase):
                rel = Relationship(type="chart", Target=obj.path)
                anchor.graphicFrame = self._chart_frame(idx)
            elif isinstance(obj, Image):
                rel = Relationship(type="image", Target=obj.path)
                child = anchor.pic or anchor.groupShape and anchor.groupShape.pic
                if not child:
                    anchor.pic = self._picture_frame(idx)
                else:
                    child.blipFill.blip.embed = "rId{0}".format(idx)

            anchors.append(anchor)
            self._rels.append(rel)

        for a in anchors:
            if isinstance(a, OneCellAnchor):
                self.oneCellAnchor.append(a)
            elif isinstance(a, TwoCellAnchor):
                self.twoCellAnchor.append(a)
            else:
                self.absoluteAnchor.append(a)

        tree = self.to_tree()
        tree.set('xmlns', SHEET_DRAWING_NS)
        return tree


    def _chart_frame(self, idx):
        chart_rel = ChartRelation(f"rId{idx}")
        frame = GraphicFrame()
        nv = frame.nvGraphicFramePr.cNvPr
        nv.id = idx
        nv.name = "Chart {0}".format(idx)
        frame.graphic.graphicData.chart = chart_rel
        return frame


    def _picture_frame(self, idx):
        pic = PictureFrame()
        pic.nvPicPr.cNvPr.descr = "Picture"
        pic.nvPicPr.cNvPr.id = idx
        pic.nvPicPr.cNvPr.name = "Image {0}".format(idx)

        pic.blipFill.blip = Blip()
        pic.blipFill.blip.embed = "rId{0}".format(idx)
        pic.blipFill.blip.cstate = "print"

        pic.spPr.prstGeom = PresetGeometry2D(prst="rect")
        pic.spPr.ln = None
        return pic


    def _write_rels(self):
        rels = RelationshipList()
        for r in self._rels:
            rels.append(r)
        return rels.to_tree()


    @property
    def path(self):
        return self._path.format(self._id)


    @property
    def _chart_rels(self):
        """
        Get relationship information for each chart and bind anchor to it
        """
        rels = []
        anchors = self.absoluteAnchor + self.oneCellAnchor + self.twoCellAnchor
        for anchor in anchors:
            if anchor.graphicFrame is not None:
                graphic = anchor.graphicFrame.graphic
                rel = graphic.graphicData.chart
                if rel is not None:
                    rel.anchor = anchor
                    rel.anchor.graphicFrame = None
                    rels.append(rel)
        return rels


    @property
    def _blip_rels(self):
        """
        Get relationship information for each blip and bind anchor to it

        Images that are not part of the XLSX package will be ignored.
        """
        rels = []
        anchors = self.absoluteAnchor + self.oneCellAnchor + self.twoCellAnchor

        for anchor in anchors:
            child = anchor.pic or anchor.groupShape and anchor.groupShape.pic
            if child and child.blipFill:
                rel = child.blipFill.blip
                if rel is not None and rel.embed:
                    rel.anchor = anchor
                    rels.append(rel)

        return rels

```

---

### File: `tmp\openpyxl_sdist\openpyxl-3.1.5\openpyxl\drawing\text.py`

```python
# Copyright (c) 2010-2024 openpyxl


from openpyxl.descriptors.serialisable import Serialisable
from openpyxl.descriptors import (
    Alias,
    Typed,
    Set,
    NoneSet,
    Sequence,
    String,
    Bool,
    MinMax,
    Integer
)
from openpyxl.descriptors.excel import (
    HexBinary,
    Coordinate,
    Relation,
)
from openpyxl.descriptors.nested import (
    NestedInteger,
    NestedText,
    NestedValue,
    EmptyTag
)
from openpyxl.xml.constants import DRAWING_NS


from .colors import ColorChoiceDescriptor
from .effect import (
    EffectList,
    EffectContainer,
)
from .fill import(
    GradientFillProperties,
    BlipFillProperties,
    PatternFillProperties,
    Blip
)
from .geometry import (
    LineProperties,
    Color,
    Scene3D
)

from openpyxl.descriptors.excel import ExtensionList as OfficeArtExtensionList
from openpyxl.descriptors.nested import NestedBool


class EmbeddedWAVAudioFile(Serialisable):

    name = String(allow_none=True)

    def __init__(self,
                 name=None,
                ):
        self.name = name


class Hyperlink(Serialisable):

    tagname = "hlinkClick"
    namespace = DRAWING_NS

    invalidUrl = String(allow_none=True)
    action = String(allow_none=True)
    tgtFrame = String(allow_none=True)
    tooltip = String(allow_none=True)
    history = Bool(allow_none=True)
    highlightClick = Bool(allow_none=True)
    endSnd = Bool(allow_none=True)
    snd = Typed(expected_type=EmbeddedWAVAudioFile, allow_none=True)
    extLst = Typed(expected_type=OfficeArtExtensionList, allow_none=True)
    id = Relation(allow_none=True)

    __elements__ = ('snd',)

    def __init__(self,
                 invalidUrl=None,
                 action=None,
                 tgtFrame=None,
                 tooltip=None,
                 history=None,
                 highlightClick=None,
                 endSnd=None,
                 snd=None,
                 extLst=None,
                 id=None,
                ):
        self.invalidUrl = invalidUrl
        self.action = action
        self.tgtFrame = tgtFrame
        self.tooltip = tooltip
        self.history = history
        self.highlightClick = highlightClick
        self.endSnd = endSnd
        self.snd = snd
        self.id = id


class Font(Serialisable):

    tagname = "latin"
    namespace = DRAWING_NS

    typeface = String()
    panose = HexBinary(allow_none=True)
    pitchFamily = MinMax(min=0, max=52, allow_none=True)
    charset = Integer(allow_none=True)

    def __init__(self,
                 typeface=None,
                 panose=None,
                 pitchFamily=None,
                 charset=None,
                ):
        self.typeface = typeface
        self.panose = panose
        self.pitchFamily = pitchFamily
        self.charset = charset


class CharacterProperties(Serialisable):

    tagname = "defRPr"
    namespace = DRAWING_NS

    kumimoji = Bool(allow_none=True)
    lang = String(allow_none=True)
    altLang = String(allow_none=True)
    sz = MinMax(allow_none=True, min=100, max=400000) # 100ths of a point
    b = Bool(allow_none=True)
    i = Bool(allow_none=True)
    u = NoneSet(values=(['words', 'sng', 'dbl', 'heavy', 'dotted',
                         'dottedHeavy', 'dash', 'dashHeavy', 'dashLong', 'dashLongHeavy',
                         'dotDash', 'dotDashHeavy', 'dotDotDash', 'dotDotDashHeavy', 'wavy',
                         'wavyHeavy', 'wavyDbl']))
    strike = NoneSet(values=(['noStrike', 'sngStrike', 'dblStrike']))
    kern = Integer(allow_none=True)
    cap = NoneSet(values=(['small', 'all']))
    spc = Integer(allow_none=True)
    normalizeH = Bool(allow_none=True)
    baseline = Integer(allow_none=True)
    noProof = Bool(allow_none=True)
    dirty = Bool(allow_none=True)
    err = Bool(allow_none=True)
    smtClean = Bool(allow_none=True)
    smtId = Integer(allow_none=True)
    bmk = String(allow_none=True)
    ln = Typed(expected_type=LineProperties, allow_none=True)
    highlight = Typed(expected_type=Color, allow_none=True)
    latin = Typed(expected_type=Font, allow_none=True)
    ea = Typed(expected_type=Font, allow_none=True)
    cs = Typed(expected_type=Font, allow_none=True)
    sym = Typed(expected_type=Font, allow_none=True)
    hlinkClick = Typed(expected_type=Hyperlink, allow_none=True)
    hlinkMouseOver = Typed(expected_type=Hyperlink, allow_none=True)
    rtl = NestedBool(allow_none=True)
    extLst = Typed(expected_type=OfficeArtExtensionList, allow_none=True)
    # uses element group EG_FillProperties
    noFill = EmptyTag(namespace=DRAWING_NS)
    solidFill = ColorChoiceDescriptor()
    gradFill = Typed(expected_type=GradientFillProperties, allow_none=True)
    blipFill = Typed(expected_type=BlipFillProperties, allow_none=True)
    pattFill = Typed(expected_type=PatternFillProperties, allow_none=True)
    grpFill = EmptyTag(namespace=DRAWING_NS)
    # uses element group EG_EffectProperties
    effectLst = Typed(expected_type=EffectList, allow_none=True)
    effectDag = Typed(expected_type=EffectContainer, allow_none=True)
    # uses element group EG_TextUnderlineLine
    uLnTx = EmptyTag()
    uLn = Typed(expected_type=LineProperties, allow_none=True)
    # uses element group EG_TextUnderlineFill
    uFillTx = EmptyTag()
    uFill = EmptyTag()

    __elements__ = ('ln', 'noFill', 'solidFill', 'gradFill', 'blipFill',
                    'pattFill', 'grpFill', 'effectLst', 'effectDag', 'highlight','uLnTx',
                    'uLn', 'uFillTx', 'uFill', 'latin', 'ea', 'cs', 'sym', 'hlinkClick',
                    'hlinkMouseOver', 'rtl', )

    def __init__(self,
                 kumimoji=None,
                 lang=None,
                 altLang=None,
                 sz=None,
                 b=None,
                 i=None,
                 u=None,
                 strike=None,
                 kern=None,
                 cap=None,
                 spc=None,
                 normalizeH=None,
                 baseline=None,
                 noProof=None,
                 dirty=None,
                 err=None,
                 smtClean=None,
                 smtId=None,
                 bmk=None,
                 ln=None,
                 highlight=None,
                 latin=None,
                 ea=None,
                 cs=None,
                 sym=None,
                 hlinkClick=None,
                 hlinkMouseOver=None,
                 rtl=None,
                 extLst=None,
                 noFill=None,
                 solidFill=None,
                 gradFill=None,
                 blipFill=None,
                 pattFill=None,
                 grpFill=None,
                 effectLst=None,
                 effectDag=None,
                 uLnTx=None,
                 uLn=None,
                 uFillTx=None,
                 uFill=None,
                ):
        self.kumimoji = kumimoji
        self.lang = lang
        self.altLang = altLang
        self.sz = sz
        self.b = b
        self.i = i
        self.u = u
        self.strike = strike
        self.kern = kern
        self.cap = cap
        self.spc = spc
        self.normalizeH = normalizeH
        self.baseline = baseline
        self.noProof = noProof
        self.dirty = dirty
        self.err = err
        self.smtClean = smtClean
        self.smtId = smtId
        self.bmk = bmk
        self.ln = ln
        self.highlight = highlight
        self.latin = latin
        self.ea = ea
        self.cs = cs
        self.sym = sym
        self.hlinkClick = hlinkClick
        self.hlinkMouseOver = hlinkMouseOver
        self.rtl = rtl
        self.noFill = noFill
        self.solidFill = solidFill
        self.gradFill = gradFill
        self.blipFill = blipFill
        self.pattFill = pattFill
        self.grpFill = grpFill
        self.effectLst = effectLst
        self.effectDag = effectDag
        self.uLnTx = uLnTx
        self.uLn = uLn
        self.uFillTx = uFillTx
        self.uFill = uFill


class TabStop(Serialisable):

    pos = Typed(expected_type=Coordinate, allow_none=True)
    algn = Typed(expected_type=Set(values=(['l', 'ctr', 'r', 'dec'])))

    def __init__(self,
                 pos=None,
                 algn=None,
                ):
        self.pos = pos
        self.algn = algn


class TabStopList(Serialisable):

    tab = Typed(expected_type=TabStop, allow_none=True)

    def __init__(self,
                 tab=None,
                ):
        self.tab = tab


class Spacing(Serialisable):

    spcPct = NestedInteger(allow_none=True)
    spcPts = NestedInteger(allow_none=True)

    __elements__ = ('spcPct', 'spcPts')

    def __init__(self,
                 spcPct=None,
                 spcPts=None,
                 ):
        self.spcPct = spcPct
        self.spcPts = spcPts


class AutonumberBullet(Serialisable):

    type = Set(values=(['alphaLcParenBoth', 'alphaUcParenBoth',
                        'alphaLcParenR', 'alphaUcParenR', 'alphaLcPeriod', 'alphaUcPeriod',
                        'arabicParenBoth', 'arabicParenR', 'arabicPeriod', 'arabicPlain',
                        'romanLcParenBoth', 'romanUcParenBoth', 'romanLcParenR', 'romanUcParenR',
                        'romanLcPeriod', 'romanUcPeriod', 'circleNumDbPlain',
                        'circleNumWdBlackPlain', 'circleNumWdWhitePlain', 'arabicDbPeriod',
                        'arabicDbPlain', 'ea1ChsPeriod', 'ea1ChsPlain', 'ea1ChtPeriod',
                        'ea1ChtPlain', 'ea1JpnChsDbPeriod', 'ea1JpnKorPlain', 'ea1JpnKorPeriod',
                        'arabic1Minus', 'arabic2Minus', 'hebrew2Minus', 'thaiAlphaPeriod',
                        'thaiAlphaParenR', 'thaiAlphaParenBoth', 'thaiNumPeriod',
                        'thaiNumParenR', 'thaiNumParenBoth', 'hindiAlphaPeriod',
                        'hindiNumPeriod', 'hindiNumParenR', 'hindiAlpha1Period']))
    startAt = Integer()

    def __init__(self,
                 type=None,
                 startAt=None,
                ):
        self.type = type
        self.startAt = startAt


class ParagraphProperties(Serialisable):

    tagname = "pPr"
    namespace = DRAWING_NS

    marL = Integer(allow_none=True)
    marR = Integer(allow_none=True)
    lvl = Integer(allow_none=True)
    indent = Integer(allow_none=True)
    algn = NoneSet(values=(['l', 'ctr', 'r', 'just', 'justLow', 'dist', 'thaiDist']))
    defTabSz = Integer(allow_none=True)
    rtl = Bool(allow_none=True)
    eaLnBrk = Bool(allow_none=True)
    fontAlgn = NoneSet(values=(['auto', 't', 'ctr', 'base', 'b']))
    latinLnBrk = Bool(allow_none=True)
    hangingPunct = Bool(allow_none=True)

    # uses element group EG_TextBulletColor
    # uses element group EG_TextBulletSize
    # uses element group EG_TextBulletTypeface
    # uses element group EG_TextBullet
    lnSpc = Typed(expected_type=Spacing, allow_none=True)
    spcBef = Typed(expected_type=Spacing, allow_none=True)
    spcAft = Typed(expected_type=Spacing, allow_none=True)
    tabLst = Typed(expected_type=TabStopList, allow_none=True)
    defRPr = Typed(expected_type=CharacterProperties, allow_none=True)
    extLst = Typed(expected_type=OfficeArtExtensionList, allow_none=True)
    buClrTx = EmptyTag()
    buClr = Typed(expected_type=Color, allow_none=True)
    buSzTx = EmptyTag()
    buSzPct = NestedInteger(allow_none=True)
    buSzPts = NestedInteger(allow_none=True)
    buFontTx = EmptyTag()
    buFont = Typed(expected_type=Font, allow_none=True)
    buNone = EmptyTag()
    buAutoNum = EmptyTag()
    buChar = NestedValue(expected_type=str, attribute="char", allow_none=True)
    buBlip = NestedValue(expected_type=Blip, attribute="blip", allow_none=True)

    __elements__ = ('lnSpc', 'spcBef', 'spcAft', 'tabLst', 'defRPr',
                    'buClrTx', 'buClr', 'buSzTx', 'buSzPct', 'buSzPts', 'buFontTx', 'buFont',
                    'buNone', 'buAutoNum', 'buChar', 'buBlip')

    def __init__(self,
                 marL=None,
                 marR=None,
                 lvl=None,
                 indent=None,
                 algn=None,
                 defTabSz=None,
                 rtl=None,
                 eaLnBrk=None,
                 fontAlgn=None,
                 latinLnBrk=None,
                 hangingPunct=None,
                 lnSpc=None,
                 spcBef=None,
                 spcAft=None,
                 tabLst=None,
                 defRPr=None,
                 extLst=None,
                 buClrTx=None,
                 buClr=None,
                 buSzTx=None,
                 buSzPct=None,
                 buSzPts=None,
                 buFontTx=None,
                 buFont=None,
                 buNone=None,
                 buAutoNum=None,
                 buChar=None,
                 buBlip=None,
                 ):
        self.marL = marL
        self.marR = marR
        self.lvl = lvl
        self.indent = indent
        self.algn = algn
        self.defTabSz = defTabSz
        self.rtl = rtl
        self.eaLnBrk = eaLnBrk
        self.fontAlgn = fontAlgn
        self.latinLnBrk = latinLnBrk
        self.hangingPunct = hangingPunct
        self.lnSpc = lnSpc
        self.spcBef = spcBef
        self.spcAft = spcAft
        self.tabLst = tabLst
        self.defRPr = defRPr
        self.buClrTx = buClrTx
        self.buClr = buClr
        self.buSzTx = buSzTx
        self.buSzPct = buSzPct
        self.buSzPts = buSzPts
        self.buFontTx = buFontTx
        self.buFont = buFont
        self.buNone = buNone
        self.buAutoNum = buAutoNum
        self.buChar = buChar
        self.buBlip = buBlip
        self.defRPr = defRPr


class ListStyle(Serialisable):

    tagname = "lstStyle"
    namespace = DRAWING_NS

    defPPr = Typed(expected_type=ParagraphProperties, allow_none=True)
    lvl1pPr = Typed(expected_type=ParagraphProperties, allow_none=True)
    lvl2pPr = Typed(expected_type=ParagraphProperties, allow_none=True)
    lvl3pPr = Typed(expected_type=ParagraphProperties, allow_none=True)
    lvl4pPr = Typed(expected_type=ParagraphProperties, allow_none=True)
    lvl5pPr = Typed(expected_type=ParagraphProperties, allow_none=True)
    lvl6pPr = Typed(expected_type=ParagraphProperties, allow_none=True)
    lvl7pPr = Typed(expected_type=ParagraphProperties, allow_none=True)
    lvl8pPr = Typed(expected_type=ParagraphProperties, allow_none=True)
    lvl9pPr = Typed(expected_type=ParagraphProperties, allow_none=True)
    extLst = Typed(expected_type=OfficeArtExtensionList, allow_none=True)

    __elements__ = ("defPPr", "lvl1pPr", "lvl2pPr", "lvl3pPr", "lvl4pPr",
                    "lvl5pPr", "lvl6pPr", "lvl7pPr", "lvl8pPr", "lvl9pPr")

    def __init__(self,
                 defPPr=None,
                 lvl1pPr=None,
                 lvl2pPr=None,
                 lvl3pPr=None,
                 lvl4pPr=None,
                 lvl5pPr=None,
                 lvl6pPr=None,
                 lvl7pPr=None,
                 lvl8pPr=None,
                 lvl9pPr=None,
                 extLst=None,
                ):
        self.defPPr = defPPr
        self.lvl1pPr = lvl1pPr
        self.lvl2pPr = lvl2pPr
        self.lvl3pPr = lvl3pPr
        self.lvl4pPr = lvl4pPr
        self.lvl5pPr = lvl5pPr
        self.lvl6pPr = lvl6pPr
        self.lvl7pPr = lvl7pPr
        self.lvl8pPr = lvl8pPr
        self.lvl9pPr = lvl9pPr


class RegularTextRun(Serialisable):

    tagname = "r"
    namespace = DRAWING_NS

    rPr = Typed(expected_type=CharacterProperties, allow_none=True)
    properties = Alias("rPr")
    t = NestedText(expected_type=str)
    value = Alias("t")

    __elements__ = ('rPr', 't')

    def __init__(self,
                 rPr=None,
                 t="",
                ):
        self.rPr = rPr
        self.t = t


class LineBreak(Serialisable):

    tagname = "br"
    namespace = DRAWING_NS

    rPr = Typed(expected_type=CharacterProperties, allow_none=True)

    __elements__ = ('rPr',)

    def __init__(self,
                 rPr=None,
                ):
        self.rPr = rPr


class TextField(Serialisable):

    id = String()
    type = String(allow_none=True)
    rPr = Typed(expected_type=CharacterProperties, allow_none=True)
    pPr = Typed(expected_type=ParagraphProperties, allow_none=True)
    t = String(allow_none=True)

    __elements__ = ('rPr', 'pPr')

    def __init__(self,
                 id=None,
                 type=None,
                 rPr=None,
                 pPr=None,
                 t=None,
                ):
        self.id = id
        self.type = type
        self.rPr = rPr
        self.pPr = pPr
        self.t = t


class Paragraph(Serialisable):

    tagname = "p"
    namespace = DRAWING_NS

    # uses element group EG_TextRun
    pPr = Typed(expected_type=ParagraphProperties, allow_none=True)
    properties = Alias("pPr")
    endParaRPr = Typed(expected_type=CharacterProperties, allow_none=True)
    r = Sequence(expected_type=RegularTextRun)
    text = Alias('r')
    br = Typed(expected_type=LineBreak, allow_none=True)
    fld = Typed(expected_type=TextField, allow_none=True)

    __elements__ = ('pPr', 'r', 'br', 'fld', 'endParaRPr')

    def __init__(self,
                 pPr=None,
                 endParaRPr=None,
                 r=None,
                 br=None,
                 fld=None,
                 ):
        self.pPr = pPr
        self.endParaRPr = endParaRPr
        if r is None:
            r = [RegularTextRun()]
        self.r = r
        self.br = br
        self.fld = fld


class GeomGuide(Serialisable):

    name = String(())
    fmla = String(())

    def __init__(self,
                 name=None,
                 fmla=None,
                ):
        self.name = name
        self.fmla = fmla


class GeomGuideList(Serialisable):

    gd = Sequence(expected_type=GeomGuide, allow_none=True)

    def __init__(self,
                 gd=None,
                ):
        self.gd = gd


class PresetTextShape(Serialisable):

    prst = Typed(expected_type=Set(values=(
        ['textNoShape', 'textPlain','textStop', 'textTriangle', 'textTriangleInverted', 'textChevron',
         'textChevronInverted', 'textRingInside', 'textRingOutside', 'textArchUp',
         'textArchDown', 'textCircle', 'textButton', 'textArchUpPour',
         'textArchDownPour', 'textCirclePour', 'textButtonPour', 'textCurveUp',
         'textCurveDown', 'textCanUp', 'textCanDown', 'textWave1', 'textWave2',
         'textDoubleWave1', 'textWave4', 'textInflate', 'textDeflate',
         'textInflateBottom', 'textDeflateBottom', 'textInflateTop',
         'textDeflateTop', 'textDeflateInflate', 'textDeflateInflateDeflate',
         'textFadeRight', 'textFadeLeft', 'textFadeUp', 'textFadeDown',
         'textSlantUp', 'textSlantDown', 'textCascadeUp', 'textCascadeDown'
         ]
    )))
    avLst = Typed(expected_type=GeomGuideList, allow_none=True)

    def __init__(self,
                 prst=None,
                 avLst=None,
                ):
        self.prst = prst
        self.avLst = avLst


class TextNormalAutofit(Serialisable):

    fontScale = Integer()
    lnSpcReduction = Integer()

    def __init__(self,
                 fontScale=None,
                 lnSpcReduction=None,
                ):
        self.fontScale = fontScale
        self.lnSpcReduction = lnSpcReduction


class RichTextProperties(Serialisable):

    tagname = "bodyPr"
    namespace = DRAWING_NS

    rot = Integer(allow_none=True)
    spcFirstLastPara = Bool(allow_none=True)
    vertOverflow = NoneSet(values=(['overflow', 'ellipsis', 'clip']))
    horzOverflow = NoneSet(values=(['overflow', 'clip']))
    vert = NoneSet(values=(['horz', 'vert', 'vert270', 'wordArtVert',
                            'eaVert', 'mongolianVert', 'wordArtVertRtl']))
    wrap = NoneSet(values=(['none', 'square']))
    lIns = Integer(allow_none=True)
    tIns = Integer(allow_none=True)
    rIns = Integer(allow_none=True)
    bIns = Integer(allow_none=True)
    numCol = Integer(allow_none=True)
    spcCol = Integer(allow_none=True)
    rtlCol = Bool(allow_none=True)
    fromWordArt = Bool(allow_none=True)
    anchor = NoneSet(values=(['t', 'ctr', 'b', 'just', 'dist']))
    anchorCtr = Bool(allow_none=True)
    forceAA = Bool(allow_none=True)
    upright = Bool(allow_none=True)
    compatLnSpc = Bool(allow_none=True)
    prstTxWarp = Typed(expected_type=PresetTextShape, allow_none=True)
    scene3d = Typed(expected_type=Scene3D, allow_none=True)
    extLst = Typed(expected_type=OfficeArtExtensionList, allow_none=True)
    noAutofit = EmptyTag()
    normAutofit = EmptyTag()
    spAutoFit = EmptyTag()
    flatTx = NestedInteger(attribute="z", allow_none=True)

    __elements__ = ('prstTxWarp', 'scene3d', 'noAutofit', 'normAutofit', 'spAutoFit')

    def __init__(self,
                 rot=None,
                 spcFirstLastPara=None,
                 vertOverflow=None,
                 horzOverflow=None,
                 vert=None,
                 wrap=None,
                 lIns=None,
                 tIns=None,
                 rIns=None,
                 bIns=None,
                 numCol=None,
                 spcCol=None,
                 rtlCol=None,
                 fromWordArt=None,
                 anchor=None,
                 anchorCtr=None,
                 forceAA=None,
                 upright=None,
                 compatLnSpc=None,
                 prstTxWarp=None,
                 scene3d=None,
                 extLst=None,
                 noAutofit=None,
                 normAutofit=None,
                 spAutoFit=None,
                 flatTx=None,
                ):
        self.rot = rot
        self.spcFirstLastPara = spcFirstLastPara
        self.vertOverflow = vertOverflow
        self.horzOverflow = horzOverflow
        self.vert = vert
        self.wrap = wrap
        self.lIns = lIns
        self.tIns = tIns
        self.rIns = rIns
        self.bIns = bIns
        self.numCol = numCol
        self.spcCol = spcCol
        self.rtlCol = rtlCol
        self.fromWordArt = fromWordArt
        self.anchor = anchor
        self.anchorCtr = anchorCtr
        self.forceAA = forceAA
        self.upright = upright
        self.compatLnSpc = compatLnSpc
        self.prstTxWarp = prstTxWarp
        self.scene3d = scene3d
        self.noAutofit = noAutofit
        self.normAutofit = normAutofit
        self.spAutoFit = spAutoFit
        self.flatTx = flatTx

```

---

### File: `tmp\openpyxl_sdist\openpyxl-3.1.5\openpyxl\drawing\xdr.py`

```python
# Copyright (c) 2010-2024 openpyxl

"""
Spreadsheet Drawing has some copies of Drawing ML elements
"""

from .geometry import Point2D, PositiveSize2D, Transform2D


class XDRPoint2D(Point2D):

    namespace = None
    x = Point2D.x
    y = Point2D.y


class XDRPositiveSize2D(PositiveSize2D):

    namespace = None
    cx = PositiveSize2D.cx
    cy = PositiveSize2D.cy


class XDRTransform2D(Transform2D):

    namespace = None
    rot = Transform2D.rot
    flipH = Transform2D.flipH
    flipV = Transform2D.flipV
    off = Transform2D.off
    ext = Transform2D.ext
    chOff = Transform2D.chOff
    chExt = Transform2D.chExt

```

---

### File: `tmp\openpyxl_sdist\openpyxl-3.1.5\openpyxl\formatting\__init__.py`

```python
# Copyright (c) 2010-2024 openpyxl

from .rule import Rule

```

---

### File: `tmp\openpyxl_sdist\openpyxl-3.1.5\openpyxl\formatting\formatting.py`

```python
# Copyright (c) 2010-2024 openpyxl

from collections import OrderedDict

from openpyxl.descriptors import (
    Bool,
    Sequence,
    Alias,
    Convertible,
)
from openpyxl.descriptors.serialisable import Serialisable

from .rule import Rule

from openpyxl.worksheet.cell_range import MultiCellRange

class ConditionalFormatting(Serialisable):

    tagname = "conditionalFormatting"

    sqref = Convertible(expected_type=MultiCellRange)
    cells = Alias("sqref")
    pivot = Bool(allow_none=True)
    cfRule = Sequence(expected_type=Rule)
    rules = Alias("cfRule")


    def __init__(self, sqref=(), pivot=None, cfRule=(), extLst=None):
        self.sqref = sqref
        self.pivot = pivot
        self.cfRule = cfRule


    def __eq__(self, other):
        if not isinstance(other, self.__class__):
            return False
        return self.sqref == other.sqref


    def __hash__(self):
        return hash(self.sqref)


    def __repr__(self):
        return "<{cls} {cells}>".format(cls=self.__class__.__name__, cells=self.sqref)


    def __contains__(self, coord):
        """
        Check whether a certain cell is affected by the formatting
        """
        return coord in self.sqref


class ConditionalFormattingList:
    """Conditional formatting rules."""


    def __init__(self):
        self._cf_rules = OrderedDict()
        self.max_priority = 0


    def add(self, range_string, cfRule):
        """Add a rule such as ColorScaleRule, FormulaRule or CellIsRule

         The priority will be added automatically.
        """
        cf = range_string
        if isinstance(range_string, str):
            cf = ConditionalFormatting(range_string)
        if not isinstance(cfRule, Rule):
            raise ValueError("Only instances of openpyxl.formatting.rule.Rule may be added")
        rule = cfRule
        self.max_priority += 1
        if not rule.priority:
            rule.priority = self.max_priority

        self._cf_rules.setdefault(cf, []).append(rule)


    def __bool__(self):
        return bool(self._cf_rules)


    def __len__(self):
        return len(self._cf_rules)


    def __iter__(self):
        for cf, rules in self._cf_rules.items():
            cf.rules = rules
            yield cf


    def __getitem__(self, key):
        """
        Get the rules for a cell range
        """
        if isinstance(key, str):
            key = ConditionalFormatting(sqref=key)
        return self._cf_rules[key]


    def __delitem__(self, key):
        key = ConditionalFormatting(sqref=key)
        del self._cf_rules[key]


    def __setitem__(self, key, rule):
        """
        Add a rule for a cell range
        """
        self.add(key, rule)

```

---

### File: `tmp\openpyxl_sdist\openpyxl-3.1.5\openpyxl\formatting\rule.py`

```python
# Copyright (c) 2010-2024 openpyxl

from openpyxl.descriptors.serialisable import Serialisable
from openpyxl.descriptors import (
    Typed,
    String,
    Sequence,
    Bool,
    NoneSet,
    Set,
    Integer,
    Float,
)
from openpyxl.descriptors.excel import ExtensionList
from openpyxl.styles.colors import Color, ColorDescriptor
from openpyxl.styles.differential import DifferentialStyle

from openpyxl.utils.cell import COORD_RE


class ValueDescriptor(Float):
    """
    Expected type depends upon type attribute of parent :-(

    Most values should be numeric BUT they can also be cell references
    """

    def __set__(self, instance, value):
        ref = None
        if value is not None and isinstance(value, str):
            ref = COORD_RE.match(value)
        if instance.type == "formula" or ref:
            self.expected_type = str
        else:
            self.expected_type = float
        super().__set__(instance, value)


class FormatObject(Serialisable):

    tagname = "cfvo"

    type = Set(values=(['num', 'percent', 'max', 'min', 'formula', 'percentile']))
    val = ValueDescriptor(allow_none=True)
    gte = Bool(allow_none=True)
    extLst = Typed(expected_type=ExtensionList, allow_none=True)

    __elements__ = ()

    def __init__(self,
                 type,
                 val=None,
                 gte=None,
                 extLst=None,
                ):
        self.type = type
        self.val = val
        self.gte = gte


class RuleType(Serialisable):

    cfvo = Sequence(expected_type=FormatObject)


class IconSet(RuleType):

    tagname = "iconSet"

    iconSet = NoneSet(values=(['3Arrows', '3ArrowsGray', '3Flags',
                           '3TrafficLights1', '3TrafficLights2', '3Signs', '3Symbols', '3Symbols2',
                           '4Arrows', '4ArrowsGray', '4RedToBlack', '4Rating', '4TrafficLights',
                           '5Arrows', '5ArrowsGray', '5Rating', '5Quarters']))
    showValue = Bool(allow_none=True)
    percent = Bool(allow_none=True)
    reverse = Bool(allow_none=True)

    __elements__ = ("cfvo",)

    def __init__(self,
                 iconSet=None,
                 showValue=None,
                 percent=None,
                 reverse=None,
                 cfvo=None,
                ):
        self.iconSet = iconSet
        self.showValue = showValue
        self.percent = percent
        self.reverse = reverse
        self.cfvo = cfvo


class DataBar(RuleType):

    tagname = "dataBar"

    minLength = Integer(allow_none=True)
    maxLength = Integer(allow_none=True)
    showValue = Bool(allow_none=True)
    color = ColorDescriptor()

    __elements__ = ('cfvo', 'color')

    def __init__(self,
                 minLength=None,
                 maxLength=None,
                 showValue=None,
                 cfvo=None,
                 color=None,
                ):
        self.minLength = minLength
        self.maxLength = maxLength
        self.showValue = showValue
        self.cfvo = cfvo
        self.color = color


class ColorScale(RuleType):

    tagname = "colorScale"

    color = Sequence(expected_type=Color)

    __elements__ = ('cfvo', 'color')

    def __init__(self,
                 cfvo=None,
                 color=None,
                ):
        self.cfvo = cfvo
        self.color = color


class Rule(Serialisable):

    tagname = "cfRule"

    type = Set(values=(['expression', 'cellIs', 'colorScale', 'dataBar',
                        'iconSet', 'top10', 'uniqueValues', 'duplicateValues', 'containsText',
                        'notContainsText', 'beginsWith', 'endsWith', 'containsBlanks',
                        'notContainsBlanks', 'containsErrors', 'notContainsErrors', 'timePeriod',
                        'aboveAverage']))
    dxfId = Integer(allow_none=True)
    priority = Integer()
    stopIfTrue = Bool(allow_none=True)
    aboveAverage = Bool(allow_none=True)
    percent = Bool(allow_none=True)
    bottom = Bool(allow_none=True)
    operator = NoneSet(values=(['lessThan', 'lessThanOrEqual', 'equal',
                            'notEqual', 'greaterThanOrEqual', 'greaterThan', 'between', 'notBetween',
                            'containsText', 'notContains', 'beginsWith', 'endsWith']))
    text = String(allow_none=True)
    timePeriod = NoneSet(values=(['today', 'yesterday', 'tomorrow', 'last7Days',
                              'thisMonth', 'lastMonth', 'nextMonth', 'thisWeek', 'lastWeek',
                              'nextWeek']))
    rank = Integer(allow_none=True)
    stdDev = Integer(allow_none=True)
    equalAverage = Bool(allow_none=True)
    formula = Sequence(expected_type=str)
    colorScale = Typed(expected_type=ColorScale, allow_none=True)
    dataBar = Typed(expected_type=DataBar, allow_none=True)
    iconSet = Typed(expected_type=IconSet, allow_none=True)
    extLst = Typed(expected_type=ExtensionList, allow_none=True)
    dxf = Typed(expected_type=DifferentialStyle, allow_none=True)

    __elements__ = ('colorScale', 'dataBar', 'iconSet', 'formula')
    __attrs__ = ('type', 'rank', 'priority', 'equalAverage', 'operator',
                 'aboveAverage', 'dxfId', 'stdDev', 'stopIfTrue', 'timePeriod', 'text',
                 'percent', 'bottom')


    def __init__(self,
                 type,
                 dxfId=None,
                 priority=0,
                 stopIfTrue=None,
                 aboveAverage=None,
                 percent=None,
                 bottom=None,
                 operator=None,
                 text=None,
                 timePeriod=None,
                 rank=None,
                 stdDev=None,
                 equalAverage=None,
                 formula=(),
                 colorScale=None,
                 dataBar=None,
                 iconSet=None,
                 extLst=None,
                 dxf=None,
                ):
        self.type = type
        self.dxfId = dxfId
        self.priority = priority
        self.stopIfTrue = stopIfTrue
        self.aboveAverage = aboveAverage
        self.percent = percent
        self.bottom = bottom
        self.operator = operator
        self.text = text
        self.timePeriod = timePeriod
        self.rank = rank
        self.stdDev = stdDev
        self.equalAverage = equalAverage
        self.formula = formula
        self.colorScale = colorScale
        self.dataBar = dataBar
        self.iconSet = iconSet
        self.dxf = dxf


def ColorScaleRule(start_type=None,
                 start_value=None,
                 start_color=None,
                 mid_type=None,
                 mid_value=None,
                 mid_color=None,
                 end_type=None,
                 end_value=None,
                 end_color=None):

    """Backwards compatibility"""
    formats = []
    if start_type is not None:
        formats.append(FormatObject(type=start_type, val=start_value))
    if mid_type is not None:
        formats.append(FormatObject(type=mid_type, val=mid_value))
    if end_type is not None:
        formats.append(FormatObject(type=end_type, val=end_value))
    colors = []
    for v in (start_color, mid_color, end_color):
        if v is not None:
            if not isinstance(v, Color):
                v = Color(v)
            colors.append(v)
    cs = ColorScale(cfvo=formats, color=colors)
    rule = Rule(type="colorScale", colorScale=cs)
    return rule


def FormulaRule(formula=None, stopIfTrue=None, font=None, border=None,
                fill=None):
    """
    Conditional formatting with custom differential style
    """
    rule = Rule(type="expression", formula=formula, stopIfTrue=stopIfTrue)
    rule.dxf =  DifferentialStyle(font=font, border=border, fill=fill)
    return rule


def CellIsRule(operator=None, formula=None, stopIfTrue=None, font=None, border=None, fill=None):
    """
    Conditional formatting rule based on cell contents.
    """
    # Excel doesn't use >, >=, etc, but allow for ease of python development
    expand = {">": "greaterThan", ">=": "greaterThanOrEqual", "<": "lessThan", "<=": "lessThanOrEqual",
              "=": "equal", "==": "equal", "!=": "notEqual"}

    operator = expand.get(operator, operator)

    rule = Rule(type='cellIs', operator=operator, formula=formula, stopIfTrue=stopIfTrue)
    rule.dxf = DifferentialStyle(font=font, border=border, fill=fill)

    return rule


def IconSetRule(icon_style=None, type=None, values=None, showValue=None, percent=None, reverse=None):
    """
    Convenience function for creating icon set rules
    """
    cfvo = []
    for val in values:
        cfvo.append(FormatObject(type, val))
    icon_set = IconSet(iconSet=icon_style, cfvo=cfvo, showValue=showValue,
                       percent=percent, reverse=reverse)
    rule = Rule(type='iconSet', iconSet=icon_set)

    return rule


def DataBarRule(start_type=None, start_value=None, end_type=None,
                end_value=None, color=None, showValue=None, minLength=None, maxLength=None):
    start = FormatObject(start_type, start_value)
    end = FormatObject(end_type, end_value)
    data_bar = DataBar(cfvo=[start, end], color=color, showValue=showValue,
                       minLength=minLength, maxLength=maxLength)
    rule = Rule(type='dataBar', dataBar=data_bar)

    return rule

```

---

### File: `tmp\openpyxl_sdist\openpyxl-3.1.5\openpyxl\formula\__init__.py`

```python
# Copyright (c) 2010-2024 openpyxl

from .tokenizer import Tokenizer

```

---

### File: `tmp\openpyxl_sdist\openpyxl-3.1.5\openpyxl\formula\tokenizer.py`

```python
"""
This module contains a tokenizer for Excel formulae.

The tokenizer is based on the Javascript tokenizer found at
http://ewbi.blogs.com/develops/2004/12/excel_formula_p.html written by Eric
Bachtal
"""

import re


class TokenizerError(Exception):
    """Base class for all Tokenizer errors."""


class Tokenizer:

    """
    A tokenizer for Excel worksheet formulae.

    Converts a str string representing an Excel formula (in A1 notation)
    into a sequence of `Token` objects.

    `formula`: The str string to tokenize

    Tokenizer defines a method `._parse()` to parse the formula into tokens,
    which can then be accessed through the `.items` attribute.

    """

    SN_RE = re.compile("^[1-9](\\.[0-9]+)?[Ee]$")  # Scientific notation
    WSPACE_RE = re.compile(r"[ \n]+")
    STRING_REGEXES = {
        # Inside a string, all characters are treated as literals, except for
        # the quote character used to start the string. That character, when
        # doubled is treated as a single character in the string. If an
        # unmatched quote appears, the string is terminated.
        '"': re.compile('"(?:[^"]*"")*[^"]*"(?!")'),
        "'": re.compile("'(?:[^']*'')*[^']*'(?!')"),
    }
    ERROR_CODES = ("#NULL!", "#DIV/0!", "#VALUE!", "#REF!", "#NAME?",
                   "#NUM!", "#N/A", "#GETTING_DATA")
    TOKEN_ENDERS = ',;}) +-*/^&=><%'  # Each of these characters, marks the
                                       # end of an operand token

    def __init__(self, formula):
        self.formula = formula
        self.items = []
        self.token_stack = []  # Used to keep track of arrays, functions, and
                               # parentheses
        self.offset = 0  # How many chars have we read
        self.token = []  # Used to build up token values char by char
        self._parse()

    def _parse(self):
        """Populate self.items with the tokens from the formula."""
        if self.offset:
            return  # Already parsed!
        if not self.formula:
            return
        elif self.formula[0] == '=':
            self.offset += 1
        else:
            self.items.append(Token(self.formula, Token.LITERAL))
            return
        consumers = (
            ('"\'', self._parse_string),
            ('[', self._parse_brackets),
            ('#', self._parse_error),
            (' ', self._parse_whitespace),
            ('\n', self._parse_whitespace),
            ('+-*/^&=><%', self._parse_operator),
            ('{(', self._parse_opener),
            (')}', self._parse_closer),
            (';,', self._parse_separator),
        )
        dispatcher = {}  # maps chars to the specific parsing function
        for chars, consumer in consumers:
            dispatcher.update(dict.fromkeys(chars, consumer))
        while self.offset < len(self.formula):
            if self.check_scientific_notation():  # May consume one character
                continue
            curr_char = self.formula[self.offset]
            if curr_char in self.TOKEN_ENDERS:
                self.save_token()
            if curr_char in dispatcher:
                self.offset += dispatcher[curr_char]()
            else:
                # TODO: this can probably be sped up using a regex to get to
                # the next interesting character
                self.token.append(curr_char)
                self.offset += 1
        self.save_token()

    def _parse_string(self):
        """
        Parse a "-delimited string or '-delimited link.

        The offset must be pointing to either a single quote ("'") or double
        quote ('"') character. The strings are parsed according to Excel
        rules where to escape the delimiter you just double it up. E.g.,
        "abc""def" in Excel is parsed as 'abc"def' in Python.

        Returns the number of characters matched. (Does not update
        self.offset)

        """
        self.assert_empty_token(can_follow=':')
        delim = self.formula[self.offset]
        assert delim in ('"', "'")
        regex = self.STRING_REGEXES[delim]
        match = regex.match(self.formula[self.offset:])
        if match is None:
            subtype = "string" if delim == '"' else 'link'
            raise TokenizerError(f"Reached end of formula while parsing {subtype} in {self.formula}")
        match = match.group(0)
        if delim == '"':
            self.items.append(Token.make_operand(match))
        else:
            self.token.append(match)
        return len(match)

    def _parse_brackets(self):
        """
        Consume all the text between square brackets [].

        Returns the number of characters matched. (Does not update
        self.offset)

        """
        assert self.formula[self.offset] == '['
        lefts = [(t.start(), 1) for t in
                 re.finditer(r"\[", self.formula[self.offset:])]
        rights = [(t.start(), -1) for t in
                  re.finditer(r"\]", self.formula[self.offset:])]

        open_count = 0
        for idx, open_close in sorted(lefts + rights):
            open_count += open_close
            if open_count == 0:
                outer_right = idx + 1
                self.token.append(
                    self.formula[self.offset:self.offset + outer_right])
                return outer_right

        raise TokenizerError(f"Encountered unmatched '[' in {self.formula}")

    def _parse_error(self):
        """
        Consume the text following a '#' as an error.

        Looks for a match in self.ERROR_CODES and returns the number of
        characters matched. (Does not update self.offset)

        """
        self.assert_empty_token(can_follow='!')
        assert self.formula[self.offset] == '#'
        subformula = self.formula[self.offset:]
        for err in self.ERROR_CODES:
            if subformula.startswith(err):
                self.items.append(Token.make_operand(''.join(self.token) + err))
                del self.token[:]
                return len(err)
        raise TokenizerError(f"Invalid error code at position {self.offset} in '{self.formula}'")

    def _parse_whitespace(self):
        """
        Consume a string of consecutive spaces.

        Returns the number of spaces found. (Does not update self.offset).

        """
        assert self.formula[self.offset] in (' ', '\n')
        self.items.append(Token(self.formula[self.offset], Token.WSPACE))
        return self.WSPACE_RE.match(self.formula[self.offset:]).end()

    def _parse_operator(self):
        """
        Consume the characters constituting an operator.

        Returns the number of characters consumed. (Does not update
        self.offset)

        """
        if self.formula[self.offset:self.offset + 2] in ('>=', '<=', '<>'):
            self.items.append(Token(
                self.formula[self.offset:self.offset + 2],
                Token.OP_IN
            ))
            return 2
        curr_char = self.formula[self.offset]  # guaranteed to be 1 char
        assert curr_char in '%*/^&=><+-'
        if curr_char == '%':
            token = Token('%', Token.OP_POST)
        elif curr_char in "*/^&=><":
            token = Token(curr_char, Token.OP_IN)
        # From here on, curr_char is guaranteed to be in '+-'
        elif not self.items:
            token = Token(curr_char, Token.OP_PRE)
        else:
            prev = next((i for i in reversed(self.items)
                         if i.type != Token.WSPACE), None)
            is_infix = prev and (
                prev.subtype == Token.CLOSE
                or prev.type == Token.OP_POST
                or prev.type == Token.OPERAND
            )
            if is_infix:
                token = Token(curr_char, Token.OP_IN)
            else:
                token = Token(curr_char, Token.OP_PRE)
        self.items.append(token)
        return 1

    def _parse_opener(self):
        """
        Consumes a ( or { character.

        Returns the number of characters consumed. (Does not update
        self.offset)

        """
        assert self.formula[self.offset] in ('(', '{')
        if self.formula[self.offset] == '{':
            self.assert_empty_token()
            token = Token.make_subexp("{")
        elif self.token:
            token_value = "".join(self.token) + '('
            del self.token[:]
            token = Token.make_subexp(token_value)
        else:
            token = Token.make_subexp("(")
        self.items.append(token)
        self.token_stack.append(token)
        return 1

    def _parse_closer(self):
        """
        Consumes a } or ) character.

        Returns the number of characters consumed. (Does not update
        self.offset)

        """
        assert self.formula[self.offset] in (')', '}')
        token = self.token_stack.pop().get_closer()
        if token.value != self.formula[self.offset]:
            raise TokenizerError(
                "Mismatched ( and { pair in '%s'" % self.formula)
        self.items.append(token)
        return 1

    def _parse_separator(self):
        """
        Consumes a ; or , character.

        Returns the number of characters consumed. (Does not update
        self.offset)

        """
        curr_char = self.formula[self.offset]
        assert curr_char in (';', ',')
        if curr_char == ';':
            token = Token.make_separator(";")
        else:
            try:
                top_type = self.token_stack[-1].type
            except IndexError:
                token = Token(",", Token.OP_IN)  # Range Union operator
            else:
                if top_type == Token.PAREN:
                    token = Token(",", Token.OP_IN)  # Range Union operator
                else:
                    token = Token.make_separator(",")
        self.items.append(token)
        return 1

    def check_scientific_notation(self):
        """
        Consumes a + or - character if part of a number in sci. notation.

        Returns True if the character was consumed and self.offset was
        updated, False otherwise.

        """
        curr_char = self.formula[self.offset]
        if (curr_char in '+-'
                and len(self.token) >= 1
                and self.SN_RE.match("".join(self.token))):
            self.token.append(curr_char)
            self.offset += 1
            return True
        return False

    def assert_empty_token(self, can_follow=()):
        """
        Ensure that there's no token currently being parsed.

        Or if there is a token being parsed, it must end with a character in
        can_follow.

        If there are unconsumed token contents, it means we hit an unexpected
        token transition. In this case, we raise a TokenizerError

        """
        if self.token and self.token[-1] not in can_follow:
            raise TokenizerError(f"Unexpected character at position {self.offset} in '{self.formula}'")

    def save_token(self):
        """If there's a token being parsed, add it to the item list."""
        if self.token:
            self.items.append(Token.make_operand("".join(self.token)))
            del self.token[:]

    def render(self):
        """Convert the parsed tokens back to a string."""
        if not self.items:
            return ""
        elif self.items[0].type == Token.LITERAL:
            return self.items[0].value
        return "=" + "".join(token.value for token in self.items)


class Token:

    """
    A token in an Excel formula.

    Tokens have three attributes:

    * `value`: The string value parsed that led to this token
    * `type`: A string identifying the type of token
    * `subtype`: A string identifying subtype of the token (optional, and
                 defaults to "")

    """

    __slots__ = ['value', 'type', 'subtype']

    LITERAL = "LITERAL"
    OPERAND = "OPERAND"
    FUNC = "FUNC"
    ARRAY = "ARRAY"
    PAREN = "PAREN"
    SEP = "SEP"
    OP_PRE = "OPERATOR-PREFIX"
    OP_IN = "OPERATOR-INFIX"
    OP_POST = "OPERATOR-POSTFIX"
    WSPACE = "WHITE-SPACE"

    def __init__(self, value, type_, subtype=""):
        self.value = value
        self.type = type_
        self.subtype = subtype

    # Literal operands:
    #
    # Literal operands are always of type 'OPERAND' and can be of subtype
    # 'TEXT' (for text strings), 'NUMBER' (for all numeric types), 'LOGICAL'
    # (for TRUE and FALSE), 'ERROR' (for literal error values), or 'RANGE'
    # (for all range references).

    TEXT = 'TEXT'
    NUMBER = 'NUMBER'
    LOGICAL = 'LOGICAL'
    ERROR = 'ERROR'
    RANGE = 'RANGE'

    def __repr__(self):
        return u"{0} {1} {2}:".format(self.type, self.subtype, self.value)

    @classmethod
    def make_operand(cls, value):
        """Create an operand token."""
        if value.startswith('"'):
            subtype = cls.TEXT
        elif value.startswith('#'):
            subtype = cls.ERROR
        elif value in ('TRUE', 'FALSE'):
            subtype = cls.LOGICAL
        else:
            try:
                float(value)
                subtype = cls.NUMBER
            except ValueError:
                subtype = cls.RANGE
        return cls(value, cls.OPERAND, subtype)


    # Subexpresssions
    #
    # There are 3 types of `Subexpressions`: functions, array literals, and
    # parentheticals. Subexpressions have 'OPEN' and 'CLOSE' tokens. 'OPEN'
    # is used when parsing the initial expression token (i.e., '(' or '{')
    # and 'CLOSE' is used when parsing the closing expression token ('}' or
    # ')').

    OPEN = "OPEN"
    CLOSE = "CLOSE"

    @classmethod
    def make_subexp(cls, value, func=False):
        """
        Create a subexpression token.

        `value`: The value of the token
        `func`: If True, force the token to be of type FUNC

        """
        assert value[-1] in ('{', '}', '(', ')')
        if func:
            assert re.match('.+\\(|\\)', value)
            type_ = Token.FUNC
        elif value in '{}':
            type_ = Token.ARRAY
        elif value in '()':
            type_ = Token.PAREN
        else:
            type_ = Token.FUNC
        subtype = cls.CLOSE if value in ')}' else cls.OPEN
        return cls(value, type_, subtype)

    def get_closer(self):
        """Return a closing token that matches this token's type."""
        assert self.type in (self.FUNC, self.ARRAY, self.PAREN)
        assert self.subtype == self.OPEN
        value = "}" if self.type == self.ARRAY else ")"
        return self.make_subexp(value, func=self.type == self.FUNC)

    # Separator tokens
    #
    # Argument separators always have type 'SEP' and can have one of two
    # subtypes: 'ARG', 'ROW'. 'ARG' is used for the ',' token, when used to
    # delimit either function arguments or array elements. 'ROW' is used for
    # the ';' token, which is always used to delimit rows in an array
    # literal.

    ARG = "ARG"
    ROW = "ROW"

    @classmethod
    def make_separator(cls, value):
        """Create a separator token"""
        assert value in (',', ';')
        subtype = cls.ARG if value == ',' else cls.ROW
        return cls(value, cls.SEP, subtype)

```

---

### File: `tmp\openpyxl_sdist\openpyxl-3.1.5\openpyxl\formula\translate.py`

```python
"""
This module contains code to translate formulae across cells in a worksheet.

The idea is that if A1 has formula "=B1+C1", then translating it to cell A2
results in formula "=B2+C2". The algorithm relies on the formula tokenizer
to identify the parts of the formula that need to change.

"""

import re
from .tokenizer import Tokenizer, Token
from openpyxl.utils import (
    coordinate_to_tuple,
    column_index_from_string,
    get_column_letter
)

class TranslatorError(Exception):
    """
    Raised when a formula can't be translated across cells.

    This error arises when a formula's references would be translated outside
    the worksheet's bounds on the top or left. Excel represents these
    situations with a #REF! literal error. E.g., if the formula at B2 is
    '=A1', attempting to translate the formula to B1 raises TranslatorError,
    since there's no cell above A1. Similarly, translating the same formula
    from B2 to A2 raises TranslatorError, since there's no cell to the left of
    A1.

    """


class Translator:

    """
    Modifies a formula so that it can be translated from one cell to another.

    `formula`: The str string to translate. Must include the leading '='
               character.
    `origin`: The cell address (in A1 notation) where this formula was
              defined (excluding the worksheet name).

    """

    def __init__(self, formula, origin):
        # Excel errors out when a workbook has formulae in R1C1 notation,
        # regardless of the calcPr:refMode setting, so I'm assuming the
        # formulae stored in the workbook must be in A1 notation.
        self.row, self.col = coordinate_to_tuple(origin)
        self.tokenizer = Tokenizer(formula)

    def get_tokens(self):
        "Returns a list with the tokens comprising the formula."
        return self.tokenizer.items

    ROW_RANGE_RE = re.compile(r"(\$?[1-9][0-9]{0,6}):(\$?[1-9][0-9]{0,6})$")
    COL_RANGE_RE = re.compile(r"(\$?[A-Za-z]{1,3}):(\$?[A-Za-z]{1,3})$")
    CELL_REF_RE = re.compile(r"(\$?[A-Za-z]{1,3})(\$?[1-9][0-9]{0,6})$")

    @staticmethod
    def translate_row(row_str, rdelta):
        """
        Translate a range row-snippet by the given number of rows.
        """
        if row_str.startswith('$'):
            return row_str
        else:
            new_row = int(row_str) + rdelta
            if new_row <= 0:
                raise TranslatorError("Formula out of range")
            return str(new_row)

    @staticmethod
    def translate_col(col_str, cdelta):
        """
        Translate a range col-snippet by the given number of columns
        """
        if col_str.startswith('$'):
            return col_str
        else:
            try:
                return get_column_letter(
                    column_index_from_string(col_str) + cdelta)
            except ValueError:
                raise TranslatorError("Formula out of range")

    @staticmethod
    def strip_ws_name(range_str):
        "Splits out the worksheet reference, if any, from a range reference."
        # This code assumes that named ranges cannot contain any exclamation
        # marks. Excel refuses to create these (even using VBA), and
        # complains of a corrupt workbook when there are names with
        # exclamation marks. The ECMA spec only states that named ranges will
        # be of `ST_Xstring` type, which in theory allows '!' (char code
        # 0x21) per http://www.w3.org/TR/xml/#charsets
        if '!' in range_str:
            sheet, range_str = range_str.rsplit('!', 1)
            return sheet + "!", range_str
        return "", range_str

    @classmethod
    def translate_range(cls, range_str, rdelta, cdelta):
        """
        Translate an A1-style range reference to the destination cell.

        `rdelta`: the row offset to add to the range
        `cdelta`: the column offset to add to the range
        `range_str`: an A1-style reference to a range. Potentially includes
                     the worksheet reference. Could also be a named range.

        """
        ws_part, range_str = cls.strip_ws_name(range_str)
        match = cls.ROW_RANGE_RE.match(range_str)  # e.g. `3:4`
        if match is not None:
            return (ws_part + cls.translate_row(match.group(1), rdelta) + ":"
                    + cls.translate_row(match.group(2), rdelta))
        match = cls.COL_RANGE_RE.match(range_str)  # e.g. `A:BC`
        if match is not None:
            return (ws_part + cls.translate_col(match.group(1), cdelta) + ':'
                    + cls.translate_col(match.group(2), cdelta))
        if ':' in range_str: # e.g. `A1:B5`
            # The check is necessarily general because range references can
            # have one or both endpoints specified by named ranges. I.e.,
            # `named_range:C2`, `C2:named_range`, and `name1:name2` are all
            # valid references. Further, Excel allows chaining multiple
            # colons together (with unclear meaning)
            return ws_part + ":".join(
                cls.translate_range(piece, rdelta, cdelta)
                for piece in range_str.split(':'))
        match = cls.CELL_REF_RE.match(range_str)
        if match is None:  # Must be a named range
            return range_str
        return (ws_part + cls.translate_col(match.group(1), cdelta)
                + cls.translate_row(match.group(2), rdelta))

    def translate_formula(self, dest=None, row_delta=0, col_delta=0):
        """
        Convert the formula into A1 notation, or as row and column coordinates

        The formula is converted into A1 assuming it is assigned to the cell
        whose address is `dest` (no worksheet name).

        """
        tokens = self.get_tokens()
        if not tokens:
            return ""
        elif tokens[0].type == Token.LITERAL:
            return tokens[0].value
        out = ['=']
        # per the spec:
        # A compliant producer or consumer considers a defined name in the
        # range A1-XFD1048576 to be an error. All other names outside this
        # range can be defined as names and overrides a cell reference if an
        # ambiguity exists. (I.18.2.5)
        if dest:
            row, col = coordinate_to_tuple(dest)
            row_delta = row - self.row
            col_delta = col - self.col
        for token in tokens:
            if (token.type == Token.OPERAND
                and token.subtype == Token.RANGE):
                out.append(self.translate_range(token.value, row_delta,
                                                col_delta))
            else:
                out.append(token.value)
        return "".join(out)

```

---

### File: `tmp\openpyxl_sdist\openpyxl-3.1.5\openpyxl\packaging\__init__.py`

```python
"""
Stuff related to Office OpenXML packaging: relationships, archive, content types.
"""

```

---

### File: `tmp\openpyxl_sdist\openpyxl-3.1.5\openpyxl\packaging\core.py`

```python
# Copyright (c) 2010-2024 openpyxl

import datetime

from openpyxl.descriptors import (
    DateTime,
    Alias,
)
from openpyxl.descriptors.serialisable import Serialisable
from openpyxl.descriptors.nested import NestedText
from openpyxl.xml.functions import (
    Element,
    QName,
)
from openpyxl.xml.constants import (
    COREPROPS_NS,
    DCORE_NS,
    XSI_NS,
    DCTERMS_NS,
)


class NestedDateTime(DateTime, NestedText):

    expected_type = datetime.datetime

    def to_tree(self, tagname=None, value=None, namespace=None):
        namespace = getattr(self, "namespace", namespace)
        if namespace is not None:
            tagname = "{%s}%s" % (namespace, tagname)
        el = Element(tagname)
        if value is not None:
            value = value.replace(tzinfo=None)
            el.text = value.isoformat(timespec="seconds") + 'Z'
            return el


class QualifiedDateTime(NestedDateTime):

    """In certain situations Excel will complain if the additional type
    attribute isn't set"""

    def to_tree(self, tagname=None, value=None, namespace=None):
        el = super().to_tree(tagname, value, namespace)
        el.set("{%s}type" % XSI_NS, QName(DCTERMS_NS, "W3CDTF"))
        return el


class DocumentProperties(Serialisable):
    """High-level properties of the document.
    Defined in ECMA-376 Par2 Annex D
    """

    tagname = "coreProperties"
    namespace = COREPROPS_NS

    category = NestedText(expected_type=str, allow_none=True)
    contentStatus = NestedText(expected_type=str, allow_none=True)
    keywords = NestedText(expected_type=str, allow_none=True)
    lastModifiedBy = NestedText(expected_type=str, allow_none=True)
    lastPrinted = NestedDateTime(allow_none=True)
    revision = NestedText(expected_type=str, allow_none=True)
    version = NestedText(expected_type=str, allow_none=True)
    last_modified_by = Alias("lastModifiedBy")

    # Dublin Core Properties
    subject = NestedText(expected_type=str, allow_none=True, namespace=DCORE_NS)
    title = NestedText(expected_type=str, allow_none=True, namespace=DCORE_NS)
    creator = NestedText(expected_type=str, allow_none=True, namespace=DCORE_NS)
    description = NestedText(expected_type=str, allow_none=True, namespace=DCORE_NS)
    identifier = NestedText(expected_type=str, allow_none=True, namespace=DCORE_NS)
    language = NestedText(expected_type=str, allow_none=True, namespace=DCORE_NS)
    # Dublin Core Terms
    created = QualifiedDateTime(allow_none=True, namespace=DCTERMS_NS) # assumed to be UTC
    modified = QualifiedDateTime(allow_none=True, namespace=DCTERMS_NS) # assumed to be UTC

    __elements__ = ("creator", "title", "description", "subject","identifier",
                    "language", "created", "modified", "lastModifiedBy", "category",
                    "contentStatus", "version", "revision", "keywords", "lastPrinted",
                    )


    def __init__(self,
                 category=None,
                 contentStatus=None,
                 keywords=None,
                 lastModifiedBy=None,
                 lastPrinted=None,
                 revision=None,
                 version=None,
                 created=None,
                 creator="openpyxl",
                 description=None,
                 identifier=None,
                 language=None,
                 modified=None,
                 subject=None,
                 title=None,
                 ):
        now = datetime.datetime.now(tz=datetime.timezone.utc).replace(tzinfo=None)
        self.contentStatus = contentStatus
        self.lastPrinted = lastPrinted
        self.revision = revision
        self.version = version
        self.creator = creator
        self.lastModifiedBy = lastModifiedBy
        self.modified = modified or now
        self.created = created or now
        self.title = title
        self.subject = subject
        self.description = description
        self.identifier = identifier
        self.language = language
        self.keywords = keywords
        self.category = category

```

---

### File: `tmp\openpyxl_sdist\openpyxl-3.1.5\openpyxl\packaging\custom.py`

```python
# Copyright (c) 2010-2024 openpyxl

"""Implementation of custom properties see  22.3 in the specification"""


from warnings import warn

from openpyxl.descriptors import Strict
from openpyxl.descriptors.serialisable import Serialisable
from openpyxl.descriptors.sequence import Sequence
from openpyxl.descriptors import (
    Alias,
    String,
    Integer,
    Float,
    DateTime,
    Bool,
)
from openpyxl.descriptors.nested import (
    NestedText,
)

from openpyxl.xml.constants import (
    CUSTPROPS_NS,
    VTYPES_NS,
    CPROPS_FMTID,
)

from .core import NestedDateTime


class NestedBoolText(Bool, NestedText):
    """
    Descriptor for handling nested elements with the value stored in the text part
    """

    pass


class _CustomDocumentProperty(Serialisable):

    """
    Low-level representation of a Custom Document Property.
    Not used directly
    Must always contain a child element, even if this is empty
    """

    tagname = "property"
    _typ = None

    name = String(allow_none=True)
    lpwstr = NestedText(expected_type=str, allow_none=True, namespace=VTYPES_NS)
    i4 = NestedText(expected_type=int, allow_none=True, namespace=VTYPES_NS)
    r8 = NestedText(expected_type=float, allow_none=True, namespace=VTYPES_NS)
    filetime = NestedDateTime(allow_none=True, namespace=VTYPES_NS)
    bool = NestedBoolText(expected_type=bool, allow_none=True, namespace=VTYPES_NS)
    linkTarget = String(expected_type=str, allow_none=True)
    fmtid = String()
    pid = Integer()

    def __init__(self,
                 name=None,
                 pid=0,
                 fmtid=CPROPS_FMTID,
                 linkTarget=None,
                 **kw):
        self.fmtid = fmtid
        self.pid = pid
        self.name = name
        self._typ = None
        self.linkTarget = linkTarget

        for k, v in kw.items():
            setattr(self, k, v)
            setattr(self, "_typ", k) # ugh!
        for e in self.__elements__:
            if e not in kw:
                setattr(self, e, None)


    @property
    def type(self):
        if self._typ is not None:
            return self._typ
        for a in self.__elements__:
            if getattr(self, a) is not None:
                return a
        if self.linkTarget is not None:
            return "linkTarget"


    def to_tree(self, tagname=None, idx=None, namespace=None):
        child = getattr(self, self._typ, None)
        if child is None:
            setattr(self, self._typ, "")

        return super().to_tree(tagname=None, idx=None, namespace=None)


class _CustomDocumentPropertyList(Serialisable):

    """
    Parses and seriliases property lists but is not used directly
    """

    tagname = "Properties"

    property = Sequence(expected_type=_CustomDocumentProperty, namespace=CUSTPROPS_NS)
    customProps = Alias("property")


    def __init__(self, property=()):
        self.property = property


    def __len__(self):
        return len(self.property)


    def to_tree(self, tagname=None, idx=None, namespace=None):
        for idx, p in enumerate(self.property, 2):
            p.pid = idx
        tree = super().to_tree(tagname, idx, namespace)
        tree.set("xmlns", CUSTPROPS_NS)

        return tree


class _TypedProperty(Strict):

    name = String()

    def __init__(self,
                 name,
                 value):
        self.name = name
        self.value = value


    def __eq__(self, other):
        return self.name == other.name and self.value == other.value


    def __repr__(self):
        return f"{self.__class__.__name__}, name={self.name}, value={self.value}"


class IntProperty(_TypedProperty):

    value = Integer()


class FloatProperty(_TypedProperty):

    value = Float()


class StringProperty(_TypedProperty):

    value = String(allow_none=True)


class DateTimeProperty(_TypedProperty):

    value = DateTime()


class BoolProperty(_TypedProperty):

    value = Bool()


class LinkProperty(_TypedProperty):

    value = String()


# from Python
CLASS_MAPPING = {
    StringProperty: "lpwstr",
    IntProperty: "i4",
    FloatProperty: "r8",
    DateTimeProperty: "filetime",
    BoolProperty: "bool",
    LinkProperty: "linkTarget"
}

XML_MAPPING = {v:k for k,v in CLASS_MAPPING.items()}


class CustomPropertyList(Strict):


    props = Sequence(expected_type=_TypedProperty)

    def __init__(self):
        self.props = []


    @classmethod
    def from_tree(cls, tree):
        """
        Create list from OOXML element
        """
        prop_list = _CustomDocumentPropertyList.from_tree(tree)
        props = []

        for prop in prop_list.property:
            attr = prop.type

            typ = XML_MAPPING.get(attr, None)
            if not typ:
                warn(f"Unknown type for {prop.name}")
                continue
            value = getattr(prop, attr)
            link = prop.linkTarget
            if link is not None:
                typ = LinkProperty
                value = prop.linkTarget

            new_prop = typ(name=prop.name, value=value)
            props.append(new_prop)

        new_prop_list = cls()
        new_prop_list.props = props
        return new_prop_list


    def append(self, prop):
        if prop.name in self.names:
            raise ValueError(f"Property with name {prop.name} already exists")

        self.props.append(prop)


    def to_tree(self):
        props = []

        for p in self.props:
            attr = CLASS_MAPPING.get(p.__class__, None)
            if not attr:
                raise TypeError("Unknown adapter for {p}")
            np = _CustomDocumentProperty(name=p.name, **{attr:p.value})
            if isinstance(p, LinkProperty):
                np._typ = "lpwstr"
                #np.lpwstr = ""
            props.append(np)

        prop_list = _CustomDocumentPropertyList(property=props)
        return prop_list.to_tree()


    def __len__(self):
        return len(self.props)


    @property
    def names(self):
        """List of property names"""
        return [p.name for p in self.props]


    def __getitem__(self, name):
        """
        Get property by name
        """
        for p in self.props:
            if p.name == name:
                return p
        raise KeyError(f"Property with name {name} not found")


    def __delitem__(self, name):
        """
        Delete a propery by name
        """
        for idx, p in enumerate(self.props):
            if p.name == name:
                self.props.pop(idx)
                return
        raise KeyError(f"Property with name {name} not found")


    def __repr__(self):
        return f"{self.__class__.__name__} containing {self.props}"


    def __iter__(self):
        return iter(self.props)

```

---

### File: `tmp\openpyxl_sdist\openpyxl-3.1.5\openpyxl\packaging\extended.py`

```python
# Copyright (c) 2010-2024 openpyxl


from openpyxl.descriptors.serialisable import Serialisable
from openpyxl.descriptors import (
    Typed,
)
from openpyxl.descriptors.nested import (
    NestedText,
)

from openpyxl.xml.constants import XPROPS_NS
from openpyxl import __version__


class DigSigBlob(Serialisable):

    __elements__ = __attrs__ = ()


class VectorLpstr(Serialisable):

    __elements__ = __attrs__ = ()


class VectorVariant(Serialisable):

    __elements__ = __attrs__ = ()


class ExtendedProperties(Serialisable):

    """
    See 22.2

    Most of this is irrelevant but Excel is very picky about the version number

    It uses XX.YYYY (Version.Build) and expects everyone else to

    We provide Major.Minor and the full version in the application name
    """

    tagname = "Properties"

    Template = NestedText(expected_type=str, allow_none=True)
    Manager = NestedText(expected_type=str, allow_none=True)
    Company = NestedText(expected_type=str, allow_none=True)
    Pages = NestedText(expected_type=int, allow_none=True)
    Words = NestedText(expected_type=int,allow_none=True)
    Characters = NestedText(expected_type=int, allow_none=True)
    PresentationFormat = NestedText(expected_type=str, allow_none=True)
    Lines = NestedText(expected_type=int, allow_none=True)
    Paragraphs = NestedText(expected_type=int, allow_none=True)
    Slides = NestedText(expected_type=int, allow_none=True)
    Notes = NestedText(expected_type=int, allow_none=True)
    TotalTime = NestedText(expected_type=int, allow_none=True)
    HiddenSlides = NestedText(expected_type=int, allow_none=True)
    MMClips = NestedText(expected_type=int, allow_none=True)
    ScaleCrop = NestedText(expected_type=bool, allow_none=True)
    HeadingPairs = Typed(expected_type=VectorVariant, allow_none=True)
    TitlesOfParts = Typed(expected_type=VectorLpstr, allow_none=True)
    LinksUpToDate = NestedText(expected_type=bool, allow_none=True)
    CharactersWithSpaces = NestedText(expected_type=int, allow_none=True)
    SharedDoc = NestedText(expected_type=bool, allow_none=True)
    HyperlinkBase = NestedText(expected_type=str, allow_none=True)
    HLinks = Typed(expected_type=VectorVariant, allow_none=True)
    HyperlinksChanged = NestedText(expected_type=bool, allow_none=True)
    DigSig = Typed(expected_type=DigSigBlob, allow_none=True)
    Application = NestedText(expected_type=str, allow_none=True)
    AppVersion = NestedText(expected_type=str, allow_none=True)
    DocSecurity = NestedText(expected_type=int, allow_none=True)

    __elements__ = ('Application', 'AppVersion', 'DocSecurity', 'ScaleCrop',
                    'LinksUpToDate', 'SharedDoc', 'HyperlinksChanged')

    def __init__(self,
                 Template=None,
                 Manager=None,
                 Company=None,
                 Pages=None,
                 Words=None,
                 Characters=None,
                 PresentationFormat=None,
                 Lines=None,
                 Paragraphs=None,
                 Slides=None,
                 Notes=None,
                 TotalTime=None,
                 HiddenSlides=None,
                 MMClips=None,
                 ScaleCrop=None,
                 HeadingPairs=None,
                 TitlesOfParts=None,
                 LinksUpToDate=None,
                 CharactersWithSpaces=None,
                 SharedDoc=None,
                 HyperlinkBase=None,
                 HLinks=None,
                 HyperlinksChanged=None,
                 DigSig=None,
                 Application=None,
                 AppVersion=None,
                 DocSecurity=None,
                ):
        self.Template = Template
        self.Manager = Manager
        self.Company = Company
        self.Pages = Pages
        self.Words = Words
        self.Characters = Characters
        self.PresentationFormat = PresentationFormat
        self.Lines = Lines
        self.Paragraphs = Paragraphs
        self.Slides = Slides
        self.Notes = Notes
        self.TotalTime = TotalTime
        self.HiddenSlides = HiddenSlides
        self.MMClips = MMClips
        self.ScaleCrop = ScaleCrop
        self.HeadingPairs = None
        self.TitlesOfParts = None
        self.LinksUpToDate = LinksUpToDate
        self.CharactersWithSpaces = CharactersWithSpaces
        self.SharedDoc = SharedDoc
        self.HyperlinkBase = HyperlinkBase
        self.HLinks = None
        self.HyperlinksChanged = HyperlinksChanged
        self.DigSig = None
        self.Application = f"Microsoft Excel Compatible / Openpyxl {__version__}"
        self.AppVersion = ".".join(__version__.split(".")[:-1])
        self.DocSecurity = DocSecurity


    def to_tree(self):
        tree = super().to_tree()
        tree.set("xmlns", XPROPS_NS)
        return tree

```

---

### File: `tmp\openpyxl_sdist\openpyxl-3.1.5\openpyxl\packaging\interface.py`

```python
# Copyright (c) 2010-2024 openpyxl

from abc import abstractproperty
from openpyxl.compat.abc import ABC


class ISerialisableFile(ABC):

    """
    Interface for Serialisable classes that represent files in the archive
    """


    @abstractproperty
    def id(self):
        """
        Object id making it unique
        """
        pass


    @abstractproperty
    def _path(self):
        """
        File path in the archive
        """
        pass


    @abstractproperty
    def _namespace(self):
        """
        Qualified namespace when serialised
        """
        pass


    @abstractproperty
    def _type(self):
        """
        The content type for the manifest
        """


    @abstractproperty
    def _rel_type(self):
        """
        The content type for relationships
        """


    @abstractproperty
    def _rel_id(self):
        """
        Links object with parent
        """

```

---

### File: `tmp\openpyxl_sdist\openpyxl-3.1.5\openpyxl\packaging\manifest.py`

```python
# Copyright (c) 2010-2024 openpyxl

"""
File manifest
"""
from mimetypes import MimeTypes
import os.path

from openpyxl.descriptors.serialisable import Serialisable
from openpyxl.descriptors import String, Sequence
from openpyxl.xml.functions import fromstring
from openpyxl.xml.constants import (
    ARC_CONTENT_TYPES,
    ARC_THEME,
    ARC_STYLE,
    THEME_TYPE,
    STYLES_TYPE,
    CONTYPES_NS,
    ACTIVEX,
    CTRL,
    VBA,
)
from openpyxl.xml.functions import tostring

# initialise mime-types
mimetypes = MimeTypes()
mimetypes.add_type('application/xml', ".xml")
mimetypes.add_type('application/vnd.openxmlformats-package.relationships+xml', ".rels")
mimetypes.add_type("application/vnd.ms-office.vbaProject", ".bin")
mimetypes.add_type("application/vnd.openxmlformats-officedocument.vmlDrawing", ".vml")
mimetypes.add_type("image/x-emf", ".emf")


class FileExtension(Serialisable):

    tagname = "Default"

    Extension = String()
    ContentType = String()

    def __init__(self, Extension, ContentType):
        self.Extension = Extension
        self.ContentType = ContentType


class Override(Serialisable):

    tagname = "Override"

    PartName = String()
    ContentType = String()

    def __init__(self, PartName, ContentType):
        self.PartName = PartName
        self.ContentType = ContentType


DEFAULT_TYPES = [
    FileExtension("rels", "application/vnd.openxmlformats-package.relationships+xml"),
    FileExtension("xml", "application/xml"),
]

DEFAULT_OVERRIDE = [
    Override("/" + ARC_STYLE, STYLES_TYPE), # Styles
    Override("/" + ARC_THEME, THEME_TYPE), # Theme
    Override("/docProps/core.xml", "application/vnd.openxmlformats-package.core-properties+xml"),
    Override("/docProps/app.xml", "application/vnd.openxmlformats-officedocument.extended-properties+xml")
]


class Manifest(Serialisable):

    tagname = "Types"

    Default = Sequence(expected_type=FileExtension, unique=True)
    Override = Sequence(expected_type=Override, unique=True)
    path = "[Content_Types].xml"

    __elements__ = ("Default", "Override")

    def __init__(self,
                 Default=(),
                 Override=(),
                 ):
        if not Default:
            Default = DEFAULT_TYPES
        self.Default = Default
        if not Override:
            Override = DEFAULT_OVERRIDE
        self.Override = Override


    @property
    def filenames(self):
        return [part.PartName for part in self.Override]


    @property
    def extensions(self):
        """
        Map content types to file extensions
        Skip parts without extensions
        """
        exts = {os.path.splitext(part.PartName)[-1] for part in self.Override}
        return [(ext[1:], mimetypes.types_map[True][ext]) for ext in sorted(exts) if ext]


    def to_tree(self):
        """
        Custom serialisation method to allow setting a default namespace
        """
        defaults = [t.Extension for t in self.Default]
        for ext, mime in self.extensions:
            if ext not in defaults:
                mime = FileExtension(ext, mime)
                self.Default.append(mime)
        tree = super().to_tree()
        tree.set("xmlns", CONTYPES_NS)
        return tree


    def __contains__(self, content_type):
        """
        Check whether a particular content type is contained
        """
        for t in self.Override:
            if t.ContentType == content_type:
                return True


    def find(self, content_type):
        """
        Find specific content-type
        """
        try:
            return next(self.findall(content_type))
        except StopIteration:
            return


    def findall(self, content_type):
        """
        Find all elements of a specific content-type
        """
        for t in self.Override:
            if t.ContentType == content_type:
                yield t


    def append(self, obj):
        """
        Add content object to the package manifest
        # needs a contract...
        """
        ct = Override(PartName=obj.path, ContentType=obj.mime_type)
        self.Override.append(ct)


    def _write(self, archive, workbook):
        """
        Write manifest to the archive
        """
        self.append(workbook)
        self._write_vba(workbook)
        self._register_mimetypes(filenames=archive.namelist())
        archive.writestr(self.path, tostring(self.to_tree()))


    def _register_mimetypes(self, filenames):
        """
        Make sure that the mime type for all file extensions is registered
        """
        for fn in filenames:
            ext = os.path.splitext(fn)[-1]
            if not ext:
                continue
            mime = mimetypes.types_map[True][ext]
            fe = FileExtension(ext[1:], mime)
            self.Default.append(fe)


    def _write_vba(self, workbook):
        """
        Add content types from cached workbook when keeping VBA
        """
        if workbook.vba_archive:
            node = fromstring(workbook.vba_archive.read(ARC_CONTENT_TYPES))
            mf = Manifest.from_tree(node)
            filenames = self.filenames
            for override in mf.Override:
                if override.PartName not in (ACTIVEX, CTRL, VBA):
                    continue
                if override.PartName not in filenames:
                    self.Override.append(override)

```

---

### File: `tmp\openpyxl_sdist\openpyxl-3.1.5\openpyxl\packaging\relationship.py`

```python
# Copyright (c) 2010-2024 openpyxl

import posixpath
from warnings import warn

from openpyxl.descriptors import (
    String,
    Alias,
    Sequence,
)
from openpyxl.descriptors.serialisable import Serialisable
from openpyxl.descriptors.container import ElementList

from openpyxl.xml.constants import REL_NS, PKG_REL_NS
from openpyxl.xml.functions import (
    Element,
    fromstring,
)


class Relationship(Serialisable):
    """Represents many kinds of relationships."""

    tagname = "Relationship"

    Type = String()
    Target = String()
    target = Alias("Target")
    TargetMode = String(allow_none=True)
    Id = String(allow_none=True)
    id = Alias("Id")


    def __init__(self,
                 Id=None,
                 Type=None,
                 type=None,
                 Target=None,
                 TargetMode=None
                 ):
        """
        `type` can be used as a shorthand with the default relationships namespace
        otherwise the `Type` must be a fully qualified URL
        """
        if type is not None:
            Type = "{0}/{1}".format(REL_NS, type)
        self.Type = Type
        self.Target = Target
        self.TargetMode = TargetMode
        self.Id = Id


class RelationshipList(ElementList):

    tagname = "Relationships"
    expected_type = Relationship


    def append(self, value):
        super().append(value)
        if not value.Id:
            value.Id = f"rId{len(self)}"


    def find(self, content_type):
        """
        Find relationships by content-type
        NB. these content-types namespaced objects and different to the MIME-types
        in the package manifest :-(
        """
        for r in self:
            if r.Type == content_type:
                yield r


    def get(self, key):
        for r in self:
            if r.Id == key:
                return r
        raise KeyError("Unknown relationship: {0}".format(key))


    def to_dict(self):
        """Return a dictionary of relations keyed by id"""
        return {r.id:r for r in self}


    def to_tree(self):
        tree = super().to_tree()
        tree.set("xmlns", PKG_REL_NS)
        return tree


def get_rels_path(path):
    """
    Convert relative path to absolutes that can be loaded from a zip
    archive.
    The path to be passed in is that of containing object (workbook,
    worksheet, etc.)
    """
    folder, obj = posixpath.split(path)
    filename = posixpath.join(folder, '_rels', '{0}.rels'.format(obj))
    return filename


def get_dependents(archive, filename):
    """
    Normalise dependency file paths to absolute ones

    Relative paths are relative to parent object
    """
    src = archive.read(filename)
    node = fromstring(src)
    try:
        rels = RelationshipList.from_tree(node)
    except TypeError:
        msg = "{0} contains invalid dependency definitions".format(filename)
        warn(msg)
        rels = RelationshipList()
    folder = posixpath.dirname(filename)
    parent = posixpath.split(folder)[0]
    for r in rels:
        if r.TargetMode == "External":
            continue
        elif r.target.startswith("/"):
            r.target = r.target[1:]
        else:
            pth = posixpath.join(parent, r.target)
            r.target = posixpath.normpath(pth)
    return rels


def get_rel(archive, deps, id=None, cls=None):
    """
    Get related object based on id or rel_type
    """
    if not any([id, cls]):
        raise ValueError("Either the id or the content type are required")
    if id is not None:
        rel = deps.get(id)
    else:
        try:
            rel = next(deps.find(cls.rel_type))
        except StopIteration: # no known dependency
            return

    path = rel.target
    src = archive.read(path)
    tree = fromstring(src)
    obj = cls.from_tree(tree)

    rels_path = get_rels_path(path)
    try:
        obj.deps = get_dependents(archive, rels_path)
    except KeyError:
        obj.deps = []

    return obj

```

---

### File: `tmp\openpyxl_sdist\openpyxl-3.1.5\openpyxl\packaging\workbook.py`

```python
# Copyright (c) 2010-2024 openpyxl

from openpyxl.descriptors.serialisable import Serialisable
from openpyxl.descriptors import (
    Alias,
    Typed,
    String,
    Integer,
    Bool,
    NoneSet,
)
from openpyxl.descriptors.excel import ExtensionList, Relation
from openpyxl.descriptors.sequence import NestedSequence
from openpyxl.descriptors.nested import NestedString

from openpyxl.xml.constants import SHEET_MAIN_NS

from openpyxl.workbook.defined_name import DefinedNameList
from openpyxl.workbook.external_reference import ExternalReference
from openpyxl.workbook.function_group import FunctionGroupList
from openpyxl.workbook.properties import WorkbookProperties, CalcProperties, FileVersion
from openpyxl.workbook.protection import WorkbookProtection, FileSharing
from openpyxl.workbook.smart_tags import SmartTagList, SmartTagProperties
from openpyxl.workbook.views import CustomWorkbookView, BookView
from openpyxl.workbook.web import WebPublishing, WebPublishObjectList


class FileRecoveryProperties(Serialisable):

    tagname = "fileRecoveryPr"

    autoRecover = Bool(allow_none=True)
    crashSave = Bool(allow_none=True)
    dataExtractLoad = Bool(allow_none=True)
    repairLoad = Bool(allow_none=True)

    def __init__(self,
                 autoRecover=None,
                 crashSave=None,
                 dataExtractLoad=None,
                 repairLoad=None,
                ):
        self.autoRecover = autoRecover
        self.crashSave = crashSave
        self.dataExtractLoad = dataExtractLoad
        self.repairLoad = repairLoad


class ChildSheet(Serialisable):
    """
    Represents a reference to a worksheet or chartsheet in workbook.xml

    It contains the title, order and state but only an indirect reference to
    the objects themselves.
    """

    tagname = "sheet"

    name = String()
    sheetId = Integer()
    state = NoneSet(values=(['visible', 'hidden', 'veryHidden']))
    id = Relation()

    def __init__(self,
                 name=None,
                 sheetId=None,
                 state="visible",
                 id=None,
                ):
        self.name = name
        self.sheetId = sheetId
        self.state = state
        self.id = id


class PivotCache(Serialisable):

    tagname = "pivotCache"

    cacheId = Integer()
    id = Relation()

    def __init__(self,
                 cacheId=None,
                 id=None
                ):
        self.cacheId = cacheId
        self.id = id


class WorkbookPackage(Serialisable):

    """
    Represent the workbook file in the archive
    """

    tagname = "workbook"

    conformance = NoneSet(values=['strict', 'transitional'])
    fileVersion = Typed(expected_type=FileVersion, allow_none=True)
    fileSharing = Typed(expected_type=FileSharing, allow_none=True)
    workbookPr = Typed(expected_type=WorkbookProperties, allow_none=True)
    properties = Alias("workbookPr")
    workbookProtection = Typed(expected_type=WorkbookProtection, allow_none=True)
    bookViews = NestedSequence(expected_type=BookView)
    sheets = NestedSequence(expected_type=ChildSheet)
    functionGroups = Typed(expected_type=FunctionGroupList, allow_none=True)
    externalReferences = NestedSequence(expected_type=ExternalReference)
    definedNames = Typed(expected_type=DefinedNameList, allow_none=True)
    calcPr = Typed(expected_type=CalcProperties, allow_none=True)
    oleSize = NestedString(allow_none=True, attribute="ref")
    customWorkbookViews = NestedSequence(expected_type=CustomWorkbookView)
    pivotCaches = NestedSequence(expected_type=PivotCache, allow_none=True)
    smartTagPr = Typed(expected_type=SmartTagProperties, allow_none=True)
    smartTagTypes = Typed(expected_type=SmartTagList, allow_none=True)
    webPublishing = Typed(expected_type=WebPublishing, allow_none=True)
    fileRecoveryPr = Typed(expected_type=FileRecoveryProperties, allow_none=True)
    webPublishObjects = Typed(expected_type=WebPublishObjectList, allow_none=True)
    extLst = Typed(expected_type=ExtensionList, allow_none=True)
    Ignorable = NestedString(namespace="http://schemas.openxmlformats.org/markup-compatibility/2006", allow_none=True)

    __elements__ = ('fileVersion', 'fileSharing', 'workbookPr',
                    'workbookProtection', 'bookViews', 'sheets', 'functionGroups',
                    'externalReferences', 'definedNames', 'calcPr', 'oleSize',
                    'customWorkbookViews', 'pivotCaches', 'smartTagPr', 'smartTagTypes',
                    'webPublishing', 'fileRecoveryPr', 'webPublishObjects')

    def __init__(self,
                 conformance=None,
                 fileVersion=None,
                 fileSharing=None,
                 workbookPr=None,
                 workbookProtection=None,
                 bookViews=(),
                 sheets=(),
                 functionGroups=None,
                 externalReferences=(),
                 definedNames=None,
                 calcPr=None,
                 oleSize=None,
                 customWorkbookViews=(),
                 pivotCaches=(),
                 smartTagPr=None,
                 smartTagTypes=None,
                 webPublishing=None,
                 fileRecoveryPr=None,
                 webPublishObjects=None,
                 extLst=None,
                 Ignorable=None,
                ):
        self.conformance = conformance
        self.fileVersion = fileVersion
        self.fileSharing = fileSharing
        if workbookPr is None:
            workbookPr = WorkbookProperties()
        self.workbookPr = workbookPr
        self.workbookProtection = workbookProtection
        self.bookViews = bookViews
        self.sheets = sheets
        self.functionGroups = functionGroups
        self.externalReferences = externalReferences
        self.definedNames = definedNames
        self.calcPr = calcPr
        self.oleSize = oleSize
        self.customWorkbookViews = customWorkbookViews
        self.pivotCaches = pivotCaches
        self.smartTagPr = smartTagPr
        self.smartTagTypes = smartTagTypes
        self.webPublishing = webPublishing
        self.fileRecoveryPr = fileRecoveryPr
        self.webPublishObjects = webPublishObjects


    def to_tree(self):
        tree = super().to_tree()
        tree.set("xmlns", SHEET_MAIN_NS)
        return tree


    @property
    def active(self):
        for view in self.bookViews:
            if view.activeTab is not None:
                return view.activeTab
        return 0

```

---

### File: `tmp\openpyxl_sdist\openpyxl-3.1.5\openpyxl\pivot\__init__.py`

```python
# Copyright (c) 2010-2024 openpyxl

```

---

### File: `tmp\openpyxl_sdist\openpyxl-3.1.5\openpyxl\pivot\cache.py`

```python
# Copyright (c) 2010-2024 openpyxl

from openpyxl.descriptors.serialisable import Serialisable
from openpyxl.descriptors import (
    Typed,
    Bool,
    Float,
    Set,
    NoneSet,
    String,
    Integer,
    DateTime,
    Sequence,
)

from openpyxl.descriptors.excel import (
    HexBinary,
    ExtensionList,
    Relation,
)
from openpyxl.descriptors.nested import NestedInteger
from openpyxl.descriptors.sequence import (
    NestedSequence,
    MultiSequence,
    MultiSequencePart,
)
from openpyxl.xml.constants import SHEET_MAIN_NS
from openpyxl.xml.functions import tostring
from openpyxl.packaging.relationship import (
    RelationshipList,
    Relationship,
    get_rels_path
)

from .table import (
    PivotArea,
    Reference,
)
from .fields import (
    Boolean,
    Error,
    Missing,
    Number,
    Text,
    TupleList,
    DateTimeField,
)

class MeasureDimensionMap(Serialisable):

    tagname = "map"

    measureGroup = Integer(allow_none=True)
    dimension = Integer(allow_none=True)

    def __init__(self,
                 measureGroup=None,
                 dimension=None,
                ):
        self.measureGroup = measureGroup
        self.dimension = dimension


class MeasureGroup(Serialisable):

    tagname = "measureGroup"

    name = String()
    caption = String()

    def __init__(self,
                 name=None,
                 caption=None,
                ):
        self.name = name
        self.caption = caption


class PivotDimension(Serialisable):

    tagname = "dimension"

    measure = Bool()
    name = String()
    uniqueName = String()
    caption = String()

    def __init__(self,
                 measure=None,
                 name=None,
                 uniqueName=None,
                 caption=None,
                ):
        self.measure = measure
        self.name = name
        self.uniqueName = uniqueName
        self.caption = caption


class CalculatedMember(Serialisable):

    tagname = "calculatedMember"

    name = String()
    mdx = String()
    memberName = String(allow_none=True)
    hierarchy = String(allow_none=True)
    parent = String(allow_none=True)
    solveOrder = Integer(allow_none=True)
    set = Bool()
    extLst = Typed(expected_type=ExtensionList, allow_none=True)

    __elements__ = ()

    def __init__(self,
                 name=None,
                 mdx=None,
                 memberName=None,
                 hierarchy=None,
                 parent=None,
                 solveOrder=None,
                 set=None,
                 extLst=None,
                ):
        self.name = name
        self.mdx = mdx
        self.memberName = memberName
        self.hierarchy = hierarchy
        self.parent = parent
        self.solveOrder = solveOrder
        self.set = set
        #self.extLst = extLst


class CalculatedItem(Serialisable):

    tagname = "calculatedItem"

    field = Integer(allow_none=True)
    formula = String()
    pivotArea = Typed(expected_type=PivotArea, )
    extLst = Typed(expected_type=ExtensionList, allow_none=True)

    __elements__ = ('pivotArea', 'extLst')

    def __init__(self,
                 field=None,
                 formula=None,
                 pivotArea=None,
                 extLst=None,
                ):
        self.field = field
        self.formula = formula
        self.pivotArea = pivotArea
        self.extLst = extLst


class ServerFormat(Serialisable):

    tagname = "serverFormat"

    culture = String(allow_none=True)
    format = String(allow_none=True)

    def __init__(self,
                 culture=None,
                 format=None,
                ):
        self.culture = culture
        self.format = format


class Query(Serialisable):

    tagname = "query"

    mdx = String()
    tpls = Typed(expected_type=TupleList, allow_none=True)

    __elements__ = ('tpls',)

    def __init__(self,
                 mdx=None,
                 tpls=None,
                ):
        self.mdx = mdx
        self.tpls = tpls


class OLAPSet(Serialisable):

    tagname = "set"

    count = Integer()
    maxRank = Integer()
    setDefinition = String()
    sortType = NoneSet(values=(['ascending', 'descending', 'ascendingAlpha',
                                'descendingAlpha', 'ascendingNatural', 'descendingNatural']))
    queryFailed = Bool()
    tpls = Typed(expected_type=TupleList, allow_none=True)
    sortByTuple = Typed(expected_type=TupleList, allow_none=True)

    __elements__ = ('tpls', 'sortByTuple')

    def __init__(self,
                 count=None,
                 maxRank=None,
                 setDefinition=None,
                 sortType=None,
                 queryFailed=None,
                 tpls=None,
                 sortByTuple=None,
                ):
        self.count = count
        self.maxRank = maxRank
        self.setDefinition = setDefinition
        self.sortType = sortType
        self.queryFailed = queryFailed
        self.tpls = tpls
        self.sortByTuple = sortByTuple


class PCDSDTCEntries(Serialisable):
    # Implements CT_PCDSDTCEntries

    tagname = "entries"

    count = Integer(allow_none=True)
    # elements are choice
    m = Typed(expected_type=Missing, allow_none=True)
    n = Typed(expected_type=Number, allow_none=True)
    e = Typed(expected_type=Error, allow_none=True)
    s = Typed(expected_type=Text, allow_none=True)

    __elements__ = ('m', 'n', 'e', 's')

    def __init__(self,
                 count=None,
                 m=None,
                 n=None,
                 e=None,
                 s=None,
                ):
        self.count = count
        self.m = m
        self.n = n
        self.e = e
        self.s = s


class TupleCache(Serialisable):

    tagname = "tupleCache"

    entries = Typed(expected_type=PCDSDTCEntries, allow_none=True)
    sets = NestedSequence(expected_type=OLAPSet, count=True)
    queryCache = NestedSequence(expected_type=Query, count=True)
    serverFormats = NestedSequence(expected_type=ServerFormat, count=True)
    extLst = Typed(expected_type=ExtensionList, allow_none=True)

    __elements__ = ('entries', 'sets', 'queryCache', 'serverFormats', 'extLst')

    def __init__(self,
                 entries=None,
                 sets=(),
                 queryCache=(),
                 serverFormats=(),
                 extLst=None,
                ):
        self.entries = entries
        self.sets = sets
        self.queryCache = queryCache
        self.serverFormats = serverFormats
        self.extLst = extLst


class OLAPKPI(Serialisable):

    tagname = "kpi"

    uniqueName = String()
    caption = String(allow_none=True)
    displayFolder = String(allow_none=True)
    measureGroup = String(allow_none=True)
    parent = String(allow_none=True)
    value = String()
    goal = String(allow_none=True)
    status = String(allow_none=True)
    trend = String(allow_none=True)
    weight = String(allow_none=True)
    time = String(allow_none=True)

    def __init__(self,
                 uniqueName=None,
                 caption=None,
                 displayFolder=None,
                 measureGroup=None,
                 parent=None,
                 value=None,
                 goal=None,
                 status=None,
                 trend=None,
                 weight=None,
                 time=None,
                ):
        self.uniqueName = uniqueName
        self.caption = caption
        self.displayFolder = displayFolder
        self.measureGroup = measureGroup
        self.parent = parent
        self.value = value
        self.goal = goal
        self.status = status
        self.trend = trend
        self.weight = weight
        self.time = time


class GroupMember(Serialisable):

    tagname = "groupMember"

    uniqueName = String()
    group = Bool()

    def __init__(self,
                 uniqueName=None,
                 group=None,
                ):
        self.uniqueName = uniqueName
        self.group = group


class LevelGroup(Serialisable):

    tagname = "group"

    name = String()
    uniqueName = String()
    caption = String()
    uniqueParent = String()
    id = Integer()
    groupMembers = NestedSequence(expected_type=GroupMember, count=True)

    __elements__ = ('groupMembers',)

    def __init__(self,
                 name=None,
                 uniqueName=None,
                 caption=None,
                 uniqueParent=None,
                 id=None,
                 groupMembers=(),
                ):
        self.name = name
        self.uniqueName = uniqueName
        self.caption = caption
        self.uniqueParent = uniqueParent
        self.id = id
        self.groupMembers = groupMembers


class GroupLevel(Serialisable):

    tagname = "groupLevel"

    uniqueName = String()
    caption = String()
    user = Bool()
    customRollUp = Bool()
    groups = NestedSequence(expected_type=LevelGroup, count=True)
    extLst = Typed(expected_type=ExtensionList, allow_none=True)

    __elements__ = ('groups', 'extLst')

    def __init__(self,
                 uniqueName=None,
                 caption=None,
                 user=None,
                 customRollUp=None,
                 groups=(),
                 extLst=None,
                ):
        self.uniqueName = uniqueName
        self.caption = caption
        self.user = user
        self.customRollUp = customRollUp
        self.groups = groups
        self.extLst = extLst


class FieldUsage(Serialisable):

    tagname = "fieldUsage"

    x = Integer()

    def __init__(self,
                 x=None,
                ):
        self.x = x


class CacheHierarchy(Serialisable):

    tagname = "cacheHierarchy"

    uniqueName = String()
    caption = String(allow_none=True)
    measure = Bool()
    set = Bool()
    parentSet = Integer(allow_none=True)
    iconSet = Integer()
    attribute = Bool()
    time = Bool()
    keyAttribute = Bool()
    defaultMemberUniqueName = String(allow_none=True)
    allUniqueName = String(allow_none=True)
    allCaption = String(allow_none=True)
    dimensionUniqueName = String(allow_none=True)
    displayFolder = String(allow_none=True)
    measureGroup = String(allow_none=True)
    measures = Bool()
    count = Integer()
    oneField = Bool()
    memberValueDatatype = Integer(allow_none=True)
    unbalanced = Bool(allow_none=True)
    unbalancedGroup = Bool(allow_none=True)
    hidden = Bool()
    fieldsUsage = NestedSequence(expected_type=FieldUsage, count=True)
    groupLevels = NestedSequence(expected_type=GroupLevel, count=True)
    extLst = Typed(expected_type=ExtensionList, allow_none=True)

    __elements__ = ('fieldsUsage', 'groupLevels')

    def __init__(self,
                 uniqueName="",
                 caption=None,
                 measure=None,
                 set=None,
                 parentSet=None,
                 iconSet=0,
                 attribute=None,
                 time=None,
                 keyAttribute=None,
                 defaultMemberUniqueName=None,
                 allUniqueName=None,
                 allCaption=None,
                 dimensionUniqueName=None,
                 displayFolder=None,
                 measureGroup=None,
                 measures=None,
                 count=None,
                 oneField=None,
                 memberValueDatatype=None,
                 unbalanced=None,
                 unbalancedGroup=None,
                 hidden=None,
                 fieldsUsage=(),
                 groupLevels=(),
                 extLst=None,
                ):
        self.uniqueName = uniqueName
        self.caption = caption
        self.measure = measure
        self.set = set
        self.parentSet = parentSet
        self.iconSet = iconSet
        self.attribute = attribute
        self.time = time
        self.keyAttribute = keyAttribute
        self.defaultMemberUniqueName = defaultMemberUniqueName
        self.allUniqueName = allUniqueName
        self.allCaption = allCaption
        self.dimensionUniqueName = dimensionUniqueName
        self.displayFolder = displayFolder
        self.measureGroup = measureGroup
        self.measures = measures
        self.count = count
        self.oneField = oneField
        self.memberValueDatatype = memberValueDatatype
        self.unbalanced = unbalanced
        self.unbalancedGroup = unbalancedGroup
        self.hidden = hidden
        self.fieldsUsage = fieldsUsage
        self.groupLevels = groupLevels
        self.extLst = extLst


class GroupItems(Serialisable):

    tagname = "groupItems"

    m = Sequence(expected_type=Missing)
    n = Sequence(expected_type=Number)
    b = Sequence(expected_type=Boolean)
    e = Sequence(expected_type=Error)
    s = Sequence(expected_type=Text)
    d = Sequence(expected_type=DateTimeField,)

    __elements__ = ('m', 'n', 'b', 'e', 's', 'd')
    __attrs__ = ("count", )

    def __init__(self,
                 count=None,
                 m=(),
                 n=(),
                 b=(),
                 e=(),
                 s=(),
                 d=(),
                ):
        self.m = m
        self.n = n
        self.b = b
        self.e = e
        self.s = s
        self.d = d


    @property
    def count(self):
        return len(self.m + self.n + self.b + self.e + self.s + self.d)


class RangePr(Serialisable):

    tagname = "rangePr"

    autoStart = Bool(allow_none=True)
    autoEnd = Bool(allow_none=True)
    groupBy = NoneSet(values=(['range', 'seconds', 'minutes', 'hours', 'days',
                           'months', 'quarters', 'years']))
    startNum = Float(allow_none=True)
    endNum = Float(allow_none=True)
    startDate = DateTime(allow_none=True)
    endDate = DateTime(allow_none=True)
    groupInterval = Float(allow_none=True)

    def __init__(self,
                 autoStart=True,
                 autoEnd=True,
                 groupBy="range",
                 startNum=None,
                 endNum=None,
                 startDate=None,
                 endDate=None,
                 groupInterval=1,
                ):
        self.autoStart = autoStart
        self.autoEnd = autoEnd
        self.groupBy = groupBy
        self.startNum = startNum
        self.endNum = endNum
        self.startDate = startDate
        self.endDate = endDate
        self.groupInterval = groupInterval


class FieldGroup(Serialisable):

    tagname = "fieldGroup"

    par = Integer(allow_none=True)
    base = Integer(allow_none=True)
    rangePr = Typed(expected_type=RangePr, allow_none=True)
    discretePr = NestedSequence(expected_type=NestedInteger, count=True)
    groupItems = Typed(expected_type=GroupItems, allow_none=True)

    __elements__ = ('rangePr', 'discretePr', 'groupItems')

    def __init__(self,
                 par=None,
                 base=None,
                 rangePr=None,
                 discretePr=(),
                 groupItems=None,
                ):
        self.par = par
        self.base = base
        self.rangePr = rangePr
        self.discretePr = discretePr
        self.groupItems = groupItems


class SharedItems(Serialisable):

    tagname = "sharedItems"

    _fields = MultiSequence()
    m = MultiSequencePart(expected_type=Missing, store="_fields")
    n = MultiSequencePart(expected_type=Number, store="_fields")
    b = MultiSequencePart(expected_type=Boolean, store="_fields")
    e = MultiSequencePart(expected_type=Error, store="_fields")
    s = MultiSequencePart(expected_type=Text,  store="_fields")
    d = MultiSequencePart(expected_type=DateTimeField, store="_fields")
    # attributes are optional and must be derived from associated cache records
    containsSemiMixedTypes = Bool(allow_none=True)
    containsNonDate = Bool(allow_none=True)
    containsDate = Bool(allow_none=True)
    containsString = Bool(allow_none=True)
    containsBlank = Bool(allow_none=True)
    containsMixedTypes = Bool(allow_none=True)
    containsNumber = Bool(allow_none=True)
    containsInteger = Bool(allow_none=True)
    minValue = Float(allow_none=True)
    maxValue = Float(allow_none=True)
    minDate = DateTime(allow_none=True)
    maxDate = DateTime(allow_none=True)
    longText = Bool(allow_none=True)

    __attrs__ = ('count', 'containsBlank', 'containsDate', 'containsInteger',
                 'containsMixedTypes', 'containsNonDate', 'containsNumber',
                 'containsSemiMixedTypes', 'containsString', 'minValue', 'maxValue',
                 'minDate', 'maxDate', 'longText')

    def __init__(self,
                 _fields=(),
                 containsSemiMixedTypes=None,
                 containsNonDate=None,
                 containsDate=None,
                 containsString=None,
                 containsBlank=None,
                 containsMixedTypes=None,
                 containsNumber=None,
                 containsInteger=None,
                 minValue=None,
                 maxValue=None,
                 minDate=None,
                 maxDate=None,
                 count=None,
                 longText=None,
                ):
        self._fields = _fields
        self.containsBlank = containsBlank
        self.containsDate = containsDate
        self.containsNonDate = containsNonDate
        self.containsString = containsString
        self.containsMixedTypes = containsMixedTypes
        self.containsSemiMixedTypes = containsSemiMixedTypes
        self.containsNumber = containsNumber
        self.containsInteger = containsInteger
        self.minValue = minValue
        self.maxValue = maxValue
        self.minDate = minDate
        self.maxDate = maxDate
        self.longText = longText


    @property
    def count(self):
        return len(self._fields)


class CacheField(Serialisable):

    tagname = "cacheField"

    sharedItems = Typed(expected_type=SharedItems, allow_none=True)
    fieldGroup = Typed(expected_type=FieldGroup, allow_none=True)
    mpMap = NestedInteger(allow_none=True, attribute="v")
    extLst = Typed(expected_type=ExtensionList, allow_none=True)
    name = String()
    caption = String(allow_none=True)
    propertyName = String(allow_none=True)
    serverField = Bool(allow_none=True)
    uniqueList = Bool(allow_none=True)
    numFmtId = Integer(allow_none=True)
    formula = String(allow_none=True)
    sqlType = Integer(allow_none=True)
    hierarchy = Integer(allow_none=True)
    level = Integer(allow_none=True)
    databaseField = Bool(allow_none=True)
    mappingCount = Integer(allow_none=True)
    memberPropertyField = Bool(allow_none=True)

    __elements__ = ('sharedItems', 'fieldGroup', 'mpMap')

    def __init__(self,
                 sharedItems=None,
                 fieldGroup=None,
                 mpMap=None,
                 extLst=None,
                 name=None,
                 caption=None,
                 propertyName=None,
                 serverField=None,
                 uniqueList=True,
                 numFmtId=None,
                 formula=None,
                 sqlType=0,
                 hierarchy=0,
                 level=0,
                 databaseField=True,
                 mappingCount=None,
                 memberPropertyField=None,
                ):
        self.sharedItems = sharedItems
        self.fieldGroup = fieldGroup
        self.mpMap = mpMap
        self.extLst = extLst
        self.name = name
        self.caption = caption
        self.propertyName = propertyName
        self.serverField = serverField
        self.uniqueList = uniqueList
        self.numFmtId = numFmtId
        self.formula = formula
        self.sqlType = sqlType
        self.hierarchy = hierarchy
        self.level = level
        self.databaseField = databaseField
        self.mappingCount = mappingCount
        self.memberPropertyField = memberPropertyField


class RangeSet(Serialisable):

    tagname = "rangeSet"

    i1 = Integer(allow_none=True)
    i2 = Integer(allow_none=True)
    i3 = Integer(allow_none=True)
    i4 = Integer(allow_none=True)
    ref = String()
    name = String(allow_none=True)
    sheet = String(allow_none=True)

    def __init__(self,
                 i1=None,
                 i2=None,
                 i3=None,
                 i4=None,
                 ref=None,
                 name=None,
                 sheet=None,
                ):
        self.i1 = i1
        self.i2 = i2
        self.i3 = i3
        self.i4 = i4
        self.ref = ref
        self.name = name
        self.sheet = sheet


class PageItem(Serialisable):

    tagname = "pageItem"

    name = String()

    def __init__(self,
                 name=None,
                ):
        self.name = name


class Consolidation(Serialisable):

    tagname = "consolidation"

    autoPage = Bool(allow_none=True)
    pages = NestedSequence(expected_type=PageItem, count=True)
    rangeSets = NestedSequence(expected_type=RangeSet, count=True)

    __elements__ = ('pages', 'rangeSets')

    def __init__(self,
                 autoPage=None,
                 pages=(),
                 rangeSets=(),
                ):
        self.autoPage = autoPage
        self.pages = pages
        self.rangeSets = rangeSets


class WorksheetSource(Serialisable):

    tagname = "worksheetSource"

    ref = String(allow_none=True)
    name = String(allow_none=True)
    sheet = String(allow_none=True)

    def __init__(self,
                 ref=None,
                 name=None,
                 sheet=None,
                ):
        self.ref = ref
        self.name = name
        self.sheet = sheet


class CacheSource(Serialisable):

    tagname = "cacheSource"

    type = Set(values=(['worksheet', 'external', 'consolidation', 'scenario']))
    connectionId = Integer(allow_none=True)
    # some elements are choice
    worksheetSource = Typed(expected_type=WorksheetSource, allow_none=True)
    consolidation = Typed(expected_type=Consolidation, allow_none=True)
    extLst = Typed(expected_type=ExtensionList, allow_none=True)

    __elements__ = ('worksheetSource', 'consolidation',)

    def __init__(self,
                 type=None,
                 connectionId=None,
                 worksheetSource=None,
                 consolidation=None,
                 extLst=None,
                ):
        self.type = type
        self.connectionId = connectionId
        self.worksheetSource = worksheetSource
        self.consolidation = consolidation


class CacheDefinition(Serialisable):

    mime_type = "application/vnd.openxmlformats-officedocument.spreadsheetml.pivotCacheDefinition+xml"
    rel_type = "http://schemas.openxmlformats.org/officeDocument/2006/relationships/pivotCacheDefinition"
    _id = 1
    _path = "/xl/pivotCache/pivotCacheDefinition{0}.xml"
    records = None

    tagname = "pivotCacheDefinition"

    invalid = Bool(allow_none=True)
    saveData = Bool(allow_none=True)
    refreshOnLoad = Bool(allow_none=True)
    optimizeMemory = Bool(allow_none=True)
    enableRefresh = Bool(allow_none=True)
    refreshedBy = String(allow_none=True)
    refreshedDate = Float(allow_none=True)
    refreshedDateIso = DateTime(allow_none=True)
    backgroundQuery = Bool(allow_none=True)
    missingItemsLimit = Integer(allow_none=True)
    createdVersion = Integer(allow_none=True)
    refreshedVersion = Integer(allow_none=True)
    minRefreshableVersion = Integer(allow_none=True)
    recordCount = Integer(allow_none=True)
    upgradeOnRefresh = Bool(allow_none=True)
    supportSubquery = Bool(allow_none=True)
    supportAdvancedDrill = Bool(allow_none=True)
    cacheSource = Typed(expected_type=CacheSource)
    cacheFields = NestedSequence(expected_type=CacheField, count=True)
    cacheHierarchies = NestedSequence(expected_type=CacheHierarchy, allow_none=True)
    kpis = NestedSequence(expected_type=OLAPKPI, count=True)
    tupleCache = Typed(expected_type=TupleCache, allow_none=True)
    calculatedItems = NestedSequence(expected_type=CalculatedItem, count=True)
    calculatedMembers = NestedSequence(expected_type=CalculatedMember, count=True)
    dimensions = NestedSequence(expected_type=PivotDimension, allow_none=True)
    measureGroups = NestedSequence(expected_type=MeasureGroup, count=True)
    maps = NestedSequence(expected_type=MeasureDimensionMap, count=True)
    extLst = Typed(expected_type=ExtensionList, allow_none=True)
    id = Relation()

    __elements__ = ('cacheSource', 'cacheFields', 'cacheHierarchies', 'kpis',
                    'tupleCache', 'calculatedItems', 'calculatedMembers', 'dimensions',
                    'measureGroups', 'maps',)

    def __init__(self,
                 invalid=None,
                 saveData=None,
                 refreshOnLoad=None,
                 optimizeMemory=None,
                 enableRefresh=None,
                 refreshedBy=None,
                 refreshedDate=None,
                 refreshedDateIso=None,
                 backgroundQuery=None,
                 missingItemsLimit=None,
                 createdVersion=None,
                 refreshedVersion=None,
                 minRefreshableVersion=None,
                 recordCount=None,
                 upgradeOnRefresh=None,
                 tupleCache=None,
                 supportSubquery=None,
                 supportAdvancedDrill=None,
                 cacheSource=None,
                 cacheFields=(),
                 cacheHierarchies=(),
                 kpis=(),
                 calculatedItems=(),
                 calculatedMembers=(),
                 dimensions=(),
                 measureGroups=(),
                 maps=(),
                 extLst=None,
                 id = None,
                ):
        self.invalid = invalid
        self.saveData = saveData
        self.refreshOnLoad = refreshOnLoad
        self.optimizeMemory = optimizeMemory
        self.enableRefresh = enableRefresh
        self.refreshedBy = refreshedBy
        self.refreshedDate = refreshedDate
        self.refreshedDateIso = refreshedDateIso
        self.backgroundQuery = backgroundQuery
        self.missingItemsLimit = missingItemsLimit
        self.createdVersion = createdVersion
        self.refreshedVersion = refreshedVersion
        self.minRefreshableVersion = minRefreshableVersion
        self.recordCount = recordCount
        self.upgradeOnRefresh = upgradeOnRefresh
        self.supportSubquery = supportSubquery
        self.supportAdvancedDrill = supportAdvancedDrill
        self.cacheSource = cacheSource
        self.cacheFields = cacheFields
        self.cacheHierarchies = cacheHierarchies
        self.kpis = kpis
        self.tupleCache = tupleCache
        self.calculatedItems = calculatedItems
        self.calculatedMembers = calculatedMembers
        self.dimensions = dimensions
        self.measureGroups = measureGroups
        self.maps = maps
        self.id = id


    def to_tree(self):
        node = super().to_tree()
        node.set("xmlns", SHEET_MAIN_NS)
        return node


    @property
    def path(self):
        return self._path.format(self._id)


    def _write(self, archive, manifest):
        """
        Add to zipfile and update manifest
        """
        self._write_rels(archive, manifest)
        xml = tostring(self.to_tree())
        archive.writestr(self.path[1:], xml)
        manifest.append(self)


    def _write_rels(self, archive, manifest):
        """
        Write the relevant child objects and add links
        """
        if self.records is None:
            return

        rels = RelationshipList()
        r = Relationship(Type=self.records.rel_type, Target=self.records.path)
        rels.append(r)
        self.id = r.id
        self.records._id = self._id
        self.records._write(archive, manifest)

        path = get_rels_path(self.path)
        xml = tostring(rels.to_tree())
        archive.writestr(path[1:], xml)

```

---

### File: `tmp\openpyxl_sdist\openpyxl-3.1.5\openpyxl\pivot\fields.py`

```python
# Copyright (c) 2010-2024 openpyxl

from openpyxl.descriptors.serialisable import Serialisable
from openpyxl.descriptors import (
    Typed,
    DateTime,
    Bool,
    Float,
    String,
    Integer,
    Sequence,
)
from openpyxl.descriptors.excel import HexBinary

class Index(Serialisable):

    tagname = "x"

    v = Integer(allow_none=True)

    def __init__(self,
                 v=0,
                ):
        self.v = v


class Tuple(Serialisable):

    tagname = "tpl"

    fld = Integer(allow_none=True)
    hier = Integer(allow_none=True)
    item = Integer()

    def __init__(self,
                 fld=None,
                 hier=None,
                 item=None,
                ):
        self.fld = fld
        self.hier = hier
        self.item = item


class TupleList(Serialisable):

    tagname = "tpls"

    c = Integer(allow_none=True)
    tpl = Typed(expected_type=Tuple, )

    __elements__ = ('tpl',)

    def __init__(self,
                 c=None,
                 tpl=None,
                ):
        self.c = c
        self.tpl = tpl


class Missing(Serialisable):

    tagname = "m"

    tpls = Sequence(expected_type=TupleList)
    x = Sequence(expected_type=Index)
    u = Bool(allow_none=True)
    f = Bool(allow_none=True)
    c = String(allow_none=True)
    cp = Integer(allow_none=True)
    _in = Integer(allow_none=True)
    bc = HexBinary(allow_none=True)
    fc = HexBinary(allow_none=True)
    i = Bool(allow_none=True)
    un = Bool(allow_none=True)
    st = Bool(allow_none=True)
    b = Bool(allow_none=True)

    __elements__ = ('tpls', 'x')

    def __init__(self,
                 tpls=(),
                 x=(),
                 u=None,
                 f=None,
                 c=None,
                 cp=None,
                 _in=None,
                 bc=None,
                 fc=None,
                 i=None,
                 un=None,
                 st=None,
                 b=None,
                ):
        self.tpls = tpls
        self.x = x
        self.u = u
        self.f = f
        self.c = c
        self.cp = cp
        self._in = _in
        self.bc = bc
        self.fc = fc
        self.i = i
        self.un = un
        self.st = st
        self.b = b


class Number(Serialisable):

    tagname = "n"

    tpls = Sequence(expected_type=TupleList)
    x = Sequence(expected_type=Index)
    v = Float()
    u = Bool(allow_none=True)
    f = Bool(allow_none=True)
    c = String(allow_none=True)
    cp = Integer(allow_none=True)
    _in = Integer(allow_none=True)
    bc = HexBinary(allow_none=True)
    fc = HexBinary(allow_none=True)
    i = Bool(allow_none=True)
    un = Bool(allow_none=True)
    st = Bool(allow_none=True)
    b = Bool(allow_none=True)

    __elements__ = ('tpls', 'x')

    def __init__(self,
                 tpls=(),
                 x=(),
                 v=None,
                 u=None,
                 f=None,
                 c=None,
                 cp=None,
                 _in=None,
                 bc=None,
                 fc=None,
                 i=None,
                 un=None,
                 st=None,
                 b=None,
                ):
        self.tpls = tpls
        self.x = x
        self.v = v
        self.u = u
        self.f = f
        self.c = c
        self.cp = cp
        self._in = _in
        self.bc = bc
        self.fc = fc
        self.i = i
        self.un = un
        self.st = st
        self.b = b


class Error(Serialisable):

    tagname = "e"

    tpls = Typed(expected_type=TupleList, allow_none=True)
    x = Sequence(expected_type=Index)
    v = String()
    u = Bool(allow_none=True)
    f = Bool(allow_none=True)
    c = String(allow_none=True)
    cp = Integer(allow_none=True)
    _in = Integer(allow_none=True)
    bc = HexBinary(allow_none=True)
    fc = HexBinary(allow_none=True)
    i = Bool(allow_none=True)
    un = Bool(allow_none=True)
    st = Bool(allow_none=True)
    b = Bool(allow_none=True)

    __elements__ = ('tpls', 'x')

    def __init__(self,
                 tpls=None,
                 x=(),
                 v=None,
                 u=None,
                 f=None,
                 c=None,
                 cp=None,
                 _in=None,
                 bc=None,
                 fc=None,
                 i=None,
                 un=None,
                 st=None,
                 b=None,
                ):
        self.tpls = tpls
        self.x = x
        self.v = v
        self.u = u
        self.f = f
        self.c = c
        self.cp = cp
        self._in = _in
        self.bc = bc
        self.fc = fc
        self.i = i
        self.un = un
        self.st = st
        self.b = b


class Boolean(Serialisable):

    tagname = "b"

    x = Sequence(expected_type=Index)
    v = Bool()
    u = Bool(allow_none=True)
    f = Bool(allow_none=True)
    c = String(allow_none=True)
    cp = Integer(allow_none=True)

    __elements__ = ('x',)

    def __init__(self,
                 x=(),
                 v=None,
                 u=None,
                 f=None,
                 c=None,
                 cp=None,
                ):
        self.x = x
        self.v = v
        self.u = u
        self.f = f
        self.c = c
        self.cp = cp


class Text(Serialisable):

    tagname = "s"

    tpls = Sequence(expected_type=TupleList)
    x = Sequence(expected_type=Index)
    v = String()
    u = Bool(allow_none=True)
    f = Bool(allow_none=True)
    c = String(allow_none=True)
    cp = Integer(allow_none=True)
    _in = Integer(allow_none=True)
    bc = HexBinary(allow_none=True)
    fc = HexBinary(allow_none=True)
    i = Bool(allow_none=True)
    un = Bool(allow_none=True)
    st = Bool(allow_none=True)
    b = Bool(allow_none=True)

    __elements__ = ('tpls', 'x')

    def __init__(self,
                 tpls=(),
                 x=(),
                 v=None,
                 u=None,
                 f=None,
                 c=None,
                 cp=None,
                 _in=None,
                 bc=None,
                 fc=None,
                 i=None,
                 un=None,
                 st=None,
                 b=None,
                 ):
        self.tpls = tpls
        self.x = x
        self.v = v
        self.u = u
        self.f = f
        self.c = c
        self.cp = cp
        self._in = _in
        self.bc = bc
        self.fc = fc
        self.i = i
        self.un = un
        self.st = st
        self.b = b


class DateTimeField(Serialisable):

    tagname = "d"

    x = Sequence(expected_type=Index)
    v = DateTime()
    u = Bool(allow_none=True)
    f = Bool(allow_none=True)
    c = String(allow_none=True)
    cp = Integer(allow_none=True)

    __elements__ = ('x',)

    def __init__(self,
                 x=(),
                 v=None,
                 u=None,
                 f=None,
                 c=None,
                 cp=None,
                 ):
        self.x = x
        self.v = v
        self.u = u
        self.f = f
        self.c = c
        self.cp = cp

```

---

### File: `tmp\openpyxl_sdist\openpyxl-3.1.5\openpyxl\pivot\record.py`

```python
# Copyright (c) 2010-2024 openpyxl

from openpyxl.descriptors.serialisable import Serialisable
from openpyxl.descriptors import (
    Typed,
    Integer,
    Sequence,
)
from openpyxl.descriptors.sequence import (
    MultiSequence,
    MultiSequencePart,
)
from openpyxl.descriptors.excel import ExtensionList
from openpyxl.descriptors.nested import (
    NestedInteger,
    NestedBool,
)

from openpyxl.xml.constants import SHEET_MAIN_NS
from openpyxl.xml.functions import tostring

from .fields import (
    Boolean,
    Error,
    Missing,
    Number,
    Text,
    TupleList,
    DateTimeField,
    Index,
)


class Record(Serialisable):

    tagname = "r"

    _fields = MultiSequence()
    m = MultiSequencePart(expected_type=Missing, store="_fields")
    n = MultiSequencePart(expected_type=Number, store="_fields")
    b = MultiSequencePart(expected_type=Boolean, store="_fields")
    e = MultiSequencePart(expected_type=Error, store="_fields")
    s = MultiSequencePart(expected_type=Text,  store="_fields")
    d = MultiSequencePart(expected_type=DateTimeField, store="_fields")
    x = MultiSequencePart(expected_type=Index, store="_fields")


    def __init__(self,
                 _fields=(),
                 m=None,
                 n=None,
                 b=None,
                 e=None,
                 s=None,
                 d=None,
                 x=None,
                ):
        self._fields = _fields


class RecordList(Serialisable):

    mime_type = "application/vnd.openxmlformats-officedocument.spreadsheetml.pivotCacheRecords+xml"
    rel_type = "http://schemas.openxmlformats.org/officeDocument/2006/relationships/pivotCacheRecords"
    _id = 1
    _path = "/xl/pivotCache/pivotCacheRecords{0}.xml"

    tagname ="pivotCacheRecords"

    r = Sequence(expected_type=Record, allow_none=True)
    extLst = Typed(expected_type=ExtensionList, allow_none=True)

    __elements__ = ('r', )
    __attrs__ = ('count', )

    def __init__(self,
                 count=None,
                 r=(),
                 extLst=None,
                ):
        self.r = r
        self.extLst = extLst


    @property
    def count(self):
        return len(self.r)


    def to_tree(self):
        tree = super().to_tree()
        tree.set("xmlns", SHEET_MAIN_NS)
        return tree


    @property
    def path(self):
        return self._path.format(self._id)


    def _write(self, archive, manifest):
        """
        Write to zipfile and update manifest
        """
        xml = tostring(self.to_tree())
        archive.writestr(self.path[1:], xml)
        manifest.append(self)


    def _write_rels(self, archive, manifest):
        pass

```

---

### File: `tmp\openpyxl_sdist\openpyxl-3.1.5\openpyxl\pivot\table.py`

```python
# Copyright (c) 2010-2024 openpyxl


from collections import defaultdict
from openpyxl.descriptors.serialisable import Serialisable
from openpyxl.descriptors import (
    Typed,
    Integer,
    NoneSet,
    Set,
    Bool,
    String,
    Bool,
    Sequence,
)

from openpyxl.descriptors.excel import ExtensionList, Relation
from openpyxl.descriptors.sequence import NestedSequence
from openpyxl.xml.constants import SHEET_MAIN_NS
from openpyxl.xml.functions import tostring
from openpyxl.packaging.relationship import (
    RelationshipList,
    Relationship,
    get_rels_path
)
from .fields import Index

from openpyxl.worksheet.filters import (
    AutoFilter,
)


class HierarchyUsage(Serialisable):

    tagname = "hierarchyUsage"

    hierarchyUsage = Integer()

    def __init__(self,
                 hierarchyUsage=None,
                ):
        self.hierarchyUsage = hierarchyUsage


class ColHierarchiesUsage(Serialisable):

    tagname = "colHierarchiesUsage"

    colHierarchyUsage = Sequence(expected_type=HierarchyUsage, )

    __elements__ = ('colHierarchyUsage',)
    __attrs__ = ('count', )

    def __init__(self,
                 count=None,
                 colHierarchyUsage=(),
                ):
        self.colHierarchyUsage = colHierarchyUsage


    @property
    def count(self):
        return len(self.colHierarchyUsage)


class RowHierarchiesUsage(Serialisable):

    tagname = "rowHierarchiesUsage"

    rowHierarchyUsage = Sequence(expected_type=HierarchyUsage, )

    __elements__ = ('rowHierarchyUsage',)
    __attrs__ = ('count', )

    def __init__(self,
                 count=None,
                 rowHierarchyUsage=(),
                ):
        self.rowHierarchyUsage = rowHierarchyUsage

    @property
    def count(self):
        return len(self.rowHierarchyUsage)


class PivotFilter(Serialisable):

    tagname = "filter"

    fld = Integer()
    mpFld = Integer(allow_none=True)
    type = Set(values=(['unknown', 'count', 'percent', 'sum', 'captionEqual',
                        'captionNotEqual', 'captionBeginsWith', 'captionNotBeginsWith',
                        'captionEndsWith', 'captionNotEndsWith', 'captionContains',
                        'captionNotContains', 'captionGreaterThan', 'captionGreaterThanOrEqual',
                        'captionLessThan', 'captionLessThanOrEqual', 'captionBetween',
                        'captionNotBetween', 'valueEqual', 'valueNotEqual', 'valueGreaterThan',
                        'valueGreaterThanOrEqual', 'valueLessThan', 'valueLessThanOrEqual',
                        'valueBetween', 'valueNotBetween', 'dateEqual', 'dateNotEqual',
                        'dateOlderThan', 'dateOlderThanOrEqual', 'dateNewerThan',
                        'dateNewerThanOrEqual', 'dateBetween', 'dateNotBetween', 'tomorrow',
                        'today', 'yesterday', 'nextWeek', 'thisWeek', 'lastWeek', 'nextMonth',
                        'thisMonth', 'lastMonth', 'nextQuarter', 'thisQuarter', 'lastQuarter',
                        'nextYear', 'thisYear', 'lastYear', 'yearToDate', 'Q1', 'Q2', 'Q3', 'Q4',
                        'M1', 'M2', 'M3', 'M4', 'M5', 'M6', 'M7', 'M8', 'M9', 'M10', 'M11',
                        'M12']))
    evalOrder = Integer(allow_none=True)
    id = Integer()
    iMeasureHier = Integer(allow_none=True)
    iMeasureFld = Integer(allow_none=True)
    name = String(allow_none=True)
    description = String(allow_none=True)
    stringValue1 = String(allow_none=True)
    stringValue2 = String(allow_none=True)
    autoFilter = Typed(expected_type=AutoFilter, )
    extLst = Typed(expected_type=ExtensionList, allow_none=True)

    __elements__ = ('autoFilter',)

    def __init__(self,
                 fld=None,
                 mpFld=None,
                 type=None,
                 evalOrder=None,
                 id=None,
                 iMeasureHier=None,
                 iMeasureFld=None,
                 name=None,
                 description=None,
                 stringValue1=None,
                 stringValue2=None,
                 autoFilter=None,
                 extLst=None,
                ):
        self.fld = fld
        self.mpFld = mpFld
        self.type = type
        self.evalOrder = evalOrder
        self.id = id
        self.iMeasureHier = iMeasureHier
        self.iMeasureFld = iMeasureFld
        self.name = name
        self.description = description
        self.stringValue1 = stringValue1
        self.stringValue2 = stringValue2
        self.autoFilter = autoFilter


class PivotFilters(Serialisable):

    count = Integer()
    filter = Typed(expected_type=PivotFilter, allow_none=True)

    __elements__ = ('filter',)

    def __init__(self,
                 count=None,
                 filter=None,
                ):
        self.filter = filter


class PivotTableStyle(Serialisable):

    tagname = "pivotTableStyleInfo"

    name = String(allow_none=True)
    showRowHeaders = Bool()
    showColHeaders = Bool()
    showRowStripes = Bool()
    showColStripes = Bool()
    showLastColumn = Bool()

    def __init__(self,
                 name=None,
                 showRowHeaders=None,
                 showColHeaders=None,
                 showRowStripes=None,
                 showColStripes=None,
                 showLastColumn=None,
                ):
        self.name = name
        self.showRowHeaders = showRowHeaders
        self.showColHeaders = showColHeaders
        self.showRowStripes = showRowStripes
        self.showColStripes = showColStripes
        self.showLastColumn = showLastColumn


class MemberList(Serialisable):

    tagname = "members"

    level = Integer(allow_none=True)
    member = NestedSequence(expected_type=String, attribute="name")

    __elements__ = ('member',)

    def __init__(self,
                 count=None,
                 level=None,
                 member=(),
                ):
        self.level = level
        self.member = member

    @property
    def count(self):
        return len(self.member)


class MemberProperty(Serialisable):

    tagname = "mps"

    name = String(allow_none=True)
    showCell = Bool(allow_none=True)
    showTip = Bool(allow_none=True)
    showAsCaption = Bool(allow_none=True)
    nameLen = Integer(allow_none=True)
    pPos = Integer(allow_none=True)
    pLen = Integer(allow_none=True)
    level = Integer(allow_none=True)
    field = Integer()

    def __init__(self,
                 name=None,
                 showCell=None,
                 showTip=None,
                 showAsCaption=None,
                 nameLen=None,
                 pPos=None,
                 pLen=None,
                 level=None,
                 field=None,
                ):
        self.name = name
        self.showCell = showCell
        self.showTip = showTip
        self.showAsCaption = showAsCaption
        self.nameLen = nameLen
        self.pPos = pPos
        self.pLen = pLen
        self.level = level
        self.field = field


class PivotHierarchy(Serialisable):

    tagname = "pivotHierarchy"

    outline = Bool()
    multipleItemSelectionAllowed = Bool()
    subtotalTop = Bool()
    showInFieldList = Bool()
    dragToRow = Bool()
    dragToCol = Bool()
    dragToPage = Bool()
    dragToData = Bool()
    dragOff = Bool()
    includeNewItemsInFilter = Bool()
    caption = String(allow_none=True)
    mps = NestedSequence(expected_type=MemberProperty, count=True)
    members = Typed(expected_type=MemberList, allow_none=True)
    extLst = Typed(expected_type=ExtensionList, allow_none=True)

    __elements__ = ('mps', 'members',)

    def __init__(self,
                 outline=None,
                 multipleItemSelectionAllowed=None,
                 subtotalTop=None,
                 showInFieldList=None,
                 dragToRow=None,
                 dragToCol=None,
                 dragToPage=None,
                 dragToData=None,
                 dragOff=None,
                 includeNewItemsInFilter=None,
                 caption=None,
                 mps=(),
                 members=None,
                 extLst=None,
                ):
        self.outline = outline
        self.multipleItemSelectionAllowed = multipleItemSelectionAllowed
        self.subtotalTop = subtotalTop
        self.showInFieldList = showInFieldList
        self.dragToRow = dragToRow
        self.dragToCol = dragToCol
        self.dragToPage = dragToPage
        self.dragToData = dragToData
        self.dragOff = dragOff
        self.includeNewItemsInFilter = includeNewItemsInFilter
        self.caption = caption
        self.mps = mps
        self.members = members
        self.extLst = extLst


class Reference(Serialisable):

    tagname = "reference"

    field = Integer(allow_none=True)
    selected = Bool(allow_none=True)
    byPosition = Bool(allow_none=True)
    relative = Bool(allow_none=True)
    defaultSubtotal = Bool(allow_none=True)
    sumSubtotal = Bool(allow_none=True)
    countASubtotal = Bool(allow_none=True)
    avgSubtotal = Bool(allow_none=True)
    maxSubtotal = Bool(allow_none=True)
    minSubtotal = Bool(allow_none=True)
    productSubtotal = Bool(allow_none=True)
    countSubtotal = Bool(allow_none=True)
    stdDevSubtotal = Bool(allow_none=True)
    stdDevPSubtotal = Bool(allow_none=True)
    varSubtotal = Bool(allow_none=True)
    varPSubtotal = Bool(allow_none=True)
    x = Sequence(expected_type=Index)
    extLst = Typed(expected_type=ExtensionList, allow_none=True)

    __elements__ = ('x',)

    def __init__(self,
                 field=None,
                 count=None,
                 selected=None,
                 byPosition=None,
                 relative=None,
                 defaultSubtotal=None,
                 sumSubtotal=None,
                 countASubtotal=None,
                 avgSubtotal=None,
                 maxSubtotal=None,
                 minSubtotal=None,
                 productSubtotal=None,
                 countSubtotal=None,
                 stdDevSubtotal=None,
                 stdDevPSubtotal=None,
                 varSubtotal=None,
                 varPSubtotal=None,
                 x=(),
                 extLst=None,
                ):
        self.field = field
        self.selected = selected
        self.byPosition = byPosition
        self.relative = relative
        self.defaultSubtotal = defaultSubtotal
        self.sumSubtotal = sumSubtotal
        self.countASubtotal = countASubtotal
        self.avgSubtotal = avgSubtotal
        self.maxSubtotal = maxSubtotal
        self.minSubtotal = minSubtotal
        self.productSubtotal = productSubtotal
        self.countSubtotal = countSubtotal
        self.stdDevSubtotal = stdDevSubtotal
        self.stdDevPSubtotal = stdDevPSubtotal
        self.varSubtotal = varSubtotal
        self.varPSubtotal = varPSubtotal
        self.x = x


    @property
    def count(self):
        return len(self.field)


class PivotArea(Serialisable):

    tagname = "pivotArea"

    references = NestedSequence(expected_type=Reference, count=True)
    extLst = Typed(expected_type=ExtensionList, allow_none=True)
    field = Integer(allow_none=True)
    type = NoneSet(values=(['normal', 'data', 'all', 'origin', 'button',
                            'topEnd', 'topRight']))
    dataOnly = Bool(allow_none=True)
    labelOnly = Bool(allow_none=True)
    grandRow = Bool(allow_none=True)
    grandCol = Bool(allow_none=True)
    cacheIndex = Bool(allow_none=True)
    outline = Bool(allow_none=True)
    offset = String(allow_none=True)
    collapsedLevelsAreSubtotals = Bool(allow_none=True)
    axis = NoneSet(values=(['axisRow', 'axisCol', 'axisPage', 'axisValues']))
    fieldPosition = Integer(allow_none=True)

    __elements__ = ('references',)

    def __init__(self,
                 references=(),
                 extLst=None,
                 field=None,
                 type="normal",
                 dataOnly=True,
                 labelOnly=None,
                 grandRow=None,
                 grandCol=None,
                 cacheIndex=None,
                 outline=True,
                 offset=None,
                 collapsedLevelsAreSubtotals=None,
                 axis=None,
                 fieldPosition=None,
                ):
        self.references = references
        self.extLst = extLst
        self.field = field
        self.type = type
        self.dataOnly = dataOnly
        self.labelOnly = labelOnly
        self.grandRow = grandRow
        self.grandCol = grandCol
        self.cacheIndex = cacheIndex
        self.outline = outline
        self.offset = offset
        self.collapsedLevelsAreSubtotals = collapsedLevelsAreSubtotals
        self.axis = axis
        self.fieldPosition = fieldPosition


class ChartFormat(Serialisable):

    tagname = "chartFormat"

    chart = Integer()
    format = Integer()
    series = Bool()
    pivotArea = Typed(expected_type=PivotArea, )

    __elements__ = ('pivotArea',)

    def __init__(self,
                 chart=None,
                 format=None,
                 series=None,
                 pivotArea=None,
                ):
        self.chart = chart
        self.format = format
        self.series = series
        self.pivotArea = pivotArea


class ConditionalFormat(Serialisable):

    tagname = "conditionalFormat"

    scope = Set(values=(['selection', 'data', 'field']))
    type = NoneSet(values=(['all', 'row', 'column']))
    priority = Integer()
    pivotAreas = NestedSequence(expected_type=PivotArea)
    extLst = Typed(expected_type=ExtensionList, allow_none=True)

    __elements__ = ('pivotAreas',)

    def __init__(self,
                 scope="selection",
                 type=None,
                 priority=None,
                 pivotAreas=(),
                 extLst=None,
                ):
        self.scope = scope
        self.type = type
        self.priority = priority
        self.pivotAreas = pivotAreas
        self.extLst = extLst


class ConditionalFormatList(Serialisable):

    tagname = "conditionalFormats"

    conditionalFormat = Sequence(expected_type=ConditionalFormat)

    __attrs__ = ("count",)

    def __init__(self, conditionalFormat=(), count=None):
        self.conditionalFormat = conditionalFormat


    def by_priority(self):
        """
        Return a dictionary of format objects keyed by (field id and format property).
        This can be used to map the formats to field but also to dedupe to match
        worksheet definitions which are grouped by cell range
        """

        fmts = {}
        for fmt in self.conditionalFormat:
            for area in fmt.pivotAreas:
                for ref in area.references:
                    for field in ref.x:
                        key = (field.v, fmt.priority)
                        fmts[key] = fmt

        return fmts


    def _dedupe(self):
        """
        Group formats by field index and priority.
        Sorted to match sorting and grouping for corresponding worksheet formats

        The implemtenters notes contain significant deviance from the OOXML
        specification, in particular how conditional formats in tables relate to
        those defined in corresponding worksheets and how to determine which
        format applies to which fields.

        There are some magical interdependencies:

        * Every pivot table fmt must have a worksheet cxf with the same priority.

        * In the reference part the field 4294967294 refers to a data field, the
        spec says -2

        * Data fields are referenced by the 0-index reference.x.v value

        Things are made more complicated by the fact that field items behave
        diffently if the parent is a reference or shared item: "In Office if the
        parent is the reference element, then restrictions of this value are
        defined by reference@field. If the parent is the tables element, then
        this value specifies the index into the table tag position in @url."
        Yeah, right!
        """
        fmts = self.by_priority()
        # sort by priority in order, keeping the highest numerical priority, least when
        # actually applied
        # this is not documented but it's what Excel is happy with
        fmts = {field:fmt for (field, priority), fmt in sorted(fmts.items(), reverse=True)}
        #fmts = {field:fmt for (field, priority), fmt in fmts.items()}
        if fmts:
            self.conditionalFormat = list(fmts.values())


    @property
    def count(self):
        return len(self.conditionalFormat)


    def to_tree(self, tagname=None):
        self._dedupe()
        return super().to_tree(tagname)


class Format(Serialisable):

    tagname = "format"

    action = NoneSet(values=(['blank', 'formatting', 'drill', 'formula']))
    dxfId = Integer(allow_none=True)
    pivotArea = Typed(expected_type=PivotArea, )
    extLst = Typed(expected_type=ExtensionList, allow_none=True)

    __elements__ = ('pivotArea',)

    def __init__(self,
                 action="formatting",
                 dxfId=None,
                 pivotArea=None,
                 extLst=None,
                ):
        self.action = action
        self.dxfId = dxfId
        self.pivotArea = pivotArea
        self.extLst = extLst


class DataField(Serialisable):

    tagname = "dataField"

    name = String(allow_none=True)
    fld = Integer()
    subtotal = Set(values=(['average', 'count', 'countNums', 'max', 'min',
                            'product', 'stdDev', 'stdDevp', 'sum', 'var', 'varp']))
    showDataAs = Set(values=(['normal', 'difference', 'percent',
                              'percentDiff', 'runTotal', 'percentOfRow', 'percentOfCol',
                              'percentOfTotal', 'index']))
    baseField = Integer()
    baseItem = Integer()
    numFmtId = Integer(allow_none=True)
    extLst = Typed(expected_type=ExtensionList, allow_none=True)

    __elements__ = ()


    def __init__(self,
                 name=None,
                 fld=None,
                 subtotal="sum",
                 showDataAs="normal",
                 baseField=-1,
                 baseItem=1048832,
                 numFmtId=None,
                 extLst=None,
                ):
        self.name = name
        self.fld = fld
        self.subtotal = subtotal
        self.showDataAs = showDataAs
        self.baseField = baseField
        self.baseItem = baseItem
        self.numFmtId = numFmtId
        self.extLst = extLst


class PageField(Serialisable):

    tagname = "pageField"

    fld = Integer()
    item = Integer(allow_none=True)
    hier = Integer(allow_none=True)
    name = String(allow_none=True)
    cap = String(allow_none=True)
    extLst = Typed(expected_type=ExtensionList, allow_none=True)

    __elements__ = ()

    def __init__(self,
                 fld=None,
                 item=None,
                 hier=None,
                 name=None,
                 cap=None,
                 extLst=None,
                ):
        self.fld = fld
        self.item = item
        self.hier = hier
        self.name = name
        self.cap = cap
        self.extLst = extLst


class RowColItem(Serialisable):

    tagname = "i"

    t = Set(values=(['data', 'default', 'sum', 'countA', 'avg', 'max', 'min',
                     'product', 'count', 'stdDev', 'stdDevP', 'var', 'varP', 'grand',
                     'blank']))
    r = Integer()
    i = Integer()
    x = Sequence(expected_type=Index, attribute="v")

    __elements__ = ('x',)

    def __init__(self,
                 t="data",
                 r=0,
                 i=0,
                 x=(),
                ):
        self.t = t
        self.r = r
        self.i = i
        self.x = x


class RowColField(Serialisable):

    tagname = "field"

    x = Integer()

    def __init__(self,
                 x=None,
                ):
        self.x = x


class AutoSortScope(Serialisable):

    pivotArea = Typed(expected_type=PivotArea, )

    __elements__ = ('pivotArea',)

    def __init__(self,
                 pivotArea=None,
                ):
        self.pivotArea = pivotArea


class FieldItem(Serialisable):

    tagname = "item"

    n = String(allow_none=True)
    t = Set(values=(['data', 'default', 'sum', 'countA', 'avg', 'max', 'min',
                     'product', 'count', 'stdDev', 'stdDevP', 'var', 'varP', 'grand',
                     'blank']))
    h = Bool(allow_none=True)
    s = Bool(allow_none=True)
    sd = Bool(allow_none=True)
    f = Bool(allow_none=True)
    m = Bool(allow_none=True)
    c = Bool(allow_none=True)
    x = Integer(allow_none=True)
    d = Bool(allow_none=True)
    e = Bool(allow_none=True)

    def __init__(self,
                 n=None,
                 t="data",
                 h=None,
                 s=None,
                 sd=True,
                 f=None,
                 m=None,
                 c=None,
                 x=None,
                 d=None,
                 e=None,
                ):
        self.n = n
        self.t = t
        self.h = h
        self.s = s
        self.sd = sd
        self.f = f
        self.m = m
        self.c = c
        self.x = x
        self.d = d
        self.e = e


class PivotField(Serialisable):

    tagname = "pivotField"

    items = NestedSequence(expected_type=FieldItem, count=True)
    autoSortScope = Typed(expected_type=AutoSortScope, allow_none=True)
    extLst = Typed(expected_type=ExtensionList, allow_none=True)
    name = String(allow_none=True)
    axis = NoneSet(values=(['axisRow', 'axisCol', 'axisPage', 'axisValues']))
    dataField = Bool(allow_none=True)
    subtotalCaption = String(allow_none=True)
    showDropDowns = Bool(allow_none=True)
    hiddenLevel = Bool(allow_none=True)
    uniqueMemberProperty = String(allow_none=True)
    compact = Bool(allow_none=True)
    allDrilled = Bool(allow_none=True)
    numFmtId = Integer(allow_none=True)
    outline = Bool(allow_none=True)
    subtotalTop = Bool(allow_none=True)
    dragToRow = Bool(allow_none=True)
    dragToCol = Bool(allow_none=True)
    multipleItemSelectionAllowed = Bool(allow_none=True)
    dragToPage = Bool(allow_none=True)
    dragToData = Bool(allow_none=True)
    dragOff = Bool(allow_none=True)
    showAll = Bool(allow_none=True)
    insertBlankRow = Bool(allow_none=True)
    serverField = Bool(allow_none=True)
    insertPageBreak = Bool(allow_none=True)
    autoShow = Bool(allow_none=True)
    topAutoShow = Bool(allow_none=True)
    hideNewItems = Bool(allow_none=True)
    measureFilter = Bool(allow_none=True)
    includeNewItemsInFilter = Bool(allow_none=True)
    itemPageCount = Integer(allow_none=True)
    sortType = Set(values=(['manual', 'ascending', 'descending']))
    dataSourceSort = Bool(allow_none=True)
    nonAutoSortDefault = Bool(allow_none=True)
    rankBy = Integer(allow_none=True)
    defaultSubtotal = Bool(allow_none=True)
    sumSubtotal = Bool(allow_none=True)
    countASubtotal = Bool(allow_none=True)
    avgSubtotal = Bool(allow_none=True)
    maxSubtotal = Bool(allow_none=True)
    minSubtotal = Bool(allow_none=True)
    productSubtotal = Bool(allow_none=True)
    countSubtotal = Bool(allow_none=True)
    stdDevSubtotal = Bool(allow_none=True)
    stdDevPSubtotal = Bool(allow_none=True)
    varSubtotal = Bool(allow_none=True)
    varPSubtotal = Bool(allow_none=True)
    showPropCell = Bool(allow_none=True)
    showPropTip = Bool(allow_none=True)
    showPropAsCaption = Bool(allow_none=True)
    defaultAttributeDrillState = Bool(allow_none=True)

    __elements__ = ('items', 'autoSortScope',)

    def __init__(self,
                 items=(),
                 autoSortScope=None,
                 name=None,
                 axis=None,
                 dataField=None,
                 subtotalCaption=None,
                 showDropDowns=True,
                 hiddenLevel=None,
                 uniqueMemberProperty=None,
                 compact=True,
                 allDrilled=None,
                 numFmtId=None,
                 outline=True,
                 subtotalTop=True,
                 dragToRow=True,
                 dragToCol=True,
                 multipleItemSelectionAllowed=None,
                 dragToPage=True,
                 dragToData=True,
                 dragOff=True,
                 showAll=True,
                 insertBlankRow=None,
                 serverField=None,
                 insertPageBreak=None,
                 autoShow=None,
                 topAutoShow=True,
                 hideNewItems=None,
                 measureFilter=None,
                 includeNewItemsInFilter=None,
                 itemPageCount=10,
                 sortType="manual",
                 dataSourceSort=None,
                 nonAutoSortDefault=None,
                 rankBy=None,
                 defaultSubtotal=True,
                 sumSubtotal=None,
                 countASubtotal=None,
                 avgSubtotal=None,
                 maxSubtotal=None,
                 minSubtotal=None,
                 productSubtotal=None,
                 countSubtotal=None,
                 stdDevSubtotal=None,
                 stdDevPSubtotal=None,
                 varSubtotal=None,
                 varPSubtotal=None,
                 showPropCell=None,
                 showPropTip=None,
                 showPropAsCaption=None,
                 defaultAttributeDrillState=None,
                 extLst=None,
                ):
        self.items = items
        self.autoSortScope = autoSortScope
        self.name = name
        self.axis = axis
        self.dataField = dataField
        self.subtotalCaption = subtotalCaption
        self.showDropDowns = showDropDowns
        self.hiddenLevel = hiddenLevel
        self.uniqueMemberProperty = uniqueMemberProperty
        self.compact = compact
        self.allDrilled = allDrilled
        self.numFmtId = numFmtId
        self.outline = outline
        self.subtotalTop = subtotalTop
        self.dragToRow = dragToRow
        self.dragToCol = dragToCol
        self.multipleItemSelectionAllowed = multipleItemSelectionAllowed
        self.dragToPage = dragToPage
        self.dragToData = dragToData
        self.dragOff = dragOff
        self.showAll = showAll
        self.insertBlankRow = insertBlankRow
        self.serverField = serverField
        self.insertPageBreak = insertPageBreak
        self.autoShow = autoShow
        self.topAutoShow = topAutoShow
        self.hideNewItems = hideNewItems
        self.measureFilter = measureFilter
        self.includeNewItemsInFilter = includeNewItemsInFilter
        self.itemPageCount = itemPageCount
        self.sortType = sortType
        self.dataSourceSort = dataSourceSort
        self.nonAutoSortDefault = nonAutoSortDefault
        self.rankBy = rankBy
        self.defaultSubtotal = defaultSubtotal
        self.sumSubtotal = sumSubtotal
        self.countASubtotal = countASubtotal
        self.avgSubtotal = avgSubtotal
        self.maxSubtotal = maxSubtotal
        self.minSubtotal = minSubtotal
        self.productSubtotal = productSubtotal
        self.countSubtotal = countSubtotal
        self.stdDevSubtotal = stdDevSubtotal
        self.stdDevPSubtotal = stdDevPSubtotal
        self.varSubtotal = varSubtotal
        self.varPSubtotal = varPSubtotal
        self.showPropCell = showPropCell
        self.showPropTip = showPropTip
        self.showPropAsCaption = showPropAsCaption
        self.defaultAttributeDrillState = defaultAttributeDrillState


class Location(Serialisable):

    tagname = "location"

    ref = String()
    firstHeaderRow = Integer()
    firstDataRow = Integer()
    firstDataCol = Integer()
    rowPageCount = Integer(allow_none=True)
    colPageCount = Integer(allow_none=True)

    def __init__(self,
                 ref=None,
                 firstHeaderRow=None,
                 firstDataRow=None,
                 firstDataCol=None,
                 rowPageCount=None,
                 colPageCount=None,
                ):
        self.ref = ref
        self.firstHeaderRow = firstHeaderRow
        self.firstDataRow = firstDataRow
        self.firstDataCol = firstDataCol
        self.rowPageCount = rowPageCount
        self.colPageCount = colPageCount


class TableDefinition(Serialisable):

    mime_type = "application/vnd.openxmlformats-officedocument.spreadsheetml.pivotTable+xml"
    rel_type = "http://schemas.openxmlformats.org/officeDocument/2006/relationships/pivotTable"
    _id = 1
    _path = "/xl/pivotTables/pivotTable{0}.xml"

    tagname = "pivotTableDefinition"
    cache = None

    name = String()
    cacheId = Integer()
    dataOnRows = Bool()
    dataPosition = Integer(allow_none=True)
    dataCaption = String()
    grandTotalCaption = String(allow_none=True)
    errorCaption = String(allow_none=True)
    showError = Bool()
    missingCaption = String(allow_none=True)
    showMissing = Bool()
    pageStyle = String(allow_none=True)
    pivotTableStyle = String(allow_none=True)
    vacatedStyle = String(allow_none=True)
    tag = String(allow_none=True)
    updatedVersion = Integer()
    minRefreshableVersion = Integer()
    asteriskTotals = Bool()
    showItems = Bool()
    editData = Bool()
    disableFieldList = Bool()
    showCalcMbrs = Bool()
    visualTotals = Bool()
    showMultipleLabel = Bool()
    showDataDropDown = Bool()
    showDrill = Bool()
    printDrill = Bool()
    showMemberPropertyTips = Bool()
    showDataTips = Bool()
    enableWizard = Bool()
    enableDrill = Bool()
    enableFieldProperties = Bool()
    preserveFormatting = Bool()
    useAutoFormatting = Bool()
    pageWrap = Integer()
    pageOverThenDown = Bool()
    subtotalHiddenItems = Bool()
    rowGrandTotals = Bool()
    colGrandTotals = Bool()
    fieldPrintTitles = Bool()
    itemPrintTitles = Bool()
    mergeItem = Bool()
    showDropZones = Bool()
    createdVersion = Integer()
    indent = Integer()
    showEmptyRow = Bool()
    showEmptyCol = Bool()
    showHeaders = Bool()
    compact = Bool()
    outline = Bool()
    outlineData = Bool()
    compactData = Bool()
    published = Bool()
    gridDropZones = Bool()
    immersive = Bool()
    multipleFieldFilters = Bool()
    chartFormat = Integer()
    rowHeaderCaption = String(allow_none=True)
    colHeaderCaption = String(allow_none=True)
    fieldListSortAscending = Bool()
    mdxSubqueries = Bool()
    customListSort = Bool(allow_none=True)
    autoFormatId = Integer(allow_none=True)
    applyNumberFormats = Bool()
    applyBorderFormats = Bool()
    applyFontFormats = Bool()
    applyPatternFormats = Bool()
    applyAlignmentFormats = Bool()
    applyWidthHeightFormats = Bool()
    location = Typed(expected_type=Location, )
    pivotFields = NestedSequence(expected_type=PivotField, count=True)
    rowFields = NestedSequence(expected_type=RowColField, count=True)
    rowItems = NestedSequence(expected_type=RowColItem, count=True)
    colFields = NestedSequence(expected_type=RowColField, count=True)
    colItems = NestedSequence(expected_type=RowColItem, count=True)
    pageFields = NestedSequence(expected_type=PageField, count=True)
    dataFields = NestedSequence(expected_type=DataField, count=True)
    formats = NestedSequence(expected_type=Format, count=True)
    conditionalFormats = Typed(expected_type=ConditionalFormatList, allow_none=True)
    chartFormats = NestedSequence(expected_type=ChartFormat, count=True)
    pivotHierarchies = NestedSequence(expected_type=PivotHierarchy, count=True)
    pivotTableStyleInfo = Typed(expected_type=PivotTableStyle, allow_none=True)
    filters = NestedSequence(expected_type=PivotFilter, count=True)
    rowHierarchiesUsage = Typed(expected_type=RowHierarchiesUsage, allow_none=True)
    colHierarchiesUsage = Typed(expected_type=ColHierarchiesUsage, allow_none=True)
    extLst = Typed(expected_type=ExtensionList, allow_none=True)
    id = Relation()

    __elements__ = ('location', 'pivotFields', 'rowFields', 'rowItems',
                    'colFields', 'colItems', 'pageFields', 'dataFields', 'formats',
                    'conditionalFormats', 'chartFormats', 'pivotHierarchies',
                    'pivotTableStyleInfo', 'filters', 'rowHierarchiesUsage',
                    'colHierarchiesUsage',)

    def __init__(self,
                 name=None,
                 cacheId=None,
                 dataOnRows=False,
                 dataPosition=None,
                 dataCaption=None,
                 grandTotalCaption=None,
                 errorCaption=None,
                 showError=False,
                 missingCaption=None,
                 showMissing=True,
                 pageStyle=None,
                 pivotTableStyle=None,
                 vacatedStyle=None,
                 tag=None,
                 updatedVersion=0,
                 minRefreshableVersion=0,
                 asteriskTotals=False,
                 showItems=True,
                 editData=False,
                 disableFieldList=False,
                 showCalcMbrs=True,
                 visualTotals=True,
                 showMultipleLabel=True,
                 showDataDropDown=True,
                 showDrill=True,
                 printDrill=False,
                 showMemberPropertyTips=True,
                 showDataTips=True,
                 enableWizard=True,
                 enableDrill=True,
                 enableFieldProperties=True,
                 preserveFormatting=True,
                 useAutoFormatting=False,
                 pageWrap=0,
                 pageOverThenDown=False,
                 subtotalHiddenItems=False,
                 rowGrandTotals=True,
                 colGrandTotals=True,
                 fieldPrintTitles=False,
                 itemPrintTitles=False,
                 mergeItem=False,
                 showDropZones=True,
                 createdVersion=0,
                 indent=1,
                 showEmptyRow=False,
                 showEmptyCol=False,
                 showHeaders=True,
                 compact=True,
                 outline=False,
                 outlineData=False,
                 compactData=True,
                 published=False,
                 gridDropZones=False,
                 immersive=True,
                 multipleFieldFilters=None,
                 chartFormat=0,
                 rowHeaderCaption=None,
                 colHeaderCaption=None,
                 fieldListSortAscending=None,
                 mdxSubqueries=None,
                 customListSort=None,
                 autoFormatId=None,
                 applyNumberFormats=False,
                 applyBorderFormats=False,
                 applyFontFormats=False,
                 applyPatternFormats=False,
                 applyAlignmentFormats=False,
                 applyWidthHeightFormats=False,
                 location=None,
                 pivotFields=(),
                 rowFields=(),
                 rowItems=(),
                 colFields=(),
                 colItems=(),
                 pageFields=(),
                 dataFields=(),
                 formats=(),
                 conditionalFormats=None,
                 chartFormats=(),
                 pivotHierarchies=(),
                 pivotTableStyleInfo=None,
                 filters=(),
                 rowHierarchiesUsage=None,
                 colHierarchiesUsage=None,
                 extLst=None,
                 id=None,
                ):
        self.name = name
        self.cacheId = cacheId
        self.dataOnRows = dataOnRows
        self.dataPosition = dataPosition
        self.dataCaption = dataCaption
        self.grandTotalCaption = grandTotalCaption
        self.errorCaption = errorCaption
        self.showError = showError
        self.missingCaption = missingCaption
        self.showMissing = showMissing
        self.pageStyle = pageStyle
        self.pivotTableStyle = pivotTableStyle
        self.vacatedStyle = vacatedStyle
        self.tag = tag
        self.updatedVersion = updatedVersion
        self.minRefreshableVersion = minRefreshableVersion
        self.asteriskTotals = asteriskTotals
        self.showItems = showItems
        self.editData = editData
        self.disableFieldList = disableFieldList
        self.showCalcMbrs = showCalcMbrs
        self.visualTotals = visualTotals
        self.showMultipleLabel = showMultipleLabel
        self.showDataDropDown = showDataDropDown
        self.showDrill = showDrill
        self.printDrill = printDrill
        self.showMemberPropertyTips = showMemberPropertyTips
        self.showDataTips = showDataTips
        self.enableWizard = enableWizard
        self.enableDrill = enableDrill
        self.enableFieldProperties = enableFieldProperties
        self.preserveFormatting = preserveFormatting
        self.useAutoFormatting = useAutoFormatting
        self.pageWrap = pageWrap
        self.pageOverThenDown = pageOverThenDown
        self.subtotalHiddenItems = subtotalHiddenItems
        self.rowGrandTotals = rowGrandTotals
        self.colGrandTotals = colGrandTotals
        self.fieldPrintTitles = fieldPrintTitles
        self.itemPrintTitles = itemPrintTitles
        self.mergeItem = mergeItem
        self.showDropZones = showDropZones
        self.createdVersion = createdVersion
        self.indent = indent
        self.showEmptyRow = showEmptyRow
        self.showEmptyCol = showEmptyCol
        self.showHeaders = showHeaders
        self.compact = compact
        self.outline = outline
        self.outlineData = outlineData
        self.compactData = compactData
        self.published = published
        self.gridDropZones = gridDropZones
        self.immersive = immersive
        self.multipleFieldFilters = multipleFieldFilters
        self.chartFormat = chartFormat
        self.rowHeaderCaption = rowHeaderCaption
        self.colHeaderCaption = colHeaderCaption
        self.fieldListSortAscending = fieldListSortAscending
        self.mdxSubqueries = mdxSubqueries
        self.customListSort = customListSort
        self.autoFormatId = autoFormatId
        self.applyNumberFormats = applyNumberFormats
        self.applyBorderFormats = applyBorderFormats
        self.applyFontFormats = applyFontFormats
        self.applyPatternFormats = applyPatternFormats
        self.applyAlignmentFormats = applyAlignmentFormats
        self.applyWidthHeightFormats = applyWidthHeightFormats
        self.location = location
        self.pivotFields = pivotFields
        self.rowFields = rowFields
        self.rowItems = rowItems
        self.colFields = colFields
        self.colItems = colItems
        self.pageFields = pageFields
        self.dataFields = dataFields
        self.formats = formats
        self.conditionalFormats = conditionalFormats
        self.conditionalFormats = None
        self.chartFormats = chartFormats
        self.pivotHierarchies = pivotHierarchies
        self.pivotTableStyleInfo = pivotTableStyleInfo
        self.filters = filters
        self.rowHierarchiesUsage = rowHierarchiesUsage
        self.colHierarchiesUsage = colHierarchiesUsage
        self.extLst = extLst
        self.id = id


    def to_tree(self):
        tree = super().to_tree()
        tree.set("xmlns", SHEET_MAIN_NS)
        return tree


    @property
    def path(self):
        return self._path.format(self._id)


    def _write(self, archive, manifest):
        """
        Add to zipfile and update manifest
        """
        self._write_rels(archive, manifest)
        xml = tostring(self.to_tree())
        archive.writestr(self.path[1:], xml)
        manifest.append(self)


    def _write_rels(self, archive, manifest):
        """
        Write the relevant child objects and add links
        """
        if self.cache is None:
            return

        rels = RelationshipList()
        r = Relationship(Type=self.cache.rel_type, Target=self.cache.path)
        rels.append(r)
        self.id = r.id
        if self.cache.path[1:] not in archive.namelist():
            self.cache._write(archive, manifest)

        path = get_rels_path(self.path)
        xml = tostring(rels.to_tree())
        archive.writestr(path[1:], xml)


    def formatted_fields(self):
        """Map fields to associated conditional formats by priority"""
        if not self.conditionalFormats:
            return {}
        fields = defaultdict(list)
        for idx, prio in self.conditionalFormats.by_priority():
            name = self.dataFields[idx].name
            fields[name].append(prio)
        return fields


    @property
    def summary(self):
        """
        Provide a simplified summary of the table
        """

        return f"{self.name} {dict(self.location)}"

```

---

### File: `tmp\openpyxl_sdist\openpyxl-3.1.5\openpyxl\reader\__init__.py`

```python
# Copyright (c) 2010-2024 openpyxl

```

---

### File: `tmp\openpyxl_sdist\openpyxl-3.1.5\openpyxl\reader\drawings.py`

```python

# Copyright (c) 2010-2024 openpyxl


from io import BytesIO
from warnings import warn

from openpyxl.xml.functions import fromstring
from openpyxl.xml.constants import IMAGE_NS
from openpyxl.packaging.relationship import (
    get_rel,
    get_rels_path,
    get_dependents,
)
from openpyxl.drawing.spreadsheet_drawing import SpreadsheetDrawing
from openpyxl.drawing.image import Image, PILImage
from openpyxl.chart.chartspace import ChartSpace
from openpyxl.chart.reader import read_chart


def find_images(archive, path):
    """
    Given the path to a drawing file extract charts and images

    Ignore errors due to unsupported parts of DrawingML
    """

    src = archive.read(path)
    tree = fromstring(src)
    try:
        drawing = SpreadsheetDrawing.from_tree(tree)
    except TypeError:
        warn("DrawingML support is incomplete and limited to charts and images only. Shapes and drawings will be lost.")
        return [], []

    rels_path = get_rels_path(path)
    deps = []
    if rels_path in archive.namelist():
        deps = get_dependents(archive, rels_path)

    charts = []
    for rel in drawing._chart_rels:
        try:
            cs = get_rel(archive, deps, rel.id, ChartSpace)
        except TypeError as e:
            warn(f"Unable to read chart {rel.id} from {path} {e}")
            continue
        chart = read_chart(cs)
        chart.anchor = rel.anchor
        charts.append(chart)

    images = []
    if not PILImage: # Pillow not installed, drop images
        return charts, images

    for rel in drawing._blip_rels:
        dep = deps.get(rel.embed)
        if dep.Type == IMAGE_NS:
            try:
                image = Image(BytesIO(archive.read(dep.target)))
            except OSError:
                msg = "The image {0} will be removed because it cannot be read".format(dep.target)
                warn(msg)
                continue
            if image.format.upper() == "WMF": # cannot save
                msg = "{0} image format is not supported so the image is being dropped".format(image.format)
                warn(msg)
                continue
            image.anchor = rel.anchor
            images.append(image)
    return charts, images

```

---

### File: `tmp\openpyxl_sdist\openpyxl-3.1.5\openpyxl\reader\excel.py`

```python
# Copyright (c) 2010-2024 openpyxl


"""Read an xlsx file into Python"""

# Python stdlib imports
from zipfile import ZipFile, ZIP_DEFLATED
from io import BytesIO
import os.path
import warnings

from openpyxl.pivot.table import TableDefinition

# Allow blanket setting of KEEP_VBA for testing
try:
    from ..tests import KEEP_VBA
except ImportError:
    KEEP_VBA = False

# package imports
from openpyxl.utils.exceptions import InvalidFileException
from openpyxl.xml.constants import (
    ARC_CORE,
    ARC_CUSTOM,
    ARC_CONTENT_TYPES,
    ARC_WORKBOOK,
    ARC_THEME,
    COMMENTS_NS,
    SHARED_STRINGS,
    XLTM,
    XLTX,
    XLSM,
    XLSX,
)
from openpyxl.cell import MergedCell
from openpyxl.comments.comment_sheet import CommentSheet

from .strings import read_string_table, read_rich_text
from .workbook import WorkbookParser
from openpyxl.styles.stylesheet import apply_stylesheet

from openpyxl.packaging.core import DocumentProperties
from openpyxl.packaging.custom import CustomPropertyList
from openpyxl.packaging.manifest import Manifest, Override

from openpyxl.packaging.relationship import (
    RelationshipList,
    get_dependents,
    get_rels_path,
)

from openpyxl.worksheet._read_only import ReadOnlyWorksheet
from openpyxl.worksheet._reader import WorksheetReader
from openpyxl.chartsheet import Chartsheet
from openpyxl.worksheet.table import Table
from openpyxl.drawing.spreadsheet_drawing import SpreadsheetDrawing

from openpyxl.xml.functions import fromstring

from .drawings import find_images


SUPPORTED_FORMATS = ('.xlsx', '.xlsm', '.xltx', '.xltm')


def _validate_archive(filename):
    """
    Does a first check whether filename is a string or a file-like
    object. If it is a string representing a filename, a check is done
    for supported formats by checking the given file-extension. If the
    file-extension is not in SUPPORTED_FORMATS an InvalidFileException
    will raised. Otherwise the filename (resp. file-like object) will
    forwarded to zipfile.ZipFile returning a ZipFile-Instance.
    """
    is_file_like = hasattr(filename, 'read')
    if not is_file_like:
        file_format = os.path.splitext(filename)[-1].lower()
        if file_format not in SUPPORTED_FORMATS:
            if file_format == '.xls':
                msg = ('openpyxl does not support the old .xls file format, '
                       'please use xlrd to read this file, or convert it to '
                       'the more recent .xlsx file format.')
            elif file_format == '.xlsb':
                msg = ('openpyxl does not support binary format .xlsb, '
                       'please convert this file to .xlsx format if you want '
                       'to open it with openpyxl')
            else:
                msg = ('openpyxl does not support %s file format, '
                       'please check you can open '
                       'it with Excel first. '
                       'Supported formats are: %s') % (file_format,
                                                       ','.join(SUPPORTED_FORMATS))
            raise InvalidFileException(msg)

    archive = ZipFile(filename, 'r')
    return archive


def _find_workbook_part(package):
    workbook_types = [XLTM, XLTX, XLSM, XLSX]
    for ct in workbook_types:
        part = package.find(ct)
        if part:
            return part

    # some applications reassign the default for application/xml
    defaults = {p.ContentType for p in package.Default}
    workbook_type = defaults & set(workbook_types)
    if workbook_type:
        return Override("/" + ARC_WORKBOOK, workbook_type.pop())

    raise IOError("File contains no valid workbook part")


class ExcelReader:

    """
    Read an Excel package and dispatch the contents to the relevant modules
    """

    def __init__(self, fn, read_only=False, keep_vba=KEEP_VBA,
                 data_only=False, keep_links=True, rich_text=False):
        self.archive = _validate_archive(fn)
        self.valid_files = self.archive.namelist()
        self.read_only = read_only
        self.keep_vba = keep_vba
        self.data_only = data_only
        self.keep_links = keep_links
        self.rich_text = rich_text
        self.shared_strings = []


    def read_manifest(self):
        src = self.archive.read(ARC_CONTENT_TYPES)
        root = fromstring(src)
        self.package = Manifest.from_tree(root)


    def read_strings(self):
        ct = self.package.find(SHARED_STRINGS)
        reader = read_string_table
        if self.rich_text:
            reader = read_rich_text
        if ct is not None:
            strings_path = ct.PartName[1:]
            with self.archive.open(strings_path,) as src:
                self.shared_strings = reader(src)


    def read_workbook(self):
        wb_part = _find_workbook_part(self.package)
        self.parser = WorkbookParser(self.archive, wb_part.PartName[1:], keep_links=self.keep_links)
        self.parser.parse()
        wb = self.parser.wb
        wb._sheets = []
        wb._data_only = self.data_only
        wb._read_only = self.read_only
        wb.template = wb_part.ContentType in (XLTX, XLTM)

        # If are going to preserve the vba then attach a copy of the archive to the
        # workbook so that is available for the save.
        if self.keep_vba:
            wb.vba_archive = ZipFile(BytesIO(), 'a', ZIP_DEFLATED)
            for name in self.valid_files:
                wb.vba_archive.writestr(name, self.archive.read(name))

        if self.read_only:
            wb._archive = self.archive

        self.wb = wb


    def read_properties(self):
        if ARC_CORE in self.valid_files:
            src = fromstring(self.archive.read(ARC_CORE))
            self.wb.properties = DocumentProperties.from_tree(src)


    def read_custom(self):
        if ARC_CUSTOM in self.valid_files:
            src = fromstring(self.archive.read(ARC_CUSTOM))
            self.wb.custom_doc_props = CustomPropertyList.from_tree(src)


    def read_theme(self):
        if ARC_THEME in self.valid_files:
            self.wb.loaded_theme = self.archive.read(ARC_THEME)


    def read_chartsheet(self, sheet, rel):
        sheet_path = rel.target
        rels_path = get_rels_path(sheet_path)
        rels = []
        if rels_path in self.valid_files:
            rels = get_dependents(self.archive, rels_path)

        with self.archive.open(sheet_path, "r") as src:
            xml = src.read()
        node = fromstring(xml)
        cs = Chartsheet.from_tree(node)
        cs._parent = self.wb
        cs.title = sheet.name
        self.wb._add_sheet(cs)

        drawings = rels.find(SpreadsheetDrawing._rel_type)
        for rel in drawings:
            charts, images = find_images(self.archive, rel.target)
            for c in charts:
                cs.add_chart(c)


    def read_worksheets(self):
        comment_warning = """Cell '{0}':{1} is part of a merged range but has a comment which will be removed because merged cells cannot contain any data."""
        for sheet, rel in self.parser.find_sheets():
            if rel.target not in self.valid_files:
                continue

            if "chartsheet" in rel.Type:
                self.read_chartsheet(sheet, rel)
                continue

            rels_path = get_rels_path(rel.target)
            rels = RelationshipList()
            if rels_path in self.valid_files:
                rels = get_dependents(self.archive, rels_path)

            if self.read_only:
                ws = ReadOnlyWorksheet(self.wb, sheet.name, rel.target, self.shared_strings)
                ws.sheet_state = sheet.state
                self.wb._sheets.append(ws)
                continue
            else:
                fh = self.archive.open(rel.target)
                ws = self.wb.create_sheet(sheet.name)
                ws._rels = rels
                ws_parser = WorksheetReader(ws, fh, self.shared_strings, self.data_only, self.rich_text)
                ws_parser.bind_all()
                fh.close()

            # assign any comments to cells
            for r in rels.find(COMMENTS_NS):
                src = self.archive.read(r.target)
                comment_sheet = CommentSheet.from_tree(fromstring(src))
                for ref, comment in comment_sheet.comments:
                    try:
                        ws[ref].comment = comment
                    except AttributeError:
                        c = ws[ref]
                        if isinstance(c, MergedCell):
                            warnings.warn(comment_warning.format(ws.title, c.coordinate))
                            continue

            # preserve link to VML file if VBA
            if self.wb.vba_archive and ws.legacy_drawing:
                ws.legacy_drawing = rels.get(ws.legacy_drawing).target
            else:
                ws.legacy_drawing = None

            for t in ws_parser.tables:
                src = self.archive.read(t)
                xml = fromstring(src)
                table = Table.from_tree(xml)
                ws.add_table(table)

            drawings = rels.find(SpreadsheetDrawing._rel_type)
            for rel in drawings:
                charts, images = find_images(self.archive, rel.target)
                for c in charts:
                    ws.add_chart(c, c.anchor)
                for im in images:
                    ws.add_image(im, im.anchor)

            pivot_rel = rels.find(TableDefinition.rel_type)
            pivot_caches = self.parser.pivot_caches
            for r in pivot_rel:
                pivot_path = r.Target
                src = self.archive.read(pivot_path)
                tree = fromstring(src)
                pivot = TableDefinition.from_tree(tree)
                pivot.cache = pivot_caches[pivot.cacheId]
                ws.add_pivot(pivot)

            ws.sheet_state = sheet.state


    def read(self):
        action = "read manifest"
        try:
            self.read_manifest()
            action = "read strings"
            self.read_strings()
            action = "read workbook"
            self.read_workbook()
            action = "read properties"
            self.read_properties()
            action = "read custom properties"
            self.read_custom()
            action = "read theme"
            self.read_theme()
            action = "read stylesheet"
            apply_stylesheet(self.archive, self.wb)
            action = "read worksheets"
            self.read_worksheets()
            action = "assign names"
            self.parser.assign_names()
            if not self.read_only:
                self.archive.close()
        except ValueError as e:
            raise ValueError(
                f"Unable to read workbook: could not {action} from {self.archive.filename}.\n"
                "This is most probably because the workbook source files contain some invalid XML.\n"
                "Please see the exception for more details."
                ) from e


def load_workbook(filename, read_only=False, keep_vba=KEEP_VBA,
                  data_only=False, keep_links=True, rich_text=False):
    """Open the given filename and return the workbook

    :param filename: the path to open or a file-like object
    :type filename: string or a file-like object open in binary mode c.f., :class:`zipfile.ZipFile`

    :param read_only: optimised for reading, content cannot be edited
    :type read_only: bool

    :param keep_vba: preserve vba content (this does NOT mean you can use it)
    :type keep_vba: bool

    :param data_only: controls whether cells with formulae have either the formula (default) or the value stored the last time Excel read the sheet
    :type data_only: bool

    :param keep_links: whether links to external workbooks should be preserved. The default is True
    :type keep_links: bool

    :param rich_text: if set to True openpyxl will preserve any rich text formatting in cells. The default is False
    :type rich_text: bool

    :rtype: :class:`openpyxl.workbook.Workbook`

    .. note::

        When using lazy load, all worksheets will be :class:`openpyxl.worksheet.iter_worksheet.IterableWorksheet`
        and the returned workbook will be read-only.

    """
    reader = ExcelReader(filename, read_only, keep_vba,
                         data_only, keep_links, rich_text)
    reader.read()
    return reader.wb

```

---

### File: `tmp\openpyxl_sdist\openpyxl-3.1.5\openpyxl\reader\strings.py`

```python
# Copyright (c) 2010-2024 openpyxl

from openpyxl.cell.text import Text

from openpyxl.xml.functions import iterparse
from openpyxl.xml.constants import SHEET_MAIN_NS
from openpyxl.cell.rich_text import CellRichText


def read_string_table(xml_source):
    """Read in all shared strings in the table"""

    strings = []
    STRING_TAG = '{%s}si' % SHEET_MAIN_NS

    for _, node in iterparse(xml_source):
        if node.tag == STRING_TAG:
            text = Text.from_tree(node).content
            text = text.replace('x005F_', '')
            node.clear()

            strings.append(text)

    return strings


def read_rich_text(xml_source):
    """Read in all shared strings in the table"""

    strings = []
    STRING_TAG = '{%s}si' % SHEET_MAIN_NS

    for _, node in iterparse(xml_source):
        if node.tag == STRING_TAG:
            text = CellRichText.from_tree(node)
            if len(text) == 0:
                text = ''
            elif len(text) == 1 and isinstance(text[0], str):
                text = text[0]
            node.clear()

            strings.append(text)

    return strings

```

---

### File: `tmp\openpyxl_sdist\openpyxl-3.1.5\openpyxl\reader\workbook.py`

```python
# Copyright (c) 2010-2024 openpyxl

from warnings import warn

from openpyxl.xml.functions import fromstring

from openpyxl.packaging.relationship import (
    get_dependents,
    get_rels_path,
    get_rel,
)
from openpyxl.packaging.workbook import WorkbookPackage
from openpyxl.workbook import Workbook
from openpyxl.workbook.defined_name import DefinedNameList
from openpyxl.workbook.external_link.external import read_external_link
from openpyxl.pivot.cache import CacheDefinition
from openpyxl.pivot.record import RecordList
from openpyxl.worksheet.print_settings import PrintTitles, PrintArea

from openpyxl.utils.datetime import CALENDAR_MAC_1904


class WorkbookParser:

    _rels = None

    def __init__(self, archive, workbook_part_name, keep_links=True):
        self.archive = archive
        self.workbook_part_name = workbook_part_name
        self.defined_names = DefinedNameList()
        self.wb = Workbook()
        self.keep_links = keep_links
        self.sheets = []


    @property
    def rels(self):
        if self._rels is None:
            self._rels = get_dependents(self.archive, get_rels_path(self.workbook_part_name)).to_dict()
        return self._rels


    def parse(self):
        src = self.archive.read(self.workbook_part_name)
        node = fromstring(src)
        package = WorkbookPackage.from_tree(node)
        if package.properties.date1904:
            self.wb.epoch = CALENDAR_MAC_1904

        self.wb.code_name = package.properties.codeName
        self.wb.active = package.active
        self.wb.views = package.bookViews
        self.sheets = package.sheets
        self.wb.calculation = package.calcPr
        self.caches = package.pivotCaches

        # external links contain cached worksheets and can be very big
        if not self.keep_links:
            package.externalReferences = []

        for ext_ref in package.externalReferences:
            rel = self.rels.get(ext_ref.id)
            self.wb._external_links.append(
                read_external_link(self.archive, rel.Target)
            )

        if package.definedNames:
            self.defined_names = package.definedNames

        self.wb.security = package.workbookProtection


    def find_sheets(self):
        """
        Find all sheets in the workbook and return the link to the source file.

        Older XLSM files sometimes contain invalid sheet elements.
        Warn user when these are removed.
        """

        for sheet in self.sheets:
            if not sheet.id:
                msg = f"File contains an invalid specification for {0}. This will be removed".format(sheet.name)
                warn(msg)
                continue
            yield sheet, self.rels[sheet.id]


    def assign_names(self):
        """
        Bind defined names and other definitions to worksheets or the workbook
        """

        for idx, names in self.defined_names.by_sheet().items():
            if idx == "global":
                self.wb.defined_names = names
                continue

            try:
                sheet = self.wb._sheets[idx]
            except IndexError:
                warn(f"Defined names for sheet index {idx} cannot be located")
                continue

            for name, defn in names.items():
                reserved = defn.is_reserved
                if reserved is None:
                    sheet.defined_names[name] = defn

                elif reserved == "Print_Titles":
                    titles = PrintTitles.from_string(defn.value)
                    sheet._print_rows = titles.rows
                    sheet._print_cols = titles.cols
                elif reserved == "Print_Area":
                    try:
                        sheet._print_area = PrintArea.from_string(defn.value)
                    except TypeError:
                        warn(f"Print area cannot be set to Defined name: {defn.value}.")
                        continue

    @property
    def pivot_caches(self):
        """
        Get PivotCache objects
        """
        d = {}
        for c in self.caches:
            cache = get_rel(self.archive, self.rels, id=c.id, cls=CacheDefinition)
            if cache.deps:
                records = get_rel(self.archive, cache.deps, cache.id, RecordList)
                cache.records = records
            d[c.cacheId] = cache
        return d

```

---

### File: `tmp\openpyxl_sdist\openpyxl-3.1.5\openpyxl\styles\__init__.py`

```python
# Copyright (c) 2010-2024 openpyxl


from .alignment import Alignment
from .borders import Border, Side
from .colors import Color
from .fills import PatternFill, GradientFill, Fill
from .fonts import Font, DEFAULT_FONT
from .numbers import NumberFormatDescriptor, is_date_format, is_builtin
from .protection import Protection
from .named_styles import NamedStyle

```

---

### File: `tmp\openpyxl_sdist\openpyxl-3.1.5\openpyxl\styles\alignment.py`

```python
# Copyright (c) 2010-2024 openpyxl

from openpyxl.compat import safe_string

from openpyxl.descriptors import Bool, MinMax, Min, Alias, NoneSet
from openpyxl.descriptors.serialisable import Serialisable


horizontal_alignments = (
    "general", "left", "center", "right", "fill", "justify", "centerContinuous",
    "distributed", )
vertical_aligments = (
    "top", "center", "bottom", "justify", "distributed",
)

class Alignment(Serialisable):
    """Alignment options for use in styles."""

    tagname = "alignment"

    horizontal = NoneSet(values=horizontal_alignments)
    vertical = NoneSet(values=vertical_aligments)
    textRotation = NoneSet(values=range(181))
    textRotation.values.add(255)
    text_rotation = Alias('textRotation')
    wrapText = Bool(allow_none=True)
    wrap_text = Alias('wrapText')
    shrinkToFit = Bool(allow_none=True)
    shrink_to_fit = Alias('shrinkToFit')
    indent = MinMax(min=0, max=255)
    relativeIndent = MinMax(min=-255, max=255)
    justifyLastLine = Bool(allow_none=True)
    readingOrder = Min(min=0)

    def __init__(self, horizontal=None, vertical=None,
                 textRotation=0, wrapText=None, shrinkToFit=None, indent=0, relativeIndent=0,
                 justifyLastLine=None, readingOrder=0, text_rotation=None,
                 wrap_text=None, shrink_to_fit=None, mergeCell=None):
        self.horizontal = horizontal
        self.vertical = vertical
        self.indent = indent
        self.relativeIndent = relativeIndent
        self.justifyLastLine = justifyLastLine
        self.readingOrder = readingOrder
        if text_rotation is not None:
            textRotation = text_rotation
        if textRotation is not None:
            self.textRotation = int(textRotation)
        if wrap_text is not None:
            wrapText = wrap_text
        self.wrapText = wrapText
        if shrink_to_fit is not None:
            shrinkToFit = shrink_to_fit
        self.shrinkToFit = shrinkToFit
        # mergeCell is vestigial


    def __iter__(self):
        for attr in self.__attrs__:
            value = getattr(self, attr)
            if value is not None and value != 0:
                yield attr, safe_string(value)

```

---

### File: `tmp\openpyxl_sdist\openpyxl-3.1.5\openpyxl\styles\borders.py`

```python
# Copyright (c) 2010-2024 openpyxl

from openpyxl.compat import safe_string
from openpyxl.descriptors import (
    NoneSet,
    Typed,
    Bool,
    Alias,
    Sequence,
    Integer,
)
from openpyxl.descriptors.serialisable import Serialisable

from .colors import ColorDescriptor


BORDER_NONE = None
BORDER_DASHDOT = 'dashDot'
BORDER_DASHDOTDOT = 'dashDotDot'
BORDER_DASHED = 'dashed'
BORDER_DOTTED = 'dotted'
BORDER_DOUBLE = 'double'
BORDER_HAIR = 'hair'
BORDER_MEDIUM = 'medium'
BORDER_MEDIUMDASHDOT = 'mediumDashDot'
BORDER_MEDIUMDASHDOTDOT = 'mediumDashDotDot'
BORDER_MEDIUMDASHED = 'mediumDashed'
BORDER_SLANTDASHDOT = 'slantDashDot'
BORDER_THICK = 'thick'
BORDER_THIN = 'thin'


class Side(Serialisable):

    """Border options for use in styles.
    Caution: if you do not specify a border_style, other attributes will
    have no effect !"""


    color = ColorDescriptor(allow_none=True)
    style = NoneSet(values=('dashDot','dashDotDot', 'dashed','dotted',
                            'double','hair', 'medium', 'mediumDashDot', 'mediumDashDotDot',
                            'mediumDashed', 'slantDashDot', 'thick', 'thin')
                    )
    border_style = Alias('style')

    def __init__(self, style=None, color=None, border_style=None):
        if border_style is not None:
            style = border_style
        self.style = style
        self.color = color


class Border(Serialisable):
    """Border positioning for use in styles."""

    tagname = "border"

    __elements__ = ('start', 'end', 'left', 'right', 'top', 'bottom',
                    'diagonal', 'vertical', 'horizontal')

    # child elements
    start = Typed(expected_type=Side, allow_none=True)
    end = Typed(expected_type=Side, allow_none=True)
    left = Typed(expected_type=Side, allow_none=True)
    right = Typed(expected_type=Side, allow_none=True)
    top = Typed(expected_type=Side, allow_none=True)
    bottom = Typed(expected_type=Side, allow_none=True)
    diagonal = Typed(expected_type=Side, allow_none=True)
    vertical = Typed(expected_type=Side, allow_none=True)
    horizontal = Typed(expected_type=Side, allow_none=True)
    # attributes
    outline = Bool()
    diagonalUp = Bool()
    diagonalDown = Bool()

    def __init__(self, left=None, right=None, top=None,
                 bottom=None, diagonal=None, diagonal_direction=None,
                 vertical=None, horizontal=None, diagonalUp=False, diagonalDown=False,
                 outline=True, start=None, end=None):
        self.left = left
        self.right = right
        self.top = top
        self.bottom = bottom
        self.diagonal = diagonal
        self.vertical = vertical
        self.horizontal = horizontal
        self.diagonal_direction = diagonal_direction
        self.diagonalUp = diagonalUp
        self.diagonalDown = diagonalDown
        self.outline = outline
        self.start = start
        self.end = end

    def __iter__(self):
        for attr in self.__attrs__:
            value = getattr(self, attr)
            if value and attr != "outline":
                yield attr, safe_string(value)
            elif attr == "outline" and not value:
                yield attr, safe_string(value)

DEFAULT_BORDER = Border(left=Side(), right=Side(), top=Side(), bottom=Side(), diagonal=Side())

```

---

### File: `tmp\openpyxl_sdist\openpyxl-3.1.5\openpyxl\styles\builtins.py`

```python
# Copyright (c) 2010-2024 openpyxl

# Builtins styles as defined in Part 4 Annex G.2

from .named_styles import NamedStyle
from openpyxl.xml.functions import fromstring


normal = """
  <namedStyle builtinId="0" name="Normal">
    <alignment/>
    <border>
      <left/>
      <right/>
      <top/>
      <bottom/>
      <diagonal/>
    </border>
    <fill>
      <patternFill/>
    </fill>
    <font>
      <name val="Calibri"/>
      <family val="2"/>
      <color theme="1"/>
      <sz val="12"/>
      <scheme val="minor"/>
    </font>
    <protection hidden="0" locked="1"/>
  </namedStyle>
"""

comma = """
  <namedStyle builtinId="3" name="Comma">
    <alignment/>
    <number_format>_-* #,##0.00\\ _$_-;\\-* #,##0.00\\ _$_-;_-* "-"??\\ _$_-;_-@_-</number_format>
    <border>
      <left/>
      <right/>
      <top/>
      <bottom/>
      <diagonal/>
    </border>
    <fill>
      <patternFill/>
    </fill>
    <font>
      <name val="Calibri"/>
      <family val="2"/>
      <color theme="1"/>
      <sz val="12"/>
      <scheme val="minor"/>
    </font>
    <protection hidden="0" locked="1"/>
  </namedStyle>
"""

comma_0 = """
  <namedStyle builtinId="6" name="Comma [0]">
    <alignment/>
    <number_format>_-* #,##0\\ _$_-;\\-* #,##0\\ _$_-;_-* "-"\\ _$_-;_-@_-</number_format>
    <border>
      <left/>
      <right/>
      <top/>
      <bottom/>
      <diagonal/>
    </border>
    <fill>
      <patternFill/>
    </fill>
    <font>
      <name val="Calibri"/>
      <family val="2"/>
      <color theme="1"/>
      <sz val="12"/>
      <scheme val="minor"/>
    </font>
    <protection hidden="0" locked="1"/>
  </namedStyle>
"""

currency = """
  <namedStyle builtinId="4" name="Currency">
    <alignment/>
    <number_format>_-* #,##0.00\\ "$"_-;\\-* #,##0.00\\ "$"_-;_-* "-"??\\ "$"_-;_-@_-</number_format>
    <border>
      <left/>
      <right/>
      <top/>
      <bottom/>
      <diagonal/>
    </border>
    <fill>
      <patternFill/>
    </fill>
    <font>
      <name val="Calibri"/>
      <family val="2"/>
      <color theme="1"/>
      <sz val="12"/>
      <scheme val="minor"/>
    </font>
    <protection hidden="0" locked="1"/>
  </namedStyle>
"""

currency_0 = """
  <namedStyle builtinId="7" name="Currency [0]">
    <alignment/>
    <number_format>_-* #,##0\\ "$"_-;\\-* #,##0\\ "$"_-;_-* "-"\\ "$"_-;_-@_-</number_format>
    <border>
      <left/>
      <right/>
      <top/>
      <bottom/>
      <diagonal/>
    </border>
    <fill>
      <patternFill/>
    </fill>
    <font>
      <name val="Calibri"/>
      <family val="2"/>
      <color theme="1"/>
      <sz val="12"/>
      <scheme val="minor"/>
    </font>
    <protection hidden="0" locked="1"/>
  </namedStyle>
"""

percent = """
  <namedStyle builtinId="5" name="Percent">
    <alignment/>
    <number_format>0%</number_format>
    <border>
      <left/>
      <right/>
      <top/>
      <bottom/>
      <diagonal/>
    </border>
    <fill>
      <patternFill/>
    </fill>
    <font>
      <name val="Calibri"/>
      <family val="2"/>
      <color theme="1"/>
      <sz val="12"/>
      <scheme val="minor"/>
    </font>
    <protection hidden="0" locked="1"/>
  </namedStyle>
"""

hyperlink = """
  <namedStyle builtinId="8" name="Hyperlink" >
    <alignment/>
    <border>
      <left/>
      <right/>
      <top/>
      <bottom/>
      <diagonal/>
    </border>
    <fill>
      <patternFill/>
    </fill>
    <font>
      <name val="Calibri"/>
      <family val="2"/>
      <color theme="10"/>
      <sz val="12"/>
      <scheme val="minor"/>
    </font>
    <protection hidden="0" locked="1"/>
  </namedStyle>"""

followed_hyperlink = """
  <namedStyle builtinId="9" name="Followed Hyperlink" >
    <alignment/>
    <border>
      <left/>
      <right/>
      <top/>
      <bottom/>
      <diagonal/>
    </border>
    <fill>
      <patternFill/>
    </fill>
    <font>
      <name val="Calibri"/>
      <family val="2"/>
      <color theme="11"/>
      <sz val="12"/>
      <scheme val="minor"/>
    </font>
    <protection hidden="0" locked="1"/>
  </namedStyle>"""

title = """
  <namedStyle builtinId="15" name="Title">
    <alignment/>
    <border>
      <left/>
      <right/>
      <top/>
      <bottom/>
      <diagonal/>
    </border>
    <fill>
      <patternFill/>
    </fill>
    <font>
      <name val="Cambria"/>
      <family val="2"/>
      <b val="1"/>
      <color theme="3"/>
      <sz val="18"/>
      <scheme val="major"/>
    </font>
    <protection hidden="0" locked="1"/>
  </namedStyle>
"""

headline_1 = """
  <namedStyle builtinId="16" name="Headline 1" >
    <alignment/>
    <border>
      <left/>
      <right/>
      <top/>
      <bottom style="thick">
        <color theme="4"/>
      </bottom>
      <diagonal/>
    </border>
    <fill>
      <patternFill/>
    </fill>
    <font>
      <name val="Calibri"/>
      <family val="2"/>
      <b val="1"/>
      <color theme="3"/>
      <sz val="15"/>
      <scheme val="minor"/>
    </font>
    <protection hidden="0" locked="1"/>
  </namedStyle>
"""

headline_2 = """
  <namedStyle builtinId="17" name="Headline 2" >
    <alignment/>
    <border>
      <left/>
      <right/>
      <top/>
      <bottom style="thick">
        <color theme="4" tint="0.5"/>
      </bottom>
      <diagonal/>
    </border>
    <fill>
      <patternFill/>
    </fill>
    <font>
      <name val="Calibri"/>
      <family val="2"/>
      <b val="1"/>
      <color theme="3"/>
      <sz val="13"/>
      <scheme val="minor"/>
    </font>
    <protection hidden="0" locked="1"/>
  </namedStyle>
"""

headline_3 = """
   <namedStyle builtinId="18" name="Headline 3" >
    <alignment/>
    <border>
      <left/>
      <right/>
      <top/>
      <bottom style="medium">
        <color theme="4" tint="0.4"/>
      </bottom>
      <diagonal/>
    </border>
    <fill>
      <patternFill/>
    </fill>
    <font>
      <name val="Calibri"/>
      <family val="2"/>
      <b val="1"/>
      <color theme="3"/>
      <sz val="11"/>
      <scheme val="minor"/>
    </font>
    <protection hidden="0" locked="1"/>
  </namedStyle>

"""

headline_4 = """
  <namedStyle builtinId="19" name="Headline 4">
    <alignment/>
    <border>
      <left/>
      <right/>
      <top/>
      <bottom/>
      <diagonal/>
    </border>
    <fill>
      <patternFill/>
    </fill>
    <font>
      <name val="Calibri"/>
      <family val="2"/>
      <b val="1"/>
      <color theme="3"/>
      <sz val="11"/>
      <scheme val="minor"/>
    </font>
    <protection hidden="0" locked="1"/>
  </namedStyle>
"""

good = """
  <namedStyle builtinId="26" name="Good" >
    <alignment/>
    <border>
      <left/>
      <right/>
      <top/>
      <bottom/>
      <diagonal/>
    </border>
    <fill>
      <patternFill patternType="solid">
        <fgColor rgb="FFC6EFCE"/>
      </patternFill>
    </fill>
    <font>
      <name val="Calibri"/>
      <family val="2"/>
      <color rgb="FF006100"/>
      <sz val="12"/>
      <scheme val="minor"/>
    </font>
    <protection hidden="0" locked="1"/>
  </namedStyle>
"""

bad = """
  <namedStyle builtinId="27" name="Bad" >
    <alignment/>
    <border>
      <left/>
      <right/>
      <top/>
      <bottom/>
      <diagonal/>
    </border>
    <fill>
      <patternFill patternType="solid">
        <fgColor rgb="FFFFC7CE"/>
      </patternFill>
    </fill>
    <font>
      <name val="Calibri"/>
      <family val="2"/>
      <color rgb="FF9C0006"/>
      <sz val="12"/>
      <scheme val="minor"/>
    </font>
    <protection hidden="0" locked="1"/>
  </namedStyle>
"""

neutral = """
  <namedStyle builtinId="28" name="Neutral" >
    <alignment/>
    <border>
      <left/>
      <right/>
      <top/>
      <bottom/>
      <diagonal/>
    </border>
    <fill>
      <patternFill patternType="solid">
        <fgColor rgb="FFFFEB9C"/>
      </patternFill>
    </fill>
    <font>
      <name val="Calibri"/>
      <family val="2"/>
      <color rgb="FF9C6500"/>
      <sz val="12"/>
      <scheme val="minor"/>
    </font>
    <protection hidden="0" locked="1"/>
  </namedStyle>
"""

input = """
  <namedStyle builtinId="20" name="Input" >
    <alignment/>
    <border>
      <left style="thin">
        <color rgb="FF7F7F7F"/>
      </left>
      <right style="thin">
        <color rgb="FF7F7F7F"/>
      </right>
      <top style="thin">
        <color rgb="FF7F7F7F"/>
      </top>
      <bottom style="thin">
        <color rgb="FF7F7F7F"/>
      </bottom>
      <diagonal/>
    </border>
    <fill>
      <patternFill patternType="solid">
        <fgColor rgb="FFFFCC99"/>
      </patternFill>
    </fill>
    <font>
      <name val="Calibri"/>
      <family val="2"/>
      <color rgb="FF3F3F76"/>
      <sz val="12"/>
      <scheme val="minor"/>
    </font>
    <protection hidden="0" locked="1"/>
  </namedStyle>
"""

output = """
  <namedStyle builtinId="21" name="Output" >
    <alignment/>
    <border>
      <left style="thin">
        <color rgb="FF3F3F3F"/>
      </left>
      <right style="thin">
        <color rgb="FF3F3F3F"/>
      </right>
      <top style="thin">
        <color rgb="FF3F3F3F"/>
      </top>
      <bottom style="thin">
        <color rgb="FF3F3F3F"/>
      </bottom>
      <diagonal/>
    </border>
    <fill>
      <patternFill patternType="solid">
        <fgColor rgb="FFF2F2F2"/>
      </patternFill>
    </fill>
    <font>
      <name val="Calibri"/>
      <family val="2"/>
      <b val="1"/>
      <color rgb="FF3F3F3F"/>
      <sz val="12"/>
      <scheme val="minor"/>
    </font>
    <protection hidden="0" locked="1"/>
  </namedStyle>
"""

calculation = """
  <namedStyle builtinId="22" name="Calculation" >
    <alignment/>
    <border>
      <left style="thin">
        <color rgb="FF7F7F7F"/>
      </left>
      <right style="thin">
        <color rgb="FF7F7F7F"/>
      </right>
      <top style="thin">
        <color rgb="FF7F7F7F"/>
      </top>
      <bottom style="thin">
        <color rgb="FF7F7F7F"/>
      </bottom>
      <diagonal/>
    </border>
    <fill>
      <patternFill patternType="solid">
        <fgColor rgb="FFF2F2F2"/>
      </patternFill>
    </fill>
    <font>
      <name val="Calibri"/>
      <family val="2"/>
      <b val="1"/>
      <color rgb="FFFA7D00"/>
      <sz val="12"/>
      <scheme val="minor"/>
    </font>
    <protection hidden="0" locked="1"/>
  </namedStyle>
"""

linked_cell = """
  <namedStyle builtinId="24" name="Linked Cell" >
    <alignment/>
    <border>
      <left/>
      <right/>
      <top/>
      <bottom style="double">
        <color rgb="FFFF8001"/>
      </bottom>
      <diagonal/>
    </border>
    <fill>
      <patternFill/>
    </fill>
    <font>
      <name val="Calibri"/>
      <family val="2"/>
      <color rgb="FFFA7D00"/>
      <sz val="12"/>
      <scheme val="minor"/>
    </font>
    <protection hidden="0" locked="1"/>
  </namedStyle>
"""

check_cell = """
  <namedStyle builtinId="23" name="Check Cell" >
    <alignment/>
    <border>
      <left style="double">
        <color rgb="FF3F3F3F"/>
      </left>
      <right style="double">
        <color rgb="FF3F3F3F"/>
      </right>
      <top style="double">
        <color rgb="FF3F3F3F"/>
      </top>
      <bottom style="double">
        <color rgb="FF3F3F3F"/>
      </bottom>
      <diagonal/>
    </border>
    <fill>
      <patternFill patternType="solid">
        <fgColor rgb="FFA5A5A5"/>
      </patternFill>
    </fill>
    <font>
      <name val="Calibri"/>
      <family val="2"/>
      <b val="1"/>
      <color theme="0"/>
      <sz val="12"/>
      <scheme val="minor"/>
    </font>
    <protection hidden="0" locked="1"/>
  </namedStyle>
"""

warning = """
  <namedStyle builtinId="11" name="Warning Text" >
    <alignment/>
    <border>
      <left/>
      <right/>
      <top/>
      <bottom/>
      <diagonal/>
    </border>
    <fill>
      <patternFill/>
    </fill>
    <font>
      <name val="Calibri"/>
      <family val="2"/>
      <color rgb="FFFF0000"/>
      <sz val="12"/>
      <scheme val="minor"/>
    </font>
    <protection hidden="0" locked="1"/>
  </namedStyle>
"""

note = """
  <namedStyle builtinId="10" name="Note" >
    <alignment/>
    <border>
      <left style="thin">
        <color rgb="FFB2B2B2"/>
      </left>
      <right style="thin">
        <color rgb="FFB2B2B2"/>
      </right>
      <top style="thin">
        <color rgb="FFB2B2B2"/>
      </top>
      <bottom style="thin">
        <color rgb="FFB2B2B2"/>
      </bottom>
      <diagonal/>
    </border>
    <fill>
      <patternFill patternType="solid">
        <fgColor rgb="FFFFFFCC"/>
      </patternFill>
    </fill>
    <font>
      <name val="Calibri"/>
      <family val="2"/>
      <color theme="1"/>
      <sz val="12"/>
      <scheme val="minor"/>
    </font>
    <protection hidden="0" locked="1"/>
  </namedStyle>
"""

explanatory = """
  <namedStyle builtinId="53" name="Explanatory Text" >
    <alignment/>
    <border>
      <left/>
      <right/>
      <top/>
      <bottom/>
      <diagonal/>
    </border>
    <fill>
      <patternFill/>
    </fill>
    <font>
      <name val="Calibri"/>
      <family val="2"/>
      <i val="1"/>
      <color rgb="FF7F7F7F"/>
      <sz val="12"/>
      <scheme val="minor"/>
    </font>
    <protection hidden="0" locked="1"/>
  </namedStyle>
"""

total = """
  <namedStyle builtinId="25" name="Total" >
    <alignment/>
    <border>
      <left/>
      <right/>
      <top style="thin">
        <color theme="4"/>
      </top>
      <bottom style="double">
        <color theme="4"/>
      </bottom>
      <diagonal/>
    </border>
    <fill>
      <patternFill/>
    </fill>
    <font>
      <name val="Calibri"/>
      <family val="2"/>
      <b val="1"/>
      <color theme="1"/>
      <sz val="12"/>
      <scheme val="minor"/>
    </font>
    <protection hidden="0" locked="1"/>
  </namedStyle>
"""

accent_1 = """
  <namedStyle builtinId="29" name="Accent1" >
    <alignment/>
    <border>
      <left/>
      <right/>
      <top/>
      <bottom/>
      <diagonal/>
    </border>
    <fill>
      <patternFill patternType="solid">
        <fgColor theme="4"/>
      </patternFill>
    </fill>
    <font>
      <name val="Calibri"/>
      <family val="2"/>
      <color theme="0"/>
      <sz val="12"/>
      <scheme val="minor"/>
    </font>
    <protection hidden="0" locked="1"/>
  </namedStyle>
"""

accent_1_20 = """
  <namedStyle builtinId="30" name="20 % - Accent1" >
    <alignment/>
    <border>
      <left/>
      <right/>
      <top/>
      <bottom/>
      <diagonal/>
    </border>
    <fill>
      <patternFill patternType="solid">
        <fgColor theme="4" tint="0.7999816888943144"/>
        <bgColor indexed="65"/>
      </patternFill>
    </fill>
    <font>
      <name val="Calibri"/>
      <family val="2"/>
      <color theme="1"/>
      <sz val="12"/>
      <scheme val="minor"/>
    </font>
    <protection hidden="0" locked="1"/>
  </namedStyle>
"""

accent_1_40 = """
  <namedStyle builtinId="31" name="40 % - Accent1" >
    <alignment/>
    <border>
      <left/>
      <right/>
      <top/>
      <bottom/>
      <diagonal/>
    </border>
    <fill>
      <patternFill patternType="solid">
        <fgColor theme="4" tint="0.5999938962981048"/>
        <bgColor indexed="65"/>
      </patternFill>
    </fill>
    <font>
      <name val="Calibri"/>
      <family val="2"/>
      <color theme="1"/>
      <sz val="12"/>
      <scheme val="minor"/>
    </font>
    <protection hidden="0" locked="1"/>
  </namedStyle>
"""

accent_1_60 = """
  <namedStyle builtinId="32" name="60 % - Accent1" >
    <alignment/>
    <border>
      <left/>
      <right/>
      <top/>
      <bottom/>
      <diagonal/>
    </border>
    <fill>
      <patternFill patternType="solid">
        <fgColor theme="4" tint="0.3999755851924192"/>
        <bgColor indexed="65"/>
      </patternFill>
    </fill>
    <font>
      <name val="Calibri"/>
      <family val="2"/>
      <color theme="0"/>
      <sz val="12"/>
      <scheme val="minor"/>
    </font>
    <protection hidden="0" locked="1"/>
  </namedStyle>
"""

accent_2 = """<namedStyle builtinId="33" name="Accent2" >
    <alignment/>
    <border>
      <left/>
      <right/>
      <top/>
      <bottom/>
      <diagonal/>
    </border>
    <fill>
      <patternFill patternType="solid">
        <fgColor theme="5"/>
      </patternFill>
    </fill>
    <font>
      <name val="Calibri"/>
      <family val="2"/>
      <color theme="0"/>
      <sz val="12"/>
      <scheme val="minor"/>
    </font>
    <protection hidden="0" locked="1"/>
  </namedStyle>"""

accent_2_20 = """
  <namedStyle builtinId="34" name="20 % - Accent2" >
    <alignment/>
    <border>
      <left/>
      <right/>
      <top/>
      <bottom/>
      <diagonal/>
    </border>
    <fill>
      <patternFill patternType="solid">
        <fgColor theme="5" tint="0.7999816888943144"/>
        <bgColor indexed="65"/>
      </patternFill>
    </fill>
    <font>
      <name val="Calibri"/>
      <family val="2"/>
      <color theme="1"/>
      <sz val="12"/>
      <scheme val="minor"/>
    </font>
    <protection hidden="0" locked="1"/>
  </namedStyle>"""

accent_2_40 = """
<namedStyle builtinId="35" name="40 % - Accent2" >
    <alignment/>
    <border>
      <left/>
      <right/>
      <top/>
      <bottom/>
      <diagonal/>
    </border>
    <fill>
      <patternFill patternType="solid">
        <fgColor theme="5" tint="0.5999938962981048"/>
        <bgColor indexed="65"/>
      </patternFill>
    </fill>
    <font>
      <name val="Calibri"/>
      <family val="2"/>
      <color theme="1"/>
      <sz val="12"/>
      <scheme val="minor"/>
    </font>
    <protection hidden="0" locked="1"/>
  </namedStyle>"""

accent_2_60 = """
<namedStyle builtinId="36" name="60 % - Accent2" >
    <alignment/>
    <border>
      <left/>
      <right/>
      <top/>
      <bottom/>
      <diagonal/>
    </border>
    <fill>
      <patternFill patternType="solid">
        <fgColor theme="5" tint="0.3999755851924192"/>
        <bgColor indexed="65"/>
      </patternFill>
    </fill>
    <font>
      <name val="Calibri"/>
      <family val="2"/>
      <color theme="0"/>
      <sz val="12"/>
      <scheme val="minor"/>
    </font>
    <protection hidden="0" locked="1"/>
  </namedStyle>"""

accent_3 = """
<namedStyle builtinId="37" name="Accent3" >
    <alignment/>
    <border>
      <left/>
      <right/>
      <top/>
      <bottom/>
      <diagonal/>
    </border>
    <fill>
      <patternFill patternType="solid">
        <fgColor theme="6"/>
      </patternFill>
    </fill>
    <font>
      <name val="Calibri"/>
      <family val="2"/>
      <color theme="0"/>
      <sz val="12"/>
      <scheme val="minor"/>
    </font>
    <protection hidden="0" locked="1"/>
  </namedStyle>"""

accent_3_20 = """
  <namedStyle builtinId="38" name="20 % - Accent3" >
    <alignment/>
    <border>
      <left/>
      <right/>
      <top/>
      <bottom/>
      <diagonal/>
    </border>
    <fill>
      <patternFill patternType="solid">
        <fgColor theme="6" tint="0.7999816888943144"/>
        <bgColor indexed="65"/>
      </patternFill>
    </fill>
    <font>
      <name val="Calibri"/>
      <family val="2"/>
      <color theme="1"/>
      <sz val="12"/>
      <scheme val="minor"/>
    </font>
    <protection hidden="0" locked="1"/>
  </namedStyle>"""

accent_3_40 = """
  <namedStyle builtinId="39" name="40 % - Accent3" >
    <alignment/>
    <border>
      <left/>
      <right/>
      <top/>
      <bottom/>
      <diagonal/>
    </border>
    <fill>
      <patternFill patternType="solid">
        <fgColor theme="6" tint="0.5999938962981048"/>
        <bgColor indexed="65"/>
      </patternFill>
    </fill>
    <font>
      <name val="Calibri"/>
      <family val="2"/>
      <color theme="1"/>
      <sz val="12"/>
      <scheme val="minor"/>
    </font>
    <protection hidden="0" locked="1"/>
  </namedStyle>
"""
accent_3_60 = """
  <namedStyle builtinId="40" name="60 % - Accent3" >
    <alignment/>
    <border>
      <left/>
      <right/>
      <top/>
      <bottom/>
      <diagonal/>
    </border>
    <fill>
      <patternFill patternType="solid">
        <fgColor theme="6" tint="0.3999755851924192"/>
        <bgColor indexed="65"/>
      </patternFill>
    </fill>
    <font>
      <name val="Calibri"/>
      <family val="2"/>
      <color theme="0"/>
      <sz val="12"/>
      <scheme val="minor"/>
    </font>
    <protection hidden="0" locked="1"/>
  </namedStyle>
"""
accent_4 = """
  <namedStyle builtinId="41" name="Accent4" >
    <alignment/>
    <border>
      <left/>
      <right/>
      <top/>
      <bottom/>
      <diagonal/>
    </border>
    <fill>
      <patternFill patternType="solid">
        <fgColor theme="7"/>
      </patternFill>
    </fill>
    <font>
      <name val="Calibri"/>
      <family val="2"/>
      <color theme="0"/>
      <sz val="12"/>
      <scheme val="minor"/>
    </font>
    <protection hidden="0" locked="1"/>
  </namedStyle>
"""

accent_4_20 = """
  <namedStyle builtinId="42" name="20 % - Accent4" >
    <alignment/>
    <border>
      <left/>
      <right/>
      <top/>
      <bottom/>
      <diagonal/>
    </border>
    <fill>
      <patternFill patternType="solid">
        <fgColor theme="7" tint="0.7999816888943144"/>
        <bgColor indexed="65"/>
      </patternFill>
    </fill>
    <font>
      <name val="Calibri"/>
      <family val="2"/>
      <color theme="1"/>
      <sz val="12"/>
      <scheme val="minor"/>
    </font>
    <protection hidden="0" locked="1"/>
  </namedStyle>
"""

accent_4_40 = """
  <namedStyle builtinId="43" name="40 % - Accent4" >
    <alignment/>
    <border>
      <left/>
      <right/>
      <top/>
      <bottom/>
      <diagonal/>
    </border>
    <fill>
      <patternFill patternType="solid">
        <fgColor theme="7" tint="0.5999938962981048"/>
        <bgColor indexed="65"/>
      </patternFill>
    </fill>
    <font>
      <name val="Calibri"/>
      <family val="2"/>
      <color theme="1"/>
      <sz val="12"/>
      <scheme val="minor"/>
    </font>
    <protection hidden="0" locked="1"/>
  </namedStyle>
"""

accent_4_60 = """
<namedStyle builtinId="44" name="60 % - Accent4" >
    <alignment/>
    <border>
      <left/>
      <right/>
      <top/>
      <bottom/>
      <diagonal/>
    </border>
    <fill>
      <patternFill patternType="solid">
        <fgColor theme="7" tint="0.3999755851924192"/>
        <bgColor indexed="65"/>
      </patternFill>
    </fill>
    <font>
      <name val="Calibri"/>
      <family val="2"/>
      <color theme="0"/>
      <sz val="12"/>
      <scheme val="minor"/>
    </font>
    <protection hidden="0" locked="1"/>
  </namedStyle>
"""

accent_5 = """
  <namedStyle builtinId="45" name="Accent5" >
    <alignment/>
    <border>
      <left/>
      <right/>
      <top/>
      <bottom/>
      <diagonal/>
    </border>
    <fill>
      <patternFill patternType="solid">
        <fgColor theme="8"/>
      </patternFill>
    </fill>
    <font>
      <name val="Calibri"/>
      <family val="2"/>
      <color theme="0"/>
      <sz val="12"/>
      <scheme val="minor"/>
    </font>
    <protection hidden="0" locked="1"/>
  </namedStyle>
"""

accent_5_20 = """
  <namedStyle builtinId="46" name="20 % - Accent5" >
    <alignment/>
    <border>
      <left/>
      <right/>
      <top/>
      <bottom/>
      <diagonal/>
    </border>
    <fill>
      <patternFill patternType="solid">
        <fgColor theme="8" tint="0.7999816888943144"/>
        <bgColor indexed="65"/>
      </patternFill>
    </fill>
    <font>
      <name val="Calibri"/>
      <family val="2"/>
      <color theme="1"/>
      <sz val="12"/>
      <scheme val="minor"/>
    </font>
    <protection hidden="0" locked="1"/>
  </namedStyle>
"""

accent_5_40 = """
  <namedStyle builtinId="47" name="40 % - Accent5" >
    <alignment/>
    <border>
      <left/>
      <right/>
      <top/>
      <bottom/>
      <diagonal/>
    </border>
    <fill>
      <patternFill patternType="solid">
        <fgColor theme="8" tint="0.5999938962981048"/>
        <bgColor indexed="65"/>
      </patternFill>
    </fill>
    <font>
      <name val="Calibri"/>
      <family val="2"/>
      <color theme="1"/>
      <sz val="12"/>
      <scheme val="minor"/>
    </font>
    <protection hidden="0" locked="1"/>
  </namedStyle>
"""

accent_5_60 = """
  <namedStyle builtinId="48" name="60 % - Accent5" >
    <alignment/>
    <border>
      <left/>
      <right/>
      <top/>
      <bottom/>
      <diagonal/>
    </border>
    <fill>
      <patternFill patternType="solid">
        <fgColor theme="8" tint="0.3999755851924192"/>
        <bgColor indexed="65"/>
      </patternFill>
    </fill>
    <font>
      <name val="Calibri"/>
      <family val="2"/>
      <color theme="0"/>
      <sz val="12"/>
      <scheme val="minor"/>
    </font>
    <protection hidden="0" locked="1"/>
  </namedStyle>
"""

accent_6 = """
  <namedStyle builtinId="49" name="Accent6" >
    <alignment/>
    <border>
      <left/>
      <right/>
      <top/>
      <bottom/>
      <diagonal/>
    </border>
    <fill>
      <patternFill patternType="solid">
        <fgColor theme="9"/>
      </patternFill>
    </fill>
    <font>
      <name val="Calibri"/>
      <family val="2"/>
      <color theme="0"/>
      <sz val="12"/>
      <scheme val="minor"/>
    </font>
    <protection hidden="0" locked="1"/>
  </namedStyle>
"""

accent_6_20 = """
  <namedStyle builtinId="50" name="20 % - Accent6" >
    <alignment/>
    <border>
      <left/>
      <right/>
      <top/>
      <bottom/>
      <diagonal/>
    </border>
    <fill>
      <patternFill patternType="solid">
        <fgColor theme="9" tint="0.7999816888943144"/>
        <bgColor indexed="65"/>
      </patternFill>
    </fill>
    <font>
      <name val="Calibri"/>
      <family val="2"/>
      <color theme="1"/>
      <sz val="12"/>
      <scheme val="minor"/>
    </font>
    <protection hidden="0" locked="1"/>
  </namedStyle>
"""

accent_6_40 = """
  <namedStyle builtinId="51" name="40 % - Accent6" >
    <alignment/>
    <border>
      <left/>
      <right/>
      <top/>
      <bottom/>
      <diagonal/>
    </border>
    <fill>
      <patternFill patternType="solid">
        <fgColor theme="9" tint="0.5999938962981048"/>
        <bgColor indexed="65"/>
      </patternFill>
    </fill>
    <font>
      <name val="Calibri"/>
      <family val="2"/>
      <color theme="1"/>
      <sz val="12"/>
      <scheme val="minor"/>
    </font>
    <protection hidden="0" locked="1"/>
  </namedStyle>
"""

accent_6_60 = """
  <namedStyle builtinId="52" name="60 % - Accent6" >
    <alignment/>
    <border>
      <left/>
      <right/>
      <top/>
      <bottom/>
      <diagonal/>
    </border>
    <fill>
      <patternFill patternType="solid">
        <fgColor theme="9" tint="0.3999755851924192"/>
        <bgColor indexed="65"/>
      </patternFill>
    </fill>
    <font>
      <name val="Calibri"/>
      <family val="2"/>
      <color theme="0"/>
      <sz val="12"/>
      <scheme val="minor"/>
    </font>
    <protection hidden="0" locked="1"/>
  </namedStyle>
"""

pandas_highlight = """
  <namedStyle hidden="0" name="Pandas">
    <alignment horizontal="center"/>
    <border>
      <left style="thin"><color rgb="00000000"/></left>
      <right style="thin"><color rgb="00000000"/></right>
      <top style="thin"><color rgb="00000000"/></top>
      <bottom style="thin"><color rgb="00000000"/></bottom>
      <diagonal/>
    </border>
    <fill>
      <patternFill/>
    </fill>
    <font>
      <b val="1"/>
    </font>
    <protection hidden="0" locked="1"/>
  </namedStyle>
"""

styles = dict(
    [
        ('Normal', NamedStyle.from_tree(fromstring(normal))),
        ('Comma', NamedStyle.from_tree(fromstring(comma))),
        ('Currency', NamedStyle.from_tree(fromstring(currency))),
        ('Percent', NamedStyle.from_tree(fromstring(percent))),
        ('Comma [0]', NamedStyle.from_tree(fromstring(comma_0))),
        ('Currency [0]', NamedStyle.from_tree(fromstring(currency_0))),
        ('Hyperlink', NamedStyle.from_tree(fromstring(hyperlink))),
        ('Followed Hyperlink', NamedStyle.from_tree(fromstring(followed_hyperlink))),
        ('Note', NamedStyle.from_tree(fromstring(note))),
        ('Warning Text', NamedStyle.from_tree(fromstring(warning))),
        ('Title', NamedStyle.from_tree(fromstring(title))),
        ('Headline 1', NamedStyle.from_tree(fromstring(headline_1))),
        ('Headline 2', NamedStyle.from_tree(fromstring(headline_2))),
        ('Headline 3', NamedStyle.from_tree(fromstring(headline_3))),
        ('Headline 4', NamedStyle.from_tree(fromstring(headline_4))),
        ('Input', NamedStyle.from_tree(fromstring(input))),
        ('Output', NamedStyle.from_tree(fromstring(output))),
        ('Calculation',NamedStyle.from_tree(fromstring(calculation))),
        ('Check Cell', NamedStyle.from_tree(fromstring(check_cell))),
        ('Linked Cell', NamedStyle.from_tree(fromstring(linked_cell))),
        ('Total', NamedStyle.from_tree(fromstring(total))),
        ('Good', NamedStyle.from_tree(fromstring(good))),
        ('Bad', NamedStyle.from_tree(fromstring(bad))),
        ('Neutral', NamedStyle.from_tree(fromstring(neutral))),
        ('Accent1', NamedStyle.from_tree(fromstring(accent_1))),
        ('20 % - Accent1', NamedStyle.from_tree(fromstring(accent_1_20))),
        ('40 % - Accent1', NamedStyle.from_tree(fromstring(accent_1_40))),
        ('60 % - Accent1', NamedStyle.from_tree(fromstring(accent_1_60))),
        ('Accent2', NamedStyle.from_tree(fromstring(accent_2))),
        ('20 % - Accent2', NamedStyle.from_tree(fromstring(accent_2_20))),
        ('40 % - Accent2', NamedStyle.from_tree(fromstring(accent_2_40))),
        ('60 % - Accent2', NamedStyle.from_tree(fromstring(accent_2_60))),
        ('Accent3', NamedStyle.from_tree(fromstring(accent_3))),
        ('20 % - Accent3', NamedStyle.from_tree(fromstring(accent_3_20))),
        ('40 % - Accent3', NamedStyle.from_tree(fromstring(accent_3_40))),
        ('60 % - Accent3', NamedStyle.from_tree(fromstring(accent_3_60))),
        ('Accent4', NamedStyle.from_tree(fromstring(accent_4))),
        ('20 % - Accent4', NamedStyle.from_tree(fromstring(accent_4_20))),
        ('40 % - Accent4', NamedStyle.from_tree(fromstring(accent_4_40))),
        ('60 % - Accent4', NamedStyle.from_tree(fromstring(accent_4_60))),
        ('Accent5', NamedStyle.from_tree(fromstring(accent_5))),
        ('20 % - Accent5', NamedStyle.from_tree(fromstring(accent_5_20))),
        ('40 % - Accent5', NamedStyle.from_tree(fromstring(accent_5_40))),
        ('60 % - Accent5', NamedStyle.from_tree(fromstring(accent_5_60))),
        ('Accent6', NamedStyle.from_tree(fromstring(accent_6))),
        ('20 % - Accent6', NamedStyle.from_tree(fromstring(accent_6_20))),
        ('40 % - Accent6', NamedStyle.from_tree(fromstring(accent_6_40))),
        ('60 % - Accent6', NamedStyle.from_tree(fromstring(accent_6_60))),
        ('Explanatory Text', NamedStyle.from_tree(fromstring(explanatory))),
        ('Pandas', NamedStyle.from_tree(fromstring(pandas_highlight)))
    ]
)

```

---

### File: `tmp\openpyxl_sdist\openpyxl-3.1.5\openpyxl\styles\cell_style.py`

```python
# Copyright (c) 2010-2024 openpyxl

from array import array

from openpyxl.descriptors.serialisable import Serialisable
from openpyxl.descriptors import (
    Typed,
    Float,
    Bool,
    Integer,
    Sequence,
)
from openpyxl.descriptors.excel import ExtensionList
from openpyxl.utils.indexed_list import IndexedList


from .alignment import Alignment
from .protection import Protection


class ArrayDescriptor:

    def __init__(self, key):
        self.key = key

    def __get__(self, instance, cls):
        return instance[self.key]

    def __set__(self, instance, value):
        instance[self.key] = value


class StyleArray(array):
    """
    Simplified named tuple with an array
    """

    __slots__ = ()
    tagname = 'xf'

    fontId = ArrayDescriptor(0)
    fillId = ArrayDescriptor(1)
    borderId = ArrayDescriptor(2)
    numFmtId = ArrayDescriptor(3)
    protectionId = ArrayDescriptor(4)
    alignmentId = ArrayDescriptor(5)
    pivotButton = ArrayDescriptor(6)
    quotePrefix = ArrayDescriptor(7)
    xfId = ArrayDescriptor(8)


    def __new__(cls, args=[0]*9):
        return array.__new__(cls, 'i', args)


    def __hash__(self):
        return hash(tuple(self))


    def __copy__(self):
        return StyleArray((self))


    def __deepcopy__(self, memo):
        return StyleArray((self))


class CellStyle(Serialisable):

    tagname = "xf"

    numFmtId = Integer()
    fontId = Integer()
    fillId = Integer()
    borderId = Integer()
    xfId = Integer(allow_none=True)
    quotePrefix = Bool(allow_none=True)
    pivotButton = Bool(allow_none=True)
    applyNumberFormat = Bool(allow_none=True)
    applyFont = Bool(allow_none=True)
    applyFill = Bool(allow_none=True)
    applyBorder = Bool(allow_none=True)
    applyAlignment = Bool(allow_none=True)
    applyProtection = Bool(allow_none=True)
    alignment = Typed(expected_type=Alignment, allow_none=True)
    protection = Typed(expected_type=Protection, allow_none=True)
    extLst = Typed(expected_type=ExtensionList, allow_none=True)

    __elements__ = ('alignment', 'protection')
    __attrs__ = ("numFmtId", "fontId", "fillId", "borderId",
                 "applyAlignment", "applyProtection", "pivotButton", "quotePrefix", "xfId")

    def __init__(self,
                 numFmtId=0,
                 fontId=0,
                 fillId=0,
                 borderId=0,
                 xfId=None,
                 quotePrefix=None,
                 pivotButton=None,
                 applyNumberFormat=None,
                 applyFont=None,
                 applyFill=None,
                 applyBorder=None,
                 applyAlignment=None,
                 applyProtection=None,
                 alignment=None,
                 protection=None,
                 extLst=None,
                ):
        self.numFmtId = numFmtId
        self.fontId = fontId
        self.fillId = fillId
        self.borderId = borderId
        self.xfId = xfId
        self.quotePrefix = quotePrefix
        self.pivotButton = pivotButton
        self.applyNumberFormat = applyNumberFormat
        self.applyFont = applyFont
        self.applyFill = applyFill
        self.applyBorder = applyBorder
        self.alignment = alignment
        self.protection = protection


    def to_array(self):
        """
        Convert to StyleArray
        """
        style = StyleArray()
        for k in ("fontId", "fillId", "borderId", "numFmtId", "pivotButton",
                  "quotePrefix", "xfId"):
            v = getattr(self, k, 0)
            if v is not None:
                setattr(style, k, v)
        return style


    @classmethod
    def from_array(cls, style):
        """
        Convert from StyleArray
        """
        return cls(numFmtId=style.numFmtId, fontId=style.fontId,
                   fillId=style.fillId, borderId=style.borderId, xfId=style.xfId,
                   quotePrefix=style.quotePrefix, pivotButton=style.pivotButton,)


    @property
    def applyProtection(self):
        return self.protection is not None or None


    @property
    def applyAlignment(self):
        return self.alignment is not None or None


class CellStyleList(Serialisable):

    tagname = "cellXfs"

    __attrs__ = ("count",)

    count = Integer(allow_none=True)
    xf = Sequence(expected_type=CellStyle)
    alignment = Sequence(expected_type=Alignment)
    protection = Sequence(expected_type=Protection)

    __elements__ = ('xf',)

    def __init__(self,
                 count=None,
                 xf=(),
                ):
        self.xf = xf


    @property
    def count(self):
        return len(self.xf)


    def __getitem__(self, idx):
        try:
            return self.xf[idx]
        except IndexError:
            print((f"{idx} is out of range"))
        return self.xf[idx]


    def _to_array(self):
        """
        Extract protection and alignments, convert to style array
        """
        self.prots = IndexedList([Protection()])
        self.alignments = IndexedList([Alignment()])
        styles = [] # allow duplicates
        for xf in self.xf:
            style = xf.to_array()
            if xf.alignment is not None:
                style.alignmentId = self.alignments.add(xf.alignment)
            if xf.protection is not None:
                style.protectionId = self.prots.add(xf.protection)
            styles.append(style)
        return IndexedList(styles)

```

---

### File: `tmp\openpyxl_sdist\openpyxl-3.1.5\openpyxl\styles\colors.py`

```python
# Copyright (c) 2010-2024 openpyxl

import re
from openpyxl.compat import safe_string
from openpyxl.descriptors import (
    String,
    Bool,
    MinMax,
    Integer,
    Typed,
)
from openpyxl.descriptors.sequence import NestedSequence
from openpyxl.descriptors.serialisable import Serialisable

# Default Color Index as per 18.8.27 of ECMA Part 4
COLOR_INDEX = (
    '00000000', '00FFFFFF', '00FF0000', '0000FF00', '000000FF', #0-4
    '00FFFF00', '00FF00FF', '0000FFFF', '00000000', '00FFFFFF', #5-9
    '00FF0000', '0000FF00', '000000FF', '00FFFF00', '00FF00FF', #10-14
    '0000FFFF', '00800000', '00008000', '00000080', '00808000', #15-19
    '00800080', '00008080', '00C0C0C0', '00808080', '009999FF', #20-24
    '00993366', '00FFFFCC', '00CCFFFF', '00660066', '00FF8080', #25-29
    '000066CC', '00CCCCFF', '00000080', '00FF00FF', '00FFFF00', #30-34
    '0000FFFF', '00800080', '00800000', '00008080', '000000FF', #35-39
    '0000CCFF', '00CCFFFF', '00CCFFCC', '00FFFF99', '0099CCFF', #40-44
    '00FF99CC', '00CC99FF', '00FFCC99', '003366FF', '0033CCCC', #45-49
    '0099CC00', '00FFCC00', '00FF9900', '00FF6600', '00666699', #50-54
    '00969696', '00003366', '00339966', '00003300', '00333300', #55-59
    '00993300', '00993366', '00333399', '00333333',  #60-63
)
# indices 64 and 65 are reserved for the system foreground and background colours respectively

# Will remove these definitions in a future release
BLACK = COLOR_INDEX[0]
WHITE = COLOR_INDEX[1]
#RED = COLOR_INDEX[2]
#DARKRED = COLOR_INDEX[8]
BLUE = COLOR_INDEX[4]
#DARKBLUE = COLOR_INDEX[12]
#GREEN = COLOR_INDEX[3]
#DARKGREEN = COLOR_INDEX[9]
#YELLOW = COLOR_INDEX[5]
#DARKYELLOW = COLOR_INDEX[19]


aRGB_REGEX = re.compile("^([A-Fa-f0-9]{8}|[A-Fa-f0-9]{6})$")


class RGB(Typed):
    """
    Descriptor for aRGB values
    If not supplied alpha is 00
    """

    expected_type = str

    def __set__(self, instance, value):
        if not self.allow_none:
            m = aRGB_REGEX.match(value)
            if m is None:
                raise ValueError("Colors must be aRGB hex values")
            if len(value) == 6:
                value = "00" + value
        super().__set__(instance, value)


class Color(Serialisable):
    """Named colors for use in styles."""

    tagname = "color"

    rgb = RGB()
    indexed = Integer()
    auto = Bool()
    theme = Integer()
    tint = MinMax(min=-1, max=1, expected_type=float)
    type = String()


    def __init__(self, rgb=BLACK, indexed=None, auto=None, theme=None, tint=0.0, index=None, type='rgb'):
        if index is not None:
            indexed = index
        if indexed is not None:
            self.type = 'indexed'
            self.indexed = indexed
        elif theme is not None:
            self.type = 'theme'
            self.theme = theme
        elif auto is not None:
            self.type = 'auto'
            self.auto = auto
        else:
            self.rgb = rgb
            self.type = 'rgb'
        self.tint = tint

    @property
    def value(self):
        return getattr(self, self.type)

    @value.setter
    def value(self, value):
        setattr(self, self.type, value)

    def __iter__(self):
        attrs = [(self.type, self.value)]
        if self.tint != 0:
            attrs.append(('tint', self.tint))
        for k, v in attrs:
            yield k, safe_string(v)

    @property
    def index(self):
        # legacy
        return self.value


    def __add__(self, other):
        """
        Adding colours is undefined behaviour best do nothing
        """
        if not isinstance(other, Color):
            return super().__add__(other)
        return self


class ColorDescriptor(Typed):

    expected_type = Color

    def __set__(self, instance, value):
        if isinstance(value, str):
            value = Color(rgb=value)
        super().__set__(instance, value)


class RgbColor(Serialisable):

    tagname = "rgbColor"

    rgb = RGB()

    def __init__(self,
                 rgb=None,
                ):
        self.rgb = rgb


class ColorList(Serialisable):

    tagname = "colors"

    indexedColors = NestedSequence(expected_type=RgbColor)
    mruColors = NestedSequence(expected_type=Color)

    __elements__ = ('indexedColors', 'mruColors')

    def __init__(self,
                 indexedColors=(),
                 mruColors=(),
                ):
        self.indexedColors = indexedColors
        self.mruColors = mruColors


    def __bool__(self):
        return bool(self.indexedColors) or bool(self.mruColors)


    @property
    def index(self):
        return [val.rgb for val in self.indexedColors]

```

---

### File: `tmp\openpyxl_sdist\openpyxl-3.1.5\openpyxl\styles\differential.py`

```python
# Copyright (c) 2010-2024 openpyxl

from openpyxl.descriptors import (
    Typed,
    Sequence,
    Alias,
)
from openpyxl.descriptors.serialisable import Serialisable
from openpyxl.styles import (
    Font,
    Fill,
    Border,
    Alignment,
    Protection,
    )
from .numbers import NumberFormat


class DifferentialStyle(Serialisable):

    tagname = "dxf"

    __elements__ = ("font", "numFmt", "fill", "alignment", "border", "protection")

    font = Typed(expected_type=Font, allow_none=True)
    numFmt = Typed(expected_type=NumberFormat, allow_none=True)
    fill = Typed(expected_type=Fill, allow_none=True)
    alignment = Typed(expected_type=Alignment, allow_none=True)
    border = Typed(expected_type=Border, allow_none=True)
    protection = Typed(expected_type=Protection, allow_none=True)

    def __init__(self,
                 font=None,
                 numFmt=None,
                 fill=None,
                 alignment=None,
                 border=None,
                 protection=None,
                 extLst=None,
                ):
        self.font = font
        self.numFmt = numFmt
        self.fill = fill
        self.alignment = alignment
        self.border = border
        self.protection = protection
        self.extLst = extLst


class DifferentialStyleList(Serialisable):
    """
    Dedupable container for differential styles.
    """

    tagname = "dxfs"

    dxf = Sequence(expected_type=DifferentialStyle)
    styles = Alias("dxf")
    __attrs__ = ("count",)


    def __init__(self, dxf=(), count=None):
        self.dxf = dxf


    def append(self, dxf):
        """
        Check to see whether style already exists and append it if does not.
        """
        if not isinstance(dxf, DifferentialStyle):
            raise TypeError('expected ' + str(DifferentialStyle))
        if dxf in self.styles:
            return
        self.styles.append(dxf)


    def add(self, dxf):
        """
        Add a differential style and return its index
        """
        self.append(dxf)
        return self.styles.index(dxf)


    def __bool__(self):
        return bool(self.styles)


    def __getitem__(self, idx):
        return self.styles[idx]


    @property
    def count(self):
        return len(self.dxf)

```

---

### File: `tmp\openpyxl_sdist\openpyxl-3.1.5\openpyxl\styles\fills.py`

```python

# Copyright (c) 2010-2024 openpyxl

from openpyxl.descriptors import (
    Float,
    Set,
    Alias,
    NoneSet,
    Sequence,
    Integer,
    MinMax,
)
from openpyxl.descriptors.serialisable import Serialisable
from openpyxl.compat import safe_string

from .colors import ColorDescriptor, Color

from openpyxl.xml.functions import Element, localname
from openpyxl.xml.constants import SHEET_MAIN_NS


FILL_NONE = 'none'
FILL_SOLID = 'solid'
FILL_PATTERN_DARKDOWN = 'darkDown'
FILL_PATTERN_DARKGRAY = 'darkGray'
FILL_PATTERN_DARKGRID = 'darkGrid'
FILL_PATTERN_DARKHORIZONTAL = 'darkHorizontal'
FILL_PATTERN_DARKTRELLIS = 'darkTrellis'
FILL_PATTERN_DARKUP = 'darkUp'
FILL_PATTERN_DARKVERTICAL = 'darkVertical'
FILL_PATTERN_GRAY0625 = 'gray0625'
FILL_PATTERN_GRAY125 = 'gray125'
FILL_PATTERN_LIGHTDOWN = 'lightDown'
FILL_PATTERN_LIGHTGRAY = 'lightGray'
FILL_PATTERN_LIGHTGRID = 'lightGrid'
FILL_PATTERN_LIGHTHORIZONTAL = 'lightHorizontal'
FILL_PATTERN_LIGHTTRELLIS = 'lightTrellis'
FILL_PATTERN_LIGHTUP = 'lightUp'
FILL_PATTERN_LIGHTVERTICAL = 'lightVertical'
FILL_PATTERN_MEDIUMGRAY = 'mediumGray'

fills = (FILL_SOLID, FILL_PATTERN_DARKDOWN, FILL_PATTERN_DARKGRAY,
         FILL_PATTERN_DARKGRID, FILL_PATTERN_DARKHORIZONTAL, FILL_PATTERN_DARKTRELLIS,
         FILL_PATTERN_DARKUP, FILL_PATTERN_DARKVERTICAL, FILL_PATTERN_GRAY0625,
         FILL_PATTERN_GRAY125, FILL_PATTERN_LIGHTDOWN, FILL_PATTERN_LIGHTGRAY,
         FILL_PATTERN_LIGHTGRID, FILL_PATTERN_LIGHTHORIZONTAL,
         FILL_PATTERN_LIGHTTRELLIS, FILL_PATTERN_LIGHTUP, FILL_PATTERN_LIGHTVERTICAL,
         FILL_PATTERN_MEDIUMGRAY)


class Fill(Serialisable):

    """Base class"""

    tagname = "fill"

    @classmethod
    def from_tree(cls, el):
        children = [c for c in el]
        if not children:
            return
        child = children[0]
        if "patternFill" in child.tag:
            return PatternFill._from_tree(child)
        return super(Fill, GradientFill).from_tree(child)


class PatternFill(Fill):
    """Area fill patterns for use in styles.
    Caution: if you do not specify a fill_type, other attributes will have
    no effect !"""

    tagname = "patternFill"

    __elements__ = ('fgColor', 'bgColor')

    patternType = NoneSet(values=fills)
    fill_type = Alias("patternType")
    fgColor = ColorDescriptor()
    start_color = Alias("fgColor")
    bgColor = ColorDescriptor()
    end_color = Alias("bgColor")

    def __init__(self, patternType=None, fgColor=Color(), bgColor=Color(),
                 fill_type=None, start_color=None, end_color=None):
        if fill_type is not None:
            patternType = fill_type
        self.patternType = patternType
        if start_color is not None:
            fgColor = start_color
        self.fgColor = fgColor
        if end_color is not None:
            bgColor = end_color
        self.bgColor = bgColor

    @classmethod
    def _from_tree(cls, el):
        attrib = dict(el.attrib)
        for child in el:
            desc = localname(child)
            attrib[desc] = Color.from_tree(child)
        return cls(**attrib)


    def to_tree(self, tagname=None, idx=None):
        parent = Element("fill")
        el = Element(self.tagname)
        if self.patternType is not None:
            el.set('patternType', self.patternType)
        for c in self.__elements__:
            value = getattr(self, c)
            if value != Color():
                el.append(value.to_tree(c))
        parent.append(el)
        return parent


DEFAULT_EMPTY_FILL = PatternFill()
DEFAULT_GRAY_FILL = PatternFill(patternType='gray125')


class Stop(Serialisable):

    tagname = "stop"

    position = MinMax(min=0, max=1)
    color = ColorDescriptor()

    def __init__(self, color, position):
        self.position = position
        self.color = color


def _assign_position(values):
    """
    Automatically assign positions if a list of colours is provided.

    It is not permitted to mix colours and stops
    """
    n_values = len(values)
    n_stops = sum(isinstance(value, Stop) for value in values)

    if n_stops == 0:
        interval = 1
        if n_values > 2:
            interval = 1 / (n_values - 1)
        values = [Stop(value, i * interval)
                  for i, value in enumerate(values)]

    elif n_stops < n_values:
        raise ValueError('Cannot interpret mix of Stops and Colors in GradientFill')

    pos = set()
    for stop in values:
        if stop.position in pos:
            raise ValueError("Duplicate position {0}".format(stop.position))
        pos.add(stop.position)

    return values


class StopList(Sequence):

    expected_type = Stop

    def __set__(self, obj, values):
        values = _assign_position(values)
        super().__set__(obj, values)


class GradientFill(Fill):
    """Fill areas with gradient

    Two types of gradient fill are supported:

        - A type='linear' gradient interpolates colours between
          a set of specified Stops, across the length of an area.
          The gradient is left-to-right by default, but this
          orientation can be modified with the degree
          attribute.  A list of Colors can be provided instead
          and they will be positioned with equal distance between them.

        - A type='path' gradient applies a linear gradient from each
          edge of the area. Attributes top, right, bottom, left specify
          the extent of fill from the respective borders. Thus top="0.2"
          will fill the top 20% of the cell.

    """

    tagname = "gradientFill"

    type = Set(values=('linear', 'path'))
    fill_type = Alias("type")
    degree = Float()
    left = Float()
    right = Float()
    top = Float()
    bottom = Float()
    stop = StopList()


    def __init__(self, type="linear", degree=0, left=0, right=0, top=0,
                 bottom=0, stop=()):
        self.degree = degree
        self.left = left
        self.right = right
        self.top = top
        self.bottom = bottom
        self.stop = stop
        self.type = type


    def __iter__(self):
        for attr in self.__attrs__:
            value = getattr(self, attr)
            if value:
                yield attr, safe_string(value)


    def to_tree(self, tagname=None, namespace=None, idx=None):
        parent = Element("fill")
        el = super().to_tree()
        parent.append(el)
        return parent

```

---

### File: `tmp\openpyxl_sdist\openpyxl-3.1.5\openpyxl\styles\fonts.py`

```python
# Copyright (c) 2010-2024 openpyxl


from openpyxl.descriptors import (
    Alias,
    Sequence,
    Integer
)
from openpyxl.descriptors.serialisable import Serialisable

from openpyxl.descriptors.nested import (
    NestedValue,
    NestedBool,
    NestedNoneSet,
    NestedMinMax,
    NestedString,
    NestedInteger,
    NestedFloat,
)
from .colors import ColorDescriptor, Color, BLACK

from openpyxl.compat import safe_string
from openpyxl.xml.functions import Element, SubElement
from openpyxl.xml.constants import SHEET_MAIN_NS


def _no_value(tagname, value, namespace=None):
    if value:
        return Element(tagname, val=safe_string(value))


class Font(Serialisable):
    """Font options used in styles."""

    UNDERLINE_DOUBLE = 'double'
    UNDERLINE_DOUBLE_ACCOUNTING = 'doubleAccounting'
    UNDERLINE_SINGLE = 'single'
    UNDERLINE_SINGLE_ACCOUNTING = 'singleAccounting'

    name = NestedString(allow_none=True)
    charset = NestedInteger(allow_none=True)
    family = NestedMinMax(min=0, max=14, allow_none=True)
    sz = NestedFloat(allow_none=True)
    size = Alias("sz")
    b = NestedBool(to_tree=_no_value)
    bold = Alias("b")
    i = NestedBool(to_tree=_no_value)
    italic = Alias("i")
    strike = NestedBool(allow_none=True)
    strikethrough = Alias("strike")
    outline = NestedBool(allow_none=True)
    shadow = NestedBool(allow_none=True)
    condense = NestedBool(allow_none=True)
    extend = NestedBool(allow_none=True)
    u = NestedNoneSet(values=('single', 'double', 'singleAccounting',
                             'doubleAccounting'))
    underline = Alias("u")
    vertAlign = NestedNoneSet(values=('superscript', 'subscript', 'baseline'))
    color = ColorDescriptor(allow_none=True)
    scheme = NestedNoneSet(values=("major", "minor"))

    tagname = "font"

    __elements__ = ('name', 'charset', 'family', 'b', 'i', 'strike', 'outline',
                  'shadow', 'condense', 'color', 'extend', 'sz', 'u', 'vertAlign',
                  'scheme')


    def __init__(self, name=None, sz=None, b=None, i=None, charset=None,
                 u=None, strike=None, color=None, scheme=None, family=None, size=None,
                 bold=None, italic=None, strikethrough=None, underline=None,
                 vertAlign=None, outline=None, shadow=None, condense=None,
                 extend=None):
        self.name = name
        self.family = family
        if size is not None:
            sz = size
        self.sz = sz
        if bold is not None:
            b = bold
        self.b = b
        if italic is not None:
            i = italic
        self.i = i
        if underline is not None:
            u = underline
        self.u = u
        if strikethrough is not None:
            strike = strikethrough
        self.strike = strike
        self.color = color
        self.vertAlign = vertAlign
        self.charset = charset
        self.outline = outline
        self.shadow = shadow
        self.condense = condense
        self.extend = extend
        self.scheme = scheme


    @classmethod
    def from_tree(cls, node):
        """
        Set default value for underline if child element is present
        """
        underline = node.find("{%s}u" % SHEET_MAIN_NS)
        if underline is not None and underline.get('val') is None:
            underline.set("val", "single")
        return super().from_tree(node)


DEFAULT_FONT = Font(name="Calibri", sz=11, family=2, b=False, i=False,
                    color=Color(theme=1), scheme="minor")

```

---

### File: `tmp\openpyxl_sdist\openpyxl-3.1.5\openpyxl\styles\named_styles.py`

```python
# Copyright (c) 2010-2024 openpyxl

from openpyxl.compat import safe_string

from openpyxl.descriptors import (
    Typed,
    Integer,
    Bool,
    String,
    Sequence,
)
from openpyxl.descriptors.excel import ExtensionList
from openpyxl.descriptors.serialisable import Serialisable

from .fills import PatternFill, Fill
from .fonts import Font
from .borders import Border
from .alignment import Alignment
from .protection import Protection
from .numbers import (
    NumberFormatDescriptor,
    BUILTIN_FORMATS_MAX_SIZE,
    BUILTIN_FORMATS_REVERSE,
)
from .cell_style import (
    StyleArray,
    CellStyle,
)


class NamedStyle(Serialisable):

    """
    Named and editable styles
    """

    font = Typed(expected_type=Font)
    fill = Typed(expected_type=Fill)
    border = Typed(expected_type=Border)
    alignment = Typed(expected_type=Alignment)
    number_format = NumberFormatDescriptor()
    protection = Typed(expected_type=Protection)
    builtinId = Integer(allow_none=True)
    hidden = Bool(allow_none=True)
    name = String()
    _wb = None
    _style = StyleArray()


    def __init__(self,
                 name="Normal",
                 font=None,
                 fill=None,
                 border=None,
                 alignment=None,
                 number_format=None,
                 protection=None,
                 builtinId=None,
                 hidden=False,
                 ):
        self.name = name
        self.font = font or Font()
        self.fill = fill or PatternFill()
        self.border = border or Border()
        self.alignment = alignment or Alignment()
        self.number_format = number_format
        self.protection = protection or Protection()
        self.builtinId = builtinId
        self.hidden = hidden
        self._wb = None
        self._style = StyleArray()


    def __setattr__(self, attr, value):
        super().__setattr__(attr, value)
        if getattr(self, '_wb', None) and attr in (
           'font', 'fill', 'border', 'alignment', 'number_format', 'protection',
            ):
            self._recalculate()


    def __iter__(self):
        for key in ('name', 'builtinId', 'hidden', 'xfId'):
            value = getattr(self, key, None)
            if value is not None:
                yield key, safe_string(value)


    def bind(self, wb):
        """
        Bind a named style to a workbook
        """
        self._wb = wb
        self._recalculate()


    def _recalculate(self):
        self._style.fontId =  self._wb._fonts.add(self.font)
        self._style.borderId = self._wb._borders.add(self.border)
        self._style.fillId =  self._wb._fills.add(self.fill)
        self._style.protectionId = self._wb._protections.add(self.protection)
        self._style.alignmentId = self._wb._alignments.add(self.alignment)
        fmt = self.number_format
        if fmt in BUILTIN_FORMATS_REVERSE:
            fmt = BUILTIN_FORMATS_REVERSE[fmt]
        else:
            fmt = self._wb._number_formats.add(self.number_format) + (
                  BUILTIN_FORMATS_MAX_SIZE)
        self._style.numFmtId = fmt


    def as_tuple(self):
        """Return a style array representing the current style"""
        return self._style


    def as_xf(self):
        """
        Return equivalent XfStyle
        """
        xf = CellStyle.from_array(self._style)
        xf.xfId = None
        xf.pivotButton = None
        xf.quotePrefix = None
        if self.alignment != Alignment():
            xf.alignment = self.alignment
        if self.protection != Protection():
            xf.protection = self.protection
        return xf


    def as_name(self):
        """
        Return relevant named style

        """
        named = _NamedCellStyle(
            name=self.name,
            builtinId=self.builtinId,
            hidden=self.hidden,
            xfId=self._style.xfId
        )
        return named


class NamedStyleList(list):
    """
    Named styles are editable and can be applied to multiple objects

    As only the index is stored in referencing objects the order mus
    be preserved.

    Returns a list of NamedStyles
    """

    def __init__(self, iterable=()):
        """
        Allow a list of named styles to be passed in and index them.
        """

        for idx, s in enumerate(iterable, len(self)):
            s._style.xfId = idx
        super().__init__(iterable)


    @property
    def names(self):
        return [s.name for s in self]


    def __getitem__(self, key):
        if isinstance(key, int):
            return super().__getitem__(key)


        for idx, name in enumerate(self.names):
            if name == key:
                return self[idx]

        raise KeyError("No named style with the name{0} exists".format(key))

    def append(self, style):
        if not isinstance(style, NamedStyle):
            raise TypeError("""Only NamedStyle instances can be added""")
        elif style.name in self.names: # hotspot
            raise ValueError("""Style {0} exists already""".format(style.name))
        style._style.xfId = (len(self))
        super().append(style)


class _NamedCellStyle(Serialisable):

    """
    Pointer-based representation of named styles in XML
    xfId refers to the corresponding CellStyleXfs

    Not used in client code.
    """

    tagname = "cellStyle"

    name = String()
    xfId = Integer()
    builtinId = Integer(allow_none=True)
    iLevel = Integer(allow_none=True)
    hidden = Bool(allow_none=True)
    customBuiltin = Bool(allow_none=True)
    extLst = Typed(expected_type=ExtensionList, allow_none=True)

    __elements__ = ()


    def __init__(self,
                 name=None,
                 xfId=None,
                 builtinId=None,
                 iLevel=None,
                 hidden=None,
                 customBuiltin=None,
                 extLst=None,
                ):
        self.name = name
        self.xfId = xfId
        self.builtinId = builtinId
        self.iLevel = iLevel
        self.hidden = hidden
        self.customBuiltin = customBuiltin


class _NamedCellStyleList(Serialisable):
    """
    Container for named cell style objects

    Not used in client code
    """

    tagname = "cellStyles"

    count = Integer(allow_none=True)
    cellStyle = Sequence(expected_type=_NamedCellStyle)

    __attrs__ = ("count",)

    def __init__(self,
                 count=None,
                 cellStyle=(),
                ):
        self.cellStyle = cellStyle


    @property
    def count(self):
        return len(self.cellStyle)


    def remove_duplicates(self):
        """
        Some applications contain duplicate definitions either by name or
        referenced style.

        As the references are 0-based indices, styles are sorted by
        index.

        Returns a list of style references with duplicates removed
        """

        def sort_fn(v):
            return v.xfId

        styles = []
        names = set()
        ids = set()

        for ns in sorted(self.cellStyle, key=sort_fn):
            if ns.xfId in ids or ns.name in names: # skip duplicates
                continue
            ids.add(ns.xfId)
            names.add(ns.name)

            styles.append(ns)

        return styles

```

---

### File: `tmp\openpyxl_sdist\openpyxl-3.1.5\openpyxl\styles\numbers.py`

```python
# Copyright (c) 2010-2024 openpyxl

import re

from openpyxl.descriptors import (
    String,
    Sequence,
    Integer,
)
from openpyxl.descriptors.serialisable import Serialisable


BUILTIN_FORMATS = {
    0: 'General',
    1: '0',
    2: '0.00',
    3: '#,##0',
    4: '#,##0.00',
    5: '"$"#,##0_);("$"#,##0)',
    6: '"$"#,##0_);[Red]("$"#,##0)',
    7: '"$"#,##0.00_);("$"#,##0.00)',
    8: '"$"#,##0.00_);[Red]("$"#,##0.00)',
    9: '0%',
    10: '0.00%',
    11: '0.00E+00',
    12: '# ?/?',
    13: '# ??/??',
    14: 'mm-dd-yy',
    15: 'd-mmm-yy',
    16: 'd-mmm',
    17: 'mmm-yy',
    18: 'h:mm AM/PM',
    19: 'h:mm:ss AM/PM',
    20: 'h:mm',
    21: 'h:mm:ss',
    22: 'm/d/yy h:mm',

    37: '#,##0_);(#,##0)',
    38: '#,##0_);[Red](#,##0)',
    39: '#,##0.00_);(#,##0.00)',
    40: '#,##0.00_);[Red](#,##0.00)',

    41: r'_(* #,##0_);_(* \(#,##0\);_(* "-"_);_(@_)',
    42: r'_("$"* #,##0_);_("$"* \(#,##0\);_("$"* "-"_);_(@_)',
    43: r'_(* #,##0.00_);_(* \(#,##0.00\);_(* "-"??_);_(@_)',

    44: r'_("$"* #,##0.00_)_("$"* \(#,##0.00\)_("$"* "-"??_)_(@_)',
    45: 'mm:ss',
    46: '[h]:mm:ss',
    47: 'mmss.0',
    48: '##0.0E+0',
    49: '@', }

BUILTIN_FORMATS_MAX_SIZE = 164
BUILTIN_FORMATS_REVERSE = dict(
        [(value, key) for key, value in BUILTIN_FORMATS.items()])

FORMAT_GENERAL = BUILTIN_FORMATS[0]
FORMAT_TEXT = BUILTIN_FORMATS[49]
FORMAT_NUMBER = BUILTIN_FORMATS[1]
FORMAT_NUMBER_00 = BUILTIN_FORMATS[2]
FORMAT_NUMBER_COMMA_SEPARATED1 = BUILTIN_FORMATS[4]
FORMAT_NUMBER_COMMA_SEPARATED2 = '#,##0.00_-'
FORMAT_PERCENTAGE = BUILTIN_FORMATS[9]
FORMAT_PERCENTAGE_00 = BUILTIN_FORMATS[10]
FORMAT_DATE_YYYYMMDD2 = 'yyyy-mm-dd'
FORMAT_DATE_YYMMDD = 'yy-mm-dd'
FORMAT_DATE_DDMMYY = 'dd/mm/yy'
FORMAT_DATE_DMYSLASH = 'd/m/y'
FORMAT_DATE_DMYMINUS = 'd-m-y'
FORMAT_DATE_DMMINUS = 'd-m'
FORMAT_DATE_MYMINUS = 'm-y'
FORMAT_DATE_XLSX14 = BUILTIN_FORMATS[14]
FORMAT_DATE_XLSX15 = BUILTIN_FORMATS[15]
FORMAT_DATE_XLSX16 = BUILTIN_FORMATS[16]
FORMAT_DATE_XLSX17 = BUILTIN_FORMATS[17]
FORMAT_DATE_XLSX22 = BUILTIN_FORMATS[22]
FORMAT_DATE_DATETIME = 'yyyy-mm-dd h:mm:ss'
FORMAT_DATE_TIME1 = BUILTIN_FORMATS[18]
FORMAT_DATE_TIME2 = BUILTIN_FORMATS[19]
FORMAT_DATE_TIME3 = BUILTIN_FORMATS[20]
FORMAT_DATE_TIME4 = BUILTIN_FORMATS[21]
FORMAT_DATE_TIME5 = BUILTIN_FORMATS[45]
FORMAT_DATE_TIME6 = BUILTIN_FORMATS[21]
FORMAT_DATE_TIME7 = 'i:s.S'
FORMAT_DATE_TIME8 = 'h:mm:ss@'
FORMAT_DATE_TIMEDELTA = '[hh]:mm:ss'
FORMAT_DATE_YYMMDDSLASH = 'yy/mm/dd@'
FORMAT_CURRENCY_USD_SIMPLE = '"$"#,##0.00_-'
FORMAT_CURRENCY_USD = '$#,##0_-'
FORMAT_CURRENCY_EUR_SIMPLE = '[$EUR ]#,##0.00_-'


COLORS = r"\[(BLACK|BLUE|CYAN|GREEN|MAGENTA|RED|WHITE|YELLOW)\]"
LITERAL_GROUP = r'".*?"' # anything in quotes
LOCALE_GROUP = r'\[(?!hh?\]|mm?\]|ss?\])[^\]]*\]' # anything in square brackets, except hours or minutes or seconds
STRIP_RE = re.compile(f"{LITERAL_GROUP}|{LOCALE_GROUP}")
TIMEDELTA_RE = re.compile(r'\[hh?\](:mm(:ss(\.0*)?)?)?|\[mm?\](:ss(\.0*)?)?|\[ss?\](\.0*)?', re.I)


# Spec 18.8.31 numFmts
# +ve;-ve;zero;text

def is_date_format(fmt):
    if fmt is None:
        return False
    fmt = fmt.split(";")[0] # only look at the first format
    fmt = STRIP_RE.sub("", fmt) # ignore some formats
    return re.search(r"(?<![_\\])[dmhysDMHYS]", fmt) is not None


def is_timedelta_format(fmt):
    if fmt is None:
        return False
    fmt = fmt.split(";")[0] # only look at the first format
    return TIMEDELTA_RE.search(fmt) is not None


def is_datetime(fmt):
    """
    Return date, time or datetime
    """
    if not is_date_format(fmt):
        return

    DATE = TIME = False

    if any((x in fmt for x in 'dy')):
        DATE = True
    if any((x in fmt for x in 'hs')):
        TIME = True

    if DATE and TIME:
        return "datetime"
    if DATE:
        return "date"
    return "time"


def is_builtin(fmt):
    return fmt in BUILTIN_FORMATS.values()


def builtin_format_code(index):
    """Return one of the standard format codes by index."""
    try:
        fmt = BUILTIN_FORMATS[index]
    except KeyError:
        fmt = None
    return fmt


def builtin_format_id(fmt):
    """Return the id of a standard style."""
    return BUILTIN_FORMATS_REVERSE.get(fmt)


class NumberFormatDescriptor(String):

    def __set__(self, instance, value):
        if value is None:
            value = FORMAT_GENERAL
        super().__set__(instance, value)


class NumberFormat(Serialisable):

    numFmtId = Integer()
    formatCode = String()

    def __init__(self,
                 numFmtId=None,
                 formatCode=None,
                ):
        self.numFmtId = numFmtId
        self.formatCode = formatCode


class NumberFormatList(Serialisable):

    count = Integer(allow_none=True)
    numFmt = Sequence(expected_type=NumberFormat)

    __elements__ = ('numFmt',)
    __attrs__ = ("count",)

    def __init__(self,
                 count=None,
                 numFmt=(),
                ):
        self.numFmt = numFmt


    @property
    def count(self):
        return len(self.numFmt)


    def __getitem__(self, idx):
        return self.numFmt[idx]

```

---

### File: `tmp\openpyxl_sdist\openpyxl-3.1.5\openpyxl\styles\protection.py`

```python
# Copyright (c) 2010-2024 openpyxl

from openpyxl.descriptors import Bool
from openpyxl.descriptors.serialisable import Serialisable


class Protection(Serialisable):
    """Protection options for use in styles."""

    tagname = "protection"

    locked = Bool()
    hidden = Bool()

    def __init__(self, locked=True, hidden=False):
        self.locked = locked
        self.hidden = hidden

```

---

### File: `tmp\openpyxl_sdist\openpyxl-3.1.5\openpyxl\styles\proxy.py`

```python
# Copyright (c) 2010-2024 openpyxl

from copy import copy

from openpyxl.compat import deprecated


class StyleProxy:
    """
    Proxy formatting objects so that they cannot be altered
    """

    __slots__ = ('__target')

    def __init__(self, target):
        self.__target = target


    def __repr__(self):
        return repr(self.__target)


    def __getattr__(self, attr):
        return getattr(self.__target, attr)


    def __setattr__(self, attr, value):
        if attr != "_StyleProxy__target":
            raise AttributeError("Style objects are immutable and cannot be changed."
                                 "Reassign the style with a copy")
        super().__setattr__(attr, value)


    def __copy__(self):
        """
        Return a copy of the proxied object.
        """
        return copy(self.__target)


    def __add__(self, other):
        """
        Add proxied object to another instance and return the combined object
        """
        return self.__target + other


    @deprecated("Use copy(obj) or cell.obj = cell.obj + other")
    def copy(self, **kw):
        """Return a copy of the proxied object. Keyword args will be passed through"""
        cp = copy(self.__target)
        for k, v in kw.items():
            setattr(cp, k, v)
        return cp


    def __eq__(self, other):
        return self.__target == other


    def __ne__(self, other):
        return not self == other

```

---

### File: `tmp\openpyxl_sdist\openpyxl-3.1.5\openpyxl\styles\styleable.py`

```python
# Copyright (c) 2010-2024 openpyxl

from copy import copy

from .numbers import (
    BUILTIN_FORMATS,
    BUILTIN_FORMATS_MAX_SIZE,
    BUILTIN_FORMATS_REVERSE,
)
from .proxy import StyleProxy
from .cell_style import StyleArray
from .named_styles import NamedStyle
from .builtins import styles


class StyleDescriptor:

    def __init__(self, collection, key):
        self.collection = collection
        self.key = key

    def __set__(self, instance, value):
        coll = getattr(instance.parent.parent, self.collection)
        if not getattr(instance, "_style"):
            instance._style = StyleArray()
        setattr(instance._style, self.key, coll.add(value))


    def __get__(self, instance, cls):
        coll = getattr(instance.parent.parent, self.collection)
        if not getattr(instance, "_style"):
            instance._style = StyleArray()
        idx =  getattr(instance._style, self.key)
        return StyleProxy(coll[idx])


class NumberFormatDescriptor:

    key = "numFmtId"
    collection = '_number_formats'

    def __set__(self, instance, value):
        coll = getattr(instance.parent.parent, self.collection)
        if value in BUILTIN_FORMATS_REVERSE:
            idx = BUILTIN_FORMATS_REVERSE[value]
        else:
            idx = coll.add(value) + BUILTIN_FORMATS_MAX_SIZE

        if not getattr(instance, "_style"):
            instance._style = StyleArray()
        setattr(instance._style, self.key, idx)


    def __get__(self, instance, cls):
        if not getattr(instance, "_style"):
            instance._style = StyleArray()
        idx = getattr(instance._style, self.key)
        if idx < BUILTIN_FORMATS_MAX_SIZE:
            return BUILTIN_FORMATS.get(idx, "General")
        coll = getattr(instance.parent.parent, self.collection)
        return coll[idx - BUILTIN_FORMATS_MAX_SIZE]


class NamedStyleDescriptor:

    key = "xfId"
    collection = "_named_styles"


    def __set__(self, instance, value):
        if not getattr(instance, "_style"):
            instance._style = StyleArray()
        coll = getattr(instance.parent.parent, self.collection)
        if isinstance(value, NamedStyle):
            style = value
            if style not in coll:
                instance.parent.parent.add_named_style(style)
        elif value not in coll.names:
            if value in styles: # is it builtin?
                style = styles[value]
                if style not in coll:
                    instance.parent.parent.add_named_style(style)
            else:
                raise ValueError("{0} is not a known style".format(value))
        else:
            style = coll[value]
        instance._style = copy(style.as_tuple())


    def __get__(self, instance, cls):
        if not getattr(instance, "_style"):
            instance._style = StyleArray()
        idx = getattr(instance._style, self.key)
        coll = getattr(instance.parent.parent, self.collection)
        return coll.names[idx]


class StyleArrayDescriptor:

    def __init__(self, key):
        self.key = key

    def __set__(self, instance, value):
        if instance._style is None:
            instance._style = StyleArray()
        setattr(instance._style, self.key, value)


    def __get__(self, instance, cls):
        if instance._style is None:
            return False
        return bool(getattr(instance._style, self.key))


class StyleableObject:
    """
    Base class for styleble objects implementing proxy and lookup functions
    """

    font = StyleDescriptor('_fonts', "fontId")
    fill = StyleDescriptor('_fills', "fillId")
    border = StyleDescriptor('_borders', "borderId")
    number_format = NumberFormatDescriptor()
    protection = StyleDescriptor('_protections', "protectionId")
    alignment = StyleDescriptor('_alignments', "alignmentId")
    style = NamedStyleDescriptor()
    quotePrefix = StyleArrayDescriptor('quotePrefix')
    pivotButton = StyleArrayDescriptor('pivotButton')

    __slots__ = ('parent', '_style')

    def __init__(self, sheet, style_array=None):
        self.parent = sheet
        if style_array is not None:
            style_array = StyleArray(style_array)
        self._style = style_array


    @property
    def style_id(self):
        if self._style is None:
            self._style = StyleArray()
        return self.parent.parent._cell_styles.add(self._style)


    @property
    def has_style(self):
        if self._style is None:
            return False
        return any(self._style)


```

---

### File: `tmp\openpyxl_sdist\openpyxl-3.1.5\openpyxl\styles\stylesheet.py`

```python
# Copyright (c) 2010-2024 openpyxl

from warnings import warn

from openpyxl.descriptors.serialisable import Serialisable
from openpyxl.descriptors import (
    Typed,
)
from openpyxl.descriptors.sequence import NestedSequence
from openpyxl.descriptors.excel import ExtensionList
from openpyxl.utils.indexed_list import IndexedList
from openpyxl.xml.constants import ARC_STYLE, SHEET_MAIN_NS
from openpyxl.xml.functions import fromstring

from .builtins import styles
from .colors import ColorList
from .differential import DifferentialStyle
from .table import TableStyleList
from .borders import Border
from .fills import Fill
from .fonts import Font
from .numbers import (
    NumberFormatList,
    BUILTIN_FORMATS,
    BUILTIN_FORMATS_MAX_SIZE,
    BUILTIN_FORMATS_REVERSE,
    is_date_format,
    is_timedelta_format,
    builtin_format_code
)
from .named_styles import (
    _NamedCellStyleList,
    NamedStyleList,
    NamedStyle,
)
from .cell_style import CellStyle, CellStyleList


class Stylesheet(Serialisable):

    tagname = "styleSheet"

    numFmts = Typed(expected_type=NumberFormatList)
    fonts = NestedSequence(expected_type=Font, count=True)
    fills = NestedSequence(expected_type=Fill, count=True)
    borders = NestedSequence(expected_type=Border, count=True)
    cellStyleXfs = Typed(expected_type=CellStyleList)
    cellXfs = Typed(expected_type=CellStyleList)
    cellStyles = Typed(expected_type=_NamedCellStyleList)
    dxfs = NestedSequence(expected_type=DifferentialStyle, count=True)
    tableStyles = Typed(expected_type=TableStyleList, allow_none=True)
    colors = Typed(expected_type=ColorList, allow_none=True)
    extLst = Typed(expected_type=ExtensionList, allow_none=True)

    __elements__ = ('numFmts', 'fonts', 'fills', 'borders', 'cellStyleXfs',
                    'cellXfs', 'cellStyles', 'dxfs', 'tableStyles', 'colors')

    def __init__(self,
                 numFmts=None,
                 fonts=(),
                 fills=(),
                 borders=(),
                 cellStyleXfs=None,
                 cellXfs=None,
                 cellStyles=None,
                 dxfs=(),
                 tableStyles=None,
                 colors=None,
                 extLst=None,
                ):
        if numFmts is None:
            numFmts = NumberFormatList()
        self.numFmts = numFmts
        self.number_formats = IndexedList()
        self.fonts = fonts
        self.fills = fills
        self.borders = borders
        if cellStyleXfs is None:
            cellStyleXfs = CellStyleList()
        self.cellStyleXfs = cellStyleXfs
        if cellXfs is None:
            cellXfs = CellStyleList()
        self.cellXfs = cellXfs
        if cellStyles is None:
            cellStyles = _NamedCellStyleList()
        self.cellStyles = cellStyles

        self.dxfs = dxfs
        self.tableStyles = tableStyles
        self.colors = colors

        self.cell_styles = self.cellXfs._to_array()
        self.alignments = self.cellXfs.alignments
        self.protections = self.cellXfs.prots
        self._normalise_numbers()
        self.named_styles = self._merge_named_styles()


    @classmethod
    def from_tree(cls, node):
        # strip all attribs
        attrs = dict(node.attrib)
        for k in attrs:
            del node.attrib[k]
        return super().from_tree(node)


    def _merge_named_styles(self):
        """
        Merge named style names "cellStyles" with their associated styles
        "cellStyleXfs"
        """
        style_refs = self.cellStyles.remove_duplicates()
        from_ref = [self._expand_named_style(style_ref) for style_ref in style_refs]

        return NamedStyleList(from_ref)


    def _expand_named_style(self, style_ref):
        """
        Expand a named style reference element to a
        named style object by binding the relevant
        objects from the stylesheet
        """
        xf = self.cellStyleXfs[style_ref.xfId]
        named_style = NamedStyle(
            name=style_ref.name,
            hidden=style_ref.hidden,
            builtinId=style_ref.builtinId,
        )

        named_style.font = self.fonts[xf.fontId]
        named_style.fill = self.fills[xf.fillId]
        named_style.border = self.borders[xf.borderId]
        if xf.numFmtId < BUILTIN_FORMATS_MAX_SIZE:
            formats = BUILTIN_FORMATS
        else:
            formats = self.custom_formats

        if xf.numFmtId in formats:
            named_style.number_format = formats[xf.numFmtId]
        if xf.alignment:
            named_style.alignment = xf.alignment
        if xf.protection:
            named_style.protection = xf.protection

        return named_style


    def _split_named_styles(self, wb):
        """
        Convert NamedStyle into separate CellStyle and Xf objects

        """
        for  style in wb._named_styles:
            self.cellStyles.cellStyle.append(style.as_name())
            self.cellStyleXfs.xf.append(style.as_xf())


    @property
    def custom_formats(self):
        return dict([(n.numFmtId, n.formatCode) for n in self.numFmts.numFmt])


    def _normalise_numbers(self):
        """
        Rebase custom numFmtIds with a floor of 164 when reading stylesheet
        And index datetime formats
        """
        date_formats = set()
        timedelta_formats = set()
        custom = self.custom_formats
        formats = self.number_formats
        for idx, style in enumerate(self.cell_styles):
            if style.numFmtId in custom:
                fmt = custom[style.numFmtId]
                if fmt in BUILTIN_FORMATS_REVERSE: # remove builtins
                    style.numFmtId = BUILTIN_FORMATS_REVERSE[fmt]
                else:
                    style.numFmtId = formats.add(fmt) + BUILTIN_FORMATS_MAX_SIZE
            else:
                fmt = builtin_format_code(style.numFmtId)
            if is_date_format(fmt):
                # Create an index of which styles refer to datetimes
                date_formats.add(idx)
            if is_timedelta_format(fmt):
                # Create an index of which styles refer to timedeltas
                timedelta_formats.add(idx)
        self.date_formats = date_formats
        self.timedelta_formats = timedelta_formats


    def to_tree(self, tagname=None, idx=None, namespace=None):
        tree = super().to_tree(tagname, idx, namespace)
        tree.set("xmlns", SHEET_MAIN_NS)
        return tree


def apply_stylesheet(archive, wb):
    """
    Add styles to workbook if present
    """
    try:
        src = archive.read(ARC_STYLE)
    except KeyError:
        return wb

    node = fromstring(src)
    stylesheet = Stylesheet.from_tree(node)

    if stylesheet.cell_styles:

        wb._borders = IndexedList(stylesheet.borders)
        wb._fonts = IndexedList(stylesheet.fonts)
        wb._fills = IndexedList(stylesheet.fills)
        wb._differential_styles.styles = stylesheet.dxfs
        wb._number_formats = stylesheet.number_formats
        wb._protections = stylesheet.protections
        wb._alignments = stylesheet.alignments
        wb._table_styles = stylesheet.tableStyles

        # need to overwrite openpyxl defaults in case workbook has different ones
        wb._cell_styles = stylesheet.cell_styles
        wb._named_styles = stylesheet.named_styles
        wb._date_formats = stylesheet.date_formats
        wb._timedelta_formats = stylesheet.timedelta_formats

        for ns in wb._named_styles:
            ns.bind(wb)

    else:
        warn("Workbook contains no stylesheet, using openpyxl's defaults")

    if not wb._named_styles:
        normal = styles['Normal']
        wb.add_named_style(normal)
        warn("Workbook contains no default style, apply openpyxl's default")

    if stylesheet.colors is not None:
        wb._colors = stylesheet.colors.index


def write_stylesheet(wb):
    stylesheet = Stylesheet()
    stylesheet.fonts = wb._fonts
    stylesheet.fills = wb._fills
    stylesheet.borders = wb._borders
    stylesheet.dxfs = wb._differential_styles.styles
    stylesheet.colors = ColorList(indexedColors=wb._colors)

    from .numbers import NumberFormat
    fmts = []
    for idx, code in enumerate(wb._number_formats, BUILTIN_FORMATS_MAX_SIZE):
        fmt = NumberFormat(idx, code)
        fmts.append(fmt)

    stylesheet.numFmts.numFmt = fmts

    xfs = []
    for style in wb._cell_styles:
        xf = CellStyle.from_array(style)

        if style.alignmentId:
            xf.alignment = wb._alignments[style.alignmentId]

        if style.protectionId:
            xf.protection = wb._protections[style.protectionId]
        xfs.append(xf)
    stylesheet.cellXfs = CellStyleList(xf=xfs)

    stylesheet._split_named_styles(wb)
    stylesheet.tableStyles = wb._table_styles

    return stylesheet.to_tree()

```

---

### File: `tmp\openpyxl_sdist\openpyxl-3.1.5\openpyxl\styles\table.py`

```python
# Copyright (c) 2010-2024 openpyxl

from openpyxl.descriptors.serialisable import Serialisable
from openpyxl.descriptors import (
    Typed,
    Float,
    Bool,
    Set,
    Integer,
    NoneSet,
    String,
    Sequence
)

from .colors import Color


class TableStyleElement(Serialisable):

    tagname = "tableStyleElement"

    type = Set(values=(['wholeTable', 'headerRow', 'totalRow', 'firstColumn',
                        'lastColumn', 'firstRowStripe', 'secondRowStripe', 'firstColumnStripe',
                        'secondColumnStripe', 'firstHeaderCell', 'lastHeaderCell',
                        'firstTotalCell', 'lastTotalCell', 'firstSubtotalColumn',
                        'secondSubtotalColumn', 'thirdSubtotalColumn', 'firstSubtotalRow',
                        'secondSubtotalRow', 'thirdSubtotalRow', 'blankRow',
                        'firstColumnSubheading', 'secondColumnSubheading',
                        'thirdColumnSubheading', 'firstRowSubheading', 'secondRowSubheading',
                        'thirdRowSubheading', 'pageFieldLabels', 'pageFieldValues']))
    size = Integer(allow_none=True)
    dxfId = Integer(allow_none=True)

    def __init__(self,
                 type=None,
                 size=None,
                 dxfId=None,
                ):
        self.type = type
        self.size = size
        self.dxfId = dxfId


class TableStyle(Serialisable):

    tagname = "tableStyle"

    name = String()
    pivot = Bool(allow_none=True)
    table = Bool(allow_none=True)
    count = Integer(allow_none=True)
    tableStyleElement = Sequence(expected_type=TableStyleElement, allow_none=True)

    __elements__ = ('tableStyleElement',)

    def __init__(self,
                 name=None,
                 pivot=None,
                 table=None,
                 count=None,
                 tableStyleElement=(),
                ):
        self.name = name
        self.pivot = pivot
        self.table = table
        self.count = count
        self.tableStyleElement = tableStyleElement


class TableStyleList(Serialisable):

    tagname = "tableStyles"

    defaultTableStyle = String(allow_none=True)
    defaultPivotStyle = String(allow_none=True)
    tableStyle = Sequence(expected_type=TableStyle, allow_none=True)

    __elements__ = ('tableStyle',)
    __attrs__ = ("count", "defaultTableStyle", "defaultPivotStyle")

    def __init__(self,
                 count=None,
                 defaultTableStyle="TableStyleMedium9",
                 defaultPivotStyle="PivotStyleLight16",
                 tableStyle=(),
                ):
        self.defaultTableStyle = defaultTableStyle
        self.defaultPivotStyle = defaultPivotStyle
        self.tableStyle = tableStyle


    @property
    def count(self):
        return len(self.tableStyle)

```

---

### File: `tmp\openpyxl_sdist\openpyxl-3.1.5\openpyxl\utils\__init__.py`

```python
# Copyright (c) 2010-2024 openpyxl


from .cell import (
    absolute_coordinate,
    cols_from_range,
    column_index_from_string,
    coordinate_to_tuple,
    get_column_letter,
    get_column_interval,
    quote_sheetname,
    range_boundaries,
    range_to_tuple,
    rows_from_range,
)

from .formulas import FORMULAE

```

---

### File: `tmp\openpyxl_sdist\openpyxl-3.1.5\openpyxl\utils\bound_dictionary.py`

```python
# Copyright (c) 2010-2024 openpyxl

from collections import defaultdict


class BoundDictionary(defaultdict):
    """
    A default dictionary where elements are tightly coupled.

    The factory method is responsible for binding the parent object to the child.

    If a reference attribute is assigned then child objects will have the key assigned to this.

    Otherwise it's just a defaultdict.
    """

    def __init__(self, reference=None, *args, **kw):
        self.reference = reference
        super().__init__(*args, **kw)


    def __getitem__(self, key):
        value = super().__getitem__(key)
        if self.reference is not None:
            setattr(value, self.reference, key)
        return value

```

---

### File: `tmp\openpyxl_sdist\openpyxl-3.1.5\openpyxl\utils\cell.py`

```python
# Copyright (c) 2010-2024 openpyxl

"""
Collection of utilities used within the package and also available for client code
"""
from functools import lru_cache
from itertools import chain, product
from string import ascii_uppercase, digits
import re

from .exceptions import CellCoordinatesException

# constants
COORD_RE = re.compile(r'^[$]?([A-Za-z]{1,3})[$]?(\d+)$')
COL_RANGE = """[A-Z]{1,3}:[A-Z]{1,3}:"""
ROW_RANGE = r"""\d+:\d+:"""
RANGE_EXPR = r"""
[$]?(?P<min_col>[A-Za-z]{1,3})?
[$]?(?P<min_row>\d+)?
(:[$]?(?P<max_col>[A-Za-z]{1,3})?
[$]?(?P<max_row>\d+)?)?
"""
ABSOLUTE_RE = re.compile('^' + RANGE_EXPR +'$', re.VERBOSE)
SHEET_TITLE = r"""
(('(?P<quoted>([^']|'')*)')|(?P<notquoted>[^'^ ^!]*))!"""
SHEETRANGE_RE = re.compile("""{0}(?P<cells>{1})(?=,?)""".format(
    SHEET_TITLE, RANGE_EXPR), re.VERBOSE)


def get_column_interval(start, end):
    """
    Given the start and end columns, return all the columns in the series.

    The start and end columns can be either column letters or 1-based
    indexes.
    """
    if isinstance(start, str):
        start = column_index_from_string(start)
    if isinstance(end, str):
        end = column_index_from_string(end)
    return [get_column_letter(x) for x in range(start, end + 1)]


def coordinate_from_string(coord_string):
    """Convert a coordinate string like 'B12' to a tuple ('B', 12)"""
    match = COORD_RE.match(coord_string)
    if not match:
        msg = f"Invalid cell coordinates ({coord_string})"
        raise CellCoordinatesException(msg)
    column, row = match.groups()
    row = int(row)
    if not row:
        msg = f"There is no row 0 ({coord_string})"
        raise CellCoordinatesException(msg)
    return column, row


def absolute_coordinate(coord_string):
    """Convert a coordinate to an absolute coordinate string (B12 -> $B$12)"""
    m = ABSOLUTE_RE.match(coord_string)
    if not m:
        raise ValueError(f"{coord_string} is not a valid coordinate range")

    d = m.groupdict('')
    for k, v in d.items():
        if v:
            d[k] = f"${v}"

    if d['max_col'] or d['max_row']:
        fmt = "{min_col}{min_row}:{max_col}{max_row}"
    else:
        fmt = "{min_col}{min_row}"
    return fmt.format(**d)


__decimal_to_alpha = [""] + list(ascii_uppercase)

@lru_cache(maxsize=None)
def get_column_letter(col_idx):
    """
    Convert decimal column position to its ASCII (base 26) form.

    Because column indices are 1-based, strides are actually pow(26, n) + 26
    Hence, a correction is applied between pow(26, n) and pow(26, 2) + 26 to
    prevent and additional column letter being prepended

    "A" == 1 == pow(26, 0)
    "Z" == 26 == pow(26, 0) + 26 // decimal equivalent 10
    "AA" == 27 == pow(26, 1) + 1
    "ZZ" == 702 == pow(26, 2) + 26 // decimal equivalent 100
    """

    if not 1 <= col_idx <= 18278:
        raise ValueError("Invalid column index {0}".format(col_idx))

    result = []

    if col_idx < 26:
        return __decimal_to_alpha[col_idx]

    while col_idx:
        col_idx, remainder = divmod(col_idx, 26)
        result.insert(0, __decimal_to_alpha[remainder])
        if not remainder:
            col_idx -= 1
            result.insert(0, "Z")

    return "".join(result)


__alpha_to_decimal = {letter:pos for pos, letter in enumerate(ascii_uppercase, 1)}
__powers = (1, 26, 676)

@lru_cache(maxsize=None)
def column_index_from_string(col):
    """
    Convert ASCII column name (base 26) to decimal with 1-based index

    Characters represent descending multiples of powers of 26

    "AFZ" == 26 * pow(26, 0) + 6 * pow(26, 1) + 1 * pow(26, 2)
    """
    error_msg = f"'{col}' is not a valid column name. Column names are from A to ZZZ"
    if len(col) > 3:
        raise ValueError(error_msg)
    idx = 0
    col = reversed(col.upper())
    for letter, power in zip(col, __powers):
        try:
            pos = __alpha_to_decimal[letter]
        except KeyError:
            raise ValueError(error_msg)
        idx += pos * power
    if not 0 < idx < 18279:
        raise ValueError(error_msg)
    return idx


def range_boundaries(range_string):
    """
    Convert a range string into a tuple of boundaries:
    (min_col, min_row, max_col, max_row)
    Cell coordinates will be converted into a range with the cell at both end
    """
    msg = "{0} is not a valid coordinate or range".format(range_string)
    m = ABSOLUTE_RE.match(range_string)
    if not m:
        raise ValueError(msg)

    min_col, min_row, sep, max_col, max_row = m.groups()

    if sep:
        cols = min_col, max_col
        rows = min_row, max_row

        if not (
            all(cols + rows) or
            all(cols) and not any(rows) or
            all(rows) and not any(cols)
        ):
            raise ValueError(msg)

    if min_col is not None:
        min_col = column_index_from_string(min_col)

    if min_row is not None:
        min_row = int(min_row)

    if max_col is not None:
        max_col = column_index_from_string(max_col)
    else:
        max_col = min_col

    if max_row is not None:
        max_row = int(max_row)
    else:
        max_row = min_row

    return min_col, min_row, max_col, max_row


def rows_from_range(range_string):
    """
    Get individual addresses for every cell in a range.
    Yields one row at a time.
    """
    min_col, min_row, max_col, max_row = range_boundaries(range_string)
    rows = range(min_row, max_row + 1)
    cols = [get_column_letter(col) for col in range(min_col, max_col + 1)]
    for row in rows:
        yield tuple('{0}{1}'.format(col, row) for col in cols)


def cols_from_range(range_string):
    """
    Get individual addresses for every cell in a range.
    Yields one row at a time.
    """
    min_col, min_row, max_col, max_row = range_boundaries(range_string)
    rows = range(min_row, max_row+1)
    cols = (get_column_letter(col) for col in range(min_col, max_col+1))
    for col in cols:
        yield tuple('{0}{1}'.format(col, row) for row in rows)


def coordinate_to_tuple(coordinate):
    """
    Convert an Excel style coordinate to (row, column) tuple
    """
    for idx, c in enumerate(coordinate):
        if c in digits:
            break
    col = coordinate[:idx]
    row = coordinate[idx:]
    return int(row), column_index_from_string(col)


def range_to_tuple(range_string):
    """
    Convert a worksheet range to the sheetname and maximum and minimum
    coordinate indices
    """
    m = SHEETRANGE_RE.match(range_string)
    if m is None:
        raise ValueError("Value must be of the form sheetname!A1:E4")
    sheetname = m.group("quoted") or m.group("notquoted")
    cells = m.group("cells")
    boundaries = range_boundaries(cells)
    return sheetname, boundaries


def quote_sheetname(sheetname):
    """
    Add quotes around sheetnames if they contain spaces.
    """
    if "'" in sheetname:
        sheetname = sheetname.replace("'", "''")

    sheetname = u"'{0}'".format(sheetname)
    return sheetname

```

---

### File: `tmp\openpyxl_sdist\openpyxl-3.1.5\openpyxl\utils\dataframe.py`

```python
# Copyright (c) 2010-2024 openpyxl

from itertools import accumulate
import operator
import numpy
from openpyxl.compat.product import prod


def dataframe_to_rows(df, index=True, header=True):
    """
    Convert a Pandas dataframe into something suitable for passing into a worksheet.
    If index is True then the index will be included, starting one row below the header.
    If header is True then column headers will be included starting one column to the right.
    Formatting should be done by client code.
    """
    from pandas import Timestamp

    if header:
        if df.columns.nlevels > 1:
            rows = expand_index(df.columns, header)
        else:
            rows = [list(df.columns.values)]
        for row in rows:
            n = []
            for v in row:
                if isinstance(v, numpy.datetime64):
                    v = Timestamp(v)
                n.append(v)
            row = n
            if index:
                row = [None]*df.index.nlevels + row
            yield row

    if index:
        yield df.index.names

    expanded = ([v] for v in df.index)
    if df.index.nlevels > 1:
        expanded = expand_index(df.index)

    # Using the expanded index is preferable to df.itertuples(index=True) so that we have 'None' inserted where applicable
    for (df_index, row) in zip(expanded, df.itertuples(index=False)):
        row = list(row)
        if index:
            row = df_index + row
        yield row


def expand_index(index, header=False):
    """
    Expand axis or column Multiindex
    For columns use header = True
    For axes use header = False (default)
    """

    # For each element of the index, zip the members with the previous row
    # If the 2 elements of the zipped list do not match, we can insert the new value into the row
    # or if an earlier member was different, all later members should be added to the row
    values = list(index.values)
    previous_value = [None] * len(values[0])
    result = []

    for value in values:
        row = [None] * len(value)

        # Once there's a difference in member of an index with the prior index, we need to store all subsequent members in the row
        prior_change = False
        for idx, (current_index_member, previous_index_member) in enumerate(zip(value, previous_value)):

            if current_index_member != previous_index_member or prior_change:
                row[idx] = current_index_member
                prior_change = True

        previous_value = value

        # If this is for a row index, we're already returning a row so just yield
        if not header:
            yield row
        else:
            result.append(row)

    # If it's for a header, we need to transpose to get it in row order
    # Example: result = [['A', 'A'], [None, 'B']] -> [['A', None], ['A', 'B']]
    if header:
        result = numpy.array(result).transpose().tolist()
        for row in result:
            yield row

```

---

### File: `tmp\openpyxl_sdist\openpyxl-3.1.5\openpyxl\utils\datetime.py`

```python
# Copyright (c) 2010-2024 openpyxl

"""Manage Excel date weirdness."""

# Python stdlib imports
import datetime
from math import isnan
import re


# constants
MAC_EPOCH = datetime.datetime(1904, 1, 1)
WINDOWS_EPOCH = datetime.datetime(1899, 12, 30)
CALENDAR_WINDOWS_1900 = 2415018.5   # Julian date of WINDOWS_EPOCH
CALENDAR_MAC_1904 = 2416480.5       # Julian date of MAC_EPOCH
CALENDAR_WINDOWS_1900 = WINDOWS_EPOCH
CALENDAR_MAC_1904 = MAC_EPOCH
SECS_PER_DAY = 86400

ISO_FORMAT = '%Y-%m-%dT%H:%M:%SZ'
ISO_REGEX = re.compile(r'''
(?P<date>(?P<year>\d{4})-(?P<month>\d{2})-(?P<day>\d{2}))?T?
(?P<time>(?P<hour>\d{2}):(?P<minute>\d{2})(:(?P<second>\d{2})(?P<microsecond>\.\d{1,3})?)?)?Z?''',
                                       re.VERBOSE)
ISO_DURATION = re.compile(r'PT((?P<hours>\d+)H)?((?P<minutes>\d+)M)?((?P<seconds>\d+(\.\d{1,3})?)S)?')


def to_ISO8601(dt):
    """Convert from a datetime to a timestamp string."""
    if hasattr(dt, "microsecond") and dt.microsecond:
        return dt.isoformat(timespec="milliseconds")
    return dt.isoformat()


def from_ISO8601(formatted_string):
    """Convert from a timestamp string to a datetime object. According to
    18.17.4 in the specification the following ISO 8601 formats are
    supported.

    Dates B.1.1 and B.2.1
    Times B.1.2 and B.2.2
    Datetimes B.1.3 and B.2.3

    There is no concept of timedeltas in the specification, but Excel
    writes them (in strict OOXML mode), so these are also understood.
    """
    if not formatted_string:
        return None

    match = ISO_REGEX.match(formatted_string)
    if match and any(match.groups()):
        parts = match.groupdict(0)
        for key in ["year", "month", "day", "hour", "minute", "second"]:
            if parts[key]:
                parts[key] = int(parts[key])

        if parts["microsecond"]:
            parts["microsecond"] = int(float(parts['microsecond']) * 1_000_000)

        if not parts["date"]:
            dt = datetime.time(parts['hour'], parts['minute'], parts['second'], parts["microsecond"])
        elif not parts["time"]:
            dt = datetime.date(parts['year'], parts['month'], parts['day'])
        else:
            del parts["time"]
            del parts["date"]
            dt = datetime.datetime(**parts)
        return dt

    match = ISO_DURATION.match(formatted_string)
    if match and any(match.groups()):
        parts = match.groupdict(0)
        for key, val in parts.items():
            if val:
                parts[key] = float(val)
        return datetime.timedelta(**parts)

    raise ValueError("Invalid datetime value {}".format(formatted_string))


def to_excel(dt, epoch=WINDOWS_EPOCH):
    """Convert Python datetime to Excel serial"""
    if isinstance(dt, datetime.time):
        return time_to_days(dt)
    if isinstance(dt, datetime.timedelta):
        return timedelta_to_days(dt)
    if isnan(dt.year):  # Pandas supports Not a Date
        return

    if not hasattr(dt, "date"):
        dt = datetime.datetime.combine(dt, datetime.time())

    # rebase on epoch and adjust for < 1900-03-01
    days = (dt - epoch).days
    if 0 < days <= 60 and epoch == WINDOWS_EPOCH:
        days -= 1
    return days + time_to_days(dt)


def from_excel(value, epoch=WINDOWS_EPOCH, timedelta=False):
    """Convert Excel serial to Python datetime"""
    if value is None:
        return

    if timedelta:
        td = datetime.timedelta(days=value)
        if td.microseconds:
            # round to millisecond precision
            td = datetime.timedelta(seconds=td.total_seconds() // 1,
                                    microseconds=round(td.microseconds, -3))
        return td

    day, fraction = divmod(value, 1)
    diff = datetime.timedelta(milliseconds=round(fraction * SECS_PER_DAY * 1000))
    if 0 <= value < 1 and diff.days == 0:
        return days_to_time(diff)
    if 0 < value < 60 and epoch == WINDOWS_EPOCH:
        day += 1
    return epoch + datetime.timedelta(days=day) + diff


def time_to_days(value):
    """Convert a time value to fractions of day"""
    return (
        (value.hour * 3600)
        + (value.minute * 60)
        + value.second
        + value.microsecond / 10**6
        ) / SECS_PER_DAY


def timedelta_to_days(value):
    """Convert a timedelta value to fractions of a day"""
    return value.total_seconds() / SECS_PER_DAY


def days_to_time(value):
    mins, seconds = divmod(value.seconds, 60)
    hours, mins = divmod(mins, 60)
    return datetime.time(hours, mins, seconds, value.microseconds)

```

---

### File: `tmp\openpyxl_sdist\openpyxl-3.1.5\openpyxl\utils\escape.py`

```python
# Copyright (c) 2010-2024 openpyxl

"""
OOXML has non-standard escaping for characters < \031
"""

import re


def escape(value):
    r"""
    Convert ASCII < 31 to OOXML: \n == _x + hex(ord(\n)) + _
    """

    CHAR_REGEX = re.compile(r"[\001-\031]")

    def _sub(match):
        """
        Callback to escape chars
        """
        return "_x{:0>4x}_".format(ord(match.group(0)))

    return CHAR_REGEX.sub(_sub, value)


def unescape(value):
    r"""
    Convert escaped strings to ASCIII: _x000a_ == \n
    """


    ESCAPED_REGEX = re.compile("_x([0-9A-Fa-f]{4})_")

    def _sub(match):
        """
        Callback to unescape chars
        """
        return chr(int(match.group(1), 16))

    if "_x" in value:
        value = ESCAPED_REGEX.sub(_sub, value)

    return value

```

---

### File: `tmp\openpyxl_sdist\openpyxl-3.1.5\openpyxl\utils\exceptions.py`

```python
# Copyright (c) 2010-2024 openpyxl


"""Definitions for openpyxl shared exception classes."""


class CellCoordinatesException(Exception):
    """Error for converting between numeric and A1-style cell references."""


class IllegalCharacterError(Exception):
    """The data submitted which cannot be used directly in Excel files. It
    must be removed or escaped."""


class NamedRangeException(Exception):
    """Error for badly formatted named ranges."""


class SheetTitleException(Exception):
    """Error for bad sheet names."""


class InvalidFileException(Exception):
    """Error for trying to open a non-ooxml file."""


class ReadOnlyWorkbookException(Exception):
    """Error for trying to modify a read-only workbook"""


class WorkbookAlreadySaved(Exception):
    """Error when attempting to perform operations on a dump workbook
    while it has already been dumped once"""

```

---

### File: `tmp\openpyxl_sdist\openpyxl-3.1.5\openpyxl\utils\formulas.py`

```python
# Copyright (c) 2010-2024 openpyxl

"""
List of builtin formulae
"""

FORMULAE = ("CUBEKPIMEMBER", "CUBEMEMBER", "CUBEMEMBERPROPERTY", "CUBERANKEDMEMBER", "CUBESET", "CUBESETCOUNT", "CUBEVALUE", "DAVERAGE", "DCOUNT", "DCOUNTA", "DGET", "DMAX", "DMIN", "DPRODUCT", "DSTDEV", "DSTDEVP", "DSUM", "DVAR", "DVARP", "DATE", "DATEDIF", "DATEVALUE", "DAY", "DAYS360", "EDATE", "EOMONTH", "HOUR", "MINUTE", "MONTH", "NETWORKDAYS", "NETWORKDAYS.INTL", "NOW", "SECOND", "TIME", "TIMEVALUE", "TODAY", "WEEKDAY", "WEEKNUM", "WORKDAY", "WORKDAY.INTL", "YEAR", "YEARFRAC", "BESSELI", "BESSELJ", "BESSELK", "BESSELY", "BIN2DEC", "BIN2HEX", "BIN2OCT", "COMPLEX", "CONVERT", "DEC2BIN", "DEC2HEX", "DEC2OCT", "DELTA", "ERF", "ERFC", "GESTEP", "HEX2BIN", "HEX2DEC", "HEX2OCT", "IMABS", "IMAGINARY", "IMARGUMENT", "IMCONJUGATE", "IMCOS", "IMDIV", "IMEXP", "IMLN", "IMLOG10", "IMLOG2", "IMPOWER", "IMPRODUCT", "IMREAL", "IMSIN", "IMSQRT", "IMSUB", "IMSUM", "OCT2BIN", "OCT2DEC", "OCT2HEX", "ACCRINT", "ACCRINTM", "AMORDEGRC", "AMORLINC", "COUPDAYBS", "COUPDAYS", "COUPDAYSNC", "COUPNCD", "COUPNUM", "COUPPCD", "CUMIPMT", "CUMPRINC", "DB", "DDB", "DISC", "DOLLARDE", "DOLLARFR", "DURATION", "EFFECT", "FV", "FVSCHEDULE", "INTRATE", "IPMT", "IRR", "ISPMT", "MDURATION", "MIRR", "NOMINAL", "NPER", "NPV", "ODDFPRICE", "ODDFYIELD", "ODDLPRICE", "ODDLYIELD", "PMT", "PPMT", "PRICE", "PRICEDISC", "PRICEMAT", "PV", "RATE", "RECEIVED", "SLN", "SYD", "TBILLEQ", "TBILLPRICE", "TBILLYIELD", "VDB", "XIRR", "XNPV", "YIELD", "YIELDDISC", "YIELDMAT", "CELL", "ERROR.TYPE", "INFO", "ISBLANK", "ISERR", "ISERROR", "ISEVEN", "ISLOGICAL", "ISNA", "ISNONTEXT", "ISNUMBER", "ISODD", "ISREF", "ISTEXT", "N", "NA", "TYPE", "AND", "FALSE", "IF", "IFERROR", "NOT", "OR", "TRUE", "ADDRESS", "AREAS", "CHOOSE", "COLUMN", "COLUMNS", "GETPIVOTDATA", "HLOOKUP", "HYPERLINK", "INDEX", "INDIRECT", "LOOKUP", "MATCH", "OFFSET", "ROW", "ROWS", "RTD", "TRANSPOSE", "VLOOKUP", "ABS", "ACOS", "ACOSH", "ASIN", "ASINH", "ATAN", "ATAN2", "ATANH", "CEILING", "COMBIN", "COS", "COSH", "DEGREES", "ECMA.CEILING", "EVEN", "EXP", "FACT", "FACTDOUBLE", "FLOOR", "GCD", "INT", "ISO.CEILING", "LCM", "LN", "LOG", "LOG10", "MDETERM", "MINVERSE", "MMULT", "MOD", "MROUND", "MULTINOMIAL", "ODD", "PI", "POWER", "PRODUCT", "QUOTIENT", "RADIANS", "RAND", "RANDBETWEEN", "ROMAN", "ROUND", "ROUNDDOWN", "ROUNDUP", "SERIESSUM", "SIGN", "SIN", "SINH", "SQRT", "SQRTPI", "SUBTOTAL", "SUM", "SUMIF", "SUMIFS", "SUMPRODUCT", "SUMSQ", "SUMX2MY2", "SUMX2PY2", "SUMXMY2", "TAN", "TANH", "TRUNC", "AVEDEV", "AVERAGE", "AVERAGEA", "AVERAGEIF", "AVERAGEIFS", "BETADIST", "BETAINV", "BINOMDIST", "CHIDIST", "CHIINV", "CHITEST", "CONFIDENCE", "CORREL", "COUNT", "COUNTA", "COUNTBLANK", "COUNTIF", "COUNTIFS", "COVAR", "CRITBINOM", "DEVSQ", "EXPONDIST", "FDIST", "FINV", "FISHER", "FISHERINV", "FORECAST", "FREQUENCY", "FTEST", "GAMMADIST", "GAMMAINV", "GAMMALN", "GEOMEAN", "GROWTH", "HARMEAN", "HYPGEOMDIST", "INTERCEPT", "KURT", "LARGE", "LINEST", "LOGEST", "LOGINV", "LOGNORMDIST", "MAX", "MAXA", "MEDIAN", "MIN", "MINA", "MODE", "NEGBINOMDIST", "NORMDIST", "NORMINV", "NORMSDIST", "NORMSINV", "PEARSON", "PERCENTILE", "PERCENTRANK", "PERMUT", "POISSON", "PROB", "QUARTILE", "RANK", "RSQ", "SKEW", "SLOPE", "SMALL", "STANDARDIZE", "STDEV", "STDEVA", "STDEVP", "STDEVPA", "STEYX", "TDIST", "TINV", "TREND", "TRIMMEAN", "TTEST", "VAR", "VARA", "VARP", "VARPA", "WEIBULL", "ZTEST", "ASC", "BAHTTEXT", "CHAR", "CLEAN", "CODE", "CONCATENATE", "DOLLAR", "EXACT", "FIND", "FINDB", "FIXED", "JIS", "LEFT", "LEFTB", "LEN", "LENB", "LOWER", "MID", "MIDB", "PHONETIC", "PROPER", "REPLACE", "REPLACEB", "REPT", "RIGHT", "RIGHTB", "SEARCH", "SEARCHB", "SUBSTITUTE", "T", "TEXT", "TRIM", "UPPER", "VALUE")

FORMULAE = frozenset(FORMULAE)


from openpyxl.formula import Tokenizer


def validate(formula):
    """
    Utility function for checking whether a formula is syntactically correct
    """
    assert formula.startswith("=")
    formula = Tokenizer(formula)
    for t in formula.items:
        if t.type == "FUNC" and t.subtype == "OPEN":
            if not t.value.startswith("_xlfn.") and t.value[:-1] not in FORMULAE:
                raise ValueError(f"Unknown function {t.value} in {formula.formula}. The function may need a prefix")

```

---

### File: `tmp\openpyxl_sdist\openpyxl-3.1.5\openpyxl\utils\indexed_list.py`

```python
# Copyright (c) 2010-2024 openpyxl


class IndexedList(list):
    """
    List with optimised access by value
    Based on Alex Martelli's recipe

    http://code.activestate.com/recipes/52303-the-auxiliary-dictionary-idiom-for-sequences-with-/
    """

    _dict = {}

    def __init__(self, iterable=None):
        self.clean = True
        self._dict = {}
        if iterable is not None:
            self.clean = False
            for idx, val in enumerate(iterable):
                self._dict[val] = idx
                list.append(self, val)

    def _rebuild_dict(self):
        self._dict = {}
        idx = 0
        for value in self:
            if value not in self._dict:
                self._dict[value] = idx
                idx += 1
        self.clean = True

    def __contains__(self, value):
        if not self.clean:
            self._rebuild_dict()
        return value in self._dict

    def index(self, value):
        if value in self:
            return self._dict[value]
        raise ValueError

    def append(self, value):
        if value not in self._dict:
            self._dict[value] = len(self)
            list.append(self, value)

    def add(self, value):
        self.append(value)
        return self._dict[value]

```

---

### File: `tmp\openpyxl_sdist\openpyxl-3.1.5\openpyxl\utils\inference.py`

```python
# Copyright (c) 2010-2024 openpyxl

"""
Type inference functions
"""
import datetime
import re

from openpyxl.styles import numbers

PERCENT_REGEX = re.compile(r'^(?P<number>\-?[0-9]*\.?[0-9]*\s?)\%$')
TIME_REGEX = re.compile(r"""
^(?: # HH:MM and HH:MM:SS
(?P<hour>[0-1]{0,1}[0-9]{2}):
(?P<minute>[0-5][0-9]):?
(?P<second>[0-5][0-9])?$)
|
^(?: # MM:SS.
([0-5][0-9]):
([0-5][0-9])?\.
(?P<microsecond>\d{1,6}))
""", re.VERBOSE)
NUMBER_REGEX = re.compile(r'^-?([\d]|[\d]+\.[\d]*|\.[\d]+|[1-9][\d]+\.?[\d]*)((E|e)[-+]?[\d]+)?$')


def cast_numeric(value):
    """Explicitly convert a string to a numeric value"""
    if NUMBER_REGEX.match(value):
        try:
            return int(value)
        except ValueError:
            return float(value)


def cast_percentage(value):
    """Explicitly convert a string to numeric value and format as a
    percentage"""
    match = PERCENT_REGEX.match(value)
    if match:
        return float(match.group('number')) / 100



def cast_time(value):
    """Explicitly convert a string to a number and format as datetime or
    time"""
    match = TIME_REGEX.match(value)
    if match:
        if match.group("microsecond") is not None:
            value = value[:12]
            pattern = "%M:%S.%f"
            #fmt = numbers.FORMAT_DATE_TIME5
        elif match.group('second') is None:
            #fmt = numbers.FORMAT_DATE_TIME3
            pattern = "%H:%M"
        else:
            pattern = "%H:%M:%S"
            #fmt = numbers.FORMAT_DATE_TIME6
        value = datetime.datetime.strptime(value, pattern)
        return value.time()

```

---

### File: `tmp\openpyxl_sdist\openpyxl-3.1.5\openpyxl\utils\protection.py`

```python
# Copyright (c) 2010-2024 openpyxl


def hash_password(plaintext_password=''):
    """
    Create a password hash from a given string for protecting a worksheet
    only. This will not work for encrypting a workbook.

    This method is based on the algorithm provided by
    Daniel Rentz of OpenOffice and the PEAR package
    Spreadsheet_Excel_Writer by Xavier Noguer <xnoguer@rezebra.com>.
    See also http://blogs.msdn.com/b/ericwhite/archive/2008/02/23/the-legacy-hashing-algorithm-in-open-xml.aspx
    """
    password = 0x0000
    for idx, char in enumerate(plaintext_password, 1):
        value = ord(char) << idx
        rotated_bits = value >> 15
        value &= 0x7fff
        password ^= (value | rotated_bits)
    password ^= len(plaintext_password)
    password ^= 0xCE4B
    return str(hex(password)).upper()[2:]

```

---

### File: `tmp\openpyxl_sdist\openpyxl-3.1.5\openpyxl\utils\units.py`

```python

# Copyright (c) 2010-2024 openpyxl

import math


#constants

DEFAULT_ROW_HEIGHT = 15.  # Default row height measured in point size.
BASE_COL_WIDTH = 8 # in characters
DEFAULT_COLUMN_WIDTH = BASE_COL_WIDTH + 5
#  = baseColumnWidth + {margin padding (2 pixels on each side, totalling 4 pixels)} + {gridline (1pixel)}


DEFAULT_LEFT_MARGIN = 0.7 # in inches, = right margin
DEFAULT_TOP_MARGIN = 0.7874 # in inches = bottom margin
DEFAULT_HEADER = 0.3 # in inches


# Conversion functions
"""
From the ECMA Spec (4th Edition part 1)
Page setup: "Left Page Margin in inches" p. 1647

Docs from
http://startbigthinksmall.wordpress.com/2010/01/04/points-inches-and-emus-measuring-units-in-office-open-xml/

See also http://msdn.microsoft.com/en-us/library/dd560821(v=office.12).aspx

dxa: The main unit in OOXML is a twentieth of a point. Also called twips.
pt: point. In Excel there are 72 points to an inch
hp: half-points are used to specify font sizes. A font-size of 12pt equals 24 half points
pct: Half-points are used to specify font sizes. A font-size of 12pt equals 24 half points

EMU: English Metric Unit, EMUs are used for coordinates in vector-based
drawings and embedded pictures. One inch equates to 914400 EMUs and a
centimeter is 360000. For bitmaps the default resolution is 96 dpi (known as
PixelsPerInch in Excel). Spec p. 1122

For radial geometry Excel uses integer units of 1/60000th of a degree.
"""



def inch_to_dxa(value):
    """1 inch = 72 * 20 dxa"""
    return int(value * 20 * 72)

def dxa_to_inch(value):
    return value / 72 / 20


def dxa_to_cm(value):
    return 2.54 * dxa_to_inch(value)

def cm_to_dxa(value):
    emu = cm_to_EMU(value)
    inch = EMU_to_inch(emu)
    return inch_to_dxa(inch)


def pixels_to_EMU(value):
    """1 pixel = 9525 EMUs"""
    return int(value * 9525)

def EMU_to_pixels(value):
    return round(value / 9525)


def cm_to_EMU(value):
    """1 cm = 360000 EMUs"""
    return int(value * 360000)

def EMU_to_cm(value):
    return round(value / 360000, 4)


def inch_to_EMU(value):
    """1 inch = 914400 EMUs"""
    return int(value * 914400)

def EMU_to_inch(value):
    return round(value / 914400, 4)


def pixels_to_points(value, dpi=96):
    """96 dpi, 72i"""
    return value * 72 / dpi


def points_to_pixels(value, dpi=96):
    return int(math.ceil(value * dpi / 72))


def degrees_to_angle(value):
    """1 degree = 60000 angles"""
    return int(round(value * 60000))


def angle_to_degrees(value):
    return round(value / 60000, 2)


def short_color(color):
    """ format a color to its short size """
    if len(color) > 6:
        return color[2:]
    return color

```

---

### File: `tmp\openpyxl_sdist\openpyxl-3.1.5\openpyxl\workbook\__init__.py`

```python
# Copyright (c) 2010-2024 openpyxl


from .workbook import Workbook

```

---

### File: `tmp\openpyxl_sdist\openpyxl-3.1.5\openpyxl\workbook\_writer.py`

```python
# Copyright (c) 2010-2024 openpyxl

"""Write the workbook global settings to the archive."""

from openpyxl.utils import quote_sheetname
from openpyxl.xml.constants import (
    ARC_APP,
    ARC_CORE,
    ARC_CUSTOM,
    ARC_WORKBOOK,
    PKG_REL_NS,
    CUSTOMUI_NS,
    ARC_ROOT_RELS,
)
from openpyxl.xml.functions import tostring, fromstring

from openpyxl.packaging.relationship import Relationship, RelationshipList
from openpyxl.workbook.defined_name import (
    DefinedName,
    DefinedNameList,
)
from openpyxl.workbook.external_reference import ExternalReference
from openpyxl.packaging.workbook import ChildSheet, WorkbookPackage, PivotCache
from openpyxl.workbook.properties import WorkbookProperties
from openpyxl.utils.datetime import CALENDAR_MAC_1904


def get_active_sheet(wb):
    """
    Return the index of the active sheet.
    If the sheet set to active is hidden return the next visible sheet or None
    """
    visible_sheets = [idx for idx, sheet in enumerate(wb._sheets) if sheet.sheet_state == "visible"]
    if not visible_sheets:
        raise IndexError("At least one sheet must be visible")

    idx = wb._active_sheet_index
    sheet = wb.active
    if sheet and sheet.sheet_state == "visible":
        return idx

    for idx in visible_sheets[idx:]:
        wb.active = idx
        return idx

    return None


class WorkbookWriter:

    def __init__(self, wb):
        self.wb = wb
        self.rels = RelationshipList()
        self.package = WorkbookPackage()
        self.package.workbookProtection = wb.security
        self.package.calcPr = wb.calculation


    def write_properties(self):

        props = WorkbookProperties() # needs a mapping to the workbook for preservation
        if self.wb.code_name is not None:
            props.codeName = self.wb.code_name
        if self.wb.excel_base_date == CALENDAR_MAC_1904:
            props.date1904 = True
        self.package.workbookPr = props


    def write_worksheets(self):
        for idx, sheet in enumerate(self.wb._sheets, 1):
            sheet_node = ChildSheet(name=sheet.title, sheetId=idx, id="rId{0}".format(idx))
            rel = Relationship(type=sheet._rel_type, Target=sheet.path)
            self.rels.append(rel)

            if not sheet.sheet_state == 'visible':
                if len(self.wb._sheets) == 1:
                    raise ValueError("The only worksheet of a workbook cannot be hidden")
                sheet_node.state = sheet.sheet_state
            self.package.sheets.append(sheet_node)


    def write_refs(self):
        for link in self.wb._external_links:
            # need to match a counter with a workbook's relations
            rId = len(self.wb.rels) + 1
            rel = Relationship(type=link._rel_type, Target=link.path)
            self.rels.append(rel)
            ext = ExternalReference(id=rel.id)
            self.package.externalReferences.append(ext)


    def write_names(self):
        defined_names = list(self.wb.defined_names.values())

        for idx, sheet in enumerate(self.wb.worksheets):
            quoted = quote_sheetname(sheet.title)

            # local names
            if sheet.defined_names:
                names = sheet.defined_names.values()
                for n in names:
                    n.localSheetId = idx
                defined_names.extend(names)

            if sheet.auto_filter:
                name = DefinedName(name='_FilterDatabase', localSheetId=idx, hidden=True)
                name.value = f"{quoted}!{sheet.auto_filter}"
                defined_names.append(name)

            if sheet.print_titles:
                name = DefinedName(name="Print_Titles", localSheetId=idx)
                name.value = sheet.print_titles
                defined_names.append(name)

            if sheet.print_area:
                name = DefinedName(name="Print_Area", localSheetId=idx)
                name.value = sheet.print_area
                defined_names.append(name)

        self.package.definedNames = DefinedNameList(definedName=defined_names)


    def write_pivots(self):
        pivot_caches = set()
        for pivot in self.wb._pivots:
            if pivot.cache not in pivot_caches:
                pivot_caches.add(pivot.cache)
                c = PivotCache(cacheId=pivot.cacheId)
                self.package.pivotCaches.append(c)
                rel = Relationship(Type=pivot.cache.rel_type, Target=pivot.cache.path)
                self.rels.append(rel)
                c.id = rel.id
        #self.wb._pivots = [] # reset


    def write_views(self):
        active = get_active_sheet(self.wb)
        if self.wb.views:
            self.wb.views[0].activeTab = active
        self.package.bookViews = self.wb.views


    def write(self):
        """Write the core workbook xml."""

        self.write_properties()
        self.write_worksheets()
        self.write_names()
        self.write_pivots()
        self.write_views()
        self.write_refs()

        return tostring(self.package.to_tree())


    def write_rels(self):
        """Write the workbook relationships xml."""

        styles =  Relationship(type='styles', Target='styles.xml')
        self.rels.append(styles)

        theme =  Relationship(type='theme', Target='theme/theme1.xml')
        self.rels.append(theme)

        if self.wb.vba_archive:
            vba =  Relationship(type='', Target='vbaProject.bin')
            vba.Type ='http://schemas.microsoft.com/office/2006/relationships/vbaProject'
            self.rels.append(vba)

        return tostring(self.rels.to_tree())


    def write_root_rels(self):
        """Write the package relationships"""

        rels = RelationshipList()

        rel = Relationship(type="officeDocument", Target=ARC_WORKBOOK)
        rels.append(rel)
        rel = Relationship(Type=f"{PKG_REL_NS}/metadata/core-properties", Target=ARC_CORE)
        rels.append(rel)

        rel = Relationship(type="extended-properties", Target=ARC_APP)
        rels.append(rel)

        if len(self.wb.custom_doc_props) >= 1:
            rel = Relationship(type="custom-properties", Target=ARC_CUSTOM)
            rels.append(rel)

        if self.wb.vba_archive is not None:
            # See if there was a customUI relation and reuse it
            xml = fromstring(self.wb.vba_archive.read(ARC_ROOT_RELS))
            root_rels = RelationshipList.from_tree(xml)
            for rel in root_rels.find(CUSTOMUI_NS):
                rels.append(rel)

        return tostring(rels.to_tree())

```

---

### File: `tmp\openpyxl_sdist\openpyxl-3.1.5\openpyxl\workbook\child.py`

```python
# Copyright (c) 2010-2024 openpyxl

import re
import warnings

from openpyxl.worksheet.header_footer import HeaderFooter

"""
Base class for worksheets, chartsheets, etc. that can be added to workbooks
"""

INVALID_TITLE_REGEX = re.compile(r'[\\*?:/\[\]]')


def avoid_duplicate_name(names, value):
    """
    Naive check to see whether name already exists.
    If name does exist suggest a name using an incrementer
    Duplicates are case insensitive
    """
    # Check for an absolute match in which case we need to find an alternative
    match = [n for n in names if n.lower() == value.lower()]
    if match:
        names = u",".join(names)
        sheet_title_regex = re.compile(f'(?P<title>{re.escape(value)})(?P<count>\\d*),?', re.I)
        matches = sheet_title_regex.findall(names)
        if matches:
            # use name, but append with the next highest integer
            counts = [int(idx) for (t, idx) in matches if idx.isdigit()]
            highest = 0
            if counts:
                highest = max(counts)
            value = u"{0}{1}".format(value, highest + 1)
    return value


class _WorkbookChild:

    __title = ""
    _id = None
    _path = "{0}"
    _parent = None
    _default_title = "Sheet"

    def __init__(self, parent=None, title=None):
        self._parent = parent
        self.title = title or self._default_title
        self.HeaderFooter = HeaderFooter()


    def __repr__(self):
        return '<{0} "{1}">'.format(self.__class__.__name__, self.title)


    @property
    def parent(self):
        return self._parent


    @property
    def encoding(self):
        return self._parent.encoding


    @property
    def title(self):
        return self.__title


    @title.setter
    def title(self, value):
        """
        Set a sheet title, ensuring it is valid.
        Limited to 31 characters, no special characters.
        Duplicate titles will be incremented numerically
        """
        if not self._parent:
            return

        if not value:
            raise ValueError("Title must have at least one character")

        if hasattr(value, "decode"):
            if not isinstance(value, str):
                try:
                    value = value.decode("ascii")
                except UnicodeDecodeError:
                    raise ValueError("Worksheet titles must be str")

        m = INVALID_TITLE_REGEX.search(value)
        if m:
            msg = "Invalid character {0} found in sheet title".format(m.group(0))
            raise ValueError(msg)

        if self.title is not None and self.title != value:
            value = avoid_duplicate_name(self.parent.sheetnames, value)

        if len(value) > 31:
            warnings.warn("Title is more than 31 characters. Some applications may not be able to read the file")

        self.__title = value


    @property
    def oddHeader(self):
        return self.HeaderFooter.oddHeader


    @oddHeader.setter
    def oddHeader(self, value):
        self.HeaderFooter.oddHeader = value


    @property
    def oddFooter(self):
        return self.HeaderFooter.oddFooter


    @oddFooter.setter
    def oddFooter(self, value):
        self.HeaderFooter.oddFooter = value


    @property
    def evenHeader(self):
        return self.HeaderFooter.evenHeader


    @evenHeader.setter
    def evenHeader(self, value):
        self.HeaderFooter.evenHeader = value


    @property
    def evenFooter(self):
        return self.HeaderFooter.evenFooter


    @evenFooter.setter
    def evenFooter(self, value):
        self.HeaderFooter.evenFooter = value


    @property
    def firstHeader(self):
        return self.HeaderFooter.firstHeader


    @firstHeader.setter
    def firstHeader(self, value):
        self.HeaderFooter.firstHeader = value


    @property
    def firstFooter(self):
        return self.HeaderFooter.firstFooter


    @firstFooter.setter
    def firstFooter(self, value):
        self.HeaderFooter.firstFooter = value


    @property
    def path(self):
        return self._path.format(self._id)

```

---

### File: `tmp\openpyxl_sdist\openpyxl-3.1.5\openpyxl\workbook\defined_name.py`

```python
# Copyright (c) 2010-2024 openpyxl

from collections import defaultdict
import re

from openpyxl.descriptors.serialisable import Serialisable
from openpyxl.descriptors import (
    Alias,
    String,
    Integer,
    Bool,
    Sequence,
    Descriptor,
)
from openpyxl.compat import safe_string
from openpyxl.formula import Tokenizer
from openpyxl.utils.cell import SHEETRANGE_RE

RESERVED = frozenset(["Print_Area", "Print_Titles", "Criteria",
                      "_FilterDatabase", "Extract", "Consolidate_Area",
                      "Sheet_Title"])

_names = "|".join(RESERVED)
RESERVED_REGEX = re.compile(r"^_xlnm\.(?P<name>{0})".format(_names))


class DefinedName(Serialisable):

    tagname = "definedName"

    name = String() # unique per workbook/worksheet
    comment = String(allow_none=True)
    customMenu = String(allow_none=True)
    description = String(allow_none=True)
    help = String(allow_none=True)
    statusBar = String(allow_none=True)
    localSheetId = Integer(allow_none=True)
    hidden = Bool(allow_none=True)
    function = Bool(allow_none=True)
    vbProcedure = Bool(allow_none=True)
    xlm = Bool(allow_none=True)
    functionGroupId = Integer(allow_none=True)
    shortcutKey = String(allow_none=True)
    publishToServer = Bool(allow_none=True)
    workbookParameter = Bool(allow_none=True)
    attr_text = Descriptor()
    value = Alias("attr_text")


    def __init__(self,
                 name=None,
                 comment=None,
                 customMenu=None,
                 description=None,
                 help=None,
                 statusBar=None,
                 localSheetId=None,
                 hidden=None,
                 function=None,
                 vbProcedure=None,
                 xlm=None,
                 functionGroupId=None,
                 shortcutKey=None,
                 publishToServer=None,
                 workbookParameter=None,
                 attr_text=None
                ):
        self.name = name
        self.comment = comment
        self.customMenu = customMenu
        self.description = description
        self.help = help
        self.statusBar = statusBar
        self.localSheetId = localSheetId
        self.hidden = hidden
        self.function = function
        self.vbProcedure = vbProcedure
        self.xlm = xlm
        self.functionGroupId = functionGroupId
        self.shortcutKey = shortcutKey
        self.publishToServer = publishToServer
        self.workbookParameter = workbookParameter
        self.attr_text = attr_text


    @property
    def type(self):
        tok = Tokenizer("=" + self.value)
        parsed = tok.items[0]
        if parsed.type == "OPERAND":
            return parsed.subtype
        return parsed.type


    @property
    def destinations(self):
        if self.type == "RANGE":
            tok = Tokenizer("=" + self.value)
            for part in tok.items:
                if part.subtype == "RANGE":
                    m = SHEETRANGE_RE.match(part.value)
                    sheetname = m.group('notquoted') or m.group('quoted')
                    yield sheetname, m.group('cells')


    @property
    def is_reserved(self):
        m = RESERVED_REGEX.match(self.name)
        if m:
            return m.group("name")


    @property
    def is_external(self):
        return re.compile(r"^\[\d+\].*").match(self.value) is not None


    def __iter__(self):
        for key in self.__attrs__:
            if key == "attr_text":
                continue
            v = getattr(self, key)
            if v is not None:
                if v in RESERVED:
                    v = "_xlnm." + v
                yield key, safe_string(v)


class DefinedNameDict(dict):

    """
    Utility class for storing defined names.
    Allows access by name and separation of global and scoped names
    """

    def __setitem__(self, key, value):
        if not isinstance(value, DefinedName):
            raise TypeError("Value must be a an instance of DefinedName")
        elif value.name != key:
            raise ValueError("Key must be the same as the name")
        super().__setitem__(key, value)


    def add(self, value):
        """
        Add names without worrying about key and name matching.
        """
        self[value.name] = value


class DefinedNameList(Serialisable):

    tagname = "definedNames"

    definedName = Sequence(expected_type=DefinedName)


    def __init__(self, definedName=()):
        self.definedName = definedName


    def by_sheet(self):
        """
        Break names down into sheet locals and globals
        """
        names = defaultdict(DefinedNameDict)
        for defn in self.definedName:
            if defn.localSheetId is None:
                if defn.name in ("_xlnm.Print_Titles", "_xlnm.Print_Area", "_xlnm._FilterDatabase"):
                    continue
                names["global"][defn.name] = defn
            else:
                sheet = int(defn.localSheetId)
                names[sheet][defn.name] = defn
        return names


    def _duplicate(self, defn):
        """
        Check for whether DefinedName with the same name and scope already
        exists
        """
        for d in self.definedName:
            if d.name == defn.name and d.localSheetId == defn.localSheetId:
                return True


    def __len__(self):
        return len(self.definedName)

```

---

### File: `tmp\openpyxl_sdist\openpyxl-3.1.5\openpyxl\workbook\external_link\__init__.py`

```python
# Copyright (c) 2010-2024 openpyxl

from .external import ExternalLink

```

---

### File: `tmp\openpyxl_sdist\openpyxl-3.1.5\openpyxl\workbook\external_link\external.py`

```python
# Copyright (c) 2010-2024 openpyxl


from openpyxl.descriptors.serialisable import Serialisable
from openpyxl.descriptors import (
    Typed,
    String,
    Bool,
    Integer,
    NoneSet,
    Sequence,
)
from openpyxl.descriptors.excel import Relation
from openpyxl.descriptors.nested import NestedText
from openpyxl.descriptors.sequence import NestedSequence, ValueSequence

from openpyxl.packaging.relationship import (
    Relationship,
    get_rels_path,
    get_dependents
    )
from openpyxl.xml.constants import SHEET_MAIN_NS
from openpyxl.xml.functions import fromstring


"""Manage links to external Workbooks"""


class ExternalCell(Serialisable):

    r = String()
    t = NoneSet(values=(['b', 'd', 'n', 'e', 's', 'str', 'inlineStr']))
    vm = Integer(allow_none=True)
    v = NestedText(allow_none=True, expected_type=str)

    def __init__(self,
                 r=None,
                 t=None,
                 vm=None,
                 v=None,
                ):
        self.r = r
        self.t = t
        self.vm = vm
        self.v = v


class ExternalRow(Serialisable):

    r = Integer()
    cell = Sequence(expected_type=ExternalCell)

    __elements__ = ('cell',)

    def __init__(self,
                 r=(),
                 cell=None,
                ):
        self.r = r
        self.cell = cell


class ExternalSheetData(Serialisable):

    sheetId = Integer()
    refreshError = Bool(allow_none=True)
    row = Sequence(expected_type=ExternalRow)

    __elements__ = ('row',)

    def __init__(self,
                 sheetId=None,
                 refreshError=None,
                 row=(),
                ):
        self.sheetId = sheetId
        self.refreshError = refreshError
        self.row = row


class ExternalSheetDataSet(Serialisable):

    sheetData = Sequence(expected_type=ExternalSheetData, )

    __elements__ = ('sheetData',)

    def __init__(self,
                 sheetData=None,
                ):
        self.sheetData = sheetData


class ExternalSheetNames(Serialisable):

    sheetName = ValueSequence(expected_type=str)

    __elements__ = ('sheetName',)

    def __init__(self,
                 sheetName=(),
                ):
        self.sheetName = sheetName


class ExternalDefinedName(Serialisable):

    tagname = "definedName"

    name = String()
    refersTo = String(allow_none=True)
    sheetId = Integer(allow_none=True)

    def __init__(self,
                 name=None,
                 refersTo=None,
                 sheetId=None,
                ):
        self.name = name
        self.refersTo = refersTo
        self.sheetId = sheetId


class ExternalBook(Serialisable):

    tagname = "externalBook"

    sheetNames = Typed(expected_type=ExternalSheetNames, allow_none=True)
    definedNames = NestedSequence(expected_type=ExternalDefinedName)
    sheetDataSet = Typed(expected_type=ExternalSheetDataSet, allow_none=True)
    id = Relation()

    __elements__ = ('sheetNames', 'definedNames', 'sheetDataSet')

    def __init__(self,
                 sheetNames=None,
                 definedNames=(),
                 sheetDataSet=None,
                 id=None,
                ):
        self.sheetNames = sheetNames
        self.definedNames = definedNames
        self.sheetDataSet = sheetDataSet
        self.id = id


class ExternalLink(Serialisable):

    tagname = "externalLink"

    _id = None
    _path = "/xl/externalLinks/externalLink{0}.xml"
    _rel_type = "externalLink"
    mime_type = "application/vnd.openxmlformats-officedocument.spreadsheetml.externalLink+xml"

    externalBook = Typed(expected_type=ExternalBook, allow_none=True)
    file_link = Typed(expected_type=Relationship, allow_none=True) # link to external file

    __elements__ = ('externalBook', )

    def __init__(self,
                 externalBook=None,
                 ddeLink=None,
                 oleLink=None,
                 extLst=None,
                ):
        self.externalBook = externalBook
        # ignore other items for the moment.


    def to_tree(self):
        node = super().to_tree()
        node.set("xmlns", SHEET_MAIN_NS)
        return node


    @property
    def path(self):
        return self._path.format(self._id)


def read_external_link(archive, book_path):
    src = archive.read(book_path)
    node = fromstring(src)
    book = ExternalLink.from_tree(node)

    link_path = get_rels_path(book_path)
    deps = get_dependents(archive, link_path)
    book.file_link = deps[0]

    return book

```

---

### File: `tmp\openpyxl_sdist\openpyxl-3.1.5\openpyxl\workbook\external_reference.py`

```python
# Copyright (c) 2010-2024 openpyxl

from openpyxl.descriptors.serialisable import Serialisable
from openpyxl.descriptors import (
    Sequence
)
from openpyxl.descriptors.excel import (
    Relation,
)

class ExternalReference(Serialisable):

    tagname = "externalReference"

    id = Relation()

    def __init__(self, id):
        self.id = id

```

---

### File: `tmp\openpyxl_sdist\openpyxl-3.1.5\openpyxl\workbook\function_group.py`

```python
# Copyright (c) 2010-2024 openpyxl

from openpyxl.descriptors.serialisable import Serialisable
from openpyxl.descriptors import (
    Sequence,
    String,
    Integer,
)

class FunctionGroup(Serialisable):

    tagname = "functionGroup"

    name = String()

    def __init__(self,
                 name=None,
                ):
        self.name = name


class FunctionGroupList(Serialisable):

    tagname = "functionGroups"

    builtInGroupCount = Integer(allow_none=True)
    functionGroup = Sequence(expected_type=FunctionGroup, allow_none=True)

    __elements__ = ('functionGroup',)

    def __init__(self,
                 builtInGroupCount=16,
                 functionGroup=(),
                ):
        self.builtInGroupCount = builtInGroupCount
        self.functionGroup = functionGroup

```

---

### File: `tmp\openpyxl_sdist\openpyxl-3.1.5\openpyxl\workbook\properties.py`

```python
# Copyright (c) 2010-2024 openpyxl

from openpyxl.descriptors.serialisable import Serialisable
from openpyxl.descriptors import (
    String,
    Float,
    Integer,
    Bool,
    NoneSet,
    Set,
)

from openpyxl.descriptors.excel import Guid


class WorkbookProperties(Serialisable):

    tagname = "workbookPr"

    date1904 = Bool(allow_none=True)
    dateCompatibility = Bool(allow_none=True)
    showObjects = NoneSet(values=(['all', 'placeholders']))
    showBorderUnselectedTables = Bool(allow_none=True)
    filterPrivacy = Bool(allow_none=True)
    promptedSolutions = Bool(allow_none=True)
    showInkAnnotation = Bool(allow_none=True)
    backupFile = Bool(allow_none=True)
    saveExternalLinkValues = Bool(allow_none=True)
    updateLinks = NoneSet(values=(['userSet', 'never', 'always']))
    codeName = String(allow_none=True)
    hidePivotFieldList = Bool(allow_none=True)
    showPivotChartFilter = Bool(allow_none=True)
    allowRefreshQuery = Bool(allow_none=True)
    publishItems = Bool(allow_none=True)
    checkCompatibility = Bool(allow_none=True)
    autoCompressPictures = Bool(allow_none=True)
    refreshAllConnections = Bool(allow_none=True)
    defaultThemeVersion = Integer(allow_none=True)

    def __init__(self,
                 date1904=None,
                 dateCompatibility=None,
                 showObjects=None,
                 showBorderUnselectedTables=None,
                 filterPrivacy=None,
                 promptedSolutions=None,
                 showInkAnnotation=None,
                 backupFile=None,
                 saveExternalLinkValues=None,
                 updateLinks=None,
                 codeName=None,
                 hidePivotFieldList=None,
                 showPivotChartFilter=None,
                 allowRefreshQuery=None,
                 publishItems=None,
                 checkCompatibility=None,
                 autoCompressPictures=None,
                 refreshAllConnections=None,
                 defaultThemeVersion=None,
                ):
        self.date1904 = date1904
        self.dateCompatibility = dateCompatibility
        self.showObjects = showObjects
        self.showBorderUnselectedTables = showBorderUnselectedTables
        self.filterPrivacy = filterPrivacy
        self.promptedSolutions = promptedSolutions
        self.showInkAnnotation = showInkAnnotation
        self.backupFile = backupFile
        self.saveExternalLinkValues = saveExternalLinkValues
        self.updateLinks = updateLinks
        self.codeName = codeName
        self.hidePivotFieldList = hidePivotFieldList
        self.showPivotChartFilter = showPivotChartFilter
        self.allowRefreshQuery = allowRefreshQuery
        self.publishItems = publishItems
        self.checkCompatibility = checkCompatibility
        self.autoCompressPictures = autoCompressPictures
        self.refreshAllConnections = refreshAllConnections
        self.defaultThemeVersion = defaultThemeVersion


class CalcProperties(Serialisable):

    tagname = "calcPr"

    calcId = Integer()
    calcMode = NoneSet(values=(['manual', 'auto', 'autoNoTable']))
    fullCalcOnLoad = Bool(allow_none=True)
    refMode = NoneSet(values=(['A1', 'R1C1']))
    iterate = Bool(allow_none=True)
    iterateCount = Integer(allow_none=True)
    iterateDelta = Float(allow_none=True)
    fullPrecision = Bool(allow_none=True)
    calcCompleted = Bool(allow_none=True)
    calcOnSave = Bool(allow_none=True)
    concurrentCalc = Bool(allow_none=True)
    concurrentManualCount = Integer(allow_none=True)
    forceFullCalc = Bool(allow_none=True)

    def __init__(self,
                 calcId=124519,
                 calcMode=None,
                 fullCalcOnLoad=True,
                 refMode=None,
                 iterate=None,
                 iterateCount=None,
                 iterateDelta=None,
                 fullPrecision=None,
                 calcCompleted=None,
                 calcOnSave=None,
                 concurrentCalc=None,
                 concurrentManualCount=None,
                 forceFullCalc=None,
                ):
        self.calcId = calcId
        self.calcMode = calcMode
        self.fullCalcOnLoad = fullCalcOnLoad
        self.refMode = refMode
        self.iterate = iterate
        self.iterateCount = iterateCount
        self.iterateDelta = iterateDelta
        self.fullPrecision = fullPrecision
        self.calcCompleted = calcCompleted
        self.calcOnSave = calcOnSave
        self.concurrentCalc = concurrentCalc
        self.concurrentManualCount = concurrentManualCount
        self.forceFullCalc = forceFullCalc


class FileVersion(Serialisable):

    tagname = "fileVersion"

    appName = String(allow_none=True)
    lastEdited = String(allow_none=True)
    lowestEdited = String(allow_none=True)
    rupBuild = String(allow_none=True)
    codeName = Guid(allow_none=True)

    def __init__(self,
                 appName=None,
                 lastEdited=None,
                 lowestEdited=None,
                 rupBuild=None,
                 codeName=None,
                ):
        self.appName = appName
        self.lastEdited = lastEdited
        self.lowestEdited = lowestEdited
        self.rupBuild = rupBuild
        self.codeName = codeName

```

---

### File: `tmp\openpyxl_sdist\openpyxl-3.1.5\openpyxl\workbook\protection.py`

```python
# Copyright (c) 2010-2024 openpyxl

from openpyxl.descriptors.serialisable import Serialisable
from openpyxl.descriptors import (
    Alias,
    Typed,
    String,
    Float,
    Integer,
    Bool,
    NoneSet,
    Set,
)
from openpyxl.descriptors.excel import (
    ExtensionList,
    HexBinary,
    Guid,
    Relation,
    Base64Binary,
)
from openpyxl.utils.protection import hash_password


class WorkbookProtection(Serialisable):

    _workbook_password, _revisions_password = None, None

    tagname = "workbookPr"

    workbook_password = Alias("workbookPassword")
    workbookPasswordCharacterSet = String(allow_none=True)
    revision_password = Alias("revisionsPassword")
    revisionsPasswordCharacterSet = String(allow_none=True)
    lockStructure = Bool(allow_none=True)
    lock_structure = Alias("lockStructure")
    lockWindows = Bool(allow_none=True)
    lock_windows = Alias("lockWindows")
    lockRevision = Bool(allow_none=True)
    lock_revision = Alias("lockRevision")
    revisionsAlgorithmName = String(allow_none=True)
    revisionsHashValue = Base64Binary(allow_none=True)
    revisionsSaltValue = Base64Binary(allow_none=True)
    revisionsSpinCount = Integer(allow_none=True)
    workbookAlgorithmName = String(allow_none=True)
    workbookHashValue = Base64Binary(allow_none=True)
    workbookSaltValue = Base64Binary(allow_none=True)
    workbookSpinCount = Integer(allow_none=True)

    __attrs__ = ('workbookPassword', 'workbookPasswordCharacterSet', 'revisionsPassword',
                 'revisionsPasswordCharacterSet', 'lockStructure', 'lockWindows', 'lockRevision',
                 'revisionsAlgorithmName', 'revisionsHashValue', 'revisionsSaltValue',
                 'revisionsSpinCount', 'workbookAlgorithmName', 'workbookHashValue',
                 'workbookSaltValue', 'workbookSpinCount')

    def __init__(self,
                 workbookPassword=None,
                 workbookPasswordCharacterSet=None,
                 revisionsPassword=None,
                 revisionsPasswordCharacterSet=None,
                 lockStructure=None,
                 lockWindows=None,
                 lockRevision=None,
                 revisionsAlgorithmName=None,
                 revisionsHashValue=None,
                 revisionsSaltValue=None,
                 revisionsSpinCount=None,
                 workbookAlgorithmName=None,
                 workbookHashValue=None,
                 workbookSaltValue=None,
                 workbookSpinCount=None,
                ):
        if workbookPassword is not None:
            self.workbookPassword = workbookPassword
        self.workbookPasswordCharacterSet = workbookPasswordCharacterSet
        if revisionsPassword is not None:
            self.revisionsPassword = revisionsPassword
        self.revisionsPasswordCharacterSet = revisionsPasswordCharacterSet
        self.lockStructure = lockStructure
        self.lockWindows = lockWindows
        self.lockRevision = lockRevision
        self.revisionsAlgorithmName = revisionsAlgorithmName
        self.revisionsHashValue = revisionsHashValue
        self.revisionsSaltValue = revisionsSaltValue
        self.revisionsSpinCount = revisionsSpinCount
        self.workbookAlgorithmName = workbookAlgorithmName
        self.workbookHashValue = workbookHashValue
        self.workbookSaltValue = workbookSaltValue
        self.workbookSpinCount = workbookSpinCount

    def set_workbook_password(self, value='', already_hashed=False):
        """Set a password on this workbook."""
        if not already_hashed:
            value = hash_password(value)
        self._workbook_password = value

    @property
    def workbookPassword(self):
        """Return the workbook password value, regardless of hash."""
        return self._workbook_password

    @workbookPassword.setter
    def workbookPassword(self, value):
        """Set a workbook password directly, forcing a hash step."""
        self.set_workbook_password(value)

    def set_revisions_password(self, value='', already_hashed=False):
        """Set a revision password on this workbook."""
        if not already_hashed:
            value = hash_password(value)
        self._revisions_password = value

    @property
    def revisionsPassword(self):
        """Return the revisions password value, regardless of hash."""
        return self._revisions_password

    @revisionsPassword.setter
    def revisionsPassword(self, value):
        """Set a revisions password directly, forcing a hash step."""
        self.set_revisions_password(value)

    @classmethod
    def from_tree(cls, node):
        """Don't hash passwords when deserialising from XML"""
        self = super().from_tree(node)
        if self.workbookPassword:
            self.set_workbook_password(node.get('workbookPassword'), already_hashed=True)
        if self.revisionsPassword:
            self.set_revisions_password(node.get('revisionsPassword'), already_hashed=True)
        return self

# Backwards compatibility
DocumentSecurity = WorkbookProtection


class FileSharing(Serialisable):

    tagname = "fileSharing"

    readOnlyRecommended = Bool(allow_none=True)
    userName = String(allow_none=True)
    reservationPassword = HexBinary(allow_none=True)
    algorithmName = String(allow_none=True)
    hashValue = Base64Binary(allow_none=True)
    saltValue = Base64Binary(allow_none=True)
    spinCount = Integer(allow_none=True)

    def __init__(self,
                 readOnlyRecommended=None,
                 userName=None,
                 reservationPassword=None,
                 algorithmName=None,
                 hashValue=None,
                 saltValue=None,
                 spinCount=None,
                ):
        self.readOnlyRecommended = readOnlyRecommended
        self.userName = userName
        self.reservationPassword = reservationPassword
        self.algorithmName = algorithmName
        self.hashValue = hashValue
        self.saltValue = saltValue
        self.spinCount = spinCount

```

---

### File: `tmp\openpyxl_sdist\openpyxl-3.1.5\openpyxl\workbook\smart_tags.py`

```python
# Copyright (c) 2010-2024 openpyxl

from openpyxl.descriptors.serialisable import Serialisable
from openpyxl.descriptors import (
    Sequence,
    String,
    Bool,
    NoneSet,

)

class SmartTag(Serialisable):

    tagname = "smartTagType"

    namespaceUri = String(allow_none=True)
    name = String(allow_none=True)
    url = String(allow_none=True)

    def __init__(self,
                 namespaceUri=None,
                 name=None,
                 url=None,
                ):
        self.namespaceUri = namespaceUri
        self.name = name
        self.url = url


class SmartTagList(Serialisable):

    tagname = "smartTagTypes"

    smartTagType = Sequence(expected_type=SmartTag, allow_none=True)

    __elements__ = ('smartTagType',)

    def __init__(self,
                 smartTagType=(),
                ):
        self.smartTagType = smartTagType


class SmartTagProperties(Serialisable):

    tagname = "smartTagPr"

    embed = Bool(allow_none=True)
    show = NoneSet(values=(['all', 'noIndicator']))

    def __init__(self,
                 embed=None,
                 show=None,
                ):
        self.embed = embed
        self.show = show

```

---

### File: `tmp\openpyxl_sdist\openpyxl-3.1.5\openpyxl\workbook\views.py`

```python
# Copyright (c) 2010-2024 openpyxl

from openpyxl.descriptors.serialisable import Serialisable
from openpyxl.descriptors import (
    Typed,
    Sequence,
    String,
    Float,
    Integer,
    Bool,
    NoneSet,
    Set,
)
from openpyxl.descriptors.excel import (
    ExtensionList,
    Guid,
)


class BookView(Serialisable):

    tagname = "workbookView"

    visibility = NoneSet(values=(['visible', 'hidden', 'veryHidden']))
    minimized = Bool(allow_none=True)
    showHorizontalScroll = Bool(allow_none=True)
    showVerticalScroll = Bool(allow_none=True)
    showSheetTabs = Bool(allow_none=True)
    xWindow = Integer(allow_none=True)
    yWindow = Integer(allow_none=True)
    windowWidth = Integer(allow_none=True)
    windowHeight = Integer(allow_none=True)
    tabRatio = Integer(allow_none=True)
    firstSheet = Integer(allow_none=True)
    activeTab = Integer(allow_none=True)
    autoFilterDateGrouping = Bool(allow_none=True)
    extLst = Typed(expected_type=ExtensionList, allow_none=True)

    __elements__ = ()

    def __init__(self,
                 visibility="visible",
                 minimized=False,
                 showHorizontalScroll=True,
                 showVerticalScroll=True,
                 showSheetTabs=True,
                 xWindow=None,
                 yWindow=None,
                 windowWidth=None,
                 windowHeight=None,
                 tabRatio=600,
                 firstSheet=0,
                 activeTab=0,
                 autoFilterDateGrouping=True,
                 extLst=None,
                ):
        self.visibility = visibility
        self.minimized = minimized
        self.showHorizontalScroll = showHorizontalScroll
        self.showVerticalScroll = showVerticalScroll
        self.showSheetTabs = showSheetTabs
        self.xWindow = xWindow
        self.yWindow = yWindow
        self.windowWidth = windowWidth
        self.windowHeight = windowHeight
        self.tabRatio = tabRatio
        self.firstSheet = firstSheet
        self.activeTab = activeTab
        self.autoFilterDateGrouping = autoFilterDateGrouping


class CustomWorkbookView(Serialisable):

    tagname = "customWorkbookView"

    name = String()
    guid = Guid()
    autoUpdate = Bool(allow_none=True)
    mergeInterval = Integer(allow_none=True)
    changesSavedWin = Bool(allow_none=True)
    onlySync = Bool(allow_none=True)
    personalView = Bool(allow_none=True)
    includePrintSettings = Bool(allow_none=True)
    includeHiddenRowCol = Bool(allow_none=True)
    maximized = Bool(allow_none=True)
    minimized = Bool(allow_none=True)
    showHorizontalScroll = Bool(allow_none=True)
    showVerticalScroll = Bool(allow_none=True)
    showSheetTabs = Bool(allow_none=True)
    xWindow = Integer(allow_none=True)
    yWindow = Integer(allow_none=True)
    windowWidth = Integer()
    windowHeight = Integer()
    tabRatio = Integer(allow_none=True)
    activeSheetId = Integer()
    showFormulaBar = Bool(allow_none=True)
    showStatusbar = Bool(allow_none=True)
    showComments = NoneSet(values=(['commNone', 'commIndicator',
                                'commIndAndComment']))
    showObjects = NoneSet(values=(['all', 'placeholders']))
    extLst = Typed(expected_type=ExtensionList, allow_none=True)

    __elements__ = ()

    def __init__(self,
                 name=None,
                 guid=None,
                 autoUpdate=None,
                 mergeInterval=None,
                 changesSavedWin=None,
                 onlySync=None,
                 personalView=None,
                 includePrintSettings=None,
                 includeHiddenRowCol=None,
                 maximized=None,
                 minimized=None,
                 showHorizontalScroll=None,
                 showVerticalScroll=None,
                 showSheetTabs=None,
                 xWindow=None,
                 yWindow=None,
                 windowWidth=None,
                 windowHeight=None,
                 tabRatio=None,
                 activeSheetId=None,
                 showFormulaBar=None,
                 showStatusbar=None,
                 showComments="commIndicator",
                 showObjects="all",
                 extLst=None,
                ):
        self.name = name
        self.guid = guid
        self.autoUpdate = autoUpdate
        self.mergeInterval = mergeInterval
        self.changesSavedWin = changesSavedWin
        self.onlySync = onlySync
        self.personalView = personalView
        self.includePrintSettings = includePrintSettings
        self.includeHiddenRowCol = includeHiddenRowCol
        self.maximized = maximized
        self.minimized = minimized
        self.showHorizontalScroll = showHorizontalScroll
        self.showVerticalScroll = showVerticalScroll
        self.showSheetTabs = showSheetTabs
        self.xWindow = xWindow
        self.yWindow = yWindow
        self.windowWidth = windowWidth
        self.windowHeight = windowHeight
        self.tabRatio = tabRatio
        self.activeSheetId = activeSheetId
        self.showFormulaBar = showFormulaBar
        self.showStatusbar = showStatusbar
        self.showComments = showComments
        self.showObjects = showObjects

```

---

### File: `tmp\openpyxl_sdist\openpyxl-3.1.5\openpyxl\workbook\web.py`

```python
# Copyright (c) 2010-2024 openpyxl

from openpyxl.descriptors.serialisable import Serialisable
from openpyxl.descriptors import (
    Typed,
    Sequence,
    String,
    Float,
    Integer,
    Bool,
    NoneSet,
)


class WebPublishObject(Serialisable):

    tagname = "webPublishingObject"

    id = Integer()
    divId = String()
    sourceObject = String(allow_none=True)
    destinationFile = String()
    title = String(allow_none=True)
    autoRepublish = Bool(allow_none=True)

    def __init__(self,
                 id=None,
                 divId=None,
                 sourceObject=None,
                 destinationFile=None,
                 title=None,
                 autoRepublish=None,
                ):
        self.id = id
        self.divId = divId
        self.sourceObject = sourceObject
        self.destinationFile = destinationFile
        self.title = title
        self.autoRepublish = autoRepublish


class WebPublishObjectList(Serialisable):

    tagname ="webPublishingObjects"

    count = Integer(allow_none=True)
    webPublishObject = Sequence(expected_type=WebPublishObject)

    __elements__ = ('webPublishObject',)

    def __init__(self,
                 count=None,
                 webPublishObject=(),
                ):
        self.webPublishObject = webPublishObject


    @property
    def count(self):
        return len(self.webPublishObject)


class WebPublishing(Serialisable):

    tagname = "webPublishing"

    css = Bool(allow_none=True)
    thicket = Bool(allow_none=True)
    longFileNames = Bool(allow_none=True)
    vml = Bool(allow_none=True)
    allowPng = Bool(allow_none=True)
    targetScreenSize = NoneSet(values=(['544x376', '640x480', '720x512', '800x600',
                                    '1024x768', '1152x882', '1152x900', '1280x1024', '1600x1200',
                                    '1800x1440', '1920x1200']))
    dpi = Integer(allow_none=True)
    codePage = Integer(allow_none=True)
    characterSet = String(allow_none=True)

    def __init__(self,
                 css=None,
                 thicket=None,
                 longFileNames=None,
                 vml=None,
                 allowPng=None,
                 targetScreenSize='800x600',
                 dpi=None,
                 codePage=None,
                 characterSet=None,
                ):
        self.css = css
        self.thicket = thicket
        self.longFileNames = longFileNames
        self.vml = vml
        self.allowPng = allowPng
        self.targetScreenSize = targetScreenSize
        self.dpi = dpi
        self.codePage = codePage
        self.characterSet = characterSet

```

---

### File: `tmp\openpyxl_sdist\openpyxl-3.1.5\openpyxl\workbook\workbook.py`

```python
# Copyright (c) 2010-2024 openpyxl

"""Workbook is the top-level container for all document information."""
from copy import copy

from openpyxl.compat import deprecated
from openpyxl.worksheet.worksheet import Worksheet
from openpyxl.worksheet._read_only import ReadOnlyWorksheet
from openpyxl.worksheet._write_only import WriteOnlyWorksheet
from openpyxl.worksheet.copier import WorksheetCopy

from openpyxl.utils import quote_sheetname
from openpyxl.utils.indexed_list import IndexedList
from openpyxl.utils.datetime  import WINDOWS_EPOCH, MAC_EPOCH
from openpyxl.utils.exceptions import ReadOnlyWorkbookException

from openpyxl.writer.excel import save_workbook

from openpyxl.styles.cell_style import StyleArray
from openpyxl.styles.named_styles import NamedStyle
from openpyxl.styles.differential import DifferentialStyleList
from openpyxl.styles.alignment import Alignment
from openpyxl.styles.borders import DEFAULT_BORDER
from openpyxl.styles.fills import DEFAULT_EMPTY_FILL, DEFAULT_GRAY_FILL
from openpyxl.styles.fonts import DEFAULT_FONT
from openpyxl.styles.protection import Protection
from openpyxl.styles.colors import COLOR_INDEX
from openpyxl.styles.named_styles import NamedStyleList
from openpyxl.styles.table import TableStyleList

from openpyxl.chartsheet import Chartsheet
from .defined_name import DefinedName, DefinedNameDict
from openpyxl.packaging.core import DocumentProperties
from openpyxl.packaging.custom import CustomPropertyList
from openpyxl.packaging.relationship import RelationshipList
from .child import _WorkbookChild
from .protection import DocumentSecurity
from .properties import CalcProperties
from .views import BookView


from openpyxl.xml.constants import (
    XLSM,
    XLSX,
    XLTM,
    XLTX
)

INTEGER_TYPES = (int,)

class Workbook:
    """Workbook is the container for all other parts of the document."""

    _read_only = False
    _data_only = False
    template = False
    path = "/xl/workbook.xml"

    def __init__(self,
                 write_only=False,
                 iso_dates=False,
                 ):
        self._sheets = []
        self._pivots = []
        self._active_sheet_index = 0
        self.defined_names = DefinedNameDict()
        self._external_links = []
        self.properties = DocumentProperties()
        self.custom_doc_props = CustomPropertyList()
        self.security = DocumentSecurity()
        self.__write_only = write_only
        self.shared_strings = IndexedList()

        self._setup_styles()

        self.loaded_theme = None
        self.vba_archive = None
        self.is_template = False
        self.code_name = None
        self.epoch = WINDOWS_EPOCH
        self.encoding = "utf-8"
        self.iso_dates = iso_dates

        if not self.write_only:
            self._sheets.append(Worksheet(self))

        self.rels = RelationshipList()
        self.calculation = CalcProperties()
        self.views = [BookView()]


    def _setup_styles(self):
        """Bootstrap styles"""

        self._fonts = IndexedList()
        self._fonts.add(DEFAULT_FONT)

        self._alignments = IndexedList([Alignment()])

        self._borders = IndexedList()
        self._borders.add(DEFAULT_BORDER)

        self._fills = IndexedList()
        self._fills.add(DEFAULT_EMPTY_FILL)
        self._fills.add(DEFAULT_GRAY_FILL)

        self._number_formats = IndexedList()
        self._date_formats = {}
        self._timedelta_formats = {}

        self._protections = IndexedList([Protection()])

        self._colors = COLOR_INDEX
        self._cell_styles = IndexedList([StyleArray()])
        self._named_styles = NamedStyleList()
        self.add_named_style(NamedStyle(font=copy(DEFAULT_FONT), border=copy(DEFAULT_BORDER), builtinId=0))
        self._table_styles = TableStyleList()
        self._differential_styles = DifferentialStyleList()


    @property
    def epoch(self):
        if self._epoch == WINDOWS_EPOCH:
            return WINDOWS_EPOCH
        return MAC_EPOCH


    @epoch.setter
    def epoch(self, value):
        if value not in (WINDOWS_EPOCH, MAC_EPOCH):
            raise ValueError("The epoch must be either 1900 or 1904")
        self._epoch = value


    @property
    def read_only(self):
        return self._read_only

    @property
    def data_only(self):
        return self._data_only

    @property
    def write_only(self):
        return self.__write_only


    @property
    def excel_base_date(self):
        return self.epoch

    @property
    def active(self):
        """Get the currently active sheet or None

        :type: :class:`openpyxl.worksheet.worksheet.Worksheet`
        """
        try:
            return self._sheets[self._active_sheet_index]
        except IndexError:
            pass

    @active.setter
    def active(self, value):
        """Set the active sheet"""
        if not isinstance(value, (_WorkbookChild, INTEGER_TYPES)):
            raise TypeError("Value must be either a worksheet, chartsheet or numerical index")
        if isinstance(value, INTEGER_TYPES):
            self._active_sheet_index = value
            return
            #if self._sheets and 0 <= value < len(self._sheets):
                #value = self._sheets[value]
            #else:
                #raise ValueError("Sheet index is outside the range of possible values", value)
        if value not in self._sheets:
            raise ValueError("Worksheet is not in the workbook")
        if value.sheet_state != "visible":
            raise ValueError("Only visible sheets can be made active")

        idx = self._sheets.index(value)
        self._active_sheet_index = idx


    def create_sheet(self, title=None, index=None):
        """Create a worksheet (at an optional index).

        :param title: optional title of the sheet
        :type title: str
        :param index: optional position at which the sheet will be inserted
        :type index: int

        """
        if self.read_only:
            raise ReadOnlyWorkbookException('Cannot create new sheet in a read-only workbook')

        if self.write_only :
            new_ws = WriteOnlyWorksheet(parent=self, title=title)
        else:
            new_ws = Worksheet(parent=self, title=title)

        self._add_sheet(sheet=new_ws, index=index)
        return new_ws


    def _add_sheet(self, sheet, index=None):
        """Add an worksheet (at an optional index)."""

        if not isinstance(sheet, (Worksheet, WriteOnlyWorksheet, Chartsheet)):
            raise TypeError("Cannot be added to a workbook")

        if sheet.parent != self:
            raise ValueError("You cannot add worksheets from another workbook.")

        if index is None:
            self._sheets.append(sheet)
        else:
            self._sheets.insert(index, sheet)


    def move_sheet(self, sheet, offset=0):
        """
        Move a sheet or sheetname
        """
        if not isinstance(sheet, Worksheet):
            sheet = self[sheet]
        idx = self._sheets.index(sheet)
        del self._sheets[idx]
        new_pos = idx + offset
        self._sheets.insert(new_pos, sheet)


    def remove(self, worksheet):
        """Remove `worksheet` from this workbook."""
        idx = self._sheets.index(worksheet)
        self._sheets.remove(worksheet)


    @deprecated("Use wb.remove(worksheet) or del wb[sheetname]")
    def remove_sheet(self, worksheet):
        """Remove `worksheet` from this workbook."""
        self.remove(worksheet)


    def create_chartsheet(self, title=None, index=None):
        if self.read_only:
            raise ReadOnlyWorkbookException("Cannot create new sheet in a read-only workbook")
        cs = Chartsheet(parent=self, title=title)

        self._add_sheet(cs, index)
        return cs


    @deprecated("Use wb[sheetname]")
    def get_sheet_by_name(self, name):
        """Returns a worksheet by its name.

        :param name: the name of the worksheet to look for
        :type name: string

        """
        return self[name]

    def __contains__(self, key):
        return key in self.sheetnames


    def index(self, worksheet):
        """Return the index of a worksheet."""
        return self.worksheets.index(worksheet)


    @deprecated("Use wb.index(worksheet)")
    def get_index(self, worksheet):
        """Return the index of the worksheet."""
        return self.index(worksheet)

    def __getitem__(self, key):
        """Returns a worksheet by its name.

        :param name: the name of the worksheet to look for
        :type name: string

        """
        for sheet in self.worksheets + self.chartsheets:
            if sheet.title == key:
                return sheet
        raise KeyError("Worksheet {0} does not exist.".format(key))

    def __delitem__(self, key):
        sheet = self[key]
        self.remove(sheet)

    def __iter__(self):
        return iter(self.worksheets)


    @deprecated("Use wb.sheetnames")
    def get_sheet_names(self):
        return self.sheetnames

    @property
    def worksheets(self):
        """A list of sheets in this workbook

        :type: list of :class:`openpyxl.worksheet.worksheet.Worksheet`
        """
        return [s for s in self._sheets if isinstance(s, (Worksheet, ReadOnlyWorksheet, WriteOnlyWorksheet))]

    @property
    def chartsheets(self):
        """A list of Chartsheets in this workbook

        :type: list of :class:`openpyxl.chartsheet.chartsheet.Chartsheet`
        """
        return [s for s in self._sheets if isinstance(s, Chartsheet)]

    @property
    def sheetnames(self):
        """Returns the list of the names of worksheets in this workbook.

        Names are returned in the worksheets order.

        :type: list of strings

        """
        return [s.title for s in self._sheets]


    @deprecated("Assign scoped named ranges directly to worksheets or global ones to the workbook. Deprecated in 3.1")
    def create_named_range(self, name, worksheet=None, value=None, scope=None):
        """Create a new named_range on a worksheet

        """
        defn = DefinedName(name=name)
        if worksheet is not None:
            defn.value = "{0}!{1}".format(quote_sheetname(worksheet.title), value)
        else:
            defn.value = value

        self.defined_names[name] = defn


    def add_named_style(self, style):
        """
        Add a named style
        """
        self._named_styles.append(style)
        style.bind(self)


    @property
    def named_styles(self):
        """
        List available named styles
        """
        return self._named_styles.names


    @property
    def mime_type(self):
        """
        The mime type is determined by whether a workbook is a template or
        not and whether it contains macros or not. Excel requires the file
        extension to match but openpyxl does not enforce this.

        """
        ct = self.template and XLTX or XLSX
        if self.vba_archive:
            ct = self.template and XLTM or XLSM
        return ct


    def save(self, filename):
        """Save the current workbook under the given `filename`.
        Use this function instead of using an `ExcelWriter`.

        .. warning::
            When creating your workbook using `write_only` set to True,
            you will only be able to call this function once. Subsequent attempts to
            modify or save the file will raise an :class:`openpyxl.shared.exc.WorkbookAlreadySaved` exception.
        """
        if self.read_only:
            raise TypeError("""Workbook is read-only""")
        if self.write_only and not self.worksheets:
            self.create_sheet()
        save_workbook(self, filename)


    @property
    def style_names(self):
        """
        List of named styles
        """
        return [s.name for s in self._named_styles]


    def copy_worksheet(self, from_worksheet):
        """Copy an existing worksheet in the current workbook

        .. warning::
            This function cannot copy worksheets between workbooks.
            worksheets can only be copied within the workbook that they belong

        :param from_worksheet: the worksheet to be copied from
        :return: copy of the initial worksheet
        """
        if self.__write_only or self._read_only:
            raise ValueError("Cannot copy worksheets in read-only or write-only mode")

        new_title = u"{0} Copy".format(from_worksheet.title)
        to_worksheet = self.create_sheet(title=new_title)
        cp = WorksheetCopy(source_worksheet=from_worksheet, target_worksheet=to_worksheet)
        cp.copy_worksheet()
        return to_worksheet


    def close(self):
        """
        Close workbook file if open. Only affects read-only and write-only modes.
        """
        if hasattr(self, '_archive'):
            self._archive.close()


    def _duplicate_name(self, name):
        """
        Check for duplicate name in defined name list and table list of each worksheet.
        Names are not case sensitive.
        """
        name = name.lower()
        for sheet in self.worksheets:
            for t in sheet.tables:
                if name == t.lower():
                    return True

        if name in self.defined_names:
            return True


```

---

### File: `tmp\openpyxl_sdist\openpyxl-3.1.5\openpyxl\worksheet\__init__.py`

```python
# Copyright (c) 2010-2024 openpyxl

```

---

### File: `tmp\openpyxl_sdist\openpyxl-3.1.5\openpyxl\worksheet\_read_only.py`

```python
# Copyright (c) 2010-2024 openpyxl

""" Read worksheets on-demand
"""

from .worksheet import Worksheet
from openpyxl.cell.read_only import ReadOnlyCell, EMPTY_CELL
from openpyxl.utils import get_column_letter

from ._reader import WorkSheetParser
from openpyxl.workbook.defined_name import DefinedNameDict


def read_dimension(source):
    parser = WorkSheetParser(source, [])
    return parser.parse_dimensions()


class ReadOnlyWorksheet:

    _min_column = 1
    _min_row = 1
    _max_column = _max_row = None

    # from Standard Worksheet
    # Methods from Worksheet
    cell = Worksheet.cell
    iter_rows = Worksheet.iter_rows
    values = Worksheet.values
    rows = Worksheet.rows
    __getitem__ = Worksheet.__getitem__
    __iter__ = Worksheet.__iter__


    def __init__(self, parent_workbook, title, worksheet_path, shared_strings):
        self.parent = parent_workbook
        self.title = title
        self.sheet_state = 'visible'
        self._current_row = None
        self._worksheet_path = worksheet_path
        self._shared_strings = shared_strings
        self._get_size()
        self.defined_names = DefinedNameDict()


    def _get_size(self):
        src = self._get_source()
        parser = WorkSheetParser(src, [])
        dimensions = parser.parse_dimensions()
        src.close()
        if dimensions is not None:
            self._min_column, self._min_row, self._max_column, self._max_row = dimensions


    def _get_source(self):
        """Parse xml source on demand, must close after use"""
        return self.parent._archive.open(self._worksheet_path)


    def _cells_by_row(self, min_col, min_row, max_col, max_row, values_only=False):
        """
        The source worksheet file may have columns or rows missing.
        Missing cells will be created.
        """
        filler = EMPTY_CELL
        if values_only:
            filler = None

        max_col = max_col or self.max_column
        max_row = max_row or self.max_row
        empty_row = []
        if max_col is not None:
            empty_row = (filler,) * (max_col + 1 - min_col)

        counter = min_row
        idx = 1
        with self._get_source() as src:
            parser = WorkSheetParser(src,
                                     self._shared_strings,
                                     data_only=self.parent.data_only,
                                     epoch=self.parent.epoch,
                                     date_formats=self.parent._date_formats,
                                     timedelta_formats=self.parent._timedelta_formats)

            for idx, row in parser.parse():
                if max_row is not None and idx > max_row:
                    break

                # some rows are missing
                for _ in range(counter, idx):
                    counter += 1
                    yield empty_row

                # return cells from a row
                if counter <= idx:
                    row = self._get_row(row, min_col, max_col, values_only)
                    counter += 1
                    yield row

        if max_row is not None and max_row < idx:
            for _ in range(counter, max_row+1):
                yield empty_row


    def _get_row(self, row, min_col=1, max_col=None, values_only=False):
        """
        Make sure a row contains always the same number of cells or values
        """
        if not row and not max_col: # in case someone wants to force rows where there aren't any
            return ()

        max_col = max_col or  row[-1]['column']
        row_width = max_col + 1 - min_col

        new_row = [EMPTY_CELL] * row_width
        if values_only:
            new_row = [None] * row_width

        for cell in row:
            counter = cell['column']
            if min_col <= counter <= max_col:
                idx = counter - min_col # position in list of cells returned
                new_row[idx] = cell['value']
                if not values_only:
                    new_row[idx] = ReadOnlyCell(self, **cell)

        return tuple(new_row)


    def _get_cell(self, row, column):
        """Cells are returned by a generator which can be empty"""
        for row in self._cells_by_row(column, row, column, row):
            if row:
                return row[0]
        return EMPTY_CELL


    def calculate_dimension(self, force=False):
        if not all([self.max_column, self.max_row]):
            if force:
                self._calculate_dimension()
            else:
                raise ValueError("Worksheet is unsized, use calculate_dimension(force=True)")
        return f"{get_column_letter(self.min_column)}{self.min_row}:{get_column_letter(self.max_column)}{self.max_row}"


    def _calculate_dimension(self):
        """
        Loop through all the cells to get the size of a worksheet.
        Do this only if it is explicitly requested.
        """

        max_col = 0
        for r in self.rows:
            if not r:
                continue
            cell = r[-1]
            max_col = max(max_col, cell.column)

        self._max_row = cell.row
        self._max_column = max_col


    def reset_dimensions(self):
        """
        Remove worksheet dimensions if these are incorrect in the worksheet source.
        NB. This probably indicates a bug in the library or application that created
        the workbook.
        """
        self._max_row = self._max_column = None


    @property
    def min_row(self):
        return self._min_row


    @property
    def max_row(self):
        return self._max_row


    @property
    def min_column(self):
        return self._min_column


    @property
    def max_column(self):
        return self._max_column

```

---

### File: `tmp\openpyxl_sdist\openpyxl-3.1.5\openpyxl\worksheet\_reader.py`

```python
# Copyright (c) 2010-2024 openpyxl

"""Reader for a single worksheet."""
from copy import copy
from warnings import warn

# compatibility imports
from openpyxl.xml.functions import iterparse

# package imports
from openpyxl.cell import Cell, MergedCell
from openpyxl.cell.text import Text
from openpyxl.worksheet.dimensions import (
    ColumnDimension,
    RowDimension,
    SheetFormatProperties,
)

from openpyxl.xml.constants import (
    SHEET_MAIN_NS,
    EXT_TYPES,
)
from openpyxl.formatting.formatting import ConditionalFormatting
from openpyxl.formula.translate import Translator
from openpyxl.utils import (
    get_column_letter,
    coordinate_to_tuple,
    )
from openpyxl.utils.datetime import from_excel, from_ISO8601, WINDOWS_EPOCH
from openpyxl.descriptors.excel import ExtensionList
from openpyxl.cell.rich_text import CellRichText

from .formula import DataTableFormula, ArrayFormula
from .filters import AutoFilter
from .header_footer import HeaderFooter
from .hyperlink import HyperlinkList
from .merge import MergeCells
from .page import PageMargins, PrintOptions, PrintPageSetup
from .pagebreak import RowBreak, ColBreak
from .protection import SheetProtection
from .scenario import ScenarioList
from .views import SheetViewList
from .datavalidation import DataValidationList
from .table import TablePartList
from .properties import WorksheetProperties
from .dimensions import SheetDimension
from .related import Related


CELL_TAG = '{%s}c' % SHEET_MAIN_NS
VALUE_TAG = '{%s}v' % SHEET_MAIN_NS
FORMULA_TAG = '{%s}f' % SHEET_MAIN_NS
MERGE_TAG = '{%s}mergeCells' % SHEET_MAIN_NS
INLINE_STRING = "{%s}is" % SHEET_MAIN_NS
COL_TAG = '{%s}col' % SHEET_MAIN_NS
ROW_TAG = '{%s}row' % SHEET_MAIN_NS
CF_TAG = '{%s}conditionalFormatting' % SHEET_MAIN_NS
LEGACY_TAG = '{%s}legacyDrawing' % SHEET_MAIN_NS
PROT_TAG = '{%s}sheetProtection' % SHEET_MAIN_NS
EXT_TAG = "{%s}extLst" % SHEET_MAIN_NS
HYPERLINK_TAG = "{%s}hyperlinks" % SHEET_MAIN_NS
TABLE_TAG = "{%s}tableParts" % SHEET_MAIN_NS
PRINT_TAG = '{%s}printOptions' % SHEET_MAIN_NS
MARGINS_TAG = '{%s}pageMargins' % SHEET_MAIN_NS
PAGE_TAG = '{%s}pageSetup' % SHEET_MAIN_NS
HEADER_TAG = '{%s}headerFooter' % SHEET_MAIN_NS
FILTER_TAG = '{%s}autoFilter' % SHEET_MAIN_NS
VALIDATION_TAG = '{%s}dataValidations' % SHEET_MAIN_NS
PROPERTIES_TAG = '{%s}sheetPr' % SHEET_MAIN_NS
VIEWS_TAG = '{%s}sheetViews' % SHEET_MAIN_NS
FORMAT_TAG = '{%s}sheetFormatPr' % SHEET_MAIN_NS
ROW_BREAK_TAG = '{%s}rowBreaks' % SHEET_MAIN_NS
COL_BREAK_TAG = '{%s}colBreaks' % SHEET_MAIN_NS
SCENARIOS_TAG = '{%s}scenarios' % SHEET_MAIN_NS
DATA_TAG = '{%s}sheetData' % SHEET_MAIN_NS
DIMENSION_TAG = '{%s}dimension' % SHEET_MAIN_NS
CUSTOM_VIEWS_TAG = '{%s}customSheetViews' % SHEET_MAIN_NS


def _cast_number(value):
    "Convert numbers as string to an int or float"
    if "." in value or "E" in value or "e" in value:
        return float(value)
    return int(value)


def parse_richtext_string(element):
    """
    Parse inline string and preserve rich text formatting
    """
    value = CellRichText.from_tree(element) or ""
    if len(value) == 1 and isinstance(value[0], str):
        value = value[0]
    return value


class WorkSheetParser:

    def __init__(self, src, shared_strings, data_only=False,
                 epoch=WINDOWS_EPOCH, date_formats=set(),
                 timedelta_formats=set(), rich_text=False):
        self.min_row = self.min_col = None
        self.epoch = epoch
        self.source = src
        self.shared_strings = shared_strings
        self.data_only = data_only
        self.shared_formulae = {}
        self.row_counter = self.col_counter = 0
        self.tables = TablePartList()
        self.date_formats = date_formats
        self.timedelta_formats = timedelta_formats
        self.row_dimensions = {}
        self.column_dimensions = {}
        self.number_formats = []
        self.keep_vba = False
        self.hyperlinks = HyperlinkList()
        self.formatting = []
        self.legacy_drawing = None
        self.merged_cells = None
        self.row_breaks = RowBreak()
        self.col_breaks = ColBreak()
        self.rich_text = rich_text


    def parse(self):
        dispatcher = {
            COL_TAG: self.parse_column_dimensions,
            PROT_TAG: self.parse_sheet_protection,
            EXT_TAG: self.parse_extensions,
            CF_TAG: self.parse_formatting,
            LEGACY_TAG: self.parse_legacy,
            ROW_BREAK_TAG: self.parse_row_breaks,
            COL_BREAK_TAG: self.parse_col_breaks,
            CUSTOM_VIEWS_TAG: self.parse_custom_views,
                      }

        properties = {
            PRINT_TAG: ('print_options', PrintOptions),
            MARGINS_TAG: ('page_margins', PageMargins),
            PAGE_TAG: ('page_setup', PrintPageSetup),
            HEADER_TAG: ('HeaderFooter', HeaderFooter),
            FILTER_TAG: ('auto_filter', AutoFilter),
            VALIDATION_TAG: ('data_validations', DataValidationList),
            PROPERTIES_TAG: ('sheet_properties', WorksheetProperties),
            VIEWS_TAG: ('views', SheetViewList),
            FORMAT_TAG: ('sheet_format', SheetFormatProperties),
            SCENARIOS_TAG: ('scenarios', ScenarioList),
            TABLE_TAG: ('tables', TablePartList),
            HYPERLINK_TAG: ('hyperlinks', HyperlinkList),
            MERGE_TAG: ('merged_cells', MergeCells),

        }

        it = iterparse(self.source) # add a finaliser to close the source when this becomes possible

        for _, element in it:
            tag_name = element.tag
            if tag_name in dispatcher:
                dispatcher[tag_name](element)
                element.clear()
            elif tag_name in properties:
                prop = properties[tag_name]
                obj = prop[1].from_tree(element)
                setattr(self, prop[0], obj)
                element.clear()
            elif tag_name == ROW_TAG:
                row = self.parse_row(element)
                element.clear()
                yield row


    def parse_dimensions(self):
        """
        Get worksheet dimensions if they are provided.
        """
        it = iterparse(self.source)

        for _event, element in it:
            if element.tag == DIMENSION_TAG:
                dim = SheetDimension.from_tree(element)
                return dim.boundaries

            elif element.tag == DATA_TAG:
                # Dimensions missing
                break
            element.clear()


    def parse_cell(self, element):
        data_type = element.get('t', 'n')
        coordinate = element.get('r')
        style_id = element.get('s', 0)
        if style_id:
            style_id = int(style_id)

        if data_type == "inlineStr":
            value = None
        else:
            value = element.findtext(VALUE_TAG, None) or None

        if coordinate:
            row, column = coordinate_to_tuple(coordinate)
            self.col_counter = column
        else:
            self.col_counter += 1
            row, column = self.row_counter, self.col_counter

        if not self.data_only and element.find(FORMULA_TAG) is not None:
            data_type = 'f'
            value = self.parse_formula(element)

        elif value is not None:
            if data_type == 'n':
                value = _cast_number(value)
                if style_id in self.date_formats:
                    data_type = 'd'
                    try:
                        value = from_excel(
                            value, self.epoch, timedelta=style_id in self.timedelta_formats
                        )
                    except (OverflowError, ValueError):
                        msg = f"""Cell {coordinate} is marked as a date but the serial value {value} is outside the limits for dates. The cell will be treated as an error."""
                        warn(msg)
                        data_type = "e"
                        value = "#VALUE!"
            elif data_type == 's':
                value = self.shared_strings[int(value)]
            elif data_type == 'b':
                value = bool(int(value))
            elif data_type == "str":
                data_type = "s"
            elif data_type == 'd':
                value = from_ISO8601(value)

        elif data_type == 'inlineStr':
                child = element.find(INLINE_STRING)
                if child is not None:
                    data_type = 's'
                    if self.rich_text:
                        value = parse_richtext_string(child)
                    else:
                        value = Text.from_tree(child).content

        return {'row':row, 'column':column, 'value':value, 'data_type':data_type, 'style_id':style_id}


    def parse_formula(self, element):
        """
        possible formulae types: shared, array, datatable
        """
        formula = element.find(FORMULA_TAG)
        formula_type = formula.get('t')
        coordinate = element.get('r')
        value = "="
        if formula.text is not None:
            value += formula.text

        if formula_type == "array":
            value = ArrayFormula(ref=formula.get('ref'), text=value)

        elif formula_type == "shared":
            idx = formula.get('si')
            if idx in self.shared_formulae:
                trans = self.shared_formulae[idx]
                value = trans.translate_formula(coordinate)
            elif value != "=":
                self.shared_formulae[idx] = Translator(value, coordinate)

        elif formula_type == "dataTable":
            value = DataTableFormula(**formula.attrib)

        return value


    def parse_column_dimensions(self, col):
        attrs = dict(col.attrib)
        column = get_column_letter(int(attrs['min']))
        attrs['index'] = column
        self.column_dimensions[column] = attrs


    def parse_row(self, row):
        attrs = dict(row.attrib)

        if "r" in attrs:
            try:
                self.row_counter = int(attrs['r'])
            except ValueError:
                val = float(attrs['r'])
                if val.is_integer():
                    self.row_counter = int(val)
                else:
                    raise ValueError(f"{attrs['r']} is not a valid row number")
        else:
            self.row_counter += 1
        self.col_counter = 0

        keys = {k for k in attrs if not k.startswith('{')}
        if keys - {'r', 'spans'}:
            # don't create dimension objects unless they have relevant information
            self.row_dimensions[str(self.row_counter)] = attrs

        cells = [self.parse_cell(el) for el in row]
        return self.row_counter, cells


    def parse_formatting(self, element):
        try:
            cf = ConditionalFormatting.from_tree(element)
            self.formatting.append(cf)
        except TypeError as e:
            msg = f"Failed to load a conditional formatting rule. It will be discarded. Cause: {e}"
            warn(msg)


    def parse_sheet_protection(self, element):
        protection = SheetProtection.from_tree(element)
        password = element.get("password")
        if password is not None:
            protection.set_password(password, True)
        self.protection = protection


    def parse_extensions(self, element):
        extLst = ExtensionList.from_tree(element)
        for e in extLst.ext:
            ext_type = EXT_TYPES.get(e.uri.upper(), "Unknown")
            msg = "{0} extension is not supported and will be removed".format(ext_type)
            warn(msg)


    def parse_legacy(self, element):
        obj = Related.from_tree(element)
        self.legacy_drawing = obj.id


    def parse_row_breaks(self, element):
        brk = RowBreak.from_tree(element)
        self.row_breaks = brk


    def parse_col_breaks(self, element):
        brk = ColBreak.from_tree(element)
        self.col_breaks = brk


    def parse_custom_views(self, element):
        # clear page_breaks to avoid duplication which Excel doesn't like
        # basically they're ignored in custom views
        self.row_breaks = RowBreak()
        self.col_breaks = ColBreak()


class WorksheetReader:
    """
    Create a parser and apply it to a workbook
    """

    def __init__(self, ws, xml_source, shared_strings, data_only, rich_text):
        self.ws = ws
        self.parser = WorkSheetParser(xml_source, shared_strings,
                data_only, ws.parent.epoch, ws.parent._date_formats,
                ws.parent._timedelta_formats, rich_text)
        self.tables = []


    def bind_cells(self):
        for idx, row in self.parser.parse():
            for cell in row:
                style = self.ws.parent._cell_styles[cell['style_id']]
                c = Cell(self.ws, row=cell['row'], column=cell['column'], style_array=style)
                c._value = cell['value']
                c.data_type = cell['data_type']
                self.ws._cells[(cell['row'], cell['column'])] = c

        if self.ws._cells:
            self.ws._current_row = self.ws.max_row # use cells not row dimensions


    def bind_formatting(self):
        for cf in self.parser.formatting:
            for rule in cf.rules:
                if rule.dxfId is not None:
                    rule.dxf = self.ws.parent._differential_styles[rule.dxfId]
                self.ws.conditional_formatting[cf] = rule


    def bind_tables(self):
        for t in self.parser.tables.tablePart:
            rel = self.ws._rels.get(t.id)
            self.tables.append(rel.Target)


    def bind_merged_cells(self):
        from openpyxl.worksheet.cell_range import MultiCellRange
        from openpyxl.worksheet.merge import MergedCellRange
        if not self.parser.merged_cells:
            return

        ranges = []
        for cr in self.parser.merged_cells.mergeCell:
            mcr = MergedCellRange(self.ws, cr.ref)
            self.ws._clean_merge_range(mcr)
            ranges.append(mcr)
        self.ws.merged_cells = MultiCellRange(ranges)


    def bind_hyperlinks(self):
        for link in self.parser.hyperlinks.hyperlink:
            if link.id:
                rel = self.ws._rels.get(link.id)
                link.target = rel.Target
            if ":" in link.ref:
                # range of cells
                for row in self.ws[link.ref]:
                    for cell in row:
                        try:
                            cell.hyperlink = copy(link)
                        except AttributeError:
                            pass
            else:
                cell = self.ws[link.ref]
                if isinstance(cell, MergedCell):
                    cell = self.normalize_merged_cell_link(cell.coordinate)
                cell.hyperlink = link

    def normalize_merged_cell_link(self, coord):
        """
        Returns the appropriate cell to which a hyperlink, which references a merged cell at the specified coordinates,
        should be bound.
        """
        for rng in self.ws.merged_cells:
            if coord in rng:
                return self.ws.cell(*rng.top[0])

    def bind_col_dimensions(self):
        for col, cd in self.parser.column_dimensions.items():
            if 'style' in cd:
                key = int(cd['style'])
                cd['style'] = self.ws.parent._cell_styles[key]
            self.ws.column_dimensions[col] = ColumnDimension(self.ws, **cd)


    def bind_row_dimensions(self):
        for row, rd in self.parser.row_dimensions.items():
            if 's' in rd:
                key = int(rd['s'])
                rd['s'] = self.ws.parent._cell_styles[key]
            self.ws.row_dimensions[int(row)] = RowDimension(self.ws, **rd)


    def bind_properties(self):
        for k in ('print_options', 'page_margins', 'page_setup',
                  'HeaderFooter', 'auto_filter', 'data_validations',
                  'sheet_properties', 'views', 'sheet_format',
                  'row_breaks', 'col_breaks', 'scenarios', 'legacy_drawing',
                  'protection',
                  ):
            v = getattr(self.parser, k, None)
            if v is not None:
                setattr(self.ws, k, v)


    def bind_all(self):
        self.bind_cells()
        self.bind_merged_cells()
        self.bind_hyperlinks()
        self.bind_formatting()
        self.bind_col_dimensions()
        self.bind_row_dimensions()
        self.bind_tables()
        self.bind_properties()

```

---

### File: `tmp\openpyxl_sdist\openpyxl-3.1.5\openpyxl\worksheet\_write_only.py`

```python
# Copyright (c) 2010-2024 openpyxl


"""Write worksheets to xml representations in an optimized way"""

from inspect import isgenerator

from openpyxl.cell import Cell, WriteOnlyCell
from openpyxl.workbook.child import _WorkbookChild
from .worksheet import Worksheet
from openpyxl.utils.exceptions import WorkbookAlreadySaved

from ._writer import WorksheetWriter


class WriteOnlyWorksheet(_WorkbookChild):
    """
    Streaming worksheet. Optimised to reduce memory by writing rows just in
    time.
    Cells can be styled and have comments Styles for rows and columns
    must be applied before writing cells
    """

    __saved = False
    _writer = None
    _rows = None
    _rel_type = Worksheet._rel_type
    _path = Worksheet._path
    mime_type = Worksheet.mime_type

    # copy methods from Standard worksheet
    _add_row = Worksheet._add_row
    _add_column = Worksheet._add_column
    add_chart = Worksheet.add_chart
    add_image = Worksheet.add_image
    add_table = Worksheet.add_table
    tables = Worksheet.tables
    print_titles = Worksheet.print_titles
    print_title_cols = Worksheet.print_title_cols
    print_title_rows = Worksheet.print_title_rows
    freeze_panes = Worksheet.freeze_panes
    print_area = Worksheet.print_area
    sheet_view = Worksheet.sheet_view
    _setup = Worksheet._setup

    def __init__(self, parent, title):
        super().__init__(parent, title)
        self._max_col = 0
        self._max_row = 0
        self._setup()

    @property
    def closed(self):
        return self.__saved


    def _write_rows(self):
        """
        Send rows to the writer's stream
        """
        try:
            xf = self._writer.xf.send(True)
        except StopIteration:
            self._already_saved()

        with xf.element("sheetData"):
            row_idx = 1
            try:
                while True:
                    row = (yield)
                    row = self._values_to_row(row, row_idx)
                    self._writer.write_row(xf, row, row_idx)
                    row_idx += 1
            except GeneratorExit:
                pass

        self._writer.xf.send(None)


    def _get_writer(self):
        if self._writer is None:
            self._writer = WorksheetWriter(self)
            self._writer.write_top()


    def close(self):
        if self.__saved:
            self._already_saved()

        self._get_writer()

        if self._rows is None:
            self._writer.write_rows()
        else:
            self._rows.close()

        self._writer.write_tail()

        self._writer.close()
        self.__saved = True


    def append(self, row):
        """
        :param row: iterable containing values to append
        :type row: iterable
        """

        if (not isgenerator(row) and
            not isinstance(row, (list, tuple, range))
            ):
            self._invalid_row(row)

        self._get_writer()

        if self._rows is None:
            self._rows = self._write_rows()
            next(self._rows)

        self._rows.send(row)


    def _values_to_row(self, values, row_idx):
        """
        Convert whatever has been appended into a form suitable for work_rows
        """
        cell = WriteOnlyCell(self)

        for col_idx, value in enumerate(values, 1):
            if value is None:
                continue
            try:
                cell.value = value
            except ValueError:
                if isinstance(value, Cell):
                    cell = value
                else:
                    raise ValueError

            cell.column = col_idx
            cell.row = row_idx

            if cell.hyperlink is not None:
                cell.hyperlink.ref = cell.coordinate

            yield cell

            # reset cell if style applied
            if cell.has_style or cell.hyperlink:
                cell = WriteOnlyCell(self)


    def _already_saved(self):
        raise WorkbookAlreadySaved('Workbook has already been saved and cannot be modified or saved anymore.')


    def _invalid_row(self, iterable):
        raise TypeError('Value must be a list, tuple, range or a generator Supplied value is {0}'.format(
            type(iterable))
                        )

```

---

### File: `tmp\openpyxl_sdist\openpyxl-3.1.5\openpyxl\worksheet\_writer.py`

```python
# Copyright (c) 2010-2024 openpyxl

import atexit
from collections import defaultdict
from io import BytesIO
import os
from tempfile import NamedTemporaryFile
from warnings import warn

from openpyxl.xml.functions import xmlfile
from openpyxl.xml.constants import SHEET_MAIN_NS

from openpyxl.comments.comment_sheet import CommentRecord
from openpyxl.packaging.relationship import Relationship, RelationshipList
from openpyxl.styles.differential import DifferentialStyle

from .dimensions import SheetDimension
from .hyperlink import HyperlinkList
from .merge import MergeCell, MergeCells
from .related import Related
from .table import TablePartList

from openpyxl.cell._writer import write_cell


ALL_TEMP_FILES = []

@atexit.register
def _openpyxl_shutdown():
    for path in ALL_TEMP_FILES:
        if os.path.exists(path):
            os.remove(path)


def create_temporary_file(suffix=''):
    fobj = NamedTemporaryFile(mode='w+', suffix=suffix,
                              prefix='openpyxl.', delete=False)
    filename = fobj.name
    fobj.close()
    ALL_TEMP_FILES.append(filename)
    return filename


class WorksheetWriter:


    def __init__(self, ws, out=None):
        self.ws = ws
        self.ws._hyperlinks = []
        self.ws._comments = []
        if out is None:
            out = create_temporary_file()
        self.out = out
        self._rels = RelationshipList()
        self.xf = self.get_stream()
        next(self.xf) # start generator


    def write_properties(self):
        props = self.ws.sheet_properties
        self.xf.send(props.to_tree())


    def write_dimensions(self):
        """
        Write worksheet size if known
        """
        ref = getattr(self.ws, 'calculate_dimension', None)
        if ref:
            dim = SheetDimension(ref())
            self.xf.send(dim.to_tree())


    def write_format(self):
        self.ws.sheet_format.outlineLevelCol = self.ws.column_dimensions.max_outline
        fmt = self.ws.sheet_format
        self.xf.send(fmt.to_tree())


    def write_views(self):
        views = self.ws.views
        self.xf.send(views.to_tree())


    def write_cols(self):
        cols = self.ws.column_dimensions
        self.xf.send(cols.to_tree())


    def write_top(self):
        """
        Write all elements up to rows:
        properties
        dimensions
        views
        format
        cols
        """
        self.write_properties()
        self.write_dimensions()
        self.write_views()
        self.write_format()
        self.write_cols()


    def rows(self):
        """Return all rows, and any cells that they contain"""
        # order cells by row
        rows = defaultdict(list)
        for (row, col), cell in sorted(self.ws._cells.items()):
            rows[row].append(cell)

        # add empty rows if styling has been applied
        for row in self.ws.row_dimensions.keys() - rows.keys():
            rows[row] = []

        return sorted(rows.items())


    def write_rows(self):
        xf = self.xf.send(True)

        with xf.element("sheetData"):
            for row_idx, row in self.rows():
                self.write_row(xf, row, row_idx)

        self.xf.send(None) # return control to generator


    def write_row(self, xf, row, row_idx):
        attrs = {'r': f"{row_idx}"}
        dims = self.ws.row_dimensions
        attrs.update(dims.get(row_idx, {}))

        with xf.element("row", attrs):

            for cell in row:
                if cell._comment is not None:
                    comment = CommentRecord.from_cell(cell)
                    self.ws._comments.append(comment)
                if (
                    cell._value is None
                    and not cell.has_style
                    and not cell._comment
                    ):
                    continue
                write_cell(xf, self.ws, cell, cell.has_style)


    def write_protection(self):
        prot = self.ws.protection
        if prot:
            self.xf.send(prot.to_tree())


    def write_scenarios(self):
        scenarios = self.ws.scenarios
        if scenarios:
            self.xf.send(scenarios.to_tree())


    def write_filter(self):
        flt = self.ws.auto_filter
        if flt:
            self.xf.send(flt.to_tree())


    def write_sort(self):
        """
        As per discusion with the OOXML Working Group global sort state is not required.
        openpyxl never reads it from existing files
        """
        pass


    def write_merged_cells(self):
        merged = self.ws.merged_cells
        if merged:
            cells = [MergeCell(str(ref)) for ref in self.ws.merged_cells]
            self.xf.send(MergeCells(mergeCell=cells).to_tree())


    def write_formatting(self):
        df = DifferentialStyle()
        wb = self.ws.parent
        for cf in self.ws.conditional_formatting:
            for rule in cf.rules:
                if rule.dxf and rule.dxf != df:
                    rule.dxfId = wb._differential_styles.add(rule.dxf)
            self.xf.send(cf.to_tree())


    def write_validations(self):
        dv = self.ws.data_validations
        if dv:
            self.xf.send(dv.to_tree())


    def write_hyperlinks(self):

        links = self.ws._hyperlinks

        for link in links:
            if link.target:
                rel = Relationship(type="hyperlink", TargetMode="External", Target=link.target)
                self._rels.append(rel)
                link.id = rel.id

        if links:
            self.xf.send(HyperlinkList(links).to_tree())


    def write_print(self):
        print_options = self.ws.print_options
        if print_options:
            self.xf.send(print_options.to_tree())


    def write_margins(self):
        margins = self.ws.page_margins
        if margins:
            self.xf.send(margins.to_tree())


    def write_page(self):
        setup = self.ws.page_setup
        if setup:
            self.xf.send(setup.to_tree())


    def write_header(self):
        hf = self.ws.HeaderFooter
        if hf:
            self.xf.send(hf.to_tree())


    def write_breaks(self):
        brks = (self.ws.row_breaks, self.ws.col_breaks)
        for brk in brks:
            if brk:
                self.xf.send(brk.to_tree())


    def write_drawings(self):
        if self.ws._charts or self.ws._images:
            rel = Relationship(type="drawing", Target="")
            self._rels.append(rel)
            drawing = Related()
            drawing.id = rel.id
            self.xf.send(drawing.to_tree("drawing"))


    def write_legacy(self):
        """
        Comments & VBA controls use VML and require an additional element
        that is no longer in the specification.
        """
        if (self.ws.legacy_drawing is not None or self.ws._comments):
            legacy = Related(id="anysvml")
            self.xf.send(legacy.to_tree("legacyDrawing"))


    def write_tables(self):
        tables = TablePartList()

        for table in self.ws.tables.values():
            if not table.tableColumns:
                table._initialise_columns()
                if table.headerRowCount:
                    try:
                        row = self.ws[table.ref][0]
                        for cell, col in zip(row, table.tableColumns):
                            if cell.data_type != "s":
                                warn("File may not be readable: column headings must be strings.")
                            col.name = str(cell.value)
                    except TypeError:
                        warn("Column headings are missing, file may not be readable")
            rel = Relationship(Type=table._rel_type, Target="")
            self._rels.append(rel)
            table._rel_id = rel.Id
            tables.append(Related(id=rel.Id))

        if tables:
            self.xf.send(tables.to_tree())


    def get_stream(self):
        with xmlfile(self.out) as xf:
            with xf.element("worksheet", xmlns=SHEET_MAIN_NS):
                try:
                    while True:
                        el = (yield)
                        if el is True:
                            yield xf
                        elif el is None: # et_xmlfile chokes
                            continue
                        else:
                            xf.write(el)
                except GeneratorExit:
                    pass


    def write_tail(self):
        """
        Write all elements after the rows
        calc properties
        protection
        protected ranges #
        scenarios
        filters
        sorts # always ignored
        data consolidation #
        custom views #
        merged cells
        phonetic properties #
        conditional formatting
        data validation
        hyperlinks
        print options
        page margins
        page setup
        header
        row breaks
        col breaks
        custom properties #
        cell watches #
        ignored errors #
        smart tags #
        drawing
        drawingHF #
        background #
        OLE objects #
        controls #
        web publishing #
        tables
        """
        self.write_protection()
        self.write_scenarios()
        self.write_filter()
        self.write_merged_cells()
        self.write_formatting()
        self.write_validations()
        self.write_hyperlinks()
        self.write_print()
        self.write_margins()
        self.write_page()
        self.write_header()
        self.write_breaks()
        self.write_drawings()
        self.write_legacy()
        self.write_tables()


    def write(self):
        """
        High level
        """
        self.write_top()
        self.write_rows()
        self.write_tail()
        self.close()


    def close(self):
        """
        Close the context manager
        """
        if self.xf:
            self.xf.close()


    def read(self):
        """
        Close the context manager and return serialised XML
        """
        self.close()
        if isinstance(self.out, BytesIO):
            return self.out.getvalue()
        with open(self.out, "rb") as src:
            out = src.read()

        return out


    def cleanup(self):
        """
        Remove tempfile
        """
        os.remove(self.out)
        ALL_TEMP_FILES.remove(self.out)

```

---

### File: `tmp\openpyxl_sdist\openpyxl-3.1.5\openpyxl\worksheet\cell_range.py`

```python
# Copyright (c) 2010-2024 openpyxl

from copy import copy
from operator import attrgetter

from openpyxl.descriptors import Strict
from openpyxl.descriptors import MinMax
from openpyxl.descriptors.sequence import UniqueSequence
from openpyxl.descriptors.serialisable import Serialisable

from openpyxl.utils import (
    range_boundaries,
    range_to_tuple,
    get_column_letter,
    quote_sheetname,
)

class CellRange(Serialisable):
    """
    Represents a range in a sheet: title and coordinates.

    This object is used to perform operations on ranges, like:

    - shift, expand or shrink
    - union/intersection with another sheet range,

    We can check whether a range is:

    - equal or not equal to another,
    - disjoint of another,
    - contained in another.

    We can get:

    - the size of a range.
    - the range bounds (vertices)
    - the coordinates,
    - the string representation,

    """

    min_col = MinMax(min=1, max=18278, expected_type=int)
    min_row = MinMax(min=1, max=1048576, expected_type=int)
    max_col = MinMax(min=1, max=18278, expected_type=int)
    max_row = MinMax(min=1, max=1048576, expected_type=int)


    def __init__(self, range_string=None, min_col=None, min_row=None,
                 max_col=None, max_row=None, title=None):
        if range_string is not None:
            if "!" in range_string:
                title, (min_col, min_row, max_col, max_row) = range_to_tuple(range_string)
            else:
                min_col, min_row, max_col, max_row = range_boundaries(range_string)

        self.min_col = min_col
        self.min_row = min_row
        self.max_col = max_col
        self.max_row = max_row
        self.title = title

        if min_col > max_col:
            fmt = "{max_col} must be greater than {min_col}"
            raise ValueError(fmt.format(min_col=min_col, max_col=max_col))
        if min_row > max_row:
            fmt = "{max_row} must be greater than {min_row}"
            raise ValueError(fmt.format(min_row=min_row, max_row=max_row))


    @property
    def bounds(self):
        """
        Vertices of the range as a tuple
        """
        return self.min_col, self.min_row, self.max_col, self.max_row


    @property
    def coord(self):
        """
        Excel-style representation of the range
        """
        fmt = "{min_col}{min_row}:{max_col}{max_row}"
        if (self.min_col == self.max_col
            and self.min_row == self.max_row):
            fmt = "{min_col}{min_row}"

        return fmt.format(
            min_col=get_column_letter(self.min_col),
            min_row=self.min_row,
            max_col=get_column_letter(self.max_col),
            max_row=self.max_row
        )

    @property
    def rows(self):
        """
        Return cell coordinates as rows
        """
        for row in range(self.min_row, self.max_row+1):
            yield [(row, col) for col in range(self.min_col, self.max_col+1)]


    @property
    def cols(self):
        """
        Return cell coordinates as columns
        """
        for col in range(self.min_col, self.max_col+1):
            yield [(row, col) for row in range(self.min_row, self.max_row+1)]


    @property
    def cells(self):
        from itertools import product
        return product(range(self.min_row, self.max_row+1), range(self.min_col, self.max_col+1))


    def _check_title(self, other):
        """
        Check whether comparisons between ranges are possible.
        Cannot compare ranges from different worksheets
        Skip if the range passed in has no title.
        """
        if not isinstance(other, CellRange):
            raise TypeError(repr(type(other)))

        if other.title and self.title != other.title:
            raise ValueError("Cannot work with ranges from different worksheets")


    def __repr__(self):
        fmt = u"<{cls} {coord}>"
        if self.title:
            fmt = u"<{cls} {title!r}!{coord}>"
        return fmt.format(cls=self.__class__.__name__, title=self.title, coord=self.coord)


    def __hash__(self):
        return hash((self.min_row, self.min_col, self.max_row, self.max_col))


    def __str__(self):
        fmt = "{coord}"
        title = self.title
        if title:
            fmt = u"{title}!{coord}"
            title = quote_sheetname(title)
        return fmt.format(title=title, coord=self.coord)


    def __copy__(self):
        return self.__class__(min_col=self.min_col, min_row=self.min_row,
                              max_col=self.max_col, max_row=self.max_row,
                              title=self.title)


    def shift(self, col_shift=0, row_shift=0):
        """
        Shift the focus of the range according to the shift values (*col_shift*, *row_shift*).

        :type col_shift: int
        :param col_shift: number of columns to be moved by, can be negative
        :type row_shift: int
        :param row_shift: number of rows to be moved by, can be negative
        :raise: :class:`ValueError` if any row or column index < 1
        """

        if (self.min_col + col_shift <= 0
            or self.min_row + row_shift <= 0):
            raise ValueError("Invalid shift value: col_shift={0}, row_shift={1}".format(col_shift, row_shift))
        self.min_col += col_shift
        self.min_row += row_shift
        self.max_col += col_shift
        self.max_row += row_shift


    def __ne__(self, other):
        """
        Test whether the ranges are not equal.

        :type other: openpyxl.worksheet.cell_range.CellRange
        :param other: Other sheet range
        :return: ``True`` if *range* != *other*.
        """
        try:
            self._check_title(other)
        except ValueError:
            return True

        return (
            other.min_row != self.min_row
            or self.max_row != other.max_row
            or other.min_col != self.min_col
            or self.max_col != other.max_col
        )


    def __eq__(self, other):
        """
        Test whether the ranges are equal.

        :type other: openpyxl.worksheet.cell_range.CellRange
        :param other: Other sheet range
        :return: ``True`` if *range* == *other*.
        """
        return not self.__ne__(other)


    def issubset(self, other):
        """
        Test whether every cell in this range is also in *other*.

        :type other: openpyxl.worksheet.cell_range.CellRange
        :param other: Other sheet range
        :return: ``True`` if *range* <= *other*.
        """
        self._check_title(other)

        return other.__superset(self)

    __le__ = issubset


    def __lt__(self, other):
        """
        Test whether *other* contains every cell of this range, and more.

        :type other: openpyxl.worksheet.cell_range.CellRange
        :param other: Other sheet range
        :return: ``True`` if *range* < *other*.
        """
        return self.__le__(other) and self.__ne__(other)


    def __superset(self, other):
        return (
            (self.min_row <= other.min_row <= other.max_row <= self.max_row)
            and
            (self.min_col <= other.min_col <= other.max_col <= self.max_col)
        )


    def issuperset(self, other):
        """
        Test whether every cell in *other* is in this range.

        :type other: openpyxl.worksheet.cell_range.CellRange
        :param other: Other sheet range
        :return: ``True`` if *range* >= *other* (or *other* in *range*).
        """
        self._check_title(other)

        return self.__superset(other)

    __ge__ = issuperset


    def __contains__(self, coord):
        """
        Check whether the range contains a particular cell coordinate
        """
        cr = self.__class__(coord)
        return self.__superset(cr)


    def __gt__(self, other):
        """
        Test whether this range contains every cell in *other*, and more.

        :type other: openpyxl.worksheet.cell_range.CellRange
        :param other: Other sheet range
        :return: ``True`` if *range* > *other*.
        """
        return self.__ge__(other) and self.__ne__(other)


    def isdisjoint(self, other):
        """
        Return ``True`` if this range has no cell in common with *other*.
        Ranges are disjoint if and only if their intersection is the empty range.

        :type other: openpyxl.worksheet.cell_range.CellRange
        :param other: Other sheet range.
        :return: ``True`` if the range has no cells in common with other.
        """
        self._check_title(other)

        # Sort by top-left vertex
        if self.bounds > other.bounds:
            self, other = other, self

        return (self.max_col < other.min_col
                or self.max_row < other.min_row
                or other.max_row < self.min_row)


    def intersection(self, other):
        """
        Return a new range with cells common to this range and *other*

        :type other: openpyxl.worksheet.cell_range.CellRange
        :param other: Other sheet range.
        :return: the intersecting sheet range.
        :raise: :class:`ValueError` if the *other* range doesn't intersect
            with this range.
        """
        if self.isdisjoint(other):
            raise ValueError("Range {0} doesn't intersect {0}".format(self, other))

        min_row = max(self.min_row, other.min_row)
        max_row = min(self.max_row, other.max_row)
        min_col = max(self.min_col, other.min_col)
        max_col = min(self.max_col, other.max_col)

        return CellRange(min_col=min_col, min_row=min_row, max_col=max_col,
                         max_row=max_row)

    __and__ = intersection


    def union(self, other):
        """
        Return the minimal superset of this range and *other*. This new range
        will contain all cells from this range, *other*, and any additional
        cells required to form a rectangular ``CellRange``.

        :type other: openpyxl.worksheet.cell_range.CellRange
        :param other: Other sheet range.
        :return: a ``CellRange`` that is a superset of this and *other*.
        """
        self._check_title(other)

        min_row = min(self.min_row, other.min_row)
        max_row = max(self.max_row, other.max_row)
        min_col = min(self.min_col, other.min_col)
        max_col = max(self.max_col, other.max_col)
        return CellRange(min_col=min_col, min_row=min_row, max_col=max_col,
                         max_row=max_row, title=self.title)

    __or__ = union


    def __iter__(self):
        """
        For use as a dictionary elsewhere in the library.
        """
        for x in self.__attrs__:
            if x == "title":
                continue
            v = getattr(self, x)
            yield x, v


    def expand(self, right=0, down=0, left=0, up=0):
        """
        Expand the range by the dimensions provided.

        :type right: int
        :param right: expand range to the right by this number of cells
        :type down: int
        :param down: expand range down by this number of cells
        :type left: int
        :param left: expand range to the left by this number of cells
        :type up: int
        :param up: expand range up by this number of cells
        """
        self.min_col -= left
        self.min_row -= up
        self.max_col += right
        self.max_row += down


    def shrink(self, right=0, bottom=0, left=0, top=0):
        """
        Shrink the range by the dimensions provided.

        :type right: int
        :param right: shrink range from the right by this number of cells
        :type down: int
        :param down: shrink range from the top by this number of cells
        :type left: int
        :param left: shrink range from the left by this number of cells
        :type up: int
        :param up: shrink range from the bottom by this number of cells
        """
        self.min_col += left
        self.min_row += top
        self.max_col -= right
        self.max_row -= bottom


    @property
    def size(self):
        """ Return the size of the range as a dictionary of rows and columns. """
        cols = self.max_col + 1 - self.min_col
        rows = self.max_row + 1 - self.min_row
        return {'columns':cols, 'rows':rows}


    @property
    def top(self):
        """A list of cell coordinates that comprise the top of the range"""
        return [(self.min_row, col) for col in range(self.min_col, self.max_col+1)]


    @property
    def bottom(self):
        """A list of cell coordinates that comprise the bottom of the range"""
        return [(self.max_row, col) for col in range(self.min_col, self.max_col+1)]


    @property
    def left(self):
        """A list of cell coordinates that comprise the left-side of the range"""
        return [(row, self.min_col) for row in range(self.min_row, self.max_row+1)]


    @property
    def right(self):
        """A list of cell coordinates that comprise the right-side of the range"""
        return [(row, self.max_col) for row in range(self.min_row, self.max_row+1)]


class MultiCellRange(Strict):


    ranges = UniqueSequence(expected_type=CellRange)


    def __init__(self, ranges=set()):
        if isinstance(ranges, str):
            ranges = [CellRange(r) for r in ranges.split()]
        self.ranges = set(ranges)


    def __contains__(self, coord):
        if isinstance(coord, str):
            coord = CellRange(coord)
        for r in self.ranges:
            if coord <= r:
                return True
        return False


    def __repr__(self):
        ranges = " ".join([str(r) for r in self.sorted()])
        return f"<{self.__class__.__name__} [{ranges}]>"


    def __str__(self):
        ranges = u" ".join([str(r) for r in self.sorted()])
        return ranges


    def __hash__(self):
        return hash(str(self))


    def sorted(self):
        """
        Return a sorted list of items
        """
        return sorted(self.ranges, key=attrgetter('min_col', 'min_row', 'max_col', 'max_row'))


    def add(self, coord):
        """
        Add a cell coordinate or CellRange
        """
        cr = coord
        if isinstance(coord, str):
            cr = CellRange(coord)
        elif not isinstance(coord, CellRange):
            raise ValueError("You can only add CellRanges")
        if cr not in self:
            self.ranges.add(cr)


    def __iadd__(self, coord):
        self.add(coord)
        return self


    def __eq__(self, other):
        if  isinstance(other, str):
            other = self.__class__(other)
        return self.ranges == other.ranges


    def __ne__(self, other):
        return not self == other


    def __bool__(self):
        return bool(self.ranges)


    def remove(self, coord):
        if not isinstance(coord, CellRange):
            coord = CellRange(coord)
        self.ranges.remove(coord)


    def __iter__(self):
        for cr in self.ranges:
            yield cr


    def __copy__(self):
        ranges = {copy(r) for r in self.ranges}
        return MultiCellRange(ranges)

```

---

### File: `tmp\openpyxl_sdist\openpyxl-3.1.5\openpyxl\worksheet\cell_watch.py`

```python
#Autogenerated schema
from openpyxl.descriptors.serialisable import Serialisable
from openpyxl.descriptors import (
    Sequence,
    String,
)

# could be done using a nestedSequence

class CellWatch(Serialisable):

    tagname = "cellWatch"

    r = String()

    def __init__(self,
                 r=None,
                ):
        self.r = r


class CellWatches(Serialisable):

    tagname = "cellWatches"

    cellWatch = Sequence(expected_type=CellWatch)

    __elements__ = ('cellWatch',)

    def __init__(self,
                 cellWatch=(),
                ):
        self.cellWatch = cellWatch


```

---

### File: `tmp\openpyxl_sdist\openpyxl-3.1.5\openpyxl\worksheet\controls.py`

```python
# Copyright (c) 2010-2024 openpyxl

from openpyxl.descriptors.serialisable import Serialisable
from openpyxl.descriptors import (
    Typed,
    Bool,
    Integer,
    String,
    Sequence,
)

from openpyxl.descriptors.excel import Relation
from .ole import ObjectAnchor


class ControlProperty(Serialisable):

    tagname = "controlPr"

    anchor = Typed(expected_type=ObjectAnchor, )
    locked = Bool(allow_none=True)
    defaultSize = Bool(allow_none=True)
    _print = Bool(allow_none=True)
    disabled = Bool(allow_none=True)
    recalcAlways = Bool(allow_none=True)
    uiObject = Bool(allow_none=True)
    autoFill = Bool(allow_none=True)
    autoLine = Bool(allow_none=True)
    autoPict = Bool(allow_none=True)
    macro = String(allow_none=True)
    altText = String(allow_none=True)
    linkedCell = String(allow_none=True)
    listFillRange = String(allow_none=True)
    cf = String(allow_none=True)
    id = Relation(allow_none=True)

    __elements__ = ('anchor',)

    def __init__(self,
                 anchor=None,
                 locked=True,
                 defaultSize=True,
                 _print=True,
                 disabled=False,
                 recalcAlways=False,
                 uiObject=False,
                 autoFill=True,
                 autoLine=True,
                 autoPict=True,
                 macro=None,
                 altText=None,
                 linkedCell=None,
                 listFillRange=None,
                 cf='pict',
                 id=None,
                ):
        self.anchor = anchor
        self.locked = locked
        self.defaultSize = defaultSize
        self._print = _print
        self.disabled = disabled
        self.recalcAlways = recalcAlways
        self.uiObject = uiObject
        self.autoFill = autoFill
        self.autoLine = autoLine
        self.autoPict = autoPict
        self.macro = macro
        self.altText = altText
        self.linkedCell = linkedCell
        self.listFillRange = listFillRange
        self.cf = cf
        self.id = id


class Control(Serialisable):

    tagname = "control"

    controlPr = Typed(expected_type=ControlProperty, allow_none=True)
    shapeId = Integer()
    name = String(allow_none=True)

    __elements__ = ('controlPr',)

    def __init__(self,
                 controlPr=None,
                 shapeId=None,
                 name=None,
                ):
        self.controlPr = controlPr
        self.shapeId = shapeId
        self.name = name


class Controls(Serialisable):

    tagname = "controls"

    control = Sequence(expected_type=Control)

    __elements__ = ('control',)

    def __init__(self,
                 control=(),
                ):
        self.control = control


```

---

### File: `tmp\openpyxl_sdist\openpyxl-3.1.5\openpyxl\worksheet\copier.py`

```python
# Copyright (c) 2010-2024 openpyxl

#standard lib imports
from copy import copy

from .worksheet import Worksheet


class WorksheetCopy:
    """
    Copy the values, styles, dimensions, merged cells, margins, and
    print/page setup from one worksheet to another within the same
    workbook.
    """

    def __init__(self, source_worksheet, target_worksheet):
        self.source = source_worksheet
        self.target = target_worksheet
        self._verify_resources()


    def _verify_resources(self):

        if (not isinstance(self.source, Worksheet)
            and not isinstance(self.target, Worksheet)):
            raise TypeError("Can only copy worksheets")

        if self.source is self.target:
            raise ValueError("Cannot copy a worksheet to itself")

        if self.source.parent != self.target.parent:
            raise ValueError('Cannot copy between worksheets from different workbooks')


    def copy_worksheet(self):
        self._copy_cells()
        self._copy_dimensions()

        self.target.sheet_format = copy(self.source.sheet_format)
        self.target.sheet_properties = copy(self.source.sheet_properties)
        self.target.merged_cells = copy(self.source.merged_cells)
        self.target.page_margins = copy(self.source.page_margins)
        self.target.page_setup = copy(self.source.page_setup)
        self.target.print_options = copy(self.source.print_options)


    def _copy_cells(self):
        for (row, col), source_cell  in self.source._cells.items():
            target_cell = self.target.cell(column=col, row=row)

            target_cell._value = source_cell._value
            target_cell.data_type = source_cell.data_type

            if source_cell.has_style:
                target_cell._style = copy(source_cell._style)

            if source_cell.hyperlink:
                target_cell._hyperlink = copy(source_cell.hyperlink)

            if source_cell.comment:
                target_cell.comment = copy(source_cell.comment)


    def _copy_dimensions(self):
        for attr in ('row_dimensions', 'column_dimensions'):
            src = getattr(self.source, attr)
            target = getattr(self.target, attr)
            for key, dim in src.items():
                target[key] = copy(dim)
                target[key].worksheet = self.target

```

---

### File: `tmp\openpyxl_sdist\openpyxl-3.1.5\openpyxl\worksheet\custom.py`

```python
#Autogenerated schema
from openpyxl.descriptors.serialisable import Serialisable
from openpyxl.descriptors import (
    String,
    Sequence,
)

# can be done with a nested sequence


class CustomProperty(Serialisable):

    tagname = "customProperty"

    name = String()

    def __init__(self,
                 name=None,
                ):
        self.name = name


class CustomProperties(Serialisable):

    tagname = "customProperties"

    customPr = Sequence(expected_type=CustomProperty)

    __elements__ = ('customPr',)

    def __init__(self,
                 customPr=(),
                ):
        self.customPr = customPr


```

---

### File: `tmp\openpyxl_sdist\openpyxl-3.1.5\openpyxl\worksheet\datavalidation.py`

```python
# Copyright (c) 2010-2024 openpyxl

from collections import defaultdict
from itertools import chain
from operator import itemgetter

from openpyxl.descriptors.serialisable import Serialisable
from openpyxl.descriptors import (
    Bool,
    NoneSet,
    String,
    Sequence,
    Alias,
    Integer,
    Convertible,
)
from openpyxl.descriptors.nested import NestedText

from openpyxl.utils import (
    rows_from_range,
    coordinate_to_tuple,
    get_column_letter,
)


def collapse_cell_addresses(cells, input_ranges=()):
    """ Collapse a collection of cell co-ordinates down into an optimal
        range or collection of ranges.

        E.g. Cells A1, A2, A3, B1, B2 and B3 should have the data-validation
        object applied, attempt to collapse down to a single range, A1:B3.

        Currently only collapsing contiguous vertical ranges (i.e. above
        example results in A1:A3 B1:B3).
    """

    ranges = list(input_ranges)

    # convert cell into row, col tuple
    raw_coords = (coordinate_to_tuple(cell) for cell in cells)

    # group by column in order
    grouped_coords = defaultdict(list)
    for row, col in sorted(raw_coords, key=itemgetter(1)):
        grouped_coords[col].append(row)

    # create range string from first and last row in column
    for col, cells in grouped_coords.items():
        col = get_column_letter(col)
        fmt = "{0}{1}:{2}{3}"
        if len(cells) == 1:
            fmt = "{0}{1}"
        r = fmt.format(col, min(cells), col, max(cells))
        ranges.append(r)

    return " ".join(ranges)


def expand_cell_ranges(range_string):
    """
    Expand cell ranges to a sequence of addresses.
    Reverse of collapse_cell_addresses
    Eg. converts "A1:A2 B1:B2" to (A1, A2, B1, B2)
    """
    # expand ranges to rows and then flatten
    rows = (rows_from_range(rs) for rs in range_string.split()) # list of rows
    cells = (chain(*row) for row in rows) # flatten rows
    return set(chain(*cells))


from .cell_range import MultiCellRange


class DataValidation(Serialisable):

    tagname = "dataValidation"

    sqref = Convertible(expected_type=MultiCellRange)
    cells = Alias("sqref")
    ranges = Alias("sqref")

    showDropDown = Bool(allow_none=True)
    hide_drop_down = Alias('showDropDown')
    showInputMessage = Bool(allow_none=True)
    showErrorMessage = Bool(allow_none=True)
    allowBlank = Bool(allow_none=True)
    allow_blank = Alias('allowBlank')

    errorTitle = String(allow_none = True)
    error = String(allow_none = True)
    promptTitle = String(allow_none = True)
    prompt = String(allow_none = True)
    formula1 = NestedText(allow_none=True, expected_type=str)
    formula2 = NestedText(allow_none=True, expected_type=str)

    type = NoneSet(values=("whole", "decimal", "list", "date", "time",
                           "textLength", "custom"))
    errorStyle = NoneSet(values=("stop", "warning", "information"))
    imeMode = NoneSet(values=("noControl", "off", "on", "disabled",
                              "hiragana", "fullKatakana", "halfKatakana", "fullAlpha","halfAlpha",
                              "fullHangul", "halfHangul"))
    operator = NoneSet(values=("between", "notBetween", "equal", "notEqual",
                               "lessThan", "lessThanOrEqual", "greaterThan", "greaterThanOrEqual"))
    validation_type = Alias('type')

    def __init__(self,
                 type=None,
                 formula1=None,
                 formula2=None,
                 showErrorMessage=False,
                 showInputMessage=False,
                 showDropDown=False,
                 allowBlank=False,
                 sqref=(),
                 promptTitle=None,
                 errorStyle=None,
                 error=None,
                 prompt=None,
                 errorTitle=None,
                 imeMode=None,
                 operator=None,
                 allow_blank=None,
                 ):
        self.sqref = sqref
        self.showDropDown = showDropDown
        self.imeMode = imeMode
        self.operator = operator
        self.formula1 = formula1
        self.formula2 = formula2
        if allow_blank is not None:
            allowBlank = allow_blank
        self.allowBlank = allowBlank
        self.showErrorMessage = showErrorMessage
        self.showInputMessage = showInputMessage
        self.type = type
        self.promptTitle = promptTitle
        self.errorStyle = errorStyle
        self.error = error
        self.prompt = prompt
        self.errorTitle = errorTitle


    def add(self, cell):
        """Adds a cell or cell coordinate to this validator"""
        if hasattr(cell, "coordinate"):
            cell = cell.coordinate
        self.sqref += cell


    def __contains__(self, cell):
        if hasattr(cell, "coordinate"):
            cell = cell.coordinate
        return cell in self.sqref


class DataValidationList(Serialisable):

    tagname = "dataValidations"

    disablePrompts = Bool(allow_none=True)
    xWindow = Integer(allow_none=True)
    yWindow = Integer(allow_none=True)
    dataValidation = Sequence(expected_type=DataValidation)

    __elements__ = ('dataValidation',)
    __attrs__ = ('disablePrompts', 'xWindow', 'yWindow', 'count')

    def __init__(self,
                 disablePrompts=None,
                 xWindow=None,
                 yWindow=None,
                 count=None,
                 dataValidation=(),
                ):
        self.disablePrompts = disablePrompts
        self.xWindow = xWindow
        self.yWindow = yWindow
        self.dataValidation = dataValidation


    @property
    def count(self):
        return len(self)


    def __len__(self):
        return len(self.dataValidation)


    def append(self, dv):
        self.dataValidation.append(dv)


    def to_tree(self, tagname=None):
        """
        Need to skip validations that have no cell ranges
        """
        ranges = self.dataValidation # copy
        self.dataValidation = [r for r in self.dataValidation if bool(r.sqref)]
        xml = super().to_tree(tagname)
        self.dataValidation = ranges
        return xml

```

---

### File: `tmp\openpyxl_sdist\openpyxl-3.1.5\openpyxl\worksheet\dimensions.py`

```python
# Copyright (c) 2010-2024 openpyxl

from copy import copy

from openpyxl.compat import safe_string
from openpyxl.utils import (
    get_column_letter,
    get_column_interval,
    column_index_from_string,
    range_boundaries,
)
from openpyxl.utils.units import DEFAULT_COLUMN_WIDTH
from openpyxl.descriptors import (
    Integer,
    Float,
    Bool,
    Strict,
    String,
    Alias,
)
from openpyxl.descriptors.serialisable import Serialisable
from openpyxl.styles.styleable import StyleableObject
from openpyxl.utils.bound_dictionary import BoundDictionary
from openpyxl.xml.functions import Element


class Dimension(Strict, StyleableObject):
    """Information about the display properties of a row or column."""
    __fields__ = ('hidden',
                 'outlineLevel',
                 'collapsed',)

    index = Integer()
    hidden = Bool()
    outlineLevel = Integer(allow_none=True)
    outline_level = Alias('outlineLevel')
    collapsed = Bool()
    style = Alias('style_id')


    def __init__(self, index, hidden, outlineLevel,
                 collapsed, worksheet, visible=True, style=None):
        super().__init__(sheet=worksheet, style_array=style)
        self.index = index
        self.hidden = hidden
        self.outlineLevel = outlineLevel
        self.collapsed = collapsed


    def __iter__(self):
        for key in self.__fields__:
            value = getattr(self, key, None)
            if value:
                yield key, safe_string(value)


    def __copy__(self):
        cp = self.__new__(self.__class__)
        attrib = self.__dict__
        attrib['worksheet'] = self.parent
        cp.__init__(**attrib)
        cp._style = copy(self._style)
        return cp


    def __repr__(self):
        return f"<{self.__class__.__name__} Instance, Attributes={dict(self)}>"


class RowDimension(Dimension):
    """Information about the display properties of a row."""

    __fields__ = Dimension.__fields__ + ('ht', 'customFormat', 'customHeight', 's',
                                         'thickBot', 'thickTop')
    r = Alias('index')
    s = Alias('style_id')
    ht = Float(allow_none=True)
    height = Alias('ht')
    thickBot = Bool()
    thickTop = Bool()

    def __init__(self,
                 worksheet,
                 index=0,
                 ht=None,
                 customHeight=None, # do not write
                 s=None,
                 customFormat=None, # do not write
                 hidden=False,
                 outlineLevel=0,
                 outline_level=None,
                 collapsed=False,
                 visible=None,
                 height=None,
                 r=None,
                 spans=None,
                 thickBot=None,
                 thickTop=None,
                 **kw
                 ):
        if r is not None:
            index = r
        if height is not None:
            ht = height
        self.ht = ht
        if visible is not None:
            hidden = not visible
        if outline_level is not None:
            outlineLevel = outline_level
        self.thickBot = thickBot
        self.thickTop = thickTop
        super().__init__(index, hidden, outlineLevel,
                                           collapsed, worksheet, style=s)

    @property
    def customFormat(self):
        """Always true if there is a style for the row"""
        return self.has_style

    @property
    def customHeight(self):
        """Always true if there is a height for the row"""
        return self.ht is not None


class ColumnDimension(Dimension):
    """Information about the display properties of a column."""

    width = Float()
    bestFit = Bool()
    auto_size = Alias('bestFit')
    index = String()
    min = Integer(allow_none=True)
    max = Integer(allow_none=True)
    collapsed = Bool()

    __fields__ = Dimension.__fields__ + ('width', 'bestFit', 'customWidth', 'style',
                                         'min', 'max')

    def __init__(self,
                 worksheet,
                 index='A',
                 width=DEFAULT_COLUMN_WIDTH,
                 bestFit=False,
                 hidden=False,
                 outlineLevel=0,
                 outline_level=None,
                 collapsed=False,
                 style=None,
                 min=None,
                 max=None,
                 customWidth=False, # do not write
                 visible=None,
                 auto_size=None,):
        self.width = width
        self.min = min
        self.max = max
        if visible is not None:
            hidden = not visible
        if auto_size is not None:
            bestFit = auto_size
        self.bestFit = bestFit
        if outline_level is not None:
            outlineLevel = outline_level
        self.collapsed = collapsed
        super().__init__(index, hidden, outlineLevel,
                                              collapsed, worksheet, style=style)


    @property
    def customWidth(self):
        """Always true if there is a width for the column"""
        return bool(self.width)


    def reindex(self):
        """
        Set boundaries for column definition
        """
        if not all([self.min, self.max]):
            self.min = self.max = column_index_from_string(self.index)

    @property
    def range(self):
        """Return the range of cells actually covered"""
        return f"{get_column_letter(self.min)}:{get_column_letter(self.max)}"


    def to_tree(self):
        attrs = dict(self)
        if attrs.keys() != {'min', 'max'}:
            return Element("col", **attrs)


class DimensionHolder(BoundDictionary):
    """
    Allow columns to be grouped
    """

    def __init__(self, worksheet, reference="index", default_factory=None):
        self.worksheet = worksheet
        self.max_outline = None
        self.default_factory = default_factory
        super().__init__(reference, default_factory)


    def group(self, start, end=None, outline_level=1, hidden=False):
        """allow grouping a range of consecutive rows or columns together

        :param start: first row or column to be grouped (mandatory)
        :param end: last row or column to be grouped (optional, default to start)
        :param outline_level: outline level
        :param hidden: should the group be hidden on workbook open or not
        """
        if end is None:
            end = start

        if isinstance(self.default_factory(), ColumnDimension):
            new_dim = self[start]
            new_dim.outline_level = outline_level
            new_dim.hidden = hidden
            work_sequence = get_column_interval(start, end)[1:]
            for column_letter in work_sequence:
                if column_letter in self:
                    del self[column_letter]
            new_dim.min, new_dim.max = map(column_index_from_string, (start, end))
        elif isinstance(self.default_factory(), RowDimension):
            for el in range(start, end + 1):
                new_dim = self.worksheet.row_dimensions[el]
                new_dim.outline_level = outline_level
                new_dim.hidden = hidden


    def to_tree(self):

        def sorter(value):
            value.reindex()
            return value.min

        el = Element('cols')
        outlines = set()

        for col in sorted(self.values(), key=sorter):
            obj = col.to_tree()
            if obj is not None:
                outlines.add(col.outlineLevel)
                el.append(obj)

        if outlines:
            self.max_outline = max(outlines)

        if len(el):
            return el # must have at least one child


class SheetFormatProperties(Serialisable):

    tagname = "sheetFormatPr"

    baseColWidth = Integer(allow_none=True)
    defaultColWidth = Float(allow_none=True)
    defaultRowHeight = Float()
    customHeight = Bool(allow_none=True)
    zeroHeight = Bool(allow_none=True)
    thickTop = Bool(allow_none=True)
    thickBottom = Bool(allow_none=True)
    outlineLevelRow = Integer(allow_none=True)
    outlineLevelCol = Integer(allow_none=True)

    def __init__(self,
                 baseColWidth=8, #according to spec
                 defaultColWidth=None,
                 defaultRowHeight=15,
                 customHeight=None,
                 zeroHeight=None,
                 thickTop=None,
                 thickBottom=None,
                 outlineLevelRow=None,
                 outlineLevelCol=None,
                ):
        self.baseColWidth = baseColWidth
        self.defaultColWidth = defaultColWidth
        self.defaultRowHeight = defaultRowHeight
        self.customHeight = customHeight
        self.zeroHeight = zeroHeight
        self.thickTop = thickTop
        self.thickBottom = thickBottom
        self.outlineLevelRow = outlineLevelRow
        self.outlineLevelCol = outlineLevelCol


class SheetDimension(Serialisable):

    tagname = "dimension"

    ref = String()

    def __init__(self,
                 ref=None,
                ):
        self.ref = ref


    @property
    def boundaries(self):
        return range_boundaries(self.ref)

```

---

### File: `tmp\openpyxl_sdist\openpyxl-3.1.5\openpyxl\worksheet\drawing.py`

```python
# Copyright (c) 2010-2024 openpyxl

from openpyxl.descriptors.serialisable import Serialisable
from openpyxl.descriptors.excel import Relation


class Drawing(Serialisable):

    tagname = "drawing"

    id = Relation()

    def __init__(self, id=None):
        self.id = id

```

---

### File: `tmp\openpyxl_sdist\openpyxl-3.1.5\openpyxl\worksheet\errors.py`

```python
#Autogenerated schema
from openpyxl.descriptors.serialisable import Serialisable
from openpyxl.descriptors import (
    Typed,
    String,
    Bool,
    Sequence,
)
from openpyxl.descriptors.excel import CellRange


class Extension(Serialisable):

    tagname = "extension"

    uri = String(allow_none=True)

    def __init__(self,
                 uri=None,
                ):
        self.uri = uri


class ExtensionList(Serialisable):

    tagname = "extensionList"

    # uses element group EG_ExtensionList
    ext = Sequence(expected_type=Extension)

    __elements__ = ('ext',)

    def __init__(self,
                 ext=(),
                ):
        self.ext = ext


class IgnoredError(Serialisable):

    tagname = "ignoredError"

    sqref = CellRange
    evalError = Bool(allow_none=True)
    twoDigitTextYear = Bool(allow_none=True)
    numberStoredAsText = Bool(allow_none=True)
    formula = Bool(allow_none=True)
    formulaRange = Bool(allow_none=True)
    unlockedFormula = Bool(allow_none=True)
    emptyCellReference = Bool(allow_none=True)
    listDataValidation = Bool(allow_none=True)
    calculatedColumn = Bool(allow_none=True)

    def __init__(self,
                 sqref=None,
                 evalError=False,
                 twoDigitTextYear=False,
                 numberStoredAsText=False,
                 formula=False,
                 formulaRange=False,
                 unlockedFormula=False,
                 emptyCellReference=False,
                 listDataValidation=False,
                 calculatedColumn=False,
                ):
        self.sqref = sqref
        self.evalError = evalError
        self.twoDigitTextYear = twoDigitTextYear
        self.numberStoredAsText = numberStoredAsText
        self.formula = formula
        self.formulaRange = formulaRange
        self.unlockedFormula = unlockedFormula
        self.emptyCellReference = emptyCellReference
        self.listDataValidation = listDataValidation
        self.calculatedColumn = calculatedColumn


class IgnoredErrors(Serialisable):

    tagname = "ignoredErrors"

    ignoredError = Sequence(expected_type=IgnoredError)
    extLst = Typed(expected_type=ExtensionList, allow_none=True)

    __elements__ = ('ignoredError', 'extLst')

    def __init__(self,
                 ignoredError=(),
                 extLst=None,
                ):
        self.ignoredError = ignoredError
        self.extLst = extLst


```

---

### File: `tmp\openpyxl_sdist\openpyxl-3.1.5\openpyxl\worksheet\filters.py`

```python
# Copyright (c) 2010-2024 openpyxl

import re

from openpyxl.descriptors.serialisable import Serialisable
from openpyxl.descriptors import (
    Alias,
    Typed,
    Set,
    Float,
    DateTime,
    NoneSet,
    Bool,
    Integer,
    String,
    Sequence,
    MinMax,
)
from openpyxl.descriptors.excel import ExtensionList, CellRange
from openpyxl.descriptors.sequence import ValueSequence
from openpyxl.utils import absolute_coordinate


class SortCondition(Serialisable):

    tagname = "sortCondition"

    descending = Bool(allow_none=True)
    sortBy = NoneSet(values=(['value', 'cellColor', 'fontColor', 'icon']))
    ref = CellRange()
    customList = String(allow_none=True)
    dxfId = Integer(allow_none=True)
    iconSet = NoneSet(values=(['3Arrows', '3ArrowsGray', '3Flags',
                           '3TrafficLights1', '3TrafficLights2', '3Signs', '3Symbols', '3Symbols2',
                           '4Arrows', '4ArrowsGray', '4RedToBlack', '4Rating', '4TrafficLights',
                           '5Arrows', '5ArrowsGray', '5Rating', '5Quarters']))
    iconId = Integer(allow_none=True)

    def __init__(self,
                 ref=None,
                 descending=None,
                 sortBy=None,
                 customList=None,
                 dxfId=None,
                 iconSet=None,
                 iconId=None,
                ):
        self.descending = descending
        self.sortBy = sortBy
        self.ref = ref
        self.customList = customList
        self.dxfId = dxfId
        self.iconSet = iconSet
        self.iconId = iconId


class SortState(Serialisable):

    tagname = "sortState"

    columnSort = Bool(allow_none=True)
    caseSensitive = Bool(allow_none=True)
    sortMethod = NoneSet(values=(['stroke', 'pinYin']))
    ref = CellRange()
    sortCondition = Sequence(expected_type=SortCondition, allow_none=True)
    extLst = Typed(expected_type=ExtensionList, allow_none=True)

    __elements__ = ('sortCondition',)

    def __init__(self,
                 columnSort=None,
                 caseSensitive=None,
                 sortMethod=None,
                 ref=None,
                 sortCondition=(),
                 extLst=None,
                ):
        self.columnSort = columnSort
        self.caseSensitive = caseSensitive
        self.sortMethod = sortMethod
        self.ref = ref
        self.sortCondition = sortCondition


    def __bool__(self):
        return self.ref is not None



class IconFilter(Serialisable):

    tagname = "iconFilter"

    iconSet = Set(values=(['3Arrows', '3ArrowsGray', '3Flags',
                           '3TrafficLights1', '3TrafficLights2', '3Signs', '3Symbols', '3Symbols2',
                           '4Arrows', '4ArrowsGray', '4RedToBlack', '4Rating', '4TrafficLights',
                           '5Arrows', '5ArrowsGray', '5Rating', '5Quarters']))
    iconId = Integer(allow_none=True)

    def __init__(self,
                 iconSet=None,
                 iconId=None,
                ):
        self.iconSet = iconSet
        self.iconId = iconId


class ColorFilter(Serialisable):

    tagname = "colorFilter"

    dxfId = Integer(allow_none=True)
    cellColor = Bool(allow_none=True)

    def __init__(self,
                 dxfId=None,
                 cellColor=None,
                ):
        self.dxfId = dxfId
        self.cellColor = cellColor


class DynamicFilter(Serialisable):

    tagname = "dynamicFilter"

    type = Set(values=(['null', 'aboveAverage', 'belowAverage', 'tomorrow',
                        'today', 'yesterday', 'nextWeek', 'thisWeek', 'lastWeek', 'nextMonth',
                        'thisMonth', 'lastMonth', 'nextQuarter', 'thisQuarter', 'lastQuarter',
                        'nextYear', 'thisYear', 'lastYear', 'yearToDate', 'Q1', 'Q2', 'Q3', 'Q4',
                        'M1', 'M2', 'M3', 'M4', 'M5', 'M6', 'M7', 'M8', 'M9', 'M10', 'M11',
                        'M12']))
    val = Float(allow_none=True)
    valIso = DateTime(allow_none=True)
    maxVal = Float(allow_none=True)
    maxValIso = DateTime(allow_none=True)

    def __init__(self,
                 type=None,
                 val=None,
                 valIso=None,
                 maxVal=None,
                 maxValIso=None,
                ):
        self.type = type
        self.val = val
        self.valIso = valIso
        self.maxVal = maxVal
        self.maxValIso = maxValIso


class CustomFilter(Serialisable):

    tagname = "customFilter"

    val = String()
    operator = Set(values=['equal', 'lessThan', 'lessThanOrEqual',
                           'notEqual', 'greaterThanOrEqual', 'greaterThan'])

    def __init__(self, operator="equal", val=None):
        self.operator = operator
        self.val = val


    def _get_subtype(self):
        if self.val == " ":
            subtype = BlankFilter
        else:
            try:
                float(self.val)
                subtype = NumberFilter
            except ValueError:
                subtype = StringFilter
        return subtype


    def convert(self):
        """Convert to more specific filter"""
        typ = self._get_subtype()
        if typ in (BlankFilter, NumberFilter):
            return typ(**dict(self))

        operator, term = StringFilter._guess_operator(self.val)
        flt = StringFilter(operator, term)
        if self.operator == "notEqual":
            flt.exclude = True
        return flt


class BlankFilter(CustomFilter):
    """
    Exclude blanks
    """

    __attrs__ = ("operator", "val")

    def __init__(self, **kw):
        pass


    @property
    def operator(self):
        return "notEqual"


    @property
    def val(self):
        return " "


class NumberFilter(CustomFilter):


    operator = Set(values=
                   ['equal', 'lessThan', 'lessThanOrEqual',
                    'notEqual', 'greaterThanOrEqual', 'greaterThan'])
    val = Float()

    def __init__(self, operator="equal", val=None):
        self.operator = operator
        self.val = val


string_format_mapping = {
    "contains": "*{}*",
    "startswith": "{}*",
    "endswith": "*{}",
    "wildcard":  "{}",
}


class StringFilter(CustomFilter):

    operator = Set(values=['contains', 'startswith', 'endswith', 'wildcard']
                   )
    val = String()
    exclude = Bool()


    def __init__(self, operator="contains", val=None, exclude=False):
        self.operator = operator
        self.val = val
        self.exclude = exclude


    def _escape(self):
        """Escape wildcards ~, * ? when serialising"""
        if self.operator == "wildcard":
            return self.val
        return re.sub(r"~|\*|\?", r"~\g<0>", self.val)


    @staticmethod
    def _unescape(value):
        """
        Unescape value
        """
        return re.sub(r"~(?P<op>[~*?])", r"\g<op>", value)


    @staticmethod
    def _guess_operator(value):
        value = StringFilter._unescape(value)
        endswith = r"^(?P<endswith>\*)(?P<term>[^\*\?]*$)"
        startswith = r"^(?P<term>[^\*\?]*)(?P<startswith>\*)$"
        contains = r"^(?P<contains>\*)(?P<term>[^\*\?]*)\*$"
        d = {"wildcard": True, "term": value}
        for pat in [contains, startswith, endswith]:
            m = re.match(pat, value)
            if m:
                d = m.groupdict()

        term = d.pop("term")
        op = list(d)[0]
        return op, term


    def to_tree(self, tagname=None, idx=None, namespace=None):
        fmt = string_format_mapping[self.operator]
        op = self.exclude and "notEqual" or "equal"
        value = fmt.format(self._escape())
        flt = CustomFilter(op, value)
        return flt.to_tree(tagname, idx, namespace)


class CustomFilters(Serialisable):

    tagname = "customFilters"

    _and = Bool(allow_none=True)
    customFilter = Sequence(expected_type=CustomFilter) # min 1, max 2

    __elements__ = ('customFilter',)

    def __init__(self,
                 _and=None,
                 customFilter=(),
                ):
        self._and = _and
        self.customFilter = customFilter


class Top10(Serialisable):

    tagname = "top10"

    top = Bool(allow_none=True)
    percent = Bool(allow_none=True)
    val = Float()
    filterVal = Float(allow_none=True)

    def __init__(self,
                 top=None,
                 percent=None,
                 val=None,
                 filterVal=None,
                ):
        self.top = top
        self.percent = percent
        self.val = val
        self.filterVal = filterVal


class DateGroupItem(Serialisable):

    tagname = "dateGroupItem"

    year = Integer()
    month = MinMax(min=1, max=12, allow_none=True)
    day = MinMax(min=1, max=31, allow_none=True)
    hour = MinMax(min=0, max=23, allow_none=True)
    minute = MinMax(min=0, max=59, allow_none=True)
    second = Integer(min=0, max=59, allow_none=True)
    dateTimeGrouping = Set(values=(['year', 'month', 'day', 'hour', 'minute',
                                    'second']))

    def __init__(self,
                 year=None,
                 month=None,
                 day=None,
                 hour=None,
                 minute=None,
                 second=None,
                 dateTimeGrouping=None,
                ):
        self.year = year
        self.month = month
        self.day = day
        self.hour = hour
        self.minute = minute
        self.second = second
        self.dateTimeGrouping = dateTimeGrouping


class Filters(Serialisable):

    tagname = "filters"

    blank = Bool(allow_none=True)
    calendarType = NoneSet(values=["gregorian","gregorianUs",
                                   "gregorianMeFrench","gregorianArabic", "hijri","hebrew",
                                   "taiwan","japan", "thai","korea",
                                   "saka","gregorianXlitEnglish","gregorianXlitFrench"])
    filter = ValueSequence(expected_type=str)
    dateGroupItem = Sequence(expected_type=DateGroupItem, allow_none=True)

    __elements__ = ('filter', 'dateGroupItem')

    def __init__(self,
                 blank=None,
                 calendarType=None,
                 filter=(),
                 dateGroupItem=(),
                ):
        self.blank = blank
        self.calendarType = calendarType
        self.filter = filter
        self.dateGroupItem = dateGroupItem


class FilterColumn(Serialisable):

    tagname = "filterColumn"

    colId = Integer()
    col_id = Alias('colId')
    hiddenButton = Bool(allow_none=True)
    showButton = Bool(allow_none=True)
    # some elements are choice
    filters = Typed(expected_type=Filters, allow_none=True)
    top10 = Typed(expected_type=Top10, allow_none=True)
    customFilters = Typed(expected_type=CustomFilters, allow_none=True)
    dynamicFilter = Typed(expected_type=DynamicFilter, allow_none=True)
    colorFilter = Typed(expected_type=ColorFilter, allow_none=True)
    iconFilter = Typed(expected_type=IconFilter, allow_none=True)
    extLst = Typed(expected_type=ExtensionList, allow_none=True)

    __elements__ = ('filters', 'top10', 'customFilters', 'dynamicFilter',
                    'colorFilter', 'iconFilter')

    def __init__(self,
                 colId=None,
                 hiddenButton=False,
                 showButton=True,
                 filters=None,
                 top10=None,
                 customFilters=None,
                 dynamicFilter=None,
                 colorFilter=None,
                 iconFilter=None,
                 extLst=None,
                 blank=None,
                 vals=None,
                ):
        self.colId = colId
        self.hiddenButton = hiddenButton
        self.showButton = showButton
        self.filters = filters
        self.top10 = top10
        self.customFilters = customFilters
        self.dynamicFilter = dynamicFilter
        self.colorFilter = colorFilter
        self.iconFilter = iconFilter
        if blank is not None and self.filters:
            self.filters.blank = blank
        if vals is not None and self.filters:
            self.filters.filter = vals


class AutoFilter(Serialisable):

    tagname = "autoFilter"

    ref = CellRange()
    filterColumn = Sequence(expected_type=FilterColumn, allow_none=True)
    sortState = Typed(expected_type=SortState, allow_none=True)
    extLst = Typed(expected_type=ExtensionList, allow_none=True)

    __elements__ = ('filterColumn', 'sortState')

    def __init__(self,
                 ref=None,
                 filterColumn=(),
                 sortState=None,
                 extLst=None,
                ):
        self.ref = ref
        self.filterColumn = filterColumn
        self.sortState = sortState


    def __bool__(self):
        return self.ref is not None


    def __str__(self):
        return absolute_coordinate(self.ref)


    def add_filter_column(self, col_id, vals, blank=False):
        """
        Add row filter for specified column.

        :param col_id: Zero-origin column id. 0 means first column.
        :type  col_id: int
        :param vals: Value list to show.
        :type  vals: str[]
        :param blank: Show rows that have blank cell if True (default=``False``)
        :type  blank: bool
        """
        self.filterColumn.append(FilterColumn(colId=col_id, filters=Filters(blank=blank, filter=vals)))


    def add_sort_condition(self, ref, descending=False):
        """
        Add sort condition for cpecified range of cells.

        :param ref: range of the cells (e.g. 'A2:A150')
        :type  ref: string, is the same as that of the filter
        :param descending: Descending sort order (default=``False``)
        :type  descending: bool
        """
        cond = SortCondition(ref, descending)
        if self.sortState is None:
            self.sortState = SortState(ref=self.ref)
        self.sortState.sortCondition.append(cond)

```

---

### File: `tmp\openpyxl_sdist\openpyxl-3.1.5\openpyxl\worksheet\formula.py`

```python
# Copyright (c) 2010-2024 openpyxl

from openpyxl.compat import safe_string

class DataTableFormula:


    t = "dataTable"

    def __init__(self,
                 ref,
                 ca=False,
                 dt2D=False,
                 dtr=False,
                 r1=None,
                 r2=None,
                 del1=False,
                 del2=False,
                 **kw):
        self.ref = ref
        self.ca = ca
        self.dt2D = dt2D
        self.dtr = dtr
        self.r1 = r1
        self.r2 = r2
        self.del1 = del1
        self.del2 = del2


    def __iter__(self):
        for k in ["t", "ref", "dt2D", "dtr", "r1", "r2", "del1", "del2", "ca"]:
            v = getattr(self, k)
            if v:
                yield k, safe_string(v)


class ArrayFormula:

    t = "array"


    def __init__(self, ref, text=None):
        self.ref = ref
        self.text = text


    def __iter__(self):
        for k in ["t", "ref"]:
            v = getattr(self, k)
            if v:
                yield k, safe_string(v)

```

---

### File: `tmp\openpyxl_sdist\openpyxl-3.1.5\openpyxl\worksheet\header_footer.py`

```python
# Copyright (c) 2010-2024 openpyxl

# Simplified implementation of headers and footers: let worksheets have separate items

import re
from warnings import warn

from openpyxl.descriptors import (
    Alias,
    Bool,
    Strict,
    String,
    Integer,
    MatchPattern,
    Typed,
)
from openpyxl.descriptors.serialisable import Serialisable


from openpyxl.xml.functions import Element
from openpyxl.utils.escape import escape, unescape


FONT_PATTERN = '&"(?P<font>.+)"'
COLOR_PATTERN  = "&K(?P<color>[A-F0-9]{6})"
SIZE_REGEX = r"&(?P<size>\d+\s?)"
FORMAT_REGEX = re.compile("{0}|{1}|{2}".format(FONT_PATTERN, COLOR_PATTERN,
                                               SIZE_REGEX)
                          )

def _split_string(text):
    """
    Split the combined (decoded) string into left, center and right parts

    # See http://stackoverflow.com/questions/27711175/regex-with-multiple-optional-groups for discussion
    """

    ITEM_REGEX = re.compile("""
    (&L(?P<left>.+?))?
    (&C(?P<center>.+?))?
    (&R(?P<right>.+?))?
    $""", re.VERBOSE | re.DOTALL)

    m = ITEM_REGEX.match(text)
    try:
        parts = m.groupdict()
    except AttributeError:
        warn("""Cannot parse header or footer so it will be ignored""")
        parts = {'left':'', 'right':'', 'center':''}
    return parts


class _HeaderFooterPart(Strict):

    """
    Individual left/center/right header/footer part

    Do not use directly.

    Header & Footer ampersand codes:

    * &A   Inserts the worksheet name
    * &B   Toggles bold
    * &D or &[Date]   Inserts the current date
    * &E   Toggles double-underline
    * &F or &[File]   Inserts the workbook name
    * &I   Toggles italic
    * &N or &[Pages]   Inserts the total page count
    * &S   Toggles strikethrough
    * &T   Inserts the current time
    * &[Tab]   Inserts the worksheet name
    * &U   Toggles underline
    * &X   Toggles superscript
    * &Y   Toggles subscript
    * &P or &[Page]   Inserts the current page number
    * &P+n   Inserts the page number incremented by n
    * &P-n   Inserts the page number decremented by n
    * &[Path]   Inserts the workbook path
    * &&   Escapes the ampersand character
    * &"fontname"   Selects the named font
    * &nn   Selects the specified 2-digit font point size

    Colours are in RGB Hex
    """

    text = String(allow_none=True)
    font = String(allow_none=True)
    size = Integer(allow_none=True)
    RGB = ("^[A-Fa-f0-9]{6}$")
    color = MatchPattern(allow_none=True, pattern=RGB)


    def __init__(self, text=None, font=None, size=None, color=None):
        self.text = text
        self.font = font
        self.size = size
        self.color = color


    def __str__(self):
        """
        Convert to Excel HeaderFooter miniformat minus position
        """
        fmt = []
        if self.font:
            fmt.append(u'&"{0}"'.format(self.font))
        if self.size:
            fmt.append("&{0} ".format(self.size))
        if self.color:
            fmt.append("&K{0}".format(self.color))
        return u"".join(fmt + [self.text])

    def __bool__(self):
        return bool(self.text)



    @classmethod
    def from_str(cls, text):
        """
        Convert from miniformat to object
        """
        keys = ('font', 'color', 'size')
        kw = dict((k, v) for match in FORMAT_REGEX.findall(text)
                  for k, v in zip(keys, match) if v)

        kw['text'] = FORMAT_REGEX.sub('', text)

        return cls(**kw)


class HeaderFooterItem(Strict):
    """
    Header or footer item

    """

    left = Typed(expected_type=_HeaderFooterPart)
    center = Typed(expected_type=_HeaderFooterPart)
    centre = Alias("center")
    right = Typed(expected_type=_HeaderFooterPart)

    __keys = ('L', 'C', 'R')


    def __init__(self, left=None, right=None, center=None):
        if left is None:
            left = _HeaderFooterPart()
        self.left = left
        if center is None:
            center = _HeaderFooterPart()
        self.center = center
        if right is None:
            right = _HeaderFooterPart()
        self.right = right


    def __str__(self):
        """
        Pack parts into a single string
        """
        TRANSFORM = {'&[Tab]': '&A', '&[Pages]': '&N', '&[Date]': '&D',
                     '&[Path]': '&Z', '&[Page]': '&P', '&[Time]': '&T', '&[File]': '&F',
                     '&[Picture]': '&G'}

        # escape keys and create regex
        SUBS_REGEX = re.compile("|".join(["({0})".format(re.escape(k))
                                          for k in TRANSFORM]))

        def replace(match):
            """
            Callback for re.sub
            Replace expanded control with mini-format equivalent
            """
            sub = match.group(0)
            return TRANSFORM[sub]

        txt = []
        for key, part in zip(
            self.__keys, [self.left, self.center, self.right]):
            if part.text is not None:
                txt.append(u"&{0}{1}".format(key, str(part)))
        txt = "".join(txt)
        txt = SUBS_REGEX.sub(replace, txt)
        return escape(txt)


    def __bool__(self):
        return any([self.left, self.center, self.right])



    def to_tree(self, tagname):
        """
        Return as XML node
        """
        el = Element(tagname)
        el.text = str(self)
        return el


    @classmethod
    def from_tree(cls, node):
        if node.text:
            text = unescape(node.text)
            parts = _split_string(text)
            for k, v in parts.items():
                if v is not None:
                    parts[k] = _HeaderFooterPart.from_str(v)
            self = cls(**parts)
            return self


class HeaderFooter(Serialisable):

    tagname = "headerFooter"

    differentOddEven = Bool(allow_none=True)
    differentFirst = Bool(allow_none=True)
    scaleWithDoc = Bool(allow_none=True)
    alignWithMargins = Bool(allow_none=True)
    oddHeader = Typed(expected_type=HeaderFooterItem, allow_none=True)
    oddFooter = Typed(expected_type=HeaderFooterItem, allow_none=True)
    evenHeader = Typed(expected_type=HeaderFooterItem, allow_none=True)
    evenFooter = Typed(expected_type=HeaderFooterItem, allow_none=True)
    firstHeader = Typed(expected_type=HeaderFooterItem, allow_none=True)
    firstFooter = Typed(expected_type=HeaderFooterItem, allow_none=True)

    __elements__ = ("oddHeader", "oddFooter", "evenHeader", "evenFooter", "firstHeader", "firstFooter")

    def __init__(self,
                 differentOddEven=None,
                 differentFirst=None,
                 scaleWithDoc=None,
                 alignWithMargins=None,
                 oddHeader=None,
                 oddFooter=None,
                 evenHeader=None,
                 evenFooter=None,
                 firstHeader=None,
                 firstFooter=None,
                ):
        self.differentOddEven = differentOddEven
        self.differentFirst = differentFirst
        self.scaleWithDoc = scaleWithDoc
        self.alignWithMargins = alignWithMargins
        if oddHeader is None:
            oddHeader = HeaderFooterItem()
        self.oddHeader = oddHeader
        if oddFooter is None:
            oddFooter = HeaderFooterItem()
        self.oddFooter = oddFooter
        if evenHeader is None:
            evenHeader = HeaderFooterItem()
        self.evenHeader = evenHeader
        if evenFooter is None:
            evenFooter = HeaderFooterItem()
        self.evenFooter = evenFooter
        if firstHeader is None:
            firstHeader = HeaderFooterItem()
        self.firstHeader = firstHeader
        if firstFooter is None:
            firstFooter = HeaderFooterItem()
        self.firstFooter = firstFooter


    def __bool__(self):
        parts = [getattr(self, attr) for attr in self.__attrs__ + self.__elements__]
        return any(parts)


```

---

### File: `tmp\openpyxl_sdist\openpyxl-3.1.5\openpyxl\worksheet\hyperlink.py`

```python
from openpyxl.descriptors.serialisable import Serialisable
from openpyxl.descriptors import (
    String,
    Sequence,
)
from openpyxl.descriptors.excel import Relation


class Hyperlink(Serialisable):

    tagname = "hyperlink"

    ref = String()
    location = String(allow_none=True)
    tooltip = String(allow_none=True)
    display = String(allow_none=True)
    id = Relation()
    target = String(allow_none=True)

    __attrs__ = ("ref", "location", "tooltip", "display", "id")

    def __init__(self,
                 ref=None,
                 location=None,
                 tooltip=None,
                 display=None,
                 id=None,
                 target=None,
                ):
        self.ref = ref
        self.location = location
        self.tooltip = tooltip
        self.display = display
        self.id = id
        self.target = target


class HyperlinkList(Serialisable):

    tagname = "hyperlinks"

    __expected_type = Hyperlink
    hyperlink = Sequence(expected_type=__expected_type)

    def __init__(self, hyperlink=()):
        self.hyperlink = hyperlink

```

---

### File: `tmp\openpyxl_sdist\openpyxl-3.1.5\openpyxl\worksheet\merge.py`

```python
# Copyright (c) 2010-2024 openpyxl

import copy

from openpyxl.descriptors.serialisable import Serialisable
from openpyxl.descriptors import (
    Integer,
    Sequence,
)

from openpyxl.cell.cell import MergedCell
from openpyxl.styles.borders import Border

from .cell_range import CellRange


class MergeCell(CellRange):

    tagname = "mergeCell"
    ref = CellRange.coord

    __attrs__ = ("ref",)


    def __init__(self,
                 ref=None,
                ):
        super().__init__(ref)


    def __copy__(self):
        return self.__class__(self.ref)


class MergeCells(Serialisable):

    tagname = "mergeCells"

    count = Integer(allow_none=True)
    mergeCell = Sequence(expected_type=MergeCell, )

    __elements__ = ('mergeCell',)
    __attrs__ = ('count',)

    def __init__(self,
                 count=None,
                 mergeCell=(),
                ):
        self.mergeCell = mergeCell


    @property
    def count(self):
        return len(self.mergeCell)


class MergedCellRange(CellRange):

    """
    MergedCellRange stores the border information of a merged cell in the top
    left cell of the merged cell.
    The remaining cells in the merged cell are stored as MergedCell objects and
    get their border information from the upper left cell.
    """

    def __init__(self, worksheet, coord):
        self.ws = worksheet
        super().__init__(range_string=coord)
        self.start_cell = None
        self._get_borders()


    def _get_borders(self):
        """
        If the upper left cell of the merged cell does not yet exist, it is
        created.
        The upper left cell gets the border information of the bottom and right
        border from the bottom right cell of the merged cell, if available.
        """

        # Top-left cell.
        self.start_cell = self.ws._cells.get((self.min_row, self.min_col))
        if self.start_cell is None:
            self.start_cell = self.ws.cell(row=self.min_row, column=self.min_col)

        # Bottom-right cell
        end_cell = self.ws._cells.get((self.max_row, self.max_col))
        if end_cell is not None:
            self.start_cell.border += Border(right=end_cell.border.right,
                                             bottom=end_cell.border.bottom)


    def format(self):
        """
        Each cell of the merged cell is created as MergedCell if it does not
        already exist.

        The MergedCells at the edge of the merged cell gets its borders from
        the upper left cell.

         - The top MergedCells get the top border from the top left cell.
         - The bottom MergedCells get the bottom border from the top left cell.
         - The left MergedCells get the left border from the top left cell.
         - The right MergedCells get the right border from the top left cell.
        """

        names = ['top', 'left', 'right', 'bottom']

        for name in names:
            side = getattr(self.start_cell.border, name)
            if side and side.style is None:
                continue # don't need to do anything if there is no border style
            border = Border(**{name:side})
            for coord in getattr(self, name):
                cell = self.ws._cells.get(coord)
                if cell is None:
                    row, col = coord
                    cell = MergedCell(self.ws, row=row, column=col)
                    self.ws._cells[(cell.row, cell.column)] = cell
                cell.border += border

        protected = self.start_cell.protection is not None
        if protected:
            protection = copy.copy(self.start_cell.protection)
        for coord in self.cells:
            cell = self.ws._cells.get(coord)
            if cell is None:
                row, col = coord
                cell = MergedCell(self.ws, row=row, column=col)
                self.ws._cells[(cell.row, cell.column)] = cell

            if protected:
                cell.protection = protection


    def __contains__(self, coord):
        return coord in CellRange(self.coord)


    def __copy__(self):
        return self.__class__(self.ws, self.coord)

```

---

### File: `tmp\openpyxl_sdist\openpyxl-3.1.5\openpyxl\worksheet\ole.py`

```python
# Copyright (c) 2010-2024 openpyxl

from openpyxl.descriptors.serialisable import Serialisable
from openpyxl.descriptors import (
    Typed,
    Integer,
    String,
    Set,
    Bool,
    Sequence,
)

from openpyxl.drawing.spreadsheet_drawing import AnchorMarker
from openpyxl.xml.constants import SHEET_DRAWING_NS


class ObjectAnchor(Serialisable):

    tagname = "anchor"

    _from = Typed(expected_type=AnchorMarker, namespace=SHEET_DRAWING_NS)
    to = Typed(expected_type=AnchorMarker, namespace=SHEET_DRAWING_NS)
    moveWithCells = Bool(allow_none=True)
    sizeWithCells = Bool(allow_none=True)
    z_order = Integer(allow_none=True, hyphenated=True)


    def __init__(self,
                 _from=None,
                 to=None,
                 moveWithCells=False,
                 sizeWithCells=False,
                 z_order=None,
                ):
        self._from = _from
        self.to = to
        self.moveWithCells = moveWithCells
        self.sizeWithCells = sizeWithCells
        self.z_order = z_order


class ObjectPr(Serialisable):

    tagname = "objectPr"

    anchor = Typed(expected_type=ObjectAnchor, )
    locked = Bool(allow_none=True)
    defaultSize = Bool(allow_none=True)
    _print = Bool(allow_none=True)
    disabled = Bool(allow_none=True)
    uiObject = Bool(allow_none=True)
    autoFill = Bool(allow_none=True)
    autoLine = Bool(allow_none=True)
    autoPict = Bool(allow_none=True)
    macro = String()
    altText = String(allow_none=True)
    dde = Bool(allow_none=True)

    __elements__ = ('anchor',)

    def __init__(self,
                 anchor=None,
                 locked=True,
                 defaultSize=True,
                 _print=True,
                 disabled=False,
                 uiObject=False,
                 autoFill=True,
                 autoLine=True,
                 autoPict=True,
                 macro=None,
                 altText=None,
                 dde=False,
                ):
        self.anchor = anchor
        self.locked = locked
        self.defaultSize = defaultSize
        self._print = _print
        self.disabled = disabled
        self.uiObject = uiObject
        self.autoFill = autoFill
        self.autoLine = autoLine
        self.autoPict = autoPict
        self.macro = macro
        self.altText = altText
        self.dde = dde


class OleObject(Serialisable):

    tagname = "oleObject"

    objectPr = Typed(expected_type=ObjectPr, allow_none=True)
    progId = String(allow_none=True)
    dvAspect = Set(values=(['DVASPECT_CONTENT', 'DVASPECT_ICON']))
    link = String(allow_none=True)
    oleUpdate = Set(values=(['OLEUPDATE_ALWAYS', 'OLEUPDATE_ONCALL']))
    autoLoad = Bool(allow_none=True)
    shapeId = Integer()

    __elements__ = ('objectPr',)

    def __init__(self,
                 objectPr=None,
                 progId=None,
                 dvAspect='DVASPECT_CONTENT',
                 link=None,
                 oleUpdate=None,
                 autoLoad=False,
                 shapeId=None,
                ):
        self.objectPr = objectPr
        self.progId = progId
        self.dvAspect = dvAspect
        self.link = link
        self.oleUpdate = oleUpdate
        self.autoLoad = autoLoad
        self.shapeId = shapeId


class OleObjects(Serialisable):

    tagname = "oleObjects"

    oleObject = Sequence(expected_type=OleObject)

    __elements__ = ('oleObject',)

    def __init__(self,
                 oleObject=(),
                ):
        self.oleObject = oleObject


```

---

### File: `tmp\openpyxl_sdist\openpyxl-3.1.5\openpyxl\worksheet\page.py`

```python
# Copyright (c) 2010-2024 openpyxl

from openpyxl.descriptors.serialisable import Serialisable
from openpyxl.descriptors import (
    Float,
    Bool,
    Integer,
    NoneSet,
    )
from openpyxl.descriptors.excel import UniversalMeasure, Relation


class PrintPageSetup(Serialisable):
    """ Worksheet print page setup """

    tagname = "pageSetup"

    orientation = NoneSet(values=("default", "portrait", "landscape"))
    paperSize = Integer(allow_none=True)
    scale = Integer(allow_none=True)
    fitToHeight = Integer(allow_none=True)
    fitToWidth = Integer(allow_none=True)
    firstPageNumber = Integer(allow_none=True)
    useFirstPageNumber = Bool(allow_none=True)
    paperHeight = UniversalMeasure(allow_none=True)
    paperWidth = UniversalMeasure(allow_none=True)
    pageOrder = NoneSet(values=("downThenOver", "overThenDown"))
    usePrinterDefaults = Bool(allow_none=True)
    blackAndWhite = Bool(allow_none=True)
    draft = Bool(allow_none=True)
    cellComments = NoneSet(values=("asDisplayed", "atEnd"))
    errors = NoneSet(values=("displayed", "blank", "dash", "NA"))
    horizontalDpi = Integer(allow_none=True)
    verticalDpi = Integer(allow_none=True)
    copies = Integer(allow_none=True)
    id = Relation()


    def __init__(self,
                 worksheet=None,
                 orientation=None,
                 paperSize=None,
                 scale=None,
                 fitToHeight=None,
                 fitToWidth=None,
                 firstPageNumber=None,
                 useFirstPageNumber=None,
                 paperHeight=None,
                 paperWidth=None,
                 pageOrder=None,
                 usePrinterDefaults=None,
                 blackAndWhite=None,
                 draft=None,
                 cellComments=None,
                 errors=None,
                 horizontalDpi=None,
                 verticalDpi=None,
                 copies=None,
                 id=None):
        self._parent = worksheet
        self.orientation = orientation
        self.paperSize = paperSize
        self.scale = scale
        self.fitToHeight = fitToHeight
        self.fitToWidth = fitToWidth
        self.firstPageNumber = firstPageNumber
        self.useFirstPageNumber = useFirstPageNumber
        self.paperHeight = paperHeight
        self.paperWidth = paperWidth
        self.pageOrder = pageOrder
        self.usePrinterDefaults = usePrinterDefaults
        self.blackAndWhite = blackAndWhite
        self.draft = draft
        self.cellComments = cellComments
        self.errors = errors
        self.horizontalDpi = horizontalDpi
        self.verticalDpi = verticalDpi
        self.copies = copies
        self.id = id


    def __bool__(self):
        return bool(dict(self))




    @property
    def sheet_properties(self):
        """
        Proxy property
        """
        return self._parent.sheet_properties.pageSetUpPr


    @property
    def fitToPage(self):
        return self.sheet_properties.fitToPage


    @fitToPage.setter
    def fitToPage(self, value):
        self.sheet_properties.fitToPage = value


    @property
    def autoPageBreaks(self):
        return self.sheet_properties.autoPageBreaks


    @autoPageBreaks.setter
    def autoPageBreaks(self, value):
        self.sheet_properties.autoPageBreaks = value


    @classmethod
    def from_tree(cls, node):
        self = super().from_tree(node)
        self.id = None # strip link to binary settings
        return self


class PrintOptions(Serialisable):
    """ Worksheet print options """

    tagname = "printOptions"
    horizontalCentered = Bool(allow_none=True)
    verticalCentered = Bool(allow_none=True)
    headings = Bool(allow_none=True)
    gridLines = Bool(allow_none=True)
    gridLinesSet = Bool(allow_none=True)

    def __init__(self, horizontalCentered=None,
                 verticalCentered=None,
                 headings=None,
                 gridLines=None,
                 gridLinesSet=None,
                 ):
        self.horizontalCentered = horizontalCentered
        self.verticalCentered = verticalCentered
        self.headings = headings
        self.gridLines = gridLines
        self.gridLinesSet = gridLinesSet


    def __bool__(self):
        return bool(dict(self))


class PageMargins(Serialisable):
    """
    Information about page margins for view/print layouts.
    Standard values (in inches)
    left, right = 0.75
    top, bottom = 1
    header, footer = 0.5
    """
    tagname = "pageMargins"

    left = Float()
    right = Float()
    top = Float()
    bottom = Float()
    header = Float()
    footer = Float()

    def __init__(self, left=0.75, right=0.75, top=1, bottom=1, header=0.5,
                 footer=0.5):
        self.left = left
        self.right = right
        self.top = top
        self.bottom = bottom
        self.header = header
        self.footer = footer

```

---

### File: `tmp\openpyxl_sdist\openpyxl-3.1.5\openpyxl\worksheet\pagebreak.py`

```python
# Copyright (c) 2010-2024 openpyxl

from openpyxl.descriptors.serialisable import Serialisable
from openpyxl.descriptors import (
    Integer,
    Bool,
    Sequence,
)


class Break(Serialisable):

    tagname = "brk"

    id = Integer(allow_none=True)
    min = Integer(allow_none=True)
    max = Integer(allow_none=True)
    man = Bool(allow_none=True)
    pt = Bool(allow_none=True)

    def __init__(self,
                 id=0,
                 min=0,
                 max=16383,
                 man=True,
                 pt=None,
                ):
        self.id = id
        self.min = min
        self.max = max
        self.man = man
        self.pt = pt


class RowBreak(Serialisable):

    tagname = "rowBreaks"

    count = Integer(allow_none=True)
    manualBreakCount = Integer(allow_none=True)
    brk = Sequence(expected_type=Break, allow_none=True)

    __elements__ = ('brk',)
    __attrs__ = ("count", "manualBreakCount",)

    def __init__(self,
                 count=None,
                 manualBreakCount=None,
                 brk=(),
                ):
        self.brk = brk


    def __bool__(self):
        return len(self.brk) > 0


    def __len__(self):
        return len(self.brk)


    @property
    def count(self):
        return len(self)


    @property
    def manualBreakCount(self):
        return len(self)


    def append(self, brk=None):
        """
        Add a page break
        """
        vals = list(self.brk)
        if not isinstance(brk, Break):
            brk = Break(id=self.count+1)
        vals.append(brk)
        self.brk = vals


PageBreak = RowBreak


class ColBreak(RowBreak):

    tagname = "colBreaks"

    count = RowBreak.count
    manualBreakCount = RowBreak.manualBreakCount
    brk = RowBreak.brk

    __attrs__ = RowBreak.__attrs__

```

---

### File: `tmp\openpyxl_sdist\openpyxl-3.1.5\openpyxl\worksheet\picture.py`

```python
#Autogenerated schema
from openpyxl.descriptors.serialisable import Serialisable

# same as related

class SheetBackgroundPicture(Serialisable):

    tagname = "sheetBackgroundPicture"

```

---

### File: `tmp\openpyxl_sdist\openpyxl-3.1.5\openpyxl\worksheet\print_settings.py`

```python
# Copyright (c) 2010-2024 openpyxl

import re
from openpyxl.descriptors import (
    Strict,
    Integer,
    String,
    Typed,
)
from openpyxl.utils import quote_sheetname, absolute_coordinate
from openpyxl.utils.cell import SHEET_TITLE, SHEETRANGE_RE, RANGE_EXPR

from .cell_range import MultiCellRange

COL_RANGE = r"""(?P<cols>[$]?(?P<min_col>[a-zA-Z]{1,3}):[$]?(?P<max_col>[a-zA-Z]{1,3}))"""
COL_RANGE_RE = re.compile(COL_RANGE)
ROW_RANGE = r"""(?P<rows>[$]?(?P<min_row>\d+):[$]?(?P<max_row>\d+))"""
ROW_RANGE_RE = re.compile(ROW_RANGE)
TITLES_REGEX = re.compile("""{0}{1}?,?{2}?,?""".format(SHEET_TITLE, ROW_RANGE, COL_RANGE),
                          re.VERBOSE)
PRINT_AREA_RE = re.compile(f"({SHEET_TITLE})?(?P<cells>{RANGE_EXPR})", re.VERBOSE)

class ColRange(Strict):
    """
    Represent a range of at least one column
    """

    min_col = String()
    max_col = String()


    def __init__(self, range_string=None, min_col=None, max_col=None):
        if range_string is not None:
            match = COL_RANGE_RE.match(range_string)
            if not match:
                raise ValueError(f"{range_string} is not a valid column range")
            min_col, max_col = match.groups()[1:]
        self.min_col = min_col
        self.max_col = max_col


    def __eq__(self, other):
        if isinstance(other, self.__class__):
            return (self.min_col == other.min_col
                    and
                    self.max_col == other.max_col)
        elif isinstance(other, str):
            return (str(self) == other
                    or
                    f"{self.min_col}:{self.max_col}")
        return False


    def __repr__(self):
        return f"Range of columns from '{self.min_col}' to '{self.max_col}'"


    def __str__(self):
        return f"${self.min_col}:${self.max_col}"


class RowRange(Strict):
    """
    Represent a range of at least one row
    """

    min_row = Integer()
    max_row = Integer()

    def __init__(self, range_string=None, min_row=None, max_row=None):
        if range_string is not None:
            match = ROW_RANGE_RE.match(range_string)
            if not match:
                raise ValueError(f"{range_string} is not a valid row range")
            min_row, max_row = match.groups()[1:]
        self.min_row = min_row
        self.max_row = max_row


    def __eq__(self, other):
        if isinstance(other, self.__class__):
            return (self.min_row == other.min_row
                    and
                    self.max_row == other.max_row)
        elif isinstance(other, str):
            return (str(self) == other
                    or
                    f"{self.min_row}:{self.max_row}")
        return False

    def __repr__(self):
        return f"Range of rows from '{self.min_row}' to '{self.max_row}'"


    def __str__(self):
        return f"${self.min_row}:${self.max_row}"


class PrintTitles(Strict):
    """
    Contains at least either a range of rows or columns
    """

    cols = Typed(expected_type=ColRange, allow_none=True)
    rows = Typed(expected_type=RowRange, allow_none=True)
    title = String()


    def __init__(self, cols=None, rows=None, title=""):
        self.cols = cols
        self.rows = rows
        self.title = title


    @classmethod
    def from_string(cls, value):
        kw = dict((k, v) for match in TITLES_REGEX.finditer(value)
                  for k, v in match.groupdict().items() if v)

        if not kw:
            raise ValueError(f"{value} is not a valid print titles definition")

        cols = rows = None

        if "cols" in kw:
            cols = ColRange(kw["cols"])
        if "rows" in kw:
            rows = RowRange(kw["rows"])

        title = kw.get("quoted") or kw.get("notquoted")

        return cls(cols=cols, rows=rows, title=title)


    def __eq__(self, other):
        if isinstance(other, self.__class__):
            return (self.cols == other.cols
                    and
                    self.rows == other.rows
                    and
                    self.title == other.title)
        elif isinstance(other, str):
            return str(self) == other
        return False

    def __repr__(self):
        return f"Print titles for sheet {self.title} cols {self.rows}, rows {self.cols}"


    def __str__(self):
        title = quote_sheetname(self.title)
        titles = ",".join([f"{title}!{value}" for value in (self.rows, self.cols) if value])
        return titles or ""


class PrintArea(MultiCellRange):


    @classmethod
    def from_string(cls, value):
        new = []
        for m in PRINT_AREA_RE.finditer(value): # can be multiple
            coord = m.group("cells")
            if coord:
                new.append(coord)
        return cls(new)


    def __init__(self, ranges=(), title=""):
        self.title = ""
        super().__init__(ranges)


    def __str__(self):
        if self.ranges:
            return ",".join([f"{quote_sheetname(self.title)}!{absolute_coordinate(str(range))}"
                             for range in self.sorted()])
        return ""


    def __eq__(self, other):
        super().__eq__(other)
        if isinstance(other, str):
            return str(self) == other

```

---

### File: `tmp\openpyxl_sdist\openpyxl-3.1.5\openpyxl\worksheet\properties.py`

```python
# Copyright (c) 2010-2024 openpyxl

"""Worksheet Properties"""

from openpyxl.descriptors.serialisable import Serialisable
from openpyxl.descriptors import String, Bool, Typed
from openpyxl.styles.colors import ColorDescriptor


class Outline(Serialisable):

    tagname = "outlinePr"

    applyStyles = Bool(allow_none=True)
    summaryBelow = Bool(allow_none=True)
    summaryRight = Bool(allow_none=True)
    showOutlineSymbols = Bool(allow_none=True)


    def __init__(self,
                 applyStyles=None,
                 summaryBelow=None,
                 summaryRight=None,
                 showOutlineSymbols=None
                 ):
        self.applyStyles = applyStyles
        self.summaryBelow = summaryBelow
        self.summaryRight = summaryRight
        self.showOutlineSymbols = showOutlineSymbols


class PageSetupProperties(Serialisable):

    tagname = "pageSetUpPr"

    autoPageBreaks = Bool(allow_none=True)
    fitToPage = Bool(allow_none=True)

    def __init__(self, autoPageBreaks=None, fitToPage=None):
        self.autoPageBreaks = autoPageBreaks
        self.fitToPage = fitToPage


class WorksheetProperties(Serialisable):

    tagname = "sheetPr"

    codeName = String(allow_none=True)
    enableFormatConditionsCalculation = Bool(allow_none=True)
    filterMode = Bool(allow_none=True)
    published = Bool(allow_none=True)
    syncHorizontal = Bool(allow_none=True)
    syncRef = String(allow_none=True)
    syncVertical = Bool(allow_none=True)
    transitionEvaluation = Bool(allow_none=True)
    transitionEntry = Bool(allow_none=True)
    tabColor = ColorDescriptor(allow_none=True)
    outlinePr = Typed(expected_type=Outline, allow_none=True)
    pageSetUpPr = Typed(expected_type=PageSetupProperties, allow_none=True)

    __elements__ = ('tabColor', 'outlinePr', 'pageSetUpPr')


    def __init__(self,
                 codeName=None,
                 enableFormatConditionsCalculation=None,
                 filterMode=None,
                 published=None,
                 syncHorizontal=None,
                 syncRef=None,
                 syncVertical=None,
                 transitionEvaluation=None,
                 transitionEntry=None,
                 tabColor=None,
                 outlinePr=None,
                 pageSetUpPr=None
                 ):
        """ Attributes """
        self.codeName = codeName
        self.enableFormatConditionsCalculation = enableFormatConditionsCalculation
        self.filterMode = filterMode
        self.published = published
        self.syncHorizontal = syncHorizontal
        self.syncRef = syncRef
        self.syncVertical = syncVertical
        self.transitionEvaluation = transitionEvaluation
        self.transitionEntry = transitionEntry
        """ Elements """
        self.tabColor = tabColor
        if outlinePr is None:
            self.outlinePr = Outline(summaryBelow=True, summaryRight=True)
        else:
            self.outlinePr = outlinePr

        if pageSetUpPr is None:
            pageSetUpPr = PageSetupProperties()
        self.pageSetUpPr = pageSetUpPr

```

---

### File: `tmp\openpyxl_sdist\openpyxl-3.1.5\openpyxl\worksheet\protection.py`

```python
# Copyright (c) 2010-2024 openpyxl

from openpyxl.descriptors import (
    Bool,
    String,
    Alias,
    Integer,
)
from openpyxl.descriptors.serialisable import Serialisable
from openpyxl.descriptors.excel import (
    Base64Binary,
)
from openpyxl.utils.protection import hash_password


class _Protected:
    _password = None

    def set_password(self, value='', already_hashed=False):
        """Set a password on this sheet."""
        if not already_hashed:
            value = hash_password(value)
        self._password = value

    @property
    def password(self):
        """Return the password value, regardless of hash."""
        return self._password

    @password.setter
    def password(self, value):
        """Set a password directly, forcing a hash step."""
        self.set_password(value)


class SheetProtection(Serialisable, _Protected):
    """
    Information about protection of various aspects of a sheet. True values
    mean that protection for the object or action is active This is the
    **default** when protection is active, ie. users cannot do something
    """

    tagname = "sheetProtection"

    sheet = Bool()
    enabled = Alias('sheet')
    objects = Bool()
    scenarios = Bool()
    formatCells = Bool()
    formatColumns = Bool()
    formatRows = Bool()
    insertColumns = Bool()
    insertRows = Bool()
    insertHyperlinks = Bool()
    deleteColumns = Bool()
    deleteRows = Bool()
    selectLockedCells = Bool()
    selectUnlockedCells = Bool()
    sort = Bool()
    autoFilter = Bool()
    pivotTables = Bool()
    saltValue = Base64Binary(allow_none=True)
    spinCount = Integer(allow_none=True)
    algorithmName = String(allow_none=True)
    hashValue = Base64Binary(allow_none=True)


    __attrs__ = ('selectLockedCells', 'selectUnlockedCells', 'algorithmName',
              'sheet', 'objects', 'insertRows', 'insertHyperlinks', 'autoFilter',
              'scenarios', 'formatColumns', 'deleteColumns', 'insertColumns',
              'pivotTables', 'deleteRows', 'formatCells', 'saltValue', 'formatRows',
              'sort', 'spinCount', 'password', 'hashValue')


    def __init__(self, sheet=False, objects=False, scenarios=False,
                 formatCells=True, formatRows=True, formatColumns=True,
                 insertColumns=True, insertRows=True, insertHyperlinks=True,
                 deleteColumns=True, deleteRows=True, selectLockedCells=False,
                 selectUnlockedCells=False, sort=True, autoFilter=True, pivotTables=True,
                 password=None, algorithmName=None, saltValue=None, spinCount=None, hashValue=None):
        self.sheet = sheet
        self.objects = objects
        self.scenarios = scenarios
        self.formatCells = formatCells
        self.formatColumns = formatColumns
        self.formatRows = formatRows
        self.insertColumns = insertColumns
        self.insertRows = insertRows
        self.insertHyperlinks = insertHyperlinks
        self.deleteColumns = deleteColumns
        self.deleteRows = deleteRows
        self.selectLockedCells = selectLockedCells
        self.selectUnlockedCells = selectUnlockedCells
        self.sort = sort
        self.autoFilter = autoFilter
        self.pivotTables = pivotTables
        if password is not None:
            self.password = password
        self.algorithmName = algorithmName
        self.saltValue = saltValue
        self.spinCount = spinCount
        self.hashValue = hashValue


    def set_password(self, value='', already_hashed=False):
        super().set_password(value, already_hashed)
        self.enable()


    def enable(self):
        self.sheet = True


    def disable(self):
        self.sheet = False


    def  __bool__(self):
        return self.sheet


```

---

### File: `tmp\openpyxl_sdist\openpyxl-3.1.5\openpyxl\worksheet\related.py`

```python
# Copyright (c) 2010-2024 openpyxl

from openpyxl.descriptors.serialisable import Serialisable
from openpyxl.descriptors.excel import Relation


class Related(Serialisable):

    id = Relation()


    def __init__(self, id=None):
        self.id = id


    def to_tree(self, tagname, idx=None):
        return super().to_tree(tagname)

```

---

### File: `tmp\openpyxl_sdist\openpyxl-3.1.5\openpyxl\worksheet\scenario.py`

```python
# Copyright (c) 2010-2024 openpyxl

from openpyxl.descriptors.serialisable import Serialisable
from openpyxl.descriptors import (
    String,
    Integer,
    Bool,
    Sequence,
    Convertible,
)
from .cell_range import MultiCellRange


class InputCells(Serialisable):

    tagname = "inputCells"

    r = String()
    deleted = Bool(allow_none=True)
    undone = Bool(allow_none=True)
    val = String()
    numFmtId = Integer(allow_none=True)

    def __init__(self,
                 r=None,
                 deleted=False,
                 undone=False,
                 val=None,
                 numFmtId=None,
                ):
        self.r = r
        self.deleted = deleted
        self.undone = undone
        self.val = val
        self.numFmtId = numFmtId


class Scenario(Serialisable):

    tagname = "scenario"

    inputCells = Sequence(expected_type=InputCells)
    name = String()
    locked = Bool(allow_none=True)
    hidden = Bool(allow_none=True)
    user = String(allow_none=True)
    comment = String(allow_none=True)

    __elements__ = ('inputCells',)
    __attrs__ = ('name', 'locked', 'hidden', 'user', 'comment', 'count')

    def __init__(self,
                 inputCells=(),
                 name=None,
                 locked=False,
                 hidden=False,
                 count=None,
                 user=None,
                 comment=None,
                ):
        self.inputCells = inputCells
        self.name = name
        self.locked = locked
        self.hidden = hidden
        self.user = user
        self.comment = comment


    @property
    def count(self):
        return len(self.inputCells)


class ScenarioList(Serialisable):

    tagname = "scenarios"

    scenario = Sequence(expected_type=Scenario)
    current = Integer(allow_none=True)
    show = Integer(allow_none=True)
    sqref = Convertible(expected_type=MultiCellRange, allow_none=True)

    __elements__ = ('scenario',)

    def __init__(self,
                 scenario=(),
                 current=None,
                 show=None,
                 sqref=None,
                ):
        self.scenario = scenario
        self.current = current
        self.show = show
        self.sqref = sqref


    def append(self, scenario):
        s = self.scenario
        s.append(scenario)
        self.scenario = s


    def __bool__(self):
        return bool(self.scenario)


```

---

### File: `tmp\openpyxl_sdist\openpyxl-3.1.5\openpyxl\worksheet\smart_tag.py`

```python
#Autogenerated schema
from openpyxl.descriptors.serialisable import Serialisable
from openpyxl.descriptors import (
    Bool,
    Integer,
    String,
    Sequence,
)


class CellSmartTagPr(Serialisable):

    tagname = "cellSmartTagPr"

    key = String()
    val = String()

    def __init__(self,
                 key=None,
                 val=None,
                ):
        self.key = key
        self.val = val


class CellSmartTag(Serialisable):

    tagname = "cellSmartTag"

    cellSmartTagPr = Sequence(expected_type=CellSmartTagPr)
    type = Integer()
    deleted = Bool(allow_none=True)
    xmlBased = Bool(allow_none=True)

    __elements__ = ('cellSmartTagPr',)

    def __init__(self,
                 cellSmartTagPr=(),
                 type=None,
                 deleted=False,
                 xmlBased=False,
                ):
        self.cellSmartTagPr = cellSmartTagPr
        self.type = type
        self.deleted = deleted
        self.xmlBased = xmlBased


class CellSmartTags(Serialisable):

    tagname = "cellSmartTags"

    cellSmartTag = Sequence(expected_type=CellSmartTag)
    r = String()

    __elements__ = ('cellSmartTag',)

    def __init__(self,
                 cellSmartTag=(),
                 r=None,
                ):
        self.cellSmartTag = cellSmartTag
        self.r = r


class SmartTags(Serialisable):

    tagname = "smartTags"

    cellSmartTags = Sequence(expected_type=CellSmartTags)

    __elements__ = ('cellSmartTags',)

    def __init__(self,
                 cellSmartTags=(),
                ):
        self.cellSmartTags = cellSmartTags


```

---

### File: `tmp\openpyxl_sdist\openpyxl-3.1.5\openpyxl\worksheet\table.py`

```python
# Copyright (c) 2010-2024 openpyxl

from openpyxl.descriptors.serialisable import Serialisable
from openpyxl.descriptors import (
    Descriptor,
    Alias,
    Typed,
    Bool,
    Integer,
    NoneSet,
    String,
    Sequence,
)
from openpyxl.descriptors.excel import ExtensionList, CellRange
from openpyxl.descriptors.sequence import NestedSequence
from openpyxl.xml.constants import SHEET_MAIN_NS, REL_NS
from openpyxl.xml.functions import tostring
from openpyxl.utils import range_boundaries
from openpyxl.utils.escape import escape, unescape

from .related import Related

from .filters import (
    AutoFilter,
    SortState,
)

TABLESTYLES = tuple(
    ["TableStyleMedium{0}".format(i) for i in range(1, 29)]
    + ["TableStyleLight{0}".format(i) for i in range(1, 22)]
    + ["TableStyleDark{0}".format(i) for i in range(1, 12)]
)

PIVOTSTYLES = tuple(
    ["PivotStyleMedium{0}".format(i) for i in range(1, 29)]
    + ["PivotStyleLight{0}".format(i) for i in range(1, 29)]
    + ["PivotStyleDark{0}".format(i) for i in range(1, 29)]
)


class TableStyleInfo(Serialisable):

    tagname = "tableStyleInfo"

    name = String(allow_none=True)
    showFirstColumn = Bool(allow_none=True)
    showLastColumn = Bool(allow_none=True)
    showRowStripes = Bool(allow_none=True)
    showColumnStripes = Bool(allow_none=True)

    def __init__(self,
                 name=None,
                 showFirstColumn=None,
                 showLastColumn=None,
                 showRowStripes=None,
                 showColumnStripes=None,
                ):
        self.name = name
        self.showFirstColumn = showFirstColumn
        self.showLastColumn = showLastColumn
        self.showRowStripes = showRowStripes
        self.showColumnStripes = showColumnStripes


class XMLColumnProps(Serialisable):

    tagname = "xmlColumnPr"

    mapId = Integer()
    xpath = String()
    denormalized = Bool(allow_none=True)
    xmlDataType = String()
    extLst = Typed(expected_type=ExtensionList, allow_none=True)

    __elements__ = ()

    def __init__(self,
                 mapId=None,
                 xpath=None,
                 denormalized=None,
                 xmlDataType=None,
                 extLst=None,
                ):
        self.mapId = mapId
        self.xpath = xpath
        self.denormalized = denormalized
        self.xmlDataType = xmlDataType


class TableFormula(Serialisable):

    tagname = "tableFormula"

    ## Note formula is stored as the text value

    array = Bool(allow_none=True)
    attr_text = Descriptor()
    text = Alias('attr_text')


    def __init__(self,
                 array=None,
                 attr_text=None,
                ):
        self.array = array
        self.attr_text = attr_text


class TableColumn(Serialisable):

    tagname = "tableColumn"

    id = Integer()
    uniqueName = String(allow_none=True)
    name = String()
    totalsRowFunction = NoneSet(values=(['sum', 'min', 'max', 'average',
                                         'count', 'countNums', 'stdDev', 'var', 'custom']))
    totalsRowLabel = String(allow_none=True)
    queryTableFieldId = Integer(allow_none=True)
    headerRowDxfId = Integer(allow_none=True)
    dataDxfId = Integer(allow_none=True)
    totalsRowDxfId = Integer(allow_none=True)
    headerRowCellStyle = String(allow_none=True)
    dataCellStyle = String(allow_none=True)
    totalsRowCellStyle = String(allow_none=True)
    calculatedColumnFormula = Typed(expected_type=TableFormula, allow_none=True)
    totalsRowFormula = Typed(expected_type=TableFormula, allow_none=True)
    xmlColumnPr = Typed(expected_type=XMLColumnProps, allow_none=True)
    extLst = Typed(expected_type=ExtensionList, allow_none=True)

    __elements__ = ('calculatedColumnFormula', 'totalsRowFormula',
                    'xmlColumnPr', 'extLst')

    def __init__(self,
                 id=None,
                 uniqueName=None,
                 name=None,
                 totalsRowFunction=None,
                 totalsRowLabel=None,
                 queryTableFieldId=None,
                 headerRowDxfId=None,
                 dataDxfId=None,
                 totalsRowDxfId=None,
                 headerRowCellStyle=None,
                 dataCellStyle=None,
                 totalsRowCellStyle=None,
                 calculatedColumnFormula=None,
                 totalsRowFormula=None,
                 xmlColumnPr=None,
                 extLst=None,
                ):
        self.id = id
        self.uniqueName = uniqueName
        self.name = name
        self.totalsRowFunction = totalsRowFunction
        self.totalsRowLabel = totalsRowLabel
        self.queryTableFieldId = queryTableFieldId
        self.headerRowDxfId = headerRowDxfId
        self.dataDxfId = dataDxfId
        self.totalsRowDxfId = totalsRowDxfId
        self.headerRowCellStyle = headerRowCellStyle
        self.dataCellStyle = dataCellStyle
        self.totalsRowCellStyle = totalsRowCellStyle
        self.calculatedColumnFormula = calculatedColumnFormula
        self.totalsRowFormula = totalsRowFormula
        self.xmlColumnPr = xmlColumnPr
        self.extLst = extLst


    def __iter__(self):
        for k, v in super().__iter__():
            if k == 'name':
                v = escape(v)
            yield k, v


    @classmethod
    def from_tree(cls, node):
        self = super().from_tree(node)
        self.name = unescape(self.name)
        return self


class TableNameDescriptor(String):

    """
    Table names cannot have spaces in them
    """

    def __set__(self, instance, value):
        if value is not None and " " in value:
            raise ValueError("Table names cannot have spaces")
        super().__set__(instance, value)


class Table(Serialisable):

    _path = "/tables/table{0}.xml"
    mime_type = "application/vnd.openxmlformats-officedocument.spreadsheetml.table+xml"
    _rel_type = REL_NS + "/table"
    _rel_id = None

    tagname = "table"

    id = Integer()
    name = String(allow_none=True)
    displayName = TableNameDescriptor()
    comment = String(allow_none=True)
    ref = CellRange()
    tableType = NoneSet(values=(['worksheet', 'xml', 'queryTable']))
    headerRowCount = Integer(allow_none=True)
    insertRow = Bool(allow_none=True)
    insertRowShift = Bool(allow_none=True)
    totalsRowCount = Integer(allow_none=True)
    totalsRowShown = Bool(allow_none=True)
    published = Bool(allow_none=True)
    headerRowDxfId = Integer(allow_none=True)
    dataDxfId = Integer(allow_none=True)
    totalsRowDxfId = Integer(allow_none=True)
    headerRowBorderDxfId = Integer(allow_none=True)
    tableBorderDxfId = Integer(allow_none=True)
    totalsRowBorderDxfId = Integer(allow_none=True)
    headerRowCellStyle = String(allow_none=True)
    dataCellStyle = String(allow_none=True)
    totalsRowCellStyle = String(allow_none=True)
    connectionId = Integer(allow_none=True)
    autoFilter = Typed(expected_type=AutoFilter, allow_none=True)
    sortState = Typed(expected_type=SortState, allow_none=True)
    tableColumns = NestedSequence(expected_type=TableColumn, count=True)
    tableStyleInfo = Typed(expected_type=TableStyleInfo, allow_none=True)
    extLst = Typed(expected_type=ExtensionList, allow_none=True)

    __elements__ = ('autoFilter', 'sortState', 'tableColumns',
                    'tableStyleInfo')

    def __init__(self,
                 id=1,
                 displayName=None,
                 ref=None,
                 name=None,
                 comment=None,
                 tableType=None,
                 headerRowCount=1,
                 insertRow=None,
                 insertRowShift=None,
                 totalsRowCount=None,
                 totalsRowShown=None,
                 published=None,
                 headerRowDxfId=None,
                 dataDxfId=None,
                 totalsRowDxfId=None,
                 headerRowBorderDxfId=None,
                 tableBorderDxfId=None,
                 totalsRowBorderDxfId=None,
                 headerRowCellStyle=None,
                 dataCellStyle=None,
                 totalsRowCellStyle=None,
                 connectionId=None,
                 autoFilter=None,
                 sortState=None,
                 tableColumns=(),
                 tableStyleInfo=None,
                 extLst=None,
                ):
        self.id = id
        self.displayName = displayName
        if name is None:
            name = displayName
        self.name = name
        self.comment = comment
        self.ref = ref
        self.tableType = tableType
        self.headerRowCount = headerRowCount
        self.insertRow = insertRow
        self.insertRowShift = insertRowShift
        self.totalsRowCount = totalsRowCount
        self.totalsRowShown = totalsRowShown
        self.published = published
        self.headerRowDxfId = headerRowDxfId
        self.dataDxfId = dataDxfId
        self.totalsRowDxfId = totalsRowDxfId
        self.headerRowBorderDxfId = headerRowBorderDxfId
        self.tableBorderDxfId = tableBorderDxfId
        self.totalsRowBorderDxfId = totalsRowBorderDxfId
        self.headerRowCellStyle = headerRowCellStyle
        self.dataCellStyle = dataCellStyle
        self.totalsRowCellStyle = totalsRowCellStyle
        self.connectionId = connectionId
        self.autoFilter = autoFilter
        self.sortState = sortState
        self.tableColumns = tableColumns
        self.tableStyleInfo = tableStyleInfo


    def to_tree(self):
        tree = super().to_tree()
        tree.set("xmlns", SHEET_MAIN_NS)
        return tree


    @property
    def path(self):
        """
        Return path within the archive
        """
        return "/xl" + self._path.format(self.id)


    def _write(self, archive):
        """
        Serialise to XML and write to archive
        """
        xml = self.to_tree()
        archive.writestr(self.path[1:], tostring(xml))


    def _initialise_columns(self):
        """
        Create a list of table columns from a cell range
        Always set a ref if we have headers (the default)
        Column headings must be strings and must match cells in the worksheet.
        """

        min_col, min_row, max_col, max_row = range_boundaries(self.ref)
        for idx in range(min_col, max_col+1):
            col = TableColumn(id=idx, name="Column{0}".format(idx))
            self.tableColumns.append(col)
        if self.headerRowCount and not self.autoFilter:
            self.autoFilter = AutoFilter(ref=self.ref)


    @property
    def column_names(self):
        return [column.name for column in self.tableColumns]


class TablePartList(Serialisable):

    tagname = "tableParts"

    count = Integer(allow_none=True)
    tablePart = Sequence(expected_type=Related)

    __elements__ = ('tablePart',)
    __attrs__ = ('count',)

    def __init__(self,
                 count=None,
                 tablePart=(),
                ):
        self.tablePart = tablePart


    def append(self, part):
        self.tablePart.append(part)


    @property
    def count(self):
        return len(self.tablePart)


    def __bool__(self):
        return bool(self.tablePart)


class TableList(dict):


    def add(self, table):
        if not isinstance(table, Table):
            raise TypeError("You can only add tables")
        self[table.name] = table


    def get(self, name=None, table_range=None):
        if name is not None:
            return super().get(name)
        for table in self.values():
            if table_range == table.ref:
                return table


    def items(self):
        return [(name, table.ref) for name, table in super().items()]

```

---

### File: `tmp\openpyxl_sdist\openpyxl-3.1.5\openpyxl\worksheet\views.py`

```python
# Copyright (c) 2010-2024 openpyxl

from openpyxl.descriptors import (
    Bool,
    Integer,
    String,
    Set,
    Float,
    Typed,
    NoneSet,
    Sequence,
)
from openpyxl.descriptors.excel import ExtensionList
from openpyxl.descriptors.serialisable import Serialisable


class Pane(Serialisable):
    xSplit = Float(allow_none=True)
    ySplit = Float(allow_none=True)
    topLeftCell = String(allow_none=True)
    activePane = Set(values=("bottomRight", "topRight", "bottomLeft", "topLeft"))
    state = Set(values=("split", "frozen", "frozenSplit"))

    def __init__(self,
                 xSplit=None,
                 ySplit=None,
                 topLeftCell=None,
                 activePane="topLeft",
                 state="split"):
        self.xSplit = xSplit
        self.ySplit = ySplit
        self.topLeftCell = topLeftCell
        self.activePane = activePane
        self.state = state


class Selection(Serialisable):
    pane = NoneSet(values=("bottomRight", "topRight", "bottomLeft", "topLeft"))
    activeCell = String(allow_none=True)
    activeCellId = Integer(allow_none=True)
    sqref = String(allow_none=True)

    def __init__(self,
                 pane=None,
                 activeCell="A1",
                 activeCellId=None,
                 sqref="A1"):
        self.pane = pane
        self.activeCell = activeCell
        self.activeCellId = activeCellId
        self.sqref = sqref


class SheetView(Serialisable):

    """Information about the visible portions of this sheet."""

    tagname = "sheetView"

    windowProtection = Bool(allow_none=True)
    showFormulas = Bool(allow_none=True)
    showGridLines = Bool(allow_none=True)
    showRowColHeaders = Bool(allow_none=True)
    showZeros = Bool(allow_none=True)
    rightToLeft = Bool(allow_none=True)
    tabSelected = Bool(allow_none=True)
    showRuler = Bool(allow_none=True)
    showOutlineSymbols = Bool(allow_none=True)
    defaultGridColor = Bool(allow_none=True)
    showWhiteSpace = Bool(allow_none=True)
    view = NoneSet(values=("normal", "pageBreakPreview", "pageLayout"))
    topLeftCell = String(allow_none=True)
    colorId = Integer(allow_none=True)
    zoomScale = Integer(allow_none=True)
    zoomScaleNormal = Integer(allow_none=True)
    zoomScaleSheetLayoutView = Integer(allow_none=True)
    zoomScalePageLayoutView = Integer(allow_none=True)
    zoomToFit = Bool(allow_none=True) # Chart sheets only
    workbookViewId = Integer()
    selection = Sequence(expected_type=Selection)
    pane = Typed(expected_type=Pane, allow_none=True)

    def __init__(self,
                 windowProtection=None,
                 showFormulas=None,
                 showGridLines=None,
                 showRowColHeaders=None,
                 showZeros=None,
                 rightToLeft=None,
                 tabSelected=None,
                 showRuler=None,
                 showOutlineSymbols=None,
                 defaultGridColor=None,
                 showWhiteSpace=None,
                 view=None,
                 topLeftCell=None,
                 colorId=None,
                 zoomScale=None,
                 zoomScaleNormal=None,
                 zoomScaleSheetLayoutView=None,
                 zoomScalePageLayoutView=None,
                 zoomToFit=None,
                 workbookViewId=0,
                 selection=None,
                 pane=None,):
        self.windowProtection = windowProtection
        self.showFormulas = showFormulas
        self.showGridLines = showGridLines
        self.showRowColHeaders = showRowColHeaders
        self.showZeros = showZeros
        self.rightToLeft = rightToLeft
        self.tabSelected = tabSelected
        self.showRuler = showRuler
        self.showOutlineSymbols = showOutlineSymbols
        self.defaultGridColor = defaultGridColor
        self.showWhiteSpace = showWhiteSpace
        self.view = view
        self.topLeftCell = topLeftCell
        self.colorId = colorId
        self.zoomScale = zoomScale
        self.zoomScaleNormal = zoomScaleNormal
        self.zoomScaleSheetLayoutView = zoomScaleSheetLayoutView
        self.zoomScalePageLayoutView = zoomScalePageLayoutView
        self.zoomToFit = zoomToFit
        self.workbookViewId = workbookViewId
        self.pane = pane
        if selection is None:
            selection = (Selection(), )
        self.selection = selection


class SheetViewList(Serialisable):

    tagname = "sheetViews"

    sheetView = Sequence(expected_type=SheetView, )
    extLst = Typed(expected_type=ExtensionList, allow_none=True)

    __elements__ = ('sheetView',)

    def __init__(self,
                 sheetView=None,
                 extLst=None,
                ):
        if sheetView is None:
            sheetView = [SheetView()]
        self.sheetView = sheetView


    @property
    def active(self):
        """
        Returns the first sheet view which is assumed to be active
        """
        return self.sheetView[0]

```

---

### File: `tmp\openpyxl_sdist\openpyxl-3.1.5\openpyxl\worksheet\worksheet.py`

```python
# Copyright (c) 2010-2024 openpyxl

"""Worksheet is the 2nd-level container in Excel."""


# Python stdlib imports
from itertools import chain
from operator import itemgetter
from inspect import isgenerator
from warnings import warn

# compatibility imports
from openpyxl.compat import (
    deprecated,
)

# package imports
from openpyxl.utils import (
    column_index_from_string,
    get_column_letter,
    range_boundaries,
    coordinate_to_tuple,
)
from openpyxl.cell import Cell, MergedCell
from openpyxl.formatting.formatting import ConditionalFormattingList
from openpyxl.packaging.relationship import RelationshipList
from openpyxl.workbook.child import _WorkbookChild
from openpyxl.workbook.defined_name import (
    DefinedNameDict,
)

from openpyxl.formula.translate import Translator

from .datavalidation import DataValidationList
from .page import (
    PrintPageSetup,
    PageMargins,
    PrintOptions,
)
from .dimensions import (
    ColumnDimension,
    RowDimension,
    DimensionHolder,
    SheetFormatProperties,
)
from .protection import SheetProtection
from .filters import AutoFilter
from .views import (
    Pane,
    Selection,
    SheetViewList,
)
from .cell_range import MultiCellRange, CellRange
from .merge import MergedCellRange
from .properties import WorksheetProperties
from .pagebreak import RowBreak, ColBreak
from .scenario import ScenarioList
from .table import TableList
from .formula import ArrayFormula
from .print_settings import (
    PrintTitles,
    ColRange,
    RowRange,
    PrintArea,
)


class Worksheet(_WorkbookChild):
    """Represents a worksheet.

    Do not create worksheets yourself,
    use :func:`openpyxl.workbook.Workbook.create_sheet` instead

    """

    _rel_type = "worksheet"
    _path = "/xl/worksheets/sheet{0}.xml"
    mime_type = "application/vnd.openxmlformats-officedocument.spreadsheetml.worksheet+xml"

    BREAK_NONE = 0
    BREAK_ROW = 1
    BREAK_COLUMN = 2

    SHEETSTATE_VISIBLE = 'visible'
    SHEETSTATE_HIDDEN = 'hidden'
    SHEETSTATE_VERYHIDDEN = 'veryHidden'

    # Paper size
    PAPERSIZE_LETTER = '1'
    PAPERSIZE_LETTER_SMALL = '2'
    PAPERSIZE_TABLOID = '3'
    PAPERSIZE_LEDGER = '4'
    PAPERSIZE_LEGAL = '5'
    PAPERSIZE_STATEMENT = '6'
    PAPERSIZE_EXECUTIVE = '7'
    PAPERSIZE_A3 = '8'
    PAPERSIZE_A4 = '9'
    PAPERSIZE_A4_SMALL = '10'
    PAPERSIZE_A5 = '11'

    # Page orientation
    ORIENTATION_PORTRAIT = 'portrait'
    ORIENTATION_LANDSCAPE = 'landscape'

    def __init__(self, parent, title=None):
        _WorkbookChild.__init__(self, parent, title)
        self._setup()

    def _setup(self):
        self.row_dimensions = DimensionHolder(worksheet=self,
                                              default_factory=self._add_row)
        self.column_dimensions = DimensionHolder(worksheet=self,
                                                 default_factory=self._add_column)
        self.row_breaks = RowBreak()
        self.col_breaks = ColBreak()
        self._cells = {}
        self._charts = []
        self._images = []
        self._rels = RelationshipList()
        self._drawing = None
        self._comments = []
        self.merged_cells = MultiCellRange()
        self._tables = TableList()
        self._pivots = []
        self.data_validations = DataValidationList()
        self._hyperlinks = []
        self.sheet_state = 'visible'
        self.page_setup = PrintPageSetup(worksheet=self)
        self.print_options = PrintOptions()
        self._print_rows = None
        self._print_cols = None
        self._print_area = PrintArea()
        self.page_margins = PageMargins()
        self.views = SheetViewList()
        self.protection = SheetProtection()
        self.defined_names = DefinedNameDict()

        self._current_row = 0
        self.auto_filter = AutoFilter()
        self.conditional_formatting = ConditionalFormattingList()
        self.legacy_drawing = None
        self.sheet_properties = WorksheetProperties()
        self.sheet_format = SheetFormatProperties()
        self.scenarios = ScenarioList()


    @property
    def sheet_view(self):
        return self.views.active


    @property
    def selected_cell(self):
        return self.sheet_view.selection[0].sqref


    @property
    def active_cell(self):
        return self.sheet_view.selection[0].activeCell


    @property
    def array_formulae(self):
        """Returns a dictionary of cells with array formulae and the cells in array"""
        result = {}
        for c in self._cells.values():
            if c.data_type == "f":
                if isinstance(c.value, ArrayFormula):
                    result[c.coordinate] = c.value.ref
        return result


    @property
    def show_gridlines(self):
        return self.sheet_view.showGridLines


    @property
    def freeze_panes(self):
        if self.sheet_view.pane is not None:
            return self.sheet_view.pane.topLeftCell


    @freeze_panes.setter
    def freeze_panes(self, topLeftCell=None):
        if isinstance(topLeftCell, Cell):
            topLeftCell = topLeftCell.coordinate
        if topLeftCell == 'A1':
            topLeftCell = None

        if not topLeftCell:
            self.sheet_view.pane = None
            return

        row, column = coordinate_to_tuple(topLeftCell)

        view = self.sheet_view
        view.pane = Pane(topLeftCell=topLeftCell,
                        activePane="topRight",
                        state="frozen")
        view.selection[0].pane = "topRight"

        if column > 1:
            view.pane.xSplit = column - 1
        if row > 1:
            view.pane.ySplit = row - 1
            view.pane.activePane = 'bottomLeft'
            view.selection[0].pane = "bottomLeft"
            if column > 1:
                view.selection[0].pane = "bottomRight"
                view.pane.activePane = 'bottomRight'

        if row > 1 and column > 1:
            sel = list(view.selection)
            sel.insert(0, Selection(pane="topRight", activeCell=None, sqref=None))
            sel.insert(1, Selection(pane="bottomLeft", activeCell=None, sqref=None))
            view.selection = sel


    def cell(self, row, column, value=None):
        """
        Returns a cell object based on the given coordinates.

        Usage: cell(row=15, column=1, value=5)

        Calling `cell` creates cells in memory when they
        are first accessed.

        :param row: row index of the cell (e.g. 4)
        :type row: int

        :param column: column index of the cell (e.g. 3)
        :type column: int

        :param value: value of the cell (e.g. 5)
        :type value: numeric or time or string or bool or none

        :rtype: openpyxl.cell.cell.Cell
        """

        if row < 1 or column < 1:
            raise ValueError("Row or column values must be at least 1")

        cell = self._get_cell(row, column)
        if value is not None:
            cell.value = value

        return cell


    def _get_cell(self, row, column):
        """
        Internal method for getting a cell from a worksheet.
        Will create a new cell if one doesn't already exist.
        """
        if not 0 < row < 1048577:
            raise ValueError(f"Row numbers must be between 1 and 1048576. Row number supplied was {row}")
        coordinate = (row, column)
        if not coordinate in self._cells:
            cell = Cell(self, row=row, column=column)
            self._add_cell(cell)
        return self._cells[coordinate]


    def _add_cell(self, cell):
        """
        Internal method for adding cell objects.
        """
        column = cell.col_idx
        row = cell.row
        self._current_row = max(row, self._current_row)
        self._cells[(row, column)] = cell


    def __getitem__(self, key):
        """Convenience access by Excel style coordinates

        The key can be a single cell coordinate 'A1', a range of cells 'A1:D25',
        individual rows or columns 'A', 4 or ranges of rows or columns 'A:D',
        4:10.

        Single cells will always be created if they do not exist.

        Returns either a single cell or a tuple of rows or columns.
        """
        if isinstance(key, slice):
            if not all([key.start, key.stop]):
                raise IndexError("{0} is not a valid coordinate or range".format(key))
            key = "{0}:{1}".format(key.start, key.stop)

        if isinstance(key, int):
            key = str(key
                      )
        min_col, min_row, max_col, max_row = range_boundaries(key)

        if not any([min_col, min_row, max_col, max_row]):
            raise IndexError("{0} is not a valid coordinate or range".format(key))

        if min_row is None:
            cols = tuple(self.iter_cols(min_col, max_col))
            if min_col == max_col:
                cols = cols[0]
            return cols
        if min_col is None:
            rows = tuple(self.iter_rows(min_col=min_col, min_row=min_row,
                                        max_col=self.max_column, max_row=max_row))
            if min_row == max_row:
                rows = rows[0]
            return rows
        if ":" not in key:
            return self._get_cell(min_row, min_col)
        return tuple(self.iter_rows(min_row=min_row, min_col=min_col,
                                    max_row=max_row, max_col=max_col))


    def __setitem__(self, key, value):
        self[key].value = value


    def __iter__(self):
        return self.iter_rows()


    def __delitem__(self, key):
        row, column = coordinate_to_tuple(key)
        if (row, column) in self._cells:
            del self._cells[(row, column)]


    @property
    def min_row(self):
        """The minimum row index containing data (1-based)

        :type: int
        """
        min_row = 1
        if self._cells:
            min_row = min(self._cells)[0]
        return min_row


    @property
    def max_row(self):
        """The maximum row index containing data (1-based)

        :type: int
        """
        max_row = 1
        if self._cells:
            max_row = max(self._cells)[0]
        return max_row


    @property
    def min_column(self):
        """The minimum column index containing data (1-based)

        :type: int
        """
        min_col = 1
        if self._cells:
            min_col = min(c[1] for c in self._cells)
        return min_col


    @property
    def max_column(self):
        """The maximum column index containing data (1-based)

        :type: int
        """
        max_col = 1
        if self._cells:
            max_col = max(c[1] for c in self._cells)
        return max_col


    def calculate_dimension(self):
        """Return the minimum bounding range for all cells containing data (ex. 'A1:M24')

        :rtype: string
        """
        if self._cells:
            rows = set()
            cols = set()
            for row, col in self._cells:
                rows.add(row)
                cols.add(col)
            max_row = max(rows)
            max_col = max(cols)
            min_col = min(cols)
            min_row = min(rows)
        else:
            return "A1:A1"

        return f"{get_column_letter(min_col)}{min_row}:{get_column_letter(max_col)}{max_row}"


    @property
    def dimensions(self):
        """Returns the result of :func:`calculate_dimension`"""
        return self.calculate_dimension()


    def iter_rows(self, min_row=None, max_row=None, min_col=None, max_col=None, values_only=False):
        """
        Produces cells from the worksheet, by row. Specify the iteration range
        using indices of rows and columns.

        If no indices are specified the range starts at A1.

        If no cells are in the worksheet an empty tuple will be returned.

        :param min_col: smallest column index (1-based index)
        :type min_col: int

        :param min_row: smallest row index (1-based index)
        :type min_row: int

        :param max_col: largest column index (1-based index)
        :type max_col: int

        :param max_row: largest row index (1-based index)
        :type max_row: int

        :param values_only: whether only cell values should be returned
        :type values_only: bool

        :rtype: generator
        """

        if self._current_row == 0 and not any([min_col, min_row, max_col, max_row ]):
            return iter(())


        min_col = min_col or 1
        min_row = min_row or 1
        max_col = max_col or self.max_column
        max_row = max_row or self.max_row

        return self._cells_by_row(min_col, min_row, max_col, max_row, values_only)


    def _cells_by_row(self, min_col, min_row, max_col, max_row, values_only=False):
        for row in range(min_row, max_row + 1):
            cells = (self.cell(row=row, column=column) for column in range(min_col, max_col + 1))
            if values_only:
                yield tuple(cell.value for cell in cells)
            else:
                yield tuple(cells)


    @property
    def rows(self):
        """Produces all cells in the worksheet, by row (see :func:`iter_rows`)

        :type: generator
        """
        return self.iter_rows()


    @property
    def values(self):
        """Produces all cell values in the worksheet, by row

        :type: generator
        """
        for row in self.iter_rows(values_only=True):
            yield row


    def iter_cols(self, min_col=None, max_col=None, min_row=None, max_row=None, values_only=False):
        """
        Produces cells from the worksheet, by column. Specify the iteration range
        using indices of rows and columns.

        If no indices are specified the range starts at A1.

        If no cells are in the worksheet an empty tuple will be returned.

        :param min_col: smallest column index (1-based index)
        :type min_col: int

        :param min_row: smallest row index (1-based index)
        :type min_row: int

        :param max_col: largest column index (1-based index)
        :type max_col: int

        :param max_row: largest row index (1-based index)
        :type max_row: int

        :param values_only: whether only cell values should be returned
        :type values_only: bool

        :rtype: generator
        """

        if self._current_row == 0 and not any([min_col, min_row, max_col, max_row]):
            return iter(())

        min_col = min_col or 1
        min_row = min_row or 1
        max_col = max_col or self.max_column
        max_row = max_row or self.max_row

        return self._cells_by_col(min_col, min_row, max_col, max_row, values_only)


    def _cells_by_col(self, min_col, min_row, max_col, max_row, values_only=False):
        """
        Get cells by column
        """
        for column in range(min_col, max_col+1):
            cells = (self.cell(row=row, column=column)
                        for row in range(min_row, max_row+1))
            if values_only:
                yield tuple(cell.value for cell in cells)
            else:
                yield tuple(cells)


    @property
    def columns(self):
        """Produces all cells in the worksheet, by column  (see :func:`iter_cols`)"""
        return self.iter_cols()


    @property
    def column_groups(self):
        """
        Return a list of column ranges where more than one column
        """
        return [cd.range for cd in self.column_dimensions.values() if cd.min and cd.max > cd.min]


    def set_printer_settings(self, paper_size, orientation):
        """Set printer settings """

        self.page_setup.paperSize = paper_size
        self.page_setup.orientation = orientation


    def add_data_validation(self, data_validation):
        """ Add a data-validation object to the sheet.  The data-validation
            object defines the type of data-validation to be applied and the
            cell or range of cells it should apply to.
        """
        self.data_validations.append(data_validation)


    def add_chart(self, chart, anchor=None):
        """
        Add a chart to the sheet
        Optionally provide a cell for the top-left anchor
        """
        if anchor is not None:
            chart.anchor = anchor
        self._charts.append(chart)


    def add_image(self, img, anchor=None):
        """
        Add an image to the sheet.
        Optionally provide a cell for the top-left anchor
        """
        if anchor is not None:
            img.anchor = anchor
        self._images.append(img)


    def add_table(self, table):
        """
        Check for duplicate name in definedNames and other worksheet tables
        before adding table.
        """

        if self.parent._duplicate_name(table.name):
            raise ValueError("Table with name {0} already exists".format(table.name))
        if not hasattr(self, "_get_cell"):
            warn("In write-only mode you must add table columns manually")
        self._tables.add(table)


    @property
    def tables(self):
        return self._tables


    def add_pivot(self, pivot):
        self._pivots.append(pivot)


    def merge_cells(self, range_string=None, start_row=None, start_column=None, end_row=None, end_column=None):
        """ Set merge on a cell range.  Range is a cell range (e.g. A1:E1) """
        if range_string is None:
            cr = CellRange(range_string=range_string, min_col=start_column, min_row=start_row,
                      max_col=end_column, max_row=end_row)
            range_string = cr.coord
        mcr = MergedCellRange(self, range_string)
        self.merged_cells.add(mcr)
        self._clean_merge_range(mcr)


    def _clean_merge_range(self, mcr):
        """
        Remove all but the top left-cell from a range of merged cells
        and recreate the lost border information.
        Borders are then applied
        """
        cells = mcr.cells
        next(cells) # skip first cell
        for row, col in cells:
            self._cells[row, col] = MergedCell(self, row, col)
        mcr.format()


    @property
    @deprecated("Use ws.merged_cells.ranges")
    def merged_cell_ranges(self):
        """Return a copy of cell ranges"""
        return self.merged_cells.ranges[:]


    def unmerge_cells(self, range_string=None, start_row=None, start_column=None, end_row=None, end_column=None):
        """ Remove merge on a cell range.  Range is a cell range (e.g. A1:E1) """
        cr = CellRange(range_string=range_string, min_col=start_column, min_row=start_row,
                      max_col=end_column, max_row=end_row)

        if cr.coord not in self.merged_cells:
            raise ValueError("Cell range {0} is not merged".format(cr.coord))

        self.merged_cells.remove(cr)

        cells = cr.cells
        next(cells) # skip first cell
        for row, col in cells:
            del self._cells[(row, col)]


    def append(self, iterable):
        """Appends a group of values at the bottom of the current sheet.

        * If it's a list: all values are added in order, starting from the first column
        * If it's a dict: values are assigned to the columns indicated by the keys (numbers or letters)

        :param iterable: list, range or generator, or dict containing values to append
        :type iterable: list|tuple|range|generator or dict

        Usage:

        * append(['This is A1', 'This is B1', 'This is C1'])
        * **or** append({'A' : 'This is A1', 'C' : 'This is C1'})
        * **or** append({1 : 'This is A1', 3 : 'This is C1'})

        :raise: TypeError when iterable is neither a list/tuple nor a dict

        """
        row_idx = self._current_row + 1

        if (isinstance(iterable, (list, tuple, range))
            or isgenerator(iterable)):
            for col_idx, content in enumerate(iterable, 1):
                if isinstance(content, Cell):
                    # compatible with write-only mode
                    cell = content
                    if cell.parent and cell.parent != self:
                        raise ValueError("Cells cannot be copied from other worksheets")
                    cell.parent = self
                    cell.column = col_idx
                    cell.row = row_idx
                else:
                    cell = Cell(self, row=row_idx, column=col_idx, value=content)
                self._cells[(row_idx, col_idx)] = cell

        elif isinstance(iterable, dict):
            for col_idx, content in iterable.items():
                if isinstance(col_idx, str):
                    col_idx = column_index_from_string(col_idx)
                cell = Cell(self, row=row_idx, column=col_idx, value=content)
                self._cells[(row_idx, col_idx)] = cell

        else:
            self._invalid_row(iterable)

        self._current_row = row_idx


    def _move_cells(self, min_row=None, min_col=None, offset=0, row_or_col="row"):
        """
        Move either rows or columns around by the offset
        """
        reverse = offset > 0 # start at the end if inserting
        row_offset = 0
        col_offset = 0

        # need to make affected ranges contiguous
        if row_or_col == 'row':
            cells = self.iter_rows(min_row=min_row)
            row_offset = offset
            key = 0
        else:
            cells = self.iter_cols(min_col=min_col)
            col_offset = offset
            key = 1
        cells = list(cells)

        for row, column in sorted(self._cells, key=itemgetter(key), reverse=reverse):
            if min_row and row < min_row:
                continue
            elif min_col and column < min_col:
                continue

            self._move_cell(row, column, row_offset, col_offset)


    def insert_rows(self, idx, amount=1):
        """
        Insert row or rows before row==idx
        """
        self._move_cells(min_row=idx, offset=amount, row_or_col="row")
        self._current_row = self.max_row


    def insert_cols(self, idx, amount=1):
        """
        Insert column or columns before col==idx
        """
        self._move_cells(min_col=idx, offset=amount, row_or_col="column")


    def delete_rows(self, idx, amount=1):
        """
        Delete row or rows from row==idx
        """

        remainder = _gutter(idx, amount, self.max_row)

        self._move_cells(min_row=idx+amount, offset=-amount, row_or_col="row")

        # calculating min and max col is an expensive operation, do it only once
        min_col = self.min_column
        max_col = self.max_column + 1
        for row in remainder:
            for col in range(min_col, max_col):
                if (row, col) in self._cells:
                    del self._cells[row, col]
        self._current_row = self.max_row
        if not self._cells:
            self._current_row = 0


    def delete_cols(self, idx, amount=1):
        """
        Delete column or columns from col==idx
        """

        remainder = _gutter(idx, amount, self.max_column)

        self._move_cells(min_col=idx+amount, offset=-amount, row_or_col="column")

        # calculating min and max row is an expensive operation, do it only once
        min_row = self.min_row
        max_row = self.max_row + 1
        for col in remainder:
            for row in range(min_row, max_row):
                if (row, col) in self._cells:
                    del self._cells[row, col]


    def move_range(self, cell_range, rows=0, cols=0, translate=False):
        """
        Move a cell range by the number of rows and/or columns:
        down if rows > 0 and up if rows < 0
        right if cols > 0 and left if cols < 0
        Existing cells will be overwritten.
        Formulae and references will not be updated.
        """
        if isinstance(cell_range, str):
            cell_range = CellRange(cell_range)
        if not isinstance(cell_range, CellRange):
            raise ValueError("Only CellRange objects can be moved")
        if not rows and not cols:
            return

        down = rows > 0
        right = cols > 0

        if rows:
            cells = sorted(cell_range.rows, reverse=down)
        else:
            cells = sorted(cell_range.cols, reverse=right)

        for row, col in chain.from_iterable(cells):
            self._move_cell(row, col, rows, cols, translate)

        # rebase moved range
        cell_range.shift(row_shift=rows, col_shift=cols)


    def _move_cell(self, row, column, row_offset, col_offset, translate=False):
        """
        Move a cell from one place to another.
        Delete at old index
        Rebase coordinate
        """
        cell = self._get_cell(row, column)
        new_row = cell.row + row_offset
        new_col = cell.column + col_offset
        self._cells[new_row, new_col] = cell
        del self._cells[(cell.row, cell.column)]
        cell.row = new_row
        cell.column = new_col
        if translate and cell.data_type == "f":
            t = Translator(cell.value, cell.coordinate)
            cell.value = t.translate_formula(row_delta=row_offset, col_delta=col_offset)


    def _invalid_row(self, iterable):
        raise TypeError('Value must be a list, tuple, range or generator, or a dict. Supplied value is {0}'.format(
            type(iterable))
                        )


    def _add_column(self):
        """Dimension factory for column information"""

        return ColumnDimension(self)

    def _add_row(self):
        """Dimension factory for row information"""

        return RowDimension(self)


    @property
    def print_title_rows(self):
        """Rows to be printed at the top of every page (ex: '1:3')"""
        if self._print_rows:
            return str(self._print_rows)


    @print_title_rows.setter
    def print_title_rows(self, rows):
        """
        Set rows to be printed on the top of every page
        format `1:3`
        """
        if rows is not None:
            self._print_rows = RowRange(rows)


    @property
    def print_title_cols(self):
        """Columns to be printed at the left side of every page (ex: 'A:C')"""
        if self._print_cols:
            return str(self._print_cols)


    @print_title_cols.setter
    def print_title_cols(self, cols):
        """
        Set cols to be printed on the left of every page
        format ``A:C`
        """
        if cols is not None:
            self._print_cols = ColRange(cols)


    @property
    def print_titles(self):
        titles = PrintTitles(cols=self._print_cols, rows=self._print_rows, title=self.title)
        return str(titles)


    @property
    def print_area(self):
        """
        The print area for the worksheet, or None if not set. To set, supply a range
        like 'A1:D4' or a list of ranges.
        """
        self._print_area.title = self.title
        return str(self._print_area)


    @print_area.setter
    def print_area(self, value):
        """
        Range of cells in the form A1:D4 or list of ranges. Print area can be cleared
        by passing `None` or an empty list
        """
        if not value:
            self._print_area = PrintArea()
        elif isinstance(value, str):
            self._print_area = PrintArea.from_string(value)
        elif hasattr(value, "__iter__"):
            self._print_area = PrintArea.from_string(",".join(value))


def _gutter(idx, offset, max_val):
    """
    When deleting rows and columns are deleted we rely on overwriting.
    This may not be the case for a large offset on small set of cells:
    range(cells_to_delete) > range(cell_to_be_moved)
    """
    gutter = range(max(max_val+1-offset, idx), min(idx+offset, max_val)+1)
    return gutter

```

---

### File: `tmp\openpyxl_sdist\openpyxl-3.1.5\openpyxl\writer\__init__.py`

```python
# Copyright (c) 2010-2024 openpyxl

```

---

### File: `tmp\openpyxl_sdist\openpyxl-3.1.5\openpyxl\writer\excel.py`

```python
# Copyright (c) 2010-2024 openpyxl


# Python stdlib imports
import datetime
import re
from zipfile import ZipFile, ZIP_DEFLATED

# package imports
from openpyxl.utils.exceptions import InvalidFileException
from openpyxl.xml.constants import (
    ARC_ROOT_RELS,
    ARC_WORKBOOK_RELS,
    ARC_APP,
    ARC_CORE,
    ARC_CUSTOM,
    CPROPS_TYPE,
    ARC_THEME,
    ARC_STYLE,
    ARC_WORKBOOK,
    )
from openpyxl.drawing.spreadsheet_drawing import SpreadsheetDrawing
from openpyxl.xml.functions import tostring, fromstring
from openpyxl.packaging.manifest import Manifest
from openpyxl.packaging.relationship import (
    get_rels_path,
    RelationshipList,
    Relationship,
)
from openpyxl.comments.comment_sheet import CommentSheet
from openpyxl.styles.stylesheet import write_stylesheet
from openpyxl.worksheet._writer import WorksheetWriter
from openpyxl.workbook._writer import WorkbookWriter
from .theme import theme_xml


class ExcelWriter:
    """Write a workbook object to an Excel file."""

    def __init__(self, workbook, archive):
        self._archive = archive
        self.workbook = workbook
        self.manifest = Manifest()
        self.vba_modified = set()
        self._tables = []
        self._charts = []
        self._images = []
        self._drawings = []
        self._comments = []
        self._pivots = []


    def write_data(self):
        from openpyxl.packaging.extended import ExtendedProperties
        """Write the various xml files into the zip archive."""
        # cleanup all worksheets
        archive = self._archive

        props = ExtendedProperties()
        archive.writestr(ARC_APP, tostring(props.to_tree()))

        archive.writestr(ARC_CORE, tostring(self.workbook.properties.to_tree()))
        if self.workbook.loaded_theme:
            archive.writestr(ARC_THEME, self.workbook.loaded_theme)
        else:
            archive.writestr(ARC_THEME, theme_xml)

        if len(self.workbook.custom_doc_props) >= 1:
            archive.writestr(ARC_CUSTOM, tostring(self.workbook.custom_doc_props.to_tree()))
            class CustomOverride():
                path = "/" + ARC_CUSTOM #PartName
                mime_type = CPROPS_TYPE #ContentType

            custom_override = CustomOverride()
            self.manifest.append(custom_override)

        self._write_worksheets()
        self._write_chartsheets()
        self._write_images()
        self._write_charts()

        self._write_external_links()

        stylesheet = write_stylesheet(self.workbook)
        archive.writestr(ARC_STYLE, tostring(stylesheet))

        writer = WorkbookWriter(self.workbook)
        archive.writestr(ARC_ROOT_RELS, writer.write_root_rels())
        archive.writestr(ARC_WORKBOOK, writer.write())
        archive.writestr(ARC_WORKBOOK_RELS, writer.write_rels())

        self._merge_vba()

        self.manifest._write(archive, self.workbook)

    def _merge_vba(self):
        """
        If workbook contains macros then extract associated files from cache
        of old file and add to archive
        """
        ARC_VBA = re.compile("|".join(
            ('xl/vba', r'xl/drawings/.*vmlDrawing\d\.vml',
             'xl/ctrlProps', 'customUI', 'xl/activeX', r'xl/media/.*\.emf')
        )
                             )

        if self.workbook.vba_archive:
            for name in set(self.workbook.vba_archive.namelist()) - self.vba_modified:
                if ARC_VBA.match(name):
                    self._archive.writestr(name, self.workbook.vba_archive.read(name))


    def _write_images(self):
        # delegate to object
        for img in self._images:
            self._archive.writestr(img.path[1:], img._data())


    def _write_charts(self):
        # delegate to object
        if len(self._charts) != len(set(self._charts)):
            raise InvalidFileException("The same chart cannot be used in more than one worksheet")
        for chart in self._charts:
            self._archive.writestr(chart.path[1:], tostring(chart._write()))
            self.manifest.append(chart)


    def _write_drawing(self, drawing):
        """
        Write a drawing
        """
        self._drawings.append(drawing)
        drawing._id = len(self._drawings)
        for chart in drawing.charts:
            self._charts.append(chart)
            chart._id = len(self._charts)
        for img in drawing.images:
            self._images.append(img)
            img._id = len(self._images)
        rels_path = get_rels_path(drawing.path)[1:]
        self._archive.writestr(drawing.path[1:], tostring(drawing._write()))
        self._archive.writestr(rels_path, tostring(drawing._write_rels()))
        self.manifest.append(drawing)


    def _write_chartsheets(self):
        for idx, sheet in enumerate(self.workbook.chartsheets, 1):

            sheet._id = idx
            xml = tostring(sheet.to_tree())

            self._archive.writestr(sheet.path[1:], xml)
            self.manifest.append(sheet)

            if sheet._drawing:
                self._write_drawing(sheet._drawing)

                rel = Relationship(type="drawing", Target=sheet._drawing.path)
                rels = RelationshipList()
                rels.append(rel)
                tree = rels.to_tree()

                rels_path = get_rels_path(sheet.path[1:])
                self._archive.writestr(rels_path, tostring(tree))


    def _write_comment(self, ws):

        cs = CommentSheet.from_comments(ws._comments)
        self._comments.append(cs)
        cs._id = len(self._comments)
        self._archive.writestr(cs.path[1:], tostring(cs.to_tree()))
        self.manifest.append(cs)

        if ws.legacy_drawing is None or self.workbook.vba_archive is None:
            ws.legacy_drawing = 'xl/drawings/commentsDrawing{0}.vml'.format(cs._id)
            vml = None
        else:
            vml = fromstring(self.workbook.vba_archive.read(ws.legacy_drawing))

        vml = cs.write_shapes(vml)

        self._archive.writestr(ws.legacy_drawing, vml)
        self.vba_modified.add(ws.legacy_drawing)

        comment_rel = Relationship(Id="comments", type=cs._rel_type, Target=cs.path)
        ws._rels.append(comment_rel)


    def write_worksheet(self, ws):
        ws._drawing = SpreadsheetDrawing()
        ws._drawing.charts = ws._charts
        ws._drawing.images = ws._images
        if self.workbook.write_only:
            if not ws.closed:
                ws.close()
            writer = ws._writer
        else:
            writer = WorksheetWriter(ws)
            writer.write()

        ws._rels = writer._rels
        self._archive.write(writer.out, ws.path[1:])
        self.manifest.append(ws)
        writer.cleanup()


    def _write_worksheets(self):

        pivot_caches = set()

        for idx, ws in enumerate(self.workbook.worksheets, 1):

            ws._id = idx
            self.write_worksheet(ws)

            if ws._drawing:
                self._write_drawing(ws._drawing)

                for r in ws._rels:
                    if "drawing" in r.Type:
                        r.Target = ws._drawing.path

            if ws._comments:
                self._write_comment(ws)

            if ws.legacy_drawing is not None:
                shape_rel = Relationship(type="vmlDrawing", Id="anysvml",
                                         Target="/" + ws.legacy_drawing)
                ws._rels.append(shape_rel)

            for t in ws._tables.values():
                self._tables.append(t)
                t.id = len(self._tables)
                t._write(self._archive)
                self.manifest.append(t)
                ws._rels.get(t._rel_id).Target = t.path

            for p in ws._pivots:
                if p.cache not in pivot_caches:
                    pivot_caches.add(p.cache)
                    p.cache._id = len(pivot_caches)

                self._pivots.append(p)
                p._id = len(self._pivots)
                p._write(self._archive, self.manifest)
                self.workbook._pivots.append(p)
                r = Relationship(Type=p.rel_type, Target=p.path)
                ws._rels.append(r)

            if ws._rels:
                tree = ws._rels.to_tree()
                rels_path = get_rels_path(ws.path)[1:]
                self._archive.writestr(rels_path, tostring(tree))


    def _write_external_links(self):
        # delegate to object
        """Write links to external workbooks"""
        wb = self.workbook
        for idx, link in enumerate(wb._external_links, 1):
            link._id = idx
            rels_path = get_rels_path(link.path[1:])

            xml = link.to_tree()
            self._archive.writestr(link.path[1:], tostring(xml))
            rels = RelationshipList()
            rels.append(link.file_link)
            self._archive.writestr(rels_path, tostring(rels.to_tree()))
            self.manifest.append(link)


    def save(self):
        """Write data into the archive."""
        self.write_data()
        self._archive.close()


def save_workbook(workbook, filename):
    """Save the given workbook on the filesystem under the name filename.

    :param workbook: the workbook to save
    :type workbook: :class:`openpyxl.workbook.Workbook`

    :param filename: the path to which save the workbook
    :type filename: string

    :rtype: bool

    """
    archive = ZipFile(filename, 'w', ZIP_DEFLATED, allowZip64=True)
    workbook.properties.modified = datetime.datetime.now(tz=datetime.timezone.utc).replace(tzinfo=None)
    writer = ExcelWriter(workbook, archive)
    writer.save()
    return True

```

---

### File: `tmp\openpyxl_sdist\openpyxl-3.1.5\openpyxl\writer\theme.py`

```python
# Copyright (c) 2010-2024 openpyxl

"""Write the theme xml based on a fixed string."""


theme_xml = """<?xml version="1.0"?>
<a:theme xmlns:a="http://schemas.openxmlformats.org/drawingml/2006/main" name="Office Theme">
  <a:themeElements>
    <a:clrScheme name="Office">
      <a:dk1>
        <a:sysClr val="windowText" lastClr="000000"/>
      </a:dk1>
      <a:lt1>
        <a:sysClr val="window" lastClr="FFFFFF"/>
      </a:lt1>
      <a:dk2>
        <a:srgbClr val="1F497D"/>
      </a:dk2>
      <a:lt2>
        <a:srgbClr val="EEECE1"/>
      </a:lt2>
      <a:accent1>
        <a:srgbClr val="4F81BD"/>
      </a:accent1>
      <a:accent2>
        <a:srgbClr val="C0504D"/>
      </a:accent2>
      <a:accent3>
        <a:srgbClr val="9BBB59"/>
      </a:accent3>
      <a:accent4>
        <a:srgbClr val="8064A2"/>
      </a:accent4>
      <a:accent5>
        <a:srgbClr val="4BACC6"/>
      </a:accent5>
      <a:accent6>
        <a:srgbClr val="F79646"/>
      </a:accent6>
      <a:hlink>
        <a:srgbClr val="0000FF"/>
      </a:hlink>
      <a:folHlink>
        <a:srgbClr val="800080"/>
      </a:folHlink>
    </a:clrScheme>
    <a:fontScheme name="Office">
      <a:majorFont>
        <a:latin typeface="Cambria"/>
        <a:ea typeface=""/>
        <a:cs typeface=""/>
        <a:font script="Jpan" typeface="&#xFF2D;&#xFF33; &#xFF30;&#x30B4;&#x30B7;&#x30C3;&#x30AF;"/>
        <a:font script="Hang" typeface="&#xB9D1;&#xC740; &#xACE0;&#xB515;"/>
        <a:font script="Hans" typeface="&#x5B8B;&#x4F53;"/>
        <a:font script="Hant" typeface="&#x65B0;&#x7D30;&#x660E;&#x9AD4;"/>
        <a:font script="Arab" typeface="Times New Roman"/>
        <a:font script="Hebr" typeface="Times New Roman"/>
        <a:font script="Thai" typeface="Tahoma"/>
        <a:font script="Ethi" typeface="Nyala"/>
        <a:font script="Beng" typeface="Vrinda"/>
        <a:font script="Gujr" typeface="Shruti"/>
        <a:font script="Khmr" typeface="MoolBoran"/>
        <a:font script="Knda" typeface="Tunga"/>
        <a:font script="Guru" typeface="Raavi"/>
        <a:font script="Cans" typeface="Euphemia"/>
        <a:font script="Cher" typeface="Plantagenet Cherokee"/>
        <a:font script="Yiii" typeface="Microsoft Yi Baiti"/>
        <a:font script="Tibt" typeface="Microsoft Himalaya"/>
        <a:font script="Thaa" typeface="MV Boli"/>
        <a:font script="Deva" typeface="Mangal"/>
        <a:font script="Telu" typeface="Gautami"/>
        <a:font script="Taml" typeface="Latha"/>
        <a:font script="Syrc" typeface="Estrangelo Edessa"/>
        <a:font script="Orya" typeface="Kalinga"/>
        <a:font script="Mlym" typeface="Kartika"/>
        <a:font script="Laoo" typeface="DokChampa"/>
        <a:font script="Sinh" typeface="Iskoola Pota"/>
        <a:font script="Mong" typeface="Mongolian Baiti"/>
        <a:font script="Viet" typeface="Times New Roman"/>
        <a:font script="Uigh" typeface="Microsoft Uighur"/>
      </a:majorFont>
      <a:minorFont>
        <a:latin typeface="Calibri"/>
        <a:ea typeface=""/>
        <a:cs typeface=""/>
        <a:font script="Jpan" typeface="&#xFF2D;&#xFF33; &#xFF30;&#x30B4;&#x30B7;&#x30C3;&#x30AF;"/>
        <a:font script="Hang" typeface="&#xB9D1;&#xC740; &#xACE0;&#xB515;"/>
        <a:font script="Hans" typeface="&#x5B8B;&#x4F53;"/>
        <a:font script="Hant" typeface="&#x65B0;&#x7D30;&#x660E;&#x9AD4;"/>
        <a:font script="Arab" typeface="Arial"/>
        <a:font script="Hebr" typeface="Arial"/>
        <a:font script="Thai" typeface="Tahoma"/>
        <a:font script="Ethi" typeface="Nyala"/>
        <a:font script="Beng" typeface="Vrinda"/>
        <a:font script="Gujr" typeface="Shruti"/>
        <a:font script="Khmr" typeface="DaunPenh"/>
        <a:font script="Knda" typeface="Tunga"/>
        <a:font script="Guru" typeface="Raavi"/>
        <a:font script="Cans" typeface="Euphemia"/>
        <a:font script="Cher" typeface="Plantagenet Cherokee"/>
        <a:font script="Yiii" typeface="Microsoft Yi Baiti"/>
        <a:font script="Tibt" typeface="Microsoft Himalaya"/>
        <a:font script="Thaa" typeface="MV Boli"/>
        <a:font script="Deva" typeface="Mangal"/>
        <a:font script="Telu" typeface="Gautami"/>
        <a:font script="Taml" typeface="Latha"/>
        <a:font script="Syrc" typeface="Estrangelo Edessa"/>
        <a:font script="Orya" typeface="Kalinga"/>
        <a:font script="Mlym" typeface="Kartika"/>
        <a:font script="Laoo" typeface="DokChampa"/>
        <a:font script="Sinh" typeface="Iskoola Pota"/>
        <a:font script="Mong" typeface="Mongolian Baiti"/>
        <a:font script="Viet" typeface="Arial"/>
        <a:font script="Uigh" typeface="Microsoft Uighur"/>
      </a:minorFont>
    </a:fontScheme>
    <a:fmtScheme name="Office">
      <a:fillStyleLst>
        <a:solidFill>
          <a:schemeClr val="phClr"/>
        </a:solidFill>
        <a:gradFill rotWithShape="1">
          <a:gsLst>
            <a:gs pos="0">
              <a:schemeClr val="phClr">
                <a:tint val="50000"/>
                <a:satMod val="300000"/>
              </a:schemeClr>
            </a:gs>
            <a:gs pos="35000">
              <a:schemeClr val="phClr">
                <a:tint val="37000"/>
                <a:satMod val="300000"/>
              </a:schemeClr>
            </a:gs>
            <a:gs pos="100000">
              <a:schemeClr val="phClr">
                <a:tint val="15000"/>
                <a:satMod val="350000"/>
              </a:schemeClr>
            </a:gs>
          </a:gsLst>
          <a:lin ang="16200000" scaled="1"/>
        </a:gradFill>
        <a:gradFill rotWithShape="1">
          <a:gsLst>
            <a:gs pos="0">
              <a:schemeClr val="phClr">
                <a:shade val="51000"/>
                <a:satMod val="130000"/>
              </a:schemeClr>
            </a:gs>
            <a:gs pos="80000">
              <a:schemeClr val="phClr">
                <a:shade val="93000"/>
                <a:satMod val="130000"/>
              </a:schemeClr>
            </a:gs>
            <a:gs pos="100000">
              <a:schemeClr val="phClr">
                <a:shade val="94000"/>
                <a:satMod val="135000"/>
              </a:schemeClr>
            </a:gs>
          </a:gsLst>
          <a:lin ang="16200000" scaled="0"/>
        </a:gradFill>
      </a:fillStyleLst>
      <a:lnStyleLst>
        <a:ln w="9525" cap="flat" cmpd="sng" algn="ctr">
          <a:solidFill>
            <a:schemeClr val="phClr">
              <a:shade val="95000"/>
              <a:satMod val="105000"/>
            </a:schemeClr>
          </a:solidFill>
          <a:prstDash val="solid"/>
        </a:ln>
        <a:ln w="25400" cap="flat" cmpd="sng" algn="ctr">
          <a:solidFill>
            <a:schemeClr val="phClr"/>
          </a:solidFill>
          <a:prstDash val="solid"/>
        </a:ln>
        <a:ln w="38100" cap="flat" cmpd="sng" algn="ctr">
          <a:solidFill>
            <a:schemeClr val="phClr"/>
          </a:solidFill>
          <a:prstDash val="solid"/>
        </a:ln>
      </a:lnStyleLst>
      <a:effectStyleLst>
        <a:effectStyle>
          <a:effectLst>
            <a:outerShdw blurRad="40000" dist="20000" dir="5400000" rotWithShape="0">
              <a:srgbClr val="000000">
                <a:alpha val="38000"/>
              </a:srgbClr>
            </a:outerShdw>
          </a:effectLst>
        </a:effectStyle>
        <a:effectStyle>
          <a:effectLst>
            <a:outerShdw blurRad="40000" dist="23000" dir="5400000" rotWithShape="0">
              <a:srgbClr val="000000">
                <a:alpha val="35000"/>
              </a:srgbClr>
            </a:outerShdw>
          </a:effectLst>
        </a:effectStyle>
        <a:effectStyle>
          <a:effectLst>
            <a:outerShdw blurRad="40000" dist="23000" dir="5400000" rotWithShape="0">
              <a:srgbClr val="000000">
                <a:alpha val="35000"/>
              </a:srgbClr>
            </a:outerShdw>
          </a:effectLst>
          <a:scene3d>
            <a:camera prst="orthographicFront">
              <a:rot lat="0" lon="0" rev="0"/>
            </a:camera>
            <a:lightRig rig="threePt" dir="t">
              <a:rot lat="0" lon="0" rev="1200000"/>
            </a:lightRig>
          </a:scene3d>
          <a:sp3d>
            <a:bevelT w="63500" h="25400"/>
          </a:sp3d>
        </a:effectStyle>
      </a:effectStyleLst>
      <a:bgFillStyleLst>
        <a:solidFill>
          <a:schemeClr val="phClr"/>
        </a:solidFill>
        <a:gradFill rotWithShape="1">
          <a:gsLst>
            <a:gs pos="0">
              <a:schemeClr val="phClr">
                <a:tint val="40000"/>
                <a:satMod val="350000"/>
              </a:schemeClr>
            </a:gs>
            <a:gs pos="40000">
              <a:schemeClr val="phClr">
                <a:tint val="45000"/>
                <a:shade val="99000"/>
                <a:satMod val="350000"/>
              </a:schemeClr>
            </a:gs>
            <a:gs pos="100000">
              <a:schemeClr val="phClr">
                <a:shade val="20000"/>
                <a:satMod val="255000"/>
              </a:schemeClr>
            </a:gs>
          </a:gsLst>
          <a:path path="circle">
            <a:fillToRect l="50000" t="-80000" r="50000" b="180000"/>
          </a:path>
        </a:gradFill>
        <a:gradFill rotWithShape="1">
          <a:gsLst>
            <a:gs pos="0">
              <a:schemeClr val="phClr">
                <a:tint val="80000"/>
                <a:satMod val="300000"/>
              </a:schemeClr>
            </a:gs>
            <a:gs pos="100000">
              <a:schemeClr val="phClr">
                <a:shade val="30000"/>
                <a:satMod val="200000"/>
              </a:schemeClr>
            </a:gs>
          </a:gsLst>
          <a:path path="circle">
            <a:fillToRect l="50000" t="50000" r="50000" b="50000"/>
          </a:path>
        </a:gradFill>
      </a:bgFillStyleLst>
    </a:fmtScheme>
  </a:themeElements>
  <a:objectDefaults/>
  <a:extraClrSchemeLst/>
</a:theme>
"""

def write_theme():
    """Write the theme xml."""
    return theme_xml

```

---

### File: `tmp\openpyxl_sdist\openpyxl-3.1.5\openpyxl\xml\__init__.py`

```python
# Copyright (c) 2010-2024 openpyxl


"""Collection of XML resources compatible across different Python versions"""
import os


def lxml_available():
    try:
        from lxml.etree import LXML_VERSION
        LXML = LXML_VERSION >= (3, 3, 1, 0)
        if not LXML:
            import warnings
            warnings.warn("The installed version of lxml is too old to be used with openpyxl")
            return False  # we have it, but too old
        else:
            return True  # we have it, and recent enough
    except ImportError:
        return False  # we don't even have it


def lxml_env_set():
    return os.environ.get("OPENPYXL_LXML", "True") == "True"


LXML = lxml_available() and lxml_env_set()


def defusedxml_available():
    try:
        import defusedxml # noqa
    except ImportError:
        return False
    else:
        return True


def defusedxml_env_set():
    return os.environ.get("OPENPYXL_DEFUSEDXML", "True") == "True"


DEFUSEDXML = defusedxml_available() and defusedxml_env_set()

```

---

### File: `tmp\openpyxl_sdist\openpyxl-3.1.5\openpyxl\xml\constants.py`

```python
# Copyright (c) 2010-2024 openpyxl


"""Constants for fixed paths in a file and xml namespace urls."""

MIN_ROW = 0
MIN_COLUMN = 0
MAX_COLUMN = 16384
MAX_ROW = 1048576

# constants
PACKAGE_PROPS = 'docProps'
PACKAGE_XL = 'xl'
PACKAGE_RELS = '_rels'
PACKAGE_THEME = PACKAGE_XL + '/' + 'theme'
PACKAGE_WORKSHEETS = PACKAGE_XL + '/' + 'worksheets'
PACKAGE_CHARTSHEETS = PACKAGE_XL + '/' + 'chartsheets'
PACKAGE_DRAWINGS = PACKAGE_XL + '/' + 'drawings'
PACKAGE_CHARTS = PACKAGE_XL + '/' + 'charts'
PACKAGE_IMAGES = PACKAGE_XL + '/' + 'media'
PACKAGE_WORKSHEET_RELS = PACKAGE_WORKSHEETS + '/' + '_rels'
PACKAGE_CHARTSHEETS_RELS = PACKAGE_CHARTSHEETS + '/' + '_rels'
PACKAGE_PIVOT_TABLE = PACKAGE_XL + '/' + 'pivotTables'
PACKAGE_PIVOT_CACHE = PACKAGE_XL + '/' + 'pivotCache'

ARC_CONTENT_TYPES = '[Content_Types].xml'
ARC_ROOT_RELS = PACKAGE_RELS + '/.rels'
ARC_WORKBOOK_RELS = PACKAGE_XL + '/' + PACKAGE_RELS + '/workbook.xml.rels'
ARC_CORE = PACKAGE_PROPS + '/core.xml'
ARC_APP = PACKAGE_PROPS + '/app.xml'
ARC_CUSTOM = PACKAGE_PROPS + '/custom.xml'
ARC_WORKBOOK = PACKAGE_XL + '/workbook.xml'
ARC_STYLE = PACKAGE_XL + '/styles.xml'
ARC_THEME = PACKAGE_THEME + '/theme1.xml'
ARC_SHARED_STRINGS = PACKAGE_XL + '/sharedStrings.xml'
ARC_CUSTOM_UI = 'customUI/customUI.xml'

## namespaces
# XML
XML_NS = "http://www.w3.org/XML/1998/namespace"
# Dublin Core
DCORE_NS = 'http://purl.org/dc/elements/1.1/'
DCTERMS_NS = 'http://purl.org/dc/terms/'
DCTERMS_PREFIX = 'dcterms'

# Document
DOC_NS = "http://schemas.openxmlformats.org/officeDocument/2006/"
REL_NS = DOC_NS + "relationships"
COMMENTS_NS = REL_NS + "/comments"
IMAGE_NS = REL_NS + "/image"
VML_NS =  REL_NS + "/vmlDrawing"
VTYPES_NS = DOC_NS + 'docPropsVTypes'
XPROPS_NS = DOC_NS + 'extended-properties'
CUSTPROPS_NS = DOC_NS + 'custom-properties'
EXTERNAL_LINK_NS = REL_NS + "/externalLink"

# CustomDocumentProperty FMTID:
CPROPS_FMTID = "{D5CDD505-2E9C-101B-9397-08002B2CF9AE}"

# Package
PKG_NS = "http://schemas.openxmlformats.org/package/2006/"
PKG_REL_NS = PKG_NS + "relationships"
COREPROPS_NS = PKG_NS + 'metadata/core-properties'
CONTYPES_NS = PKG_NS + 'content-types'

XSI_NS = 'http://www.w3.org/2001/XMLSchema-instance'
XML_NS = 'http://www.w3.org/XML/1998/namespace'
SHEET_MAIN_NS = 'http://schemas.openxmlformats.org/spreadsheetml/2006/main'

# Drawing
CHART_NS = "http://schemas.openxmlformats.org/drawingml/2006/chart"
DRAWING_NS = "http://schemas.openxmlformats.org/drawingml/2006/main"
SHEET_DRAWING_NS = "http://schemas.openxmlformats.org/drawingml/2006/spreadsheetDrawing"
CHART_DRAWING_NS = "http://schemas.openxmlformats.org/drawingml/2006/chartDrawing"

CUSTOMUI_NS = 'http://schemas.microsoft.com/office/2006/relationships/ui/extensibility'


NAMESPACES = {
    'cp': COREPROPS_NS,
    'dc': DCORE_NS,
    DCTERMS_PREFIX: DCTERMS_NS,
    'dcmitype': 'http://purl.org/dc/dcmitype/',
    'xsi': XSI_NS,
    'vt': VTYPES_NS,
    'xml': XML_NS,
    'main': SHEET_MAIN_NS,
    'cust': CUSTPROPS_NS,
}

## Mime types
WORKBOOK_MACRO = "application/vnd.ms-excel.%s.macroEnabled.main+xml"
WORKBOOK = "application/vnd.openxmlformats-officedocument.spreadsheetml.%s.main+xml"
SPREADSHEET = "application/vnd.openxmlformats-officedocument.spreadsheetml.%s+xml"
SHARED_STRINGS = SPREADSHEET % "sharedStrings"
EXTERNAL_LINK = SPREADSHEET % "externalLink"
WORKSHEET_TYPE = SPREADSHEET % "worksheet"
COMMENTS_TYPE = SPREADSHEET % "comments"
STYLES_TYPE = SPREADSHEET % "styles"
CHARTSHEET_TYPE = SPREADSHEET % "chartsheet"
DRAWING_TYPE = "application/vnd.openxmlformats-officedocument.drawing+xml"
CHART_TYPE = "application/vnd.openxmlformats-officedocument.drawingml.chart+xml"
CHARTSHAPE_TYPE = "application/vnd.openxmlformats-officedocument.drawingml.chartshapes+xml"
THEME_TYPE = "application/vnd.openxmlformats-officedocument.theme+xml"
CPROPS_TYPE = "application/vnd.openxmlformats-officedocument.custom-properties+xml"
XLTM = WORKBOOK_MACRO % 'template'
XLSM = WORKBOOK_MACRO % 'sheet'
XLTX = WORKBOOK % 'template'
XLSX = WORKBOOK % 'sheet'


# Extensions to the specification

EXT_TYPES = {
    '{78C0D931-6437-407D-A8EE-F0AAD7539E65}': 'Conditional Formatting',
    '{CCE6A557-97BC-4B89-ADB6-D9C93CAAB3DF}': 'Data Validation',
    '{05C60535-1F16-4FD2-B633-F4F36F0B64E0}': 'Sparkline Group',
    '{A8765BA9-456A-4DAB-B4F3-ACF838C121DE}': 'Slicer List',
    '{FC87AEE6-9EDD-4A0A-B7FB-166176984837}': 'Protected Range',
    '{01252117-D84E-4E92-8308-4BE1C098FCBB}': 'Ignored Error',
    '{F7C9EE02-42E1-4005-9D12-6889AFFD525C}': 'Web Extension',
    '{3A4CF648-6AED-40f4-86FF-DC5316D8AED3}': 'Slicer List',
    '{7E03D99C-DC04-49d9-9315-930204A7B6E9}': 'Timeline Ref',
}

# Objects related to macros that we preserve
CTRL = "application/vnd.ms-excel.controlproperties+xml"
ACTIVEX = "application/vnd.ms-office.activeX+xml"
VBA = "application/vnd.ms-office.vbaProject"

```

---

### File: `tmp\openpyxl_sdist\openpyxl-3.1.5\openpyxl\xml\functions.py`

```python
# Copyright (c) 2010-2024 openpyxl

"""
XML compatibility functions
"""

# Python stdlib imports
import re
from functools import partial

from openpyxl import DEFUSEDXML, LXML

if LXML is True:
    from lxml.etree import (
    Element,
    SubElement,
    register_namespace,
    QName,
    xmlfile,
    XMLParser,
    )
    from lxml.etree import fromstring, tostring
    # do not resolve entities
    safe_parser = XMLParser(resolve_entities=False)
    fromstring = partial(fromstring, parser=safe_parser)

else:
    from xml.etree.ElementTree import (
    Element,
    SubElement,
    fromstring,
    tostring,
    QName,
    register_namespace
    )
    from et_xmlfile import xmlfile
    if DEFUSEDXML is True:
        from defusedxml.ElementTree import fromstring

from xml.etree.ElementTree import iterparse
if DEFUSEDXML is True:
    from defusedxml.ElementTree import iterparse

from openpyxl.xml.constants import (
    CHART_NS,
    DRAWING_NS,
    SHEET_DRAWING_NS,
    CHART_DRAWING_NS,
    SHEET_MAIN_NS,
    REL_NS,
    VTYPES_NS,
    COREPROPS_NS,
    CUSTPROPS_NS,
    DCTERMS_NS,
    DCTERMS_PREFIX,
    XML_NS
)

register_namespace(DCTERMS_PREFIX, DCTERMS_NS)
register_namespace('dcmitype', 'http://purl.org/dc/dcmitype/')
register_namespace('cp', COREPROPS_NS)
register_namespace('c', CHART_NS)
register_namespace('a', DRAWING_NS)
register_namespace('s', SHEET_MAIN_NS)
register_namespace('r', REL_NS)
register_namespace('vt', VTYPES_NS)
register_namespace('xdr', SHEET_DRAWING_NS)
register_namespace('cdr', CHART_DRAWING_NS)
register_namespace('xml', XML_NS)
register_namespace('cust', CUSTPROPS_NS)


tostring = partial(tostring, encoding="utf-8")

NS_REGEX = re.compile("({(?P<namespace>.*)})?(?P<localname>.*)")

def localname(node):
    if callable(node.tag):
        return "comment"
    m = NS_REGEX.match(node.tag)
    return m.group('localname')


def whitespace(node):
    stripped = node.text.strip()
    if stripped and node.text != stripped:
        node.set("{%s}space" % XML_NS, "preserve")

```

---

### File: `tmp\openpyxl_sdist\openpyxl-3.1.5\setup.py`

```python
#!/usr/bin/env python

"""Setup script for packaging openpyxl.

To build a package for distribution:
    python setup.py sdist
and upload it to the PyPI with:
    python setup.py upload

Install a link for development work:
    pip install -e .

Thee manifest.in file is used for data files.

"""

import os
import sys

from setuptools import setup, find_packages

here = os.path.abspath(os.path.dirname(__file__))
try:
    with open(os.path.join(here, 'README.rst')) as f:
        README = f.read()
except IOError:
    README = ''

from importlib.util import module_from_spec, spec_from_file_location
spec = spec_from_file_location("constants", "./openpyxl/_constants.py")
constants = module_from_spec(spec)
spec.loader.exec_module(constants)

__author__ = constants.__author__
__author_email__ = constants.__author_email__
__license__ = constants.__license__
__maintainer_email__ = constants.__maintainer_email__
__url__ = constants.__url__
__version__ = constants.__version__
__python__ = constants.__python__

def cythonize_modules():
    from Cython.Build import cythonize
    return cythonize([
        "openpyxl/worksheet/_reader.py",
        "openpyxl/worksheet/_writer.py",
        "openpyxl/utils/cell.py",
        ],
        nthreads=3,
        language_level=3,
    )


try:
    sys.argv.remove("--with-cython")
except ValueError:
    ext_modules = None
else:
    ext_modules = cythonize_modules()


setup(
    name='openpyxl',
    packages=find_packages(".",
        exclude=["*.tests", "scratchpad*", "*.c",]
        ),
    ext_modules=ext_modules,
    package_dir={},
    # metadata
    version=__version__,
    description="A Python library to read/write Excel 2010 xlsx/xlsm files",
    long_description=README,
    author=__author__,
    author_email=__author_email__,
    url=__url__,
    license=__license__,
    python_requires=f">={__python__}",
    install_requires=[
        'et_xmlfile',
        ],
    project_urls={
        'Documentation': 'https://openpyxl.readthedocs.io/en/stable/',
        'Source': 'https://foss.heptapod.net/openpyxl/openpyxl',
        'Tracker': 'https://foss.heptapod.net/openpyxl/openpyxl/-/issues',
    },
    classifiers=[
                 'Development Status :: 5 - Production/Stable',
                 'Operating System :: MacOS :: MacOS X',
                 'Operating System :: Microsoft :: Windows',
                 'Operating System :: POSIX',
                 'License :: OSI Approved :: MIT License',
                 'Programming Language :: Python',
                 'Programming Language :: Python :: 3.6',
                 'Programming Language :: Python :: 3.7',
                 'Programming Language :: Python :: 3.8',
                 'Programming Language :: Python :: 3.9',
                 'Programming Language :: Python :: 3.10',
                 'Programming Language :: Python :: 3.11',
                 ],
    )

```

---

### File: `tmp\xlsxwriter_old\XlsxWriter-1.4.5\examples\array_formula.py`

```python
#######################################################################
#
# Example of how to use Python and the XlsxWriter module to write
# simple array formulas.
#
# Copyright 2013-2021, John McNamara, jmcnamara@cpan.org
#
import xlsxwriter

# Create a new workbook and add a worksheet
workbook = xlsxwriter.Workbook('array_formula.xlsx')
worksheet = workbook.add_worksheet()

# Write some test data.
worksheet.write('B1', 500)
worksheet.write('B2', 10)
worksheet.write('B5', 1)
worksheet.write('B6', 2)
worksheet.write('B7', 3)
worksheet.write('C1', 300)
worksheet.write('C2', 15)
worksheet.write('C5', 20234)
worksheet.write('C6', 21003)
worksheet.write('C7', 10000)


# Write an array formula that returns a single value
worksheet.write_formula('A1', '{=SUM(B1:C1*B2:C2)}')

# Same as above but more verbose.
worksheet.write_array_formula('A2:A2', '{=SUM(B1:C1*B2:C2)}')

# Write an array formula that returns a range of values
worksheet.write_array_formula('A5:A7', '{=TREND(C5:C7,B5:B7)}')

workbook.close()

```

---

### File: `tmp\xlsxwriter_old\XlsxWriter-1.4.5\examples\autofilter.py`

```python
###############################################################################
#
# An example of how to create autofilters with XlsxWriter.
#
# An autofilter is a way of adding drop down lists to the headers of a 2D
# range of worksheet data. This allows users to filter the data based on
# simple criteria so that some data is shown and some is hidden.
#
# Copyright 2013-2021, John McNamara, jmcnamara@cpan.org
#
import xlsxwriter

workbook = xlsxwriter.Workbook('autofilter.xlsx')

# Add a worksheet for each autofilter example.
worksheet1 = workbook.add_worksheet()
worksheet2 = workbook.add_worksheet()
worksheet3 = workbook.add_worksheet()
worksheet4 = workbook.add_worksheet()
worksheet5 = workbook.add_worksheet()
worksheet6 = workbook.add_worksheet()

# Add a bold format for the headers.
bold = workbook.add_format({'bold': 1})

# Open a text file with autofilter example data.
textfile = open('autofilter_data.txt')

# Read the headers from the first line of the input file.
headers = textfile.readline().strip("\n").split()


# Read the text file and store the field data.
data = []
for line in textfile:
    # Split the input data based on whitespace.
    row_data = line.strip("\n").split()

    # Convert the number data from the text file.
    for i, item in enumerate(row_data):
        try:
            row_data[i] = float(item)
        except ValueError:
            pass

    data.append(row_data)


# Set up several sheets with the same data.
for worksheet in (workbook.worksheets()):
    # Make the columns wider.
    worksheet.set_column('A:D', 12)
    # Make the header row larger.
    worksheet.set_row(0, 20, bold)
    # Make the headers bold.
    worksheet.write_row('A1', headers)


###############################################################################
#
# Example 1. Autofilter without conditions.
#

# Set the autofilter.
worksheet1.autofilter('A1:D51')

row = 1
for row_data in (data):
    worksheet1.write_row(row, 0, row_data)

    # Move on to the next worksheet row.
    row += 1


###############################################################################
#
#
# Example 2. Autofilter with a filter condition in the first column.
#

# Autofilter range using Row-Column notation.
worksheet2.autofilter(0, 0, 50, 3)

# Add filter criteria. The placeholder "Region" in the filter is
# ignored and can be any string that adds clarity to the expression.
worksheet2.filter_column(0, 'Region == East')

# Hide the rows that don't match the filter criteria.
row = 1
for row_data in (data):
    region = row_data[0]

    # Check for rows that match the filter.
    if region == 'East':
        # Row matches the filter, no further action required.
        pass
    else:
        # We need to hide rows that don't match the filter.
        worksheet2.set_row(row, options={'hidden': True})

    worksheet2.write_row(row, 0, row_data)

    # Move on to the next worksheet row.
    row += 1


###############################################################################
#
#
# Example 3. Autofilter with a dual filter condition in one of the columns.
#

# Set the autofilter.
worksheet3.autofilter('A1:D51')

# Add filter criteria.
worksheet3.filter_column('A', 'x == East or x == South')

# Hide the rows that don't match the filter criteria.
row = 1
for row_data in (data):
    region = row_data[0]

    # Check for rows that match the filter.
    if region == 'East' or region == 'South':
        # Row matches the filter, no further action required.
        pass
    else:
        # We need to hide rows that don't match the filter.
        worksheet3.set_row(row, options={'hidden': True})

    worksheet3.write_row(row, 0, row_data)

    # Move on to the next worksheet row.
    row += 1


###############################################################################
#
#
# Example 4. Autofilter with filter conditions in two columns.
#

# Set the autofilter.
worksheet4.autofilter('A1:D51')

# Add filter criteria.
worksheet4.filter_column('A', 'x == East')
worksheet4.filter_column('C', 'x > 3000 and x < 8000')

# Hide the rows that don't match the filter criteria.
row = 1
for row_data in (data):
    region = row_data[0]
    volume = int(row_data[2])

    # Check for rows that match the filter.
    if region == 'East' and volume > 3000 and volume < 8000:
        # Row matches the filter, no further action required.
        pass
    else:
        # We need to hide rows that don't match the filter.
        worksheet4.set_row(row, options={'hidden': True})

    worksheet4.write_row(row, 0, row_data)

    # Move on to the next worksheet row.
    row += 1


###############################################################################
#
#
# Example 5. Autofilter with filter for blanks.
#
# Create a blank cell in our test data.

# Set the autofilter.
worksheet5.autofilter('A1:D51')

# Add filter criteria.
worksheet5.filter_column('A', 'x == Blanks')

# Simulate a blank cell in the data.
data[5][0] = ''

# Hide the rows that don't match the filter criteria.
row = 1
for row_data in (data):
    region = row_data[0]

    # Check for rows that match the filter.
    if region == '':
        # Row matches the filter, no further action required.
        pass
    else:
        # We need to hide rows that don't match the filter.
        worksheet5.set_row(row, options={'hidden': True})

    worksheet5.write_row(row, 0, row_data)

    # Move on to the next worksheet row.
    row += 1


###############################################################################
#
#
# Example 6. Autofilter with filter for non-blanks.
#

# Set the autofilter.
worksheet6.autofilter('A1:D51')

# Add filter criteria.
worksheet6.filter_column('A', 'x == NonBlanks')

# Hide the rows that don't match the filter criteria.
row = 1
for row_data in (data):
    region = row_data[0]

    # Check for rows that match the filter.
    if region != '':
        # Row matches the filter, no further action required.
        pass
    else:
        # We need to hide rows that don't match the filter.
        worksheet6.set_row(row, options={'hidden': True})

    worksheet6.write_row(row, 0, row_data)

    # Move on to the next worksheet row.
    row += 1


workbook.close()

```

---

### File: `tmp\xlsxwriter_old\XlsxWriter-1.4.5\examples\background.py`

```python
##############################################################################
#
# An example of setting a worksheet background image with the XlsxWriter
# Python module.
#
# Copyright 2013-2021, John McNamara, jmcnamara@cpan.org
#
import xlsxwriter


# Create an new Excel file and add a worksheet.
workbook = xlsxwriter.Workbook('background.xlsx')
worksheet = workbook.add_worksheet()

# Set the background image.
worksheet.set_background('logo.png')

workbook.close()

```

---

### File: `tmp\xlsxwriter_old\XlsxWriter-1.4.5\examples\cell_indentation.py`

```python
##############################################################################
#
# A simple formatting example using XlsxWriter.
#
# This program demonstrates the indentation cell format.
#
# Copyright 2013-2021, John McNamara, jmcnamara@cpan.org
#
import xlsxwriter

workbook = xlsxwriter.Workbook('cell_indentation.xlsx')

worksheet = workbook.add_worksheet()

indent1 = workbook.add_format({'indent': 1})
indent2 = workbook.add_format({'indent': 2})

worksheet.set_column('A:A', 40)

worksheet.write('A1', "This text is indented 1 level", indent1)
worksheet.write('A2', "This text is indented 2 levels", indent2)

workbook.close()

```

---

### File: `tmp\xlsxwriter_old\XlsxWriter-1.4.5\examples\chart.py`

```python
#######################################################################
#
# An example of a simple Excel chart with Python and XlsxWriter.
#
# Copyright 2013-2021, John McNamara, jmcnamara@cpan.org
#
import xlsxwriter

workbook = xlsxwriter.Workbook('chart.xlsx')
worksheet = workbook.add_worksheet()

# Create a new Chart object.
chart = workbook.add_chart({'type': 'column'})

# Write some data to add to plot on the chart.
data = [
    [1, 2, 3, 4, 5],
    [2, 4, 6, 8, 10],
    [3, 6, 9, 12, 15],
]

worksheet.write_column('A1', data[0])
worksheet.write_column('B1', data[1])
worksheet.write_column('C1', data[2])

# Configure the charts. In simplest case we just add some data series.
chart.add_series({'values': '=Sheet1!$A$1:$A$5'})
chart.add_series({'values': '=Sheet1!$B$1:$B$5'})
chart.add_series({'values': '=Sheet1!$C$1:$C$5'})

# Insert the chart into the worksheet.
worksheet.insert_chart('A7', chart)

workbook.close()

```

---

### File: `tmp\xlsxwriter_old\XlsxWriter-1.4.5\examples\chart_area.py`

```python
#######################################################################
#
# An example of creating Excel Area charts with Python and XlsxWriter.
#
# Copyright 2013-2021, John McNamara, jmcnamara@cpan.org
#
import xlsxwriter

workbook = xlsxwriter.Workbook('chart_area.xlsx')
worksheet = workbook.add_worksheet()
bold = workbook.add_format({'bold': 1})

# Add the worksheet data that the charts will refer to.
headings = ['Number', 'Batch 1', 'Batch 2']
data = [
    [2, 3, 4, 5, 6, 7],
    [40, 40, 50, 30, 25, 50],
    [30, 25, 30, 10, 5, 10],
]

worksheet.write_row('A1', headings, bold)
worksheet.write_column('A2', data[0])
worksheet.write_column('B2', data[1])
worksheet.write_column('C2', data[2])

#######################################################################
#
# Create an area chart.
#
chart1 = workbook.add_chart({'type': 'area'})

# Configure the first series.
chart1.add_series({
    'name':       '=Sheet1!$B$1',
    'categories': '=Sheet1!$A$2:$A$7',
    'values':     '=Sheet1!$B$2:$B$7',
})

# Configure a second series. Note use of alternative syntax to define ranges.
chart1.add_series({
    'name':       ['Sheet1', 0, 2],
    'categories': ['Sheet1', 1, 0, 6, 0],
    'values':     ['Sheet1', 1, 2, 6, 2],
})

# Add a chart title and some axis labels.
chart1.set_title ({'name': 'Results of sample analysis'})
chart1.set_x_axis({'name': 'Test number'})
chart1.set_y_axis({'name': 'Sample length (mm)'})

# Set an Excel chart style.
chart1.set_style(11)

# Insert the chart into the worksheet (with an offset).
worksheet.insert_chart('D2', chart1, {'x_offset': 25, 'y_offset': 10})

#######################################################################
#
# Create a stacked area chart sub-type.
#
chart2 = workbook.add_chart({'type': 'area', 'subtype': 'stacked'})

# Configure the first series.
chart2.add_series({
    'name':       '=Sheet1!$B$1',
    'categories': '=Sheet1!$A$2:$A$7',
    'values':     '=Sheet1!$B$2:$B$7',
})

# Configure second series.
chart2.add_series({
    'name':       '=Sheet1!$C$1',
    'categories': '=Sheet1!$A$2:$A$7',
    'values':     '=Sheet1!$C$2:$C$7',
})

# Add a chart title and some axis labels.
chart2.set_title ({'name': 'Stacked Chart'})
chart2.set_x_axis({'name': 'Test number'})
chart2.set_y_axis({'name': 'Sample length (mm)'})

# Set an Excel chart style.
chart2.set_style(12)

# Insert the chart into the worksheet (with an offset).
worksheet.insert_chart('D18', chart2, {'x_offset': 25, 'y_offset': 10})

#######################################################################
#
# Create a percent stacked area chart sub-type.
#
chart3 = workbook.add_chart({'type': 'area', 'subtype': 'percent_stacked'})

# Configure the first series.
chart3.add_series({
    'name':       '=Sheet1!$B$1',
    'categories': '=Sheet1!$A$2:$A$7',
    'values':     '=Sheet1!$B$2:$B$7',
})

# Configure second series.
chart3.add_series({
    'name':       '=Sheet1!$C$1',
    'categories': '=Sheet1!$A$2:$A$7',
    'values':     '=Sheet1!$C$2:$C$7',
})

# Add a chart title and some axis labels.
chart3.set_title ({'name': 'Percent Stacked Chart'})
chart3.set_x_axis({'name': 'Test number'})
chart3.set_y_axis({'name': 'Sample length (mm)'})

# Set an Excel chart style.
chart3.set_style(13)

# Insert the chart into the worksheet (with an offset).
worksheet.insert_chart('D34', chart3, {'x_offset': 25, 'y_offset': 10})

workbook.close()

```

---

### File: `tmp\xlsxwriter_old\XlsxWriter-1.4.5\examples\chart_bar.py`

```python
#######################################################################
#
# An example of creating Excel Bar charts with Python and XlsxWriter.
#
# Copyright 2013-2021, John McNamara, jmcnamara@cpan.org
#
import xlsxwriter

workbook = xlsxwriter.Workbook('chart_bar.xlsx')
worksheet = workbook.add_worksheet()
bold = workbook.add_format({'bold': 1})

# Add the worksheet data that the charts will refer to.
headings = ['Number', 'Batch 1', 'Batch 2']
data = [
    [2, 3, 4, 5, 6, 7],
    [10, 40, 50, 20, 10, 50],
    [30, 60, 70, 50, 40, 30],
]

worksheet.write_row('A1', headings, bold)
worksheet.write_column('A2', data[0])
worksheet.write_column('B2', data[1])
worksheet.write_column('C2', data[2])

#######################################################################
#
# Create a new bar chart.
#
chart1 = workbook.add_chart({'type': 'bar'})

# Configure the first series.
chart1.add_series({
    'name':       '=Sheet1!$B$1',
    'categories': '=Sheet1!$A$2:$A$7',
    'values':     '=Sheet1!$B$2:$B$7',
})

# Configure a second series. Note use of alternative syntax to define ranges.
chart1.add_series({
    'name':       ['Sheet1', 0, 2],
    'categories': ['Sheet1', 1, 0, 6, 0],
    'values':     ['Sheet1', 1, 2, 6, 2],
})

# Add a chart title and some axis labels.
chart1.set_title ({'name': 'Results of sample analysis'})
chart1.set_x_axis({'name': 'Test number'})
chart1.set_y_axis({'name': 'Sample length (mm)'})

# Set an Excel chart style.
chart1.set_style(11)

# Insert the chart into the worksheet (with an offset).
worksheet.insert_chart('D2', chart1, {'x_offset': 25, 'y_offset': 10})

#######################################################################
#
# Create a stacked chart sub-type.
#
chart2 = workbook.add_chart({'type': 'bar', 'subtype': 'stacked'})

# Configure the first series.
chart2.add_series({
    'name':       '=Sheet1!$B$1',
    'categories': '=Sheet1!$A$2:$A$7',
    'values':     '=Sheet1!$B$2:$B$7',
})

# Configure second series.
chart2.add_series({
    'name':       '=Sheet1!$C$1',
    'categories': '=Sheet1!$A$2:$A$7',
    'values':     '=Sheet1!$C$2:$C$7',
})

# Add a chart title and some axis labels.
chart2.set_title ({'name': 'Stacked Chart'})
chart2.set_x_axis({'name': 'Test number'})
chart2.set_y_axis({'name': 'Sample length (mm)'})

# Set an Excel chart style.
chart2.set_style(12)

# Insert the chart into the worksheet (with an offset).
worksheet.insert_chart('D18', chart2, {'x_offset': 25, 'y_offset': 10})

#######################################################################
#
# Create a percentage stacked chart sub-type.
#
chart3 = workbook.add_chart({'type': 'bar', 'subtype': 'percent_stacked'})

# Configure the first series.
chart3.add_series({
    'name':       '=Sheet1!$B$1',
    'categories': '=Sheet1!$A$2:$A$7',
    'values':     '=Sheet1!$B$2:$B$7',
})

# Configure second series.
chart3.add_series({
    'name':       '=Sheet1!$C$1',
    'categories': '=Sheet1!$A$2:$A$7',
    'values':     '=Sheet1!$C$2:$C$7',
})

# Add a chart title and some axis labels.
chart3.set_title ({'name': 'Percent Stacked Chart'})
chart3.set_x_axis({'name': 'Test number'})
chart3.set_y_axis({'name': 'Sample length (mm)'})

# Set an Excel chart style.
chart3.set_style(13)

# Insert the chart into the worksheet (with an offset).
worksheet.insert_chart('D34', chart3, {'x_offset': 25, 'y_offset': 10})

workbook.close()

```

---

### File: `tmp\xlsxwriter_old\XlsxWriter-1.4.5\examples\chart_clustered.py`

```python
#######################################################################
#
# A demo of a clustered category chart in XlsxWriter.
#
# Copyright 2013-2021, John McNamara, jmcnamara@cpan.org
#
from xlsxwriter.workbook import Workbook

workbook = Workbook('chart_clustered.xlsx')
worksheet = workbook.add_worksheet()
bold = workbook.add_format({'bold': 1})

# Add the worksheet data that the charts will refer to.
headings = ['Types', 'Sub Type', 'Value 1', 'Value 2', 'Value 3']
data = [
    ['Type 1', 'Sub Type A', 5000,      8000,      6000],
    ['',       'Sub Type B', 2000,      3000,      4000],
    ['',       'Sub Type C', 250,       1000,      2000],
    ['Type 2', 'Sub Type D', 6000,      6000,      6500],
    ['',       'Sub Type E', 500,       300,        200],
]

worksheet.write_row('A1', headings, bold)

for row_num, row_data in enumerate(data):
    worksheet.write_row(row_num + 1, 0, row_data)

# Create a new chart object. In this case an embedded chart.
chart = workbook.add_chart({'type': 'column'})

# Configure the series. Note, that the categories are 2D ranges (from column A
# to column B). This creates the clusters. The series are shown as formula
# strings for clarity but you can also use the list syntax. See the docs.
chart.add_series({
    'categories': '=Sheet1!$A$2:$B$6',
    'values':     '=Sheet1!$C$2:$C$6',
})

chart.add_series({
    'categories': '=Sheet1!$A$2:$B$6',
    'values':     '=Sheet1!$D$2:$D$6',
})

chart.add_series({
    'categories': '=Sheet1!$A$2:$B$6',
    'values':     '=Sheet1!$E$2:$E$6',
})

# Set the Excel chart style.
chart.set_style(37)

# Turn off the legend.
chart.set_legend({'position': 'none'})

# Insert the chart into the worksheet.
worksheet.insert_chart('G3', chart)

workbook.close()

```

---

### File: `tmp\xlsxwriter_old\XlsxWriter-1.4.5\examples\chart_column.py`

```python
#######################################################################
#
# An example of creating Excel Column charts with Python and XlsxWriter.
#
# Copyright 2013-2021, John McNamara, jmcnamara@cpan.org
#
import xlsxwriter

workbook = xlsxwriter.Workbook('chart_column.xlsx')
worksheet = workbook.add_worksheet()
bold = workbook.add_format({'bold': 1})

# Add the worksheet data that the charts will refer to.
headings = ['Number', 'Batch 1', 'Batch 2']
data = [
    [2, 3, 4, 5, 6, 7],
    [10, 40, 50, 20, 10, 50],
    [30, 60, 70, 50, 40, 30],
]

worksheet.write_row('A1', headings, bold)
worksheet.write_column('A2', data[0])
worksheet.write_column('B2', data[1])
worksheet.write_column('C2', data[2])

#######################################################################
#
# Create a new column chart.
#
chart1 = workbook.add_chart({'type': 'column'})

# Configure the first series.
chart1.add_series({
    'name':       '=Sheet1!$B$1',
    'categories': '=Sheet1!$A$2:$A$7',
    'values':     '=Sheet1!$B$2:$B$7',
})

# Configure a second series. Note use of alternative syntax to define ranges.
chart1.add_series({
    'name':       ['Sheet1', 0, 2],
    'categories': ['Sheet1', 1, 0, 6, 0],
    'values':     ['Sheet1', 1, 2, 6, 2],
})

# Add a chart title and some axis labels.
chart1.set_title ({'name': 'Results of sample analysis'})
chart1.set_x_axis({'name': 'Test number'})
chart1.set_y_axis({'name': 'Sample length (mm)'})

# Set an Excel chart style.
chart1.set_style(11)

# Insert the chart into the worksheet (with an offset).
worksheet.insert_chart('D2', chart1, {'x_offset': 25, 'y_offset': 10})

#######################################################################
#
# Create a stacked chart sub-type.
#
chart2 = workbook.add_chart({'type': 'column', 'subtype': 'stacked'})

# Configure the first series.
chart2.add_series({
    'name':       '=Sheet1!$B$1',
    'categories': '=Sheet1!$A$2:$A$7',
    'values':     '=Sheet1!$B$2:$B$7',
})

# Configure second series.
chart2.add_series({
    'name':       '=Sheet1!$C$1',
    'categories': '=Sheet1!$A$2:$A$7',
    'values':     '=Sheet1!$C$2:$C$7',
})

# Add a chart title and some axis labels.
chart2.set_title ({'name': 'Stacked Chart'})
chart2.set_x_axis({'name': 'Test number'})
chart2.set_y_axis({'name': 'Sample length (mm)'})

# Set an Excel chart style.
chart2.set_style(12)

# Insert the chart into the worksheet (with an offset).
worksheet.insert_chart('D18', chart2, {'x_offset': 25, 'y_offset': 10})

#######################################################################
#
# Create a percentage stacked chart sub-type.
#
chart3 = workbook.add_chart({'type': 'column', 'subtype': 'percent_stacked'})

# Configure the first series.
chart3.add_series({
    'name':       '=Sheet1!$B$1',
    'categories': '=Sheet1!$A$2:$A$7',
    'values':     '=Sheet1!$B$2:$B$7',
})

# Configure second series.
chart3.add_series({
    'name':       '=Sheet1!$C$1',
    'categories': '=Sheet1!$A$2:$A$7',
    'values':     '=Sheet1!$C$2:$C$7',
})

# Add a chart title and some axis labels.
chart3.set_title ({'name': 'Percent Stacked Chart'})
chart3.set_x_axis({'name': 'Test number'})
chart3.set_y_axis({'name': 'Sample length (mm)'})

# Set an Excel chart style.
chart3.set_style(13)

# Insert the chart into the worksheet (with an offset).
worksheet.insert_chart('D34', chart3, {'x_offset': 25, 'y_offset': 10})

workbook.close()

```

---

### File: `tmp\xlsxwriter_old\XlsxWriter-1.4.5\examples\chart_combined.py`

```python
#######################################################################
#
# An example of a Combined chart in XlsxWriter.
#
# Copyright 2013-2021, John McNamara, jmcnamara@cpan.org
#
from xlsxwriter.workbook import Workbook

workbook  = Workbook('chart_combined.xlsx')
worksheet = workbook.add_worksheet()

# Add a format for the headings.
bold = workbook.add_format({'bold': True})

# Add the worksheet data that the charts will refer to.
headings = ['Number', 'Batch 1', 'Batch 2']
data = [
    [2, 3, 4, 5, 6, 7],
    [10, 40, 50, 20, 10, 50],
    [30, 60, 70, 50, 40, 30],
]

worksheet.write_row('A1', headings, bold)
worksheet.write_column('A2', data[0])
worksheet.write_column('B2', data[1])
worksheet.write_column('C2', data[2])

#
# In the first example we will create a combined column and line chart.
# They will share the same X and Y axes.
#

# Create a new column chart. This will use this as the primary chart.
column_chart1 = workbook.add_chart({'type': 'column'})

# Configure the data series for the primary chart.
column_chart1.add_series({
    'name':       '=Sheet1!$B$1',
    'categories': '=Sheet1!$A$2:$A$7',
    'values':     '=Sheet1!$B$2:$B$7',
})

# Create a new column chart. This will use this as the secondary chart.
line_chart1 = workbook.add_chart({'type': 'line'})

# Configure the data series for the secondary chart.
line_chart1.add_series({
    'name':       '=Sheet1!$C$1',
    'categories': '=Sheet1!$A$2:$A$7',
    'values':     '=Sheet1!$C$2:$C$7',
})

# Combine the charts.
column_chart1.combine(line_chart1)

# Add a chart title and some axis labels. Note, this is done via the
# primary chart.
column_chart1.set_title({ 'name': 'Combined chart - same Y axis'})
column_chart1.set_x_axis({'name': 'Test number'})
column_chart1.set_y_axis({'name': 'Sample length (mm)'})

# Insert the chart into the worksheet
worksheet.insert_chart('E2', column_chart1)

#
# In the second example we will create a similar combined column and line
# chart except that the secondary chart will have a secondary Y axis.
#

# Create a new column chart. This will use this as the primary chart.
column_chart2 = workbook.add_chart({'type': 'column'})

# Configure the data series for the primary chart.
column_chart2.add_series({
    'name':       '=Sheet1!$B$1',
    'categories': '=Sheet1!$A$2:$A$7',
    'values':     '=Sheet1!$B$2:$B$7',
})

# Create a new column chart. This will use this as the secondary chart.
line_chart2 = workbook.add_chart({'type': 'line'})

# Configure the data series for the secondary chart. We also set a
# secondary Y axis via (y2_axis). This is the only difference between
# this and the first example, apart from the axis label below.
line_chart2.add_series({
    'name':       '=Sheet1!$C$1',
    'categories': '=Sheet1!$A$2:$A$7',
    'values':     '=Sheet1!$C$2:$C$7',
    'y2_axis':    True,
})

# Combine the charts.
column_chart2.combine(line_chart2)

# Add a chart title and some axis labels.
column_chart2.set_title({  'name': 'Combine chart - secondary Y axis'})
column_chart2.set_x_axis({ 'name': 'Test number'})
column_chart2.set_y_axis({ 'name': 'Sample length (mm)'})

# Note: the y2 properties are on the secondary chart.
line_chart2.set_y2_axis({'name': 'Target length (mm)'})

# Insert the chart into the worksheet
worksheet.insert_chart('E18', column_chart2)

workbook.close()

```

---

### File: `tmp\xlsxwriter_old\XlsxWriter-1.4.5\examples\chart_data_labels.py`

```python
#######################################################################
#
# A demo of an various Excel chart data label features that are available
# via an XlsxWriter chart.
#
# Copyright 2013-2021, John McNamara, jmcnamara@cpan.org
#
import xlsxwriter

workbook = xlsxwriter.Workbook('chart_data_labels.xlsx')
worksheet = workbook.add_worksheet()
bold = workbook.add_format({'bold': 1})

# Add the worksheet data that the charts will refer to.
headings = ['Number', 'Data', 'Text']

data = [
    [2, 3, 4, 5, 6, 7],
    [20, 10, 20, 30, 40, 30],
    ['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun'],
]

worksheet.write_row('A1', headings, bold)
worksheet.write_column('A2', data[0])
worksheet.write_column('B2', data[1])
worksheet.write_column('C2', data[2])

#######################################################################
#
# Example with standard data labels.
#

# Create a Column chart.
chart1 = workbook.add_chart({'type': 'column'})

# Configure the data series and add the data labels.
chart1.add_series({
    'categories': '=Sheet1!$A$2:$A$7',
    'values':     '=Sheet1!$B$2:$B$7',
    'data_labels': {'value': True},
})

# Add a chart title.
chart1.set_title({'name': 'Chart with standard data labels'})

# Turn off the chart legend.
chart1.set_legend({'none': True})

# Insert the chart into the worksheet (with an offset).
worksheet.insert_chart('D2', chart1, {'x_offset': 25, 'y_offset': 10})

#######################################################################
#
# Example with value and category data labels.
#

# Create a Column chart.
chart2 = workbook.add_chart({'type': 'column'})

# Configure the data series and add the data labels.
chart2.add_series({
    'categories': '=Sheet1!$A$2:$A$7',
    'values':     '=Sheet1!$B$2:$B$7',
    'data_labels': {'value': True, 'category': True},
})

# Add a chart title.
chart2.set_title({'name': 'Category and Value data labels'})

# Turn off the chart legend.
chart2.set_legend({'none': True})

# Insert the chart into the worksheet (with an offset).
worksheet.insert_chart('D18', chart2, {'x_offset': 25, 'y_offset': 10})

#######################################################################
#
# Example with standard data labels with different font.
#

# Create a Column chart.
chart3 = workbook.add_chart({'type': 'column'})

# Configure the data series and add the data labels.
chart3.add_series({
    'categories': '=Sheet1!$A$2:$A$7',
    'values':     '=Sheet1!$B$2:$B$7',
    'data_labels': {'value': True,
                    'font': {'bold': True,
                             'color': 'red',
                             'rotation': -30}},
})

# Add a chart title.
chart3.set_title({'name': 'Data labels with user defined font'})

# Turn off the chart legend.
chart3.set_legend({'none': True})

# Insert the chart into the worksheet (with an offset).
worksheet.insert_chart('D34', chart3, {'x_offset': 25, 'y_offset': 10})

#######################################################################
#
# Example with standard data labels and formatting.
#

# Create a Column chart.
chart4 = workbook.add_chart({'type': 'column'})

# Configure the data series and add the data labels.
chart4.add_series({
    'categories': '=Sheet1!$A$2:$A$7',
    'values':     '=Sheet1!$B$2:$B$7',
    'data_labels': {'value': True,
                    'border': {'color': 'red'},
                    'fill':   {'color': 'yellow'}},
})

# Add a chart title.
chart4.set_title({'name': 'Data labels with formatting'})

# Turn off the chart legend.
chart4.set_legend({'none': True})

# Insert the chart into the worksheet (with an offset).
worksheet.insert_chart('D50', chart4, {'x_offset': 25, 'y_offset': 10})

#######################################################################
#
# Example with custom string data labels.
#

# Create a Column chart.
chart5 = workbook.add_chart({'type': 'column'})

# Some custom labels.
custom_labels = [
    {'value': 'Amy'},
    {'value': 'Bea'},
    {'value': 'Eva'},
    {'value': 'Fay'},
    {'value': 'Liv'},
    {'value': 'Una'},
]

# Configure the data series and add the data labels.
chart5.add_series({
    'categories': '=Sheet1!$A$2:$A$7',
    'values':     '=Sheet1!$B$2:$B$7',
    'data_labels': {'value': True, 'custom': custom_labels},
})

# Add a chart title.
chart5.set_title({'name': 'Chart with custom string data labels'})

# Turn off the chart legend.
chart5.set_legend({'none': True})

# Insert the chart into the worksheet (with an offset).
worksheet.insert_chart('D66', chart5, {'x_offset': 25, 'y_offset': 10})

#######################################################################
#
# Example with custom data labels from cells.
#

# Create a Column chart.
chart6 = workbook.add_chart({'type': 'column'})

# Some custom labels.
custom_labels = [
    {'value': '=Sheet1!$C$2'},
    {'value': '=Sheet1!$C$3'},
    {'value': '=Sheet1!$C$4'},
    {'value': '=Sheet1!$C$5'},
    {'value': '=Sheet1!$C$6'},
    {'value': '=Sheet1!$C$7'},
]

# Configure the data series and add the data labels.
chart6.add_series({
    'categories': '=Sheet1!$A$2:$A$7',
    'values':     '=Sheet1!$B$2:$B$7',
    'data_labels': {'value': True, 'custom': custom_labels},
})

# Add a chart title.
chart6.set_title({'name': 'Chart with custom data labels from cells'})

# Turn off the chart legend.
chart6.set_legend({'none': True})

# Insert the chart into the worksheet (with an offset).
worksheet.insert_chart('D82', chart6, {'x_offset': 25, 'y_offset': 10})

#######################################################################
#
# Example with custom and default data labels.
#

# Create a Column chart.
chart7 = workbook.add_chart({'type': 'column'})

# The following is used to get a mix of default and custom labels. The 'None'
# items will get the default value. We also set a font for the custom items
# as an extra example.
custom_labels = [
    {'value': '=Sheet1!$C$2', 'font': {'color': 'red'}},
    None,
    {'value': '=Sheet1!$C$4', 'font': {'color': 'red'}},
    {'value': '=Sheet1!$C$5', 'font': {'color': 'red'}},
]

# Configure the data series and add the data labels.
chart7.add_series({
    'categories': '=Sheet1!$A$2:$A$7',
    'values':     '=Sheet1!$B$2:$B$7',
    'data_labels': {'value': True, 'custom': custom_labels},
})

# Add a chart title.
chart7.set_title({'name': 'Mixed custom and default data labels'})

# Turn off the chart legend.
chart7.set_legend({'none': True})

# Insert the chart into the worksheet (with an offset).
worksheet.insert_chart('D98', chart7, {'x_offset': 25, 'y_offset': 10})


#######################################################################
#
# Example with deleted custom data labels.
#

# Create a Column chart.
chart8 = workbook.add_chart({'type': 'column'})

# Some deleted custom labels and defaults (set with None values). This allows
# us to highlight certain values such as the minimum and maximum.
custom_labels = [
    {'delete': True},
    None,
    {'delete': True},
    {'delete': True},
    None,
    {'delete': True},
]

# Configure the data series and add the data labels.
chart8.add_series({
    'categories': '=Sheet1!$A$2:$A$7',
    'values':     '=Sheet1!$B$2:$B$7',
    'data_labels': {'value': True, 'custom': custom_labels},
})

# Add a chart title.
chart8.set_title({'name': 'Chart with deleted data labels'})

# Turn off the chart legend.
chart8.set_legend({'none': True})

# Insert the chart into the worksheet (with an offset).
worksheet.insert_chart('D114', chart8, {'x_offset': 25, 'y_offset': 10})

#######################################################################
#
# Example with custom string data labels and formatting.
#

# Create a Column chart.
chart9 = workbook.add_chart({'type': 'column'})

# Some custom labels.
custom_labels = [
    {'value': 'Amy', 'border': {'color': 'blue'}},
    {'value': 'Bea'},
    {'value': 'Eva'},
    {'value': 'Fay'},
    {'value': 'Liv'},
    {'value': 'Una', 'fill':   {'color': 'green'}},
]

# Configure the data series and add the data labels.
chart9.add_series({
    'categories': '=Sheet1!$A$2:$A$7',
    'values':     '=Sheet1!$B$2:$B$7',
    'data_labels': {'value': True,
                    'custom': custom_labels,
                    'border': {'color': 'red'},
                    'fill':   {'color': 'yellow'}},

})

# Add a chart title.
chart9.set_title({'name': 'Chart with custom labels and formatting'})

# Turn off the chart legend.
chart9.set_legend({'none': True})

# Insert the chart into the worksheet (with an offset).
worksheet.insert_chart('D130', chart9, {'x_offset': 25, 'y_offset': 10})

workbook.close()

```

---

### File: `tmp\xlsxwriter_old\XlsxWriter-1.4.5\examples\chart_data_table.py`

```python
#######################################################################
#
# An example of creating Excel Column charts with data tables using
# Python and XlsxWriter.
#
# Copyright 2013-2021, John McNamara, jmcnamara@cpan.org
#
import xlsxwriter

workbook = xlsxwriter.Workbook('chart_data_table.xlsx')
worksheet = workbook.add_worksheet()
bold = workbook.add_format({'bold': 1})

# Add the worksheet data that the charts will refer to.
headings = ['Number', 'Batch 1', 'Batch 2']
data = [
    [2, 3, 4, 5, 6, 7],
    [10, 40, 50, 20, 10, 50],
    [30, 60, 70, 50, 40, 30],
]

worksheet.write_row('A1', headings, bold)
worksheet.write_column('A2', data[0])
worksheet.write_column('B2', data[1])
worksheet.write_column('C2', data[2])


#######################################################################
#
# Create a column chart with a data table.
#
chart1 = workbook.add_chart({'type': 'column'})

# Configure the first series.
chart1.add_series({
    'name':       '=Sheet1!$B$1',
    'categories': '=Sheet1!$A$2:$A$7',
    'values':     '=Sheet1!$B$2:$B$7',
})

# Configure second series. Note use of alternative syntax to define ranges.
chart1.add_series({
    'name':       ['Sheet1', 0, 2],
    'categories': ['Sheet1', 1, 0, 6, 0],
    'values':     ['Sheet1', 1, 2, 6, 2],
})

# Add a chart title and some axis labels.
chart1.set_title({'name': 'Chart with Data Table'})
chart1.set_x_axis({'name': 'Test number'})
chart1.set_y_axis({'name': 'Sample length (mm)'})

# Set a default data table on the X-Axis.
chart1.set_table()

# Insert the chart into the worksheet (with an offset).
worksheet.insert_chart('D2', chart1, {'x_offset': 25, 'y_offset': 10})

#######################################################################
#
# Create a column chart with a data table and legend keys.
#
chart2 = workbook.add_chart({'type': 'column'})

# Configure the first series.
chart2.add_series({
    'name':       '=Sheet1!$B$1',
    'categories': '=Sheet1!$A$2:$A$7',
    'values':     '=Sheet1!$B$2:$B$7',
})

# Configure second series.
chart2.add_series({
    'name':       '=Sheet1!$C$1',
    'categories': '=Sheet1!$A$2:$A$7',
    'values':     '=Sheet1!$C$2:$C$7',
})

# Add a chart title and some axis labels.
chart2.set_title({'name': 'Data Table with legend keys'})
chart2.set_x_axis({'name': 'Test number'})
chart2.set_y_axis({'name': 'Sample length (mm)'})

# Set a data table on the X-Axis with the legend keys shown.
chart2.set_table({'show_keys': True})

# Hide the chart legend since the keys are shown on the data table.
chart2.set_legend({'position': 'none'})

# Insert the chart into the worksheet (with an offset).
worksheet.insert_chart('D18', chart2, {'x_offset': 25, 'y_offset': 10})

workbook.close()

```

---

### File: `tmp\xlsxwriter_old\XlsxWriter-1.4.5\examples\chart_data_tools.py`

```python
#######################################################################
#
# A demo of an various Excel chart data tools that are available via
# an XlsxWriter chart.
#
# These include, Trendlines, Data Labels, Error Bars, Drop Lines,
# High-Low Lines and Up-Down Bars.
#
# Copyright 2013-2021, John McNamara, jmcnamara@cpan.org
#
import xlsxwriter

workbook = xlsxwriter.Workbook('chart_data_tools.xlsx')
worksheet = workbook.add_worksheet()
bold = workbook.add_format({'bold': 1})

# Add the worksheet data that the charts will refer to.
headings = ['Number', 'Data 1', 'Data 2']
data = [
    [2, 3, 4, 5, 6, 7],
    [10, 40, 50, 20, 10, 50],
    [30, 60, 70, 50, 40, 30],
]

worksheet.write_row('A1', headings, bold)
worksheet.write_column('A2', data[0])
worksheet.write_column('B2', data[1])
worksheet.write_column('C2', data[2])


#######################################################################
#
# Trendline example.
#
# Create a Line chart.
chart1 = workbook.add_chart({'type': 'line'})

# Configure the first series with a polynomial trendline.
chart1.add_series({
    'categories': '=Sheet1!$A$2:$A$7',
    'values':     '=Sheet1!$B$2:$B$7',
    'trendline': {
        'type': 'polynomial',
        'order': 3,
    },
})

# Configure the second series with a moving average trendline.
chart1.add_series({
    'categories': '=Sheet1!$A$2:$A$7',
    'values':     '=Sheet1!$C$2:$C$7',
    'trendline': {'type': 'linear'},
})

# Add a chart title.
chart1.set_title({'name': 'Chart with Trendlines'})

# Insert the chart into the worksheet (with an offset).
worksheet.insert_chart('D2', chart1, {'x_offset': 25, 'y_offset': 10})

#######################################################################
#
# Data Labels and Markers example.
#
# Create a Line chart.
chart2 = workbook.add_chart({'type': 'line'})

# Configure the first series.
chart2.add_series({
    'categories': '=Sheet1!$A$2:$A$7',
    'values':     '=Sheet1!$B$2:$B$7',
    'data_labels': {'value': 1},
    'marker': {'type': 'automatic'},
})

# Configure the second series.
chart2.add_series({
    'categories': '=Sheet1!$A$2:$A$7',
    'values':     '=Sheet1!$C$2:$C$7',
})

# Add a chart title.
chart2.set_title({'name': 'Chart with Data Labels and Markers'})

# Insert the chart into the worksheet (with an offset).
worksheet.insert_chart('D18', chart2, {'x_offset': 25, 'y_offset': 10})

#######################################################################
#
# Error Bars example.
#
# Create a Line chart.
chart3 = workbook.add_chart({'type': 'line'})

# Configure the first series.
chart3.add_series({
    'categories': '=Sheet1!$A$2:$A$7',
    'values':     '=Sheet1!$B$2:$B$7',
    'y_error_bars': {'type': 'standard_error'},
})

# Configure the second series.
chart3.add_series({
    'categories': '=Sheet1!$A$2:$A$7',
    'values': '=Sheet1!$C$2:$C$7',
})

# Add a chart title.
chart3.set_title({'name': 'Chart with Error Bars'})

# Insert the chart into the worksheet (with an offset).
worksheet.insert_chart('D34', chart3, {'x_offset': 25, 'y_offset': 10})

#######################################################################
#
# Up-Down Bars example.
#
# Create a Line chart.
chart4 = workbook.add_chart({'type': 'line'})

# Add the Up-Down Bars.
chart4.set_up_down_bars()

# Configure the first series.
chart4.add_series({
    'categories': '=Sheet1!$A$2:$A$7',
    'values':     '=Sheet1!$B$2:$B$7',
})

# Configure the second series.
chart4.add_series({
    'categories': '=Sheet1!$A$2:$A$7',
    'values':     '=Sheet1!$C$2:$C$7',
})

# Add a chart title.
chart4.set_title({'name': 'Chart with Up-Down Bars'})

# Insert the chart into the worksheet (with an offset).
worksheet.insert_chart('D50', chart4, {'x_offset': 25, 'y_offset': 10})

#######################################################################
#
# High-Low Lines example.
#
# Create a Line chart.
chart5 = workbook.add_chart({'type': 'line'})

# Add the High-Low lines.
chart5.set_high_low_lines()

# Configure the first series.
chart5.add_series({
    'categories': '=Sheet1!$A$2:$A$7',
    'values':     '=Sheet1!$B$2:$B$7',
})

# Configure the second series.
chart5.add_series({
    'categories': '=Sheet1!$A$2:$A$7',
    'values':     '=Sheet1!$C$2:$C$7',
})

# Add a chart title.
chart5.set_title({'name': 'Chart with High-Low Lines'})

# Insert the chart into the worksheet (with an offset).
worksheet.insert_chart('D66', chart5, {'x_offset': 25, 'y_offset': 10})

#######################################################################
#
# Drop Lines example.
#
# Create a Line chart.
chart6 = workbook.add_chart({'type': 'line'})

# Add Drop Lines.
chart6.set_drop_lines()

# Configure the first series.
chart6.add_series({
    'categories': '=Sheet1!$A$2:$A$7',
    'values':     '=Sheet1!$B$2:$B$7',
})

# Configure the second series.
chart6.add_series({
    'categories': '=Sheet1!$A$2:$A$7',
    'values':     '=Sheet1!$C$2:$C$7',
})

# Add a chart title.
chart6.set_title({'name': 'Chart with Drop Lines'})

# Insert the chart into the worksheet (with an offset).
worksheet.insert_chart('D82', chart6, {'x_offset': 25, 'y_offset': 10})

workbook.close()

```

---

### File: `tmp\xlsxwriter_old\XlsxWriter-1.4.5\examples\chart_date_axis.py`

```python
#######################################################################
#
# An example of creating an Excel charts with a date axis using
# Python and XlsxWriter.
#
# Copyright 2013-2021, John McNamara, jmcnamara@cpan.org
#

from datetime import date
import xlsxwriter

workbook = xlsxwriter.Workbook('chart_date_axis.xlsx')

worksheet = workbook.add_worksheet()
chart = workbook.add_chart({'type': 'line'})
date_format = workbook.add_format({'num_format': 'dd/mm/yyyy'})

# Widen the first column to display the dates.
worksheet.set_column('A:A', 12)

# Some data to be plotted in the worksheet.
dates = [date(2013, 1, 1),
         date(2013, 1, 2),
         date(2013, 1, 3),
         date(2013, 1, 4),
         date(2013, 1, 5),
         date(2013, 1, 6),
         date(2013, 1, 7),
         date(2013, 1, 8),
         date(2013, 1, 9),
         date(2013, 1, 10)]

values = [10, 30, 20, 40, 20, 60, 50, 40, 30, 30]

# Write the date to the worksheet.
worksheet.write_column('A1', dates, date_format)
worksheet.write_column('B1', values)

# Add a series to the chart.
chart.add_series({
    'categories': '=Sheet1!$A$1:$A$10',
    'values': '=Sheet1!$B$1:$B$10',
})

# Configure the X axis as a Date axis and set the max and min limits.
chart.set_x_axis({
    'date_axis': True,
    'min': date(2013, 1, 2),
    'max': date(2013, 1, 9),
})

# Turn off the legend.
chart.set_legend({'none': True})

# Insert the chart into the worksheet.
worksheet.insert_chart('D2', chart)

workbook.close()

```

---

### File: `tmp\xlsxwriter_old\XlsxWriter-1.4.5\examples\chart_doughnut.py`

```python
#######################################################################
#
# An example of creating Excel Doughnut charts with Python and XlsxWriter.
#
# The demo also shows how to set segment colors. It is possible to
# define chart colors for most types of XlsxWriter charts
# via the add_series() method. However, Pie/Doughnut charts are a special
# case since each segment is represented as a point so it is necessary to
# assign formatting to each point in the series.
#
# Copyright 2013-2021, John McNamara, jmcnamara@cpan.org
#
import xlsxwriter

workbook = xlsxwriter.Workbook('chart_doughnut.xlsx')

worksheet = workbook.add_worksheet()
bold = workbook.add_format({'bold': 1})

# Add the worksheet data that the charts will refer to.
headings = ['Category', 'Values']
data = [
    ['Glazed', 'Chocolate', 'Cream'],
    [50, 35, 15],
]

worksheet.write_row('A1', headings, bold)
worksheet.write_column('A2', data[0])
worksheet.write_column('B2', data[1])

#######################################################################
#
# Create a new chart object.
#
chart1 = workbook.add_chart({'type': 'doughnut'})

# Configure the series. Note the use of the list syntax to define ranges:
chart1.add_series({
    'name':       'Doughnut sales data',
    'categories': ['Sheet1', 1, 0, 3, 0],
    'values':     ['Sheet1', 1, 1, 3, 1],
})

# Add a title.
chart1.set_title({'name': 'Popular Doughnut Types'})

# Set an Excel chart style. Colors with white outline and shadow.
chart1.set_style(10)

# Insert the chart into the worksheet (with an offset).
worksheet.insert_chart('C2', chart1, {'x_offset': 25, 'y_offset': 10})

#######################################################################
#
# Create a Doughnut chart with user defined segment colors.
#

# Create an example Doughnut chart like above.
chart2 = workbook.add_chart({'type': 'doughnut'})

# Configure the series and add user defined segment colors.
chart2.add_series({
    'name': 'Doughnut sales data',
    'categories': '=Sheet1!$A$2:$A$4',
    'values':     '=Sheet1!$B$2:$B$4',
    'points': [
        {'fill': {'color': '#FA58D0'}},
        {'fill': {'color': '#61210B'}},
        {'fill': {'color': '#F5F6CE'}},
    ],
})

# Add a title.
chart2.set_title({'name': 'Doughnut Chart with user defined colors'})

# Insert the chart into the worksheet (with an offset).
worksheet.insert_chart('C18', chart2, {'x_offset': 25, 'y_offset': 10})

#######################################################################
#
# Create a Doughnut chart with rotation of the segments.
#

# Create an example Doughnut chart like above.
chart3 = workbook.add_chart({'type': 'doughnut'})

# Configure the series.
chart3.add_series({
    'name': 'Doughnut sales data',
    'categories': '=Sheet1!$A$2:$A$4',
    'values':     '=Sheet1!$B$2:$B$4',
})

# Add a title.
chart3.set_title({'name': 'Doughnut Chart with segment rotation'})

# Change the angle/rotation of the first segment.
chart3.set_rotation(90)

# Insert the chart into the worksheet (with an offset).
worksheet.insert_chart('C34', chart3, {'x_offset': 25, 'y_offset': 10})


#######################################################################
#
# Create a Doughnut chart with user defined hole size and other options.
#

# Create an example Doughnut chart like above.
chart4 = workbook.add_chart({'type': 'doughnut'})

# Configure the series.
chart4.add_series({
    'name': 'Doughnut sales data',
    'categories': '=Sheet1!$A$2:$A$4',
    'values':     '=Sheet1!$B$2:$B$4',
    'points': [
        {'fill': {'color': '#FA58D0'}},
        {'fill': {'color': '#61210B'}},
        {'fill': {'color': '#F5F6CE'}},
    ],
})

# Set a 3D style.
chart4.set_style(26)

# Add a title.
chart4.set_title({'name': 'Doughnut Chart with options applied'})

# Change the angle/rotation of the first segment.
chart4.set_rotation(28)

# Change the hole size.
chart4.set_hole_size(33)

# Insert the chart into the worksheet (with an offset).
worksheet.insert_chart('C50', chart4, {'x_offset': 25, 'y_offset': 10})


workbook.close()

```

---

### File: `tmp\xlsxwriter_old\XlsxWriter-1.4.5\examples\chart_gauge.py`

```python
#######################################################################
#
# An example of creating a Gauge Chart in Excel with Python and XlsxWriter.
#
# A Gauge Chart isn't a native chart type in Excel. It is constructed by
# combining a doughnut chart and a pie chart and by using some non-filled
# elements. This example follows the following online example of how to create
# a Gauge Chart in Excel: https://www.excel-easy.com/examples/gauge-chart.html
#
# Copyright 2013-2021, John McNamara, jmcnamara@cpan.org
#
import xlsxwriter

workbook = xlsxwriter.Workbook('chart_gauge.xlsx')
worksheet = workbook.add_worksheet()

chart_doughnut = workbook.add_chart({'type': 'doughnut'})
chart_pie = workbook.add_chart({'type': 'pie'})

# Add some data for the Doughnut and Pie charts. This is set up so the
# gauge goes from 0-100. It is initially set at 75%.
worksheet.write_column('H2', ['Donut', 25, 50, 25, 100])
worksheet.write_column('I2', ['Pie', 75, 1, '=200-I4-I3'])

# Configure the doughnut chart as the background for the gauge.
chart_doughnut.add_series({
    'name': '=Sheet1!$H$2',
    'values': '=Sheet1!$H$3:$H$6',
    'points': [
        {'fill': {'color': 'green'}},
        {'fill': {'color': 'yellow'}},
        {'fill': {'color': 'red'}},
        {'fill': {'none': True}}],
})

# Rotate chart so the gauge parts are above the horizontal.
chart_doughnut.set_rotation(270)

# Turn off the chart legend.
chart_doughnut.set_legend({'none': True})

# Turn off the chart fill and border.
chart_doughnut.set_chartarea({
    'border': {'none': True},
    'fill': {'none': True},
})

# Configure the pie chart as the needle for the gauge.
chart_pie.add_series({
    'name': '=Sheet1!$I$2',
    'values': '=Sheet1!$I$3:$I$6',
    'points': [
        {'fill': {'none': True}},
        {'fill': {'color': 'black'}},
        {'fill': {'none': True}}],
})

# Rotate the pie chart/needle to align with the doughnut/gauge.
chart_pie.set_rotation(270)

# Combine the pie and doughnut charts.
chart_doughnut.combine(chart_pie)

# Insert the chart into the worksheet.
worksheet.insert_chart('A1', chart_doughnut)

workbook.close()

```

---

### File: `tmp\xlsxwriter_old\XlsxWriter-1.4.5\examples\chart_gradient.py`

```python
#######################################################################
#
# An example of creating an Excel charts with gradient fills using
# Python and XlsxWriter.
#
# Copyright 2013-2021, John McNamara, jmcnamara@cpan.org
#
import xlsxwriter

workbook = xlsxwriter.Workbook('chart_gradient.xlsx')
worksheet = workbook.add_worksheet()
bold = workbook.add_format({'bold': 1})

# Add the worksheet data that the charts will refer to.
headings = ['Number', 'Batch 1', 'Batch 2']
data = [
    [2, 3, 4, 5, 6, 7],
    [10, 40, 50, 20, 10, 50],
    [30, 60, 70, 50, 40, 30],
]

worksheet.write_row('A1', headings, bold)
worksheet.write_column('A2', data[0])
worksheet.write_column('B2', data[1])
worksheet.write_column('C2', data[2])


# Create a new column chart.
chart = workbook.add_chart({'type': 'column'})

# Configure the first series, including a gradient.
chart.add_series({
    'name':       '=Sheet1!$B$1',
    'categories': '=Sheet1!$A$2:$A$7',
    'values':     '=Sheet1!$B$2:$B$7',
    'gradient':   {'colors': ['#963735', '#F1DCDB']}
})

# Configure the second series, including a gradient.
chart.add_series({
    'name':       '=Sheet1!$C$1',
    'categories': '=Sheet1!$A$2:$A$7',
    'values':     '=Sheet1!$C$2:$C$7',
    'gradient':   {'colors': ['#E36C0A', '#FCEADA']}
})

# Set a gradient for the plotarea.
chart.set_plotarea({
    'gradient': {'colors': ['#FFEFD1', '#F0EBD5', '#B69F66']}
})


# Add some axis labels.
chart.set_x_axis({'name': 'Test number'})
chart.set_y_axis({'name': 'Sample length (mm)'})

# Turn off the chart legend.
chart.set_legend({'none': True})

# Insert the chart into the worksheet.
worksheet.insert_chart('E2', chart)

workbook.close()

```

---

### File: `tmp\xlsxwriter_old\XlsxWriter-1.4.5\examples\chart_line.py`

```python
#######################################################################
#
# An example of creating Excel Line charts with Python and XlsxWriter.
#
# Copyright 2013-2021, John McNamara, jmcnamara@cpan.org
#
import xlsxwriter

workbook = xlsxwriter.Workbook('chart_line.xlsx')
worksheet = workbook.add_worksheet()
bold = workbook.add_format({'bold': 1})

# Add the worksheet data that the charts will refer to.
headings = ['Number', 'Batch 1', 'Batch 2']
data = [
    [2, 3, 4, 5, 6, 7],
    [10, 40, 50, 20, 10, 50],
    [30, 60, 70, 50, 40, 30],
]

worksheet.write_row('A1', headings, bold)
worksheet.write_column('A2', data[0])
worksheet.write_column('B2', data[1])
worksheet.write_column('C2', data[2])

# Create a new chart object. In this case an embedded chart.
chart1 = workbook.add_chart({'type': 'line'})

# Configure the first series.
chart1.add_series({
    'name':       '=Sheet1!$B$1',
    'categories': '=Sheet1!$A$2:$A$7',
    'values':     '=Sheet1!$B$2:$B$7',
})

# Configure a second series. Note use of alternative syntax to define ranges.
chart1.add_series({
    'name':       ['Sheet1', 0, 2],
    'categories': ['Sheet1', 1, 0, 6, 0],
    'values':     ['Sheet1', 1, 2, 6, 2],
})

# Add a chart title and some axis labels.
chart1.set_title ({'name': 'Results of sample analysis'})
chart1.set_x_axis({'name': 'Test number'})
chart1.set_y_axis({'name': 'Sample length (mm)'})

# Set an Excel chart style. Colors with white outline and shadow.
chart1.set_style(10)

# Insert the chart into the worksheet (with an offset).
worksheet.insert_chart('D2', chart1, {'x_offset': 25, 'y_offset': 10})

#######################################################################
#
# Create a stacked line chart sub-type.
#
chart2 = workbook.add_chart({'type': 'line', 'subtype': 'stacked'})

# Configure the first series.
chart2.add_series({
    'name':       '=Sheet1!$B$1',
    'categories': '=Sheet1!$A$2:$A$7',
    'values':     '=Sheet1!$B$2:$B$7',
})

# Configure second series.
chart2.add_series({
    'name':       '=Sheet1!$C$1',
    'categories': '=Sheet1!$A$2:$A$7',
    'values':     '=Sheet1!$C$2:$C$7',
})

# Add a chart title and some axis labels.
chart2.set_title ({'name': 'Stacked Chart'})
chart2.set_x_axis({'name': 'Test number'})
chart2.set_y_axis({'name': 'Sample length (mm)'})

# Set an Excel chart style.
chart2.set_style(12)

# Insert the chart into the worksheet (with an offset).
worksheet.insert_chart('D18', chart2, {'x_offset': 25, 'y_offset': 10})

#######################################################################
#
# Create a percent stacked line chart sub-type.
#
chart3 = workbook.add_chart({'type': 'line', 'subtype': 'percent_stacked'})

# Configure the first series.
chart3.add_series({
    'name':       '=Sheet1!$B$1',
    'categories': '=Sheet1!$A$2:$A$7',
    'values':     '=Sheet1!$B$2:$B$7',
})

# Configure second series.
chart3.add_series({
    'name':       '=Sheet1!$C$1',
    'categories': '=Sheet1!$A$2:$A$7',
    'values':     '=Sheet1!$C$2:$C$7',
})

# Add a chart title and some axis labels.
chart3.set_title ({'name': 'Percent Stacked Chart'})
chart3.set_x_axis({'name': 'Test number'})
chart3.set_y_axis({'name': 'Sample length (mm)'})

# Set an Excel chart style.
chart3.set_style(13)

# Insert the chart into the worksheet (with an offset).
worksheet.insert_chart('D34', chart3, {'x_offset': 25, 'y_offset': 10})

workbook.close()

```

---

### File: `tmp\xlsxwriter_old\XlsxWriter-1.4.5\examples\chart_pareto.py`

```python
#######################################################################
#
# An example of creating of a Pareto chart with Python and XlsxWriter.
#
# Copyright 2013-2021, John McNamara, jmcnamara@cpan.org
#
import xlsxwriter

workbook = xlsxwriter.Workbook('chart_pareto.xlsx')
worksheet = workbook.add_worksheet()

# Formats used in the workbook.
bold = workbook.add_format({'bold': True})
percent_format = workbook.add_format({'num_format': '0.0%'})

# Widen the columns for visibility.
worksheet.set_column('A:A', 15)
worksheet.set_column('B:C', 10)

# Add the worksheet data that the charts will refer to.
headings = ['Reason', 'Number', 'Percentage']

reasons = [
    'Traffic', 'Child care', 'Public Transport', 'Weather',
    'Overslept', 'Emergency',
]

numbers  = [60,   40,    20,  15,  10,    5]
percents = [0.44, 0.667, 0.8, 0.9, 0.967, 1]

worksheet.write_row('A1', headings, bold)
worksheet.write_column('A2', reasons)
worksheet.write_column('B2', numbers)
worksheet.write_column('C2', percents, percent_format)


# Create a new column chart. This will be the primary chart.
column_chart = workbook.add_chart({'type': 'column'})

# Add a series.
column_chart.add_series({
    'categories': '=Sheet1!$A$2:$A$7',
    'values':     '=Sheet1!$B$2:$B$7',
})

# Add a chart title.
column_chart.set_title({'name': 'Reasons for lateness'})

# Turn off the chart legend.
column_chart.set_legend({'position': 'none'})

# Set the title and scale of the Y axes. Note, the secondary axis is set from
# the primary chart.
column_chart.set_y_axis({
    'name': 'Respondents (number)',
    'min': 0,
    'max': 120
})
column_chart.set_y2_axis({'max': 1})

# Create a new line chart. This will be the secondary chart.
line_chart = workbook.add_chart({'type': 'line'})

# Add a series, on the secondary axis.
line_chart.add_series({
    'categories': '=Sheet1!$A$2:$A$7',
    'values':     '=Sheet1!$C$2:$C$7',
    'marker':     {'type': 'automatic'},
    'y2_axis':    1,
})

# Combine the charts.
column_chart.combine(line_chart)

# Insert the chart into the worksheet.
worksheet.insert_chart('F2', column_chart)

workbook.close()

```

---

### File: `tmp\xlsxwriter_old\XlsxWriter-1.4.5\examples\chart_pattern.py`

```python
#######################################################################
#
# An example of an Excel chart with patterns using Python and XlsxWriter.
#
# Copyright 2013-2021, John McNamara, jmcnamara@cpan.org
#
import xlsxwriter

workbook = xlsxwriter.Workbook('chart_pattern.xlsx')
worksheet = workbook.add_worksheet()
bold = workbook.add_format({'bold': 1})

# Add the worksheet data that the charts will refer to.
headings = ['Shingle', 'Brick']
data = [
    [105, 150, 130, 90 ],
    [50,  120, 100, 110],
]

worksheet.write_row('A1', headings, bold)
worksheet.write_column('A2', data[0])
worksheet.write_column('B2', data[1])

# Create a new Chart object.
chart = workbook.add_chart({'type': 'column'})

# Configure the charts. Add two series with patterns. The gap is used to make
# the patterns more visible.
chart.add_series({
    'name':   '=Sheet1!$A$1',
    'values': '=Sheet1!$A$2:$A$5',
    'pattern': {
        'pattern':  'shingle',
        'fg_color': '#804000',
        'bg_color': '#c68c53'
    },
    'border':  {'color': '#804000'},
    'gap':     70,
})

chart.add_series({
    'name':   '=Sheet1!$B$1',
    'values': '=Sheet1!$B$2:$B$5',
    'pattern': {
        'pattern':  'horizontal_brick',
        'fg_color': '#b30000',
        'bg_color': '#ff6666'
    },
    'border':  {'color': '#b30000'},
})

# Add a chart title and some axis labels.
chart.set_title ({'name': 'Cladding types'})
chart.set_x_axis({'name': 'Region'})
chart.set_y_axis({'name': 'Number of houses'})

# Insert the chart into the worksheet.
worksheet.insert_chart('D2', chart)

workbook.close()

```

---

### File: `tmp\xlsxwriter_old\XlsxWriter-1.4.5\examples\chart_pie.py`

```python
#######################################################################
#
# An example of creating Excel Pie charts with Python and XlsxWriter.
#
# The demo also shows how to set segment colors. It is possible to
# define chart colors for most types of XlsxWriter charts
# via the add_series() method. However, Pie/Doughnut charts are a special
# case since each segment is represented as a point so it is necessary to
# assign formatting to each point in the series.
#
# Copyright 2013-2021, John McNamara, jmcnamara@cpan.org
#
import xlsxwriter

workbook = xlsxwriter.Workbook('chart_pie.xlsx')

worksheet = workbook.add_worksheet()
bold = workbook.add_format({'bold': 1})

# Add the worksheet data that the charts will refer to.
headings = ['Category', 'Values']
data = [
    ['Apple', 'Cherry', 'Pecan'],
    [60, 30, 10],
]

worksheet.write_row('A1', headings, bold)
worksheet.write_column('A2', data[0])
worksheet.write_column('B2', data[1])

#######################################################################
#
# Create a new chart object.
#
chart1 = workbook.add_chart({'type': 'pie'})

# Configure the series. Note the use of the list syntax to define ranges:
chart1.add_series({
    'name':       'Pie sales data',
    'categories': ['Sheet1', 1, 0, 3, 0],
    'values':     ['Sheet1', 1, 1, 3, 1],
})

# Add a title.
chart1.set_title({'name': 'Popular Pie Types'})

# Set an Excel chart style. Colors with white outline and shadow.
chart1.set_style(10)

# Insert the chart into the worksheet (with an offset).
worksheet.insert_chart('C2', chart1, {'x_offset': 25, 'y_offset': 10})

#######################################################################
#
# Create a Pie chart with user defined segment colors.
#

# Create an example Pie chart like above.
chart2 = workbook.add_chart({'type': 'pie'})

# Configure the series and add user defined segment colors.
chart2.add_series({
    'name': 'Pie sales data',
    'categories': '=Sheet1!$A$2:$A$4',
    'values':     '=Sheet1!$B$2:$B$4',
    'points': [
        {'fill': {'color': '#5ABA10'}},
        {'fill': {'color': '#FE110E'}},
        {'fill': {'color': '#CA5C05'}},
    ],
})

# Add a title.
chart2.set_title({'name': 'Pie Chart with user defined colors'})

# Insert the chart into the worksheet (with an offset).
worksheet.insert_chart('C18', chart2, {'x_offset': 25, 'y_offset': 10})

#######################################################################
#
# Create a Pie chart with rotation of the segments.
#

# Create an example Pie chart like above.
chart3 = workbook.add_chart({'type': 'pie'})

# Configure the series.
chart3.add_series({
    'name': 'Pie sales data',
    'categories': '=Sheet1!$A$2:$A$4',
    'values':     '=Sheet1!$B$2:$B$4',
})

# Add a title.
chart3.set_title({'name': 'Pie Chart with segment rotation'})

# Change the angle/rotation of the first segment.
chart3.set_rotation(90)

# Insert the chart into the worksheet (with an offset).
worksheet.insert_chart('C34', chart3, {'x_offset': 25, 'y_offset': 10})

workbook.close()

```

---

### File: `tmp\xlsxwriter_old\XlsxWriter-1.4.5\examples\chart_radar.py`

```python
#######################################################################
#
# An example of creating Excel Radar charts with Python and XlsxWriter.
#
# Copyright 2013-2021, John McNamara, jmcnamara@cpan.org
#
import xlsxwriter

workbook = xlsxwriter.Workbook('chart_radar.xlsx')
worksheet = workbook.add_worksheet()
bold = workbook.add_format({'bold': 1})

# Add the worksheet data that the charts will refer to.
headings = ['Number', 'Batch 1', 'Batch 2']
data = [
    [2, 3, 4, 5, 6, 7],
    [30, 60, 70, 50, 40, 30],
    [25, 40, 50, 30, 50, 40],
]

worksheet.write_row('A1', headings, bold)
worksheet.write_column('A2', data[0])
worksheet.write_column('B2', data[1])
worksheet.write_column('C2', data[2])

#######################################################################
#
# Create a new radar chart.
#
chart1 = workbook.add_chart({'type': 'radar'})

# Configure the first series.
chart1.add_series({
    'name':       '=Sheet1!$B$1',
    'categories': '=Sheet1!$A$2:$A$7',
    'values':     '=Sheet1!$B$2:$B$7',
})

# Configure second series. Note use of alternative syntax to define ranges.
chart1.add_series({
    'name':       ['Sheet1', 0, 2],
    'categories': ['Sheet1', 1, 0, 6, 0],
    'values':     ['Sheet1', 1, 2, 6, 2],
})

# Add a chart title and some axis labels.
chart1.set_title ({'name': 'Results of sample analysis'})
chart1.set_x_axis({'name': 'Test number'})
chart1.set_y_axis({'name': 'Sample length (mm)'})

# Set an Excel chart style.
chart1.set_style(11)

# Insert the chart into the worksheet (with an offset).
worksheet.insert_chart('D2', chart1, {'x_offset': 25, 'y_offset': 10})

#######################################################################
#
# Create a radar chart with markers chart sub-type.
#
chart2 = workbook.add_chart({'type': 'radar', 'subtype': 'with_markers'})

# Configure the first series.
chart2.add_series({
    'name':       '=Sheet1!$B$1',
    'categories': '=Sheet1!$A$2:$A$7',
    'values':     '=Sheet1!$B$2:$B$7',
})

# Configure second series.
chart2.add_series({
    'name':       '=Sheet1!$C$1',
    'categories': '=Sheet1!$A$2:$A$7',
    'values':     '=Sheet1!$C$2:$C$7',
})

# Add a chart title and some axis labels.
chart2.set_title ({'name': 'Radar Chart With Markers'})
chart2.set_x_axis({'name': 'Test number'})
chart2.set_y_axis({'name': 'Sample length (mm)'})

# Set an Excel chart style.
chart2.set_style(12)

# Insert the chart into the worksheet (with an offset).
worksheet.insert_chart('D18', chart2, {'x_offset': 25, 'y_offset': 10})

#######################################################################
#
# Create a filled radar chart sub-type.
#
chart3 = workbook.add_chart({'type': 'radar', 'subtype': 'filled'})

# Configure the first series.
chart3.add_series({
    'name':       '=Sheet1!$B$1',
    'categories': '=Sheet1!$A$2:$A$7',
    'values':     '=Sheet1!$B$2:$B$7',
})

# Configure second series.
chart3.add_series({
    'name':       '=Sheet1!$C$1',
    'categories': '=Sheet1!$A$2:$A$7',
    'values':     '=Sheet1!$C$2:$C$7',
})

# Add a chart title and some axis labels.
chart3.set_title ({'name': 'Filled Radar Chart'})
chart3.set_x_axis({'name': 'Test number'})
chart3.set_y_axis({'name': 'Sample length (mm)'})

# Set an Excel chart style.
chart3.set_style(13)

# Insert the chart into the worksheet (with an offset).
worksheet.insert_chart('D34', chart3, {'x_offset': 25, 'y_offset': 10})

workbook.close()

```

---

### File: `tmp\xlsxwriter_old\XlsxWriter-1.4.5\examples\chart_scatter.py`

```python
#######################################################################
#
# An example of creating Excel Scatter charts with Python and XlsxWriter.
#
# Copyright 2013-2021, John McNamara, jmcnamara@cpan.org
#
import xlsxwriter

workbook = xlsxwriter.Workbook('chart_scatter.xlsx')
worksheet = workbook.add_worksheet()
bold = workbook.add_format({'bold': 1})

# Add the worksheet data that the charts will refer to.
headings = ['Number', 'Batch 1', 'Batch 2']
data = [
    [2, 3, 4, 5, 6, 7],
    [10, 40, 50, 20, 10, 50],
    [30, 60, 70, 50, 40, 30],
]

worksheet.write_row('A1', headings, bold)
worksheet.write_column('A2', data[0])
worksheet.write_column('B2', data[1])
worksheet.write_column('C2', data[2])


#######################################################################
#
# Create a new scatter chart.
#
chart1 = workbook.add_chart({'type': 'scatter'})

# Configure the first series.
chart1.add_series({
    'name': '=Sheet1!$B$1',
    'categories': '=Sheet1!$A$2:$A$7',
    'values': '=Sheet1!$B$2:$B$7',
})

# Configure second series. Note use of alternative syntax to define ranges.
chart1.add_series({
    'name':       ['Sheet1', 0, 2],
    'categories': ['Sheet1', 1, 0, 6, 0],
    'values':     ['Sheet1', 1, 2, 6, 2],
})

# Add a chart title and some axis labels.
chart1.set_title ({'name': 'Results of sample analysis'})
chart1.set_x_axis({'name': 'Test number'})
chart1.set_y_axis({'name': 'Sample length (mm)'})

# Set an Excel chart style.
chart1.set_style(11)

# Insert the chart into the worksheet (with an offset).
worksheet.insert_chart('D2', chart1, {'x_offset': 25, 'y_offset': 10})

#######################################################################
#
# Create a scatter chart sub-type with straight lines and markers.
#
chart2 = workbook.add_chart({'type': 'scatter',
                             'subtype': 'straight_with_markers'})

# Configure the first series.
chart2.add_series({
    'name':       '=Sheet1!$B$1',
    'categories': '=Sheet1!$A$2:$A$7',
    'values':     '=Sheet1!$B$2:$B$7',
})

# Configure second series.
chart2.add_series({
    'name':       '=Sheet1!$C$1',
    'categories': '=Sheet1!$A$2:$A$7',
    'values':     '=Sheet1!$C$2:$C$7',
})

# Add a chart title and some axis labels.
chart2.set_title ({'name': 'Straight line with markers'})
chart2.set_x_axis({'name': 'Test number'})
chart2.set_y_axis({'name': 'Sample length (mm)'})

# Set an Excel chart style.
chart2.set_style(12)

# Insert the chart into the worksheet (with an offset).
worksheet.insert_chart('D18', chart2, {'x_offset': 25, 'y_offset': 10})

#######################################################################
#
# Create a scatter chart sub-type with straight lines and no markers.
#
chart3 = workbook.add_chart({'type': 'scatter',
                             'subtype': 'straight'})

# Configure the first series.
chart3.add_series({
    'name':       '=Sheet1!$B$1',
    'categories': '=Sheet1!$A$2:$A$7',
    'values':     '=Sheet1!$B$2:$B$7',
})

# Configure second series.
chart3.add_series({
    'name':       '=Sheet1!$C$1',
    'categories': '=Sheet1!$A$2:$A$7',
    'values':     '=Sheet1!$C$2:$C$7',
})

# Add a chart title and some axis labels.
chart3.set_title ({'name': 'Straight line'})
chart3.set_x_axis({'name': 'Test number'})
chart3.set_y_axis({'name': 'Sample length (mm)'})

# Set an Excel chart style.
chart3.set_style(13)

# Insert the chart into the worksheet (with an offset).
worksheet.insert_chart('D34', chart3, {'x_offset': 25, 'y_offset': 10})

#######################################################################
#
# Create a scatter chart sub-type with smooth lines and markers.
#
chart4 = workbook.add_chart({'type': 'scatter',
                             'subtype': 'smooth_with_markers'})

# Configure the first series.
chart4.add_series({
    'name':       '=Sheet1!$B$1',
    'categories': '=Sheet1!$A$2:$A$7',
    'values':     '=Sheet1!$B$2:$B$7',
})

# Configure second series.
chart4.add_series({
    'name':       '=Sheet1!$C$1',
    'categories': '=Sheet1!$A$2:$A$7',
    'values':     '=Sheet1!$C$2:$C$7',
})

# Add a chart title and some axis labels.
chart4.set_title ({'name': 'Smooth line with markers'})
chart4.set_x_axis({'name': 'Test number'})
chart4.set_y_axis({'name': 'Sample length (mm)'})

# Set an Excel chart style.
chart4.set_style(14)

# Insert the chart into the worksheet (with an offset).
worksheet.insert_chart('D50', chart4, {'x_offset': 25, 'y_offset': 10})

#######################################################################
#
# Create a scatter chart sub-type with smooth lines and no markers.
#
chart5 = workbook.add_chart({'type': 'scatter',
                             'subtype': 'smooth'})

# Configure the first series.
chart5.add_series({
    'name':       '=Sheet1!$B$1',
    'categories': '=Sheet1!$A$2:$A$7',
    'values':     '=Sheet1!$B$2:$B$7',
})

# Configure second series.
chart5.add_series({
    'name':       '=Sheet1!$C$1',
    'categories': '=Sheet1!$A$2:$A$7',
    'values':     '=Sheet1!$C$2:$C$7',
})

# Add a chart title and some axis labels.
chart5.set_title ({'name': 'Smooth line'})
chart5.set_x_axis({'name': 'Test number'})
chart5.set_y_axis({'name': 'Sample length (mm)'})

# Set an Excel chart style.
chart5.set_style(15)

# Insert the chart into the worksheet (with an offset).
worksheet.insert_chart('D66', chart5, {'x_offset': 25, 'y_offset': 10})

workbook.close()

```

---

### File: `tmp\xlsxwriter_old\XlsxWriter-1.4.5\examples\chart_secondary_axis.py`

```python
#######################################################################
#
# An example of creating an Excel Line chart with a secondary axis
# using Python and XlsxWriter.
#
# Copyright 2013-2021, John McNamara, jmcnamara@cpan.org
#
import xlsxwriter

workbook = xlsxwriter.Workbook('chart_secondary_axis.xlsx')
worksheet = workbook.add_worksheet()
bold = workbook.add_format({'bold': 1})

# Add the worksheet data that the charts will refer to.
headings = ['Aliens', 'Humans']
data = [
    [2, 3, 4, 5, 6, 7],
    [10, 40, 50, 20, 10, 50],
]

worksheet.write_row('A1', headings, bold)
worksheet.write_column('A2', data[0])
worksheet.write_column('B2', data[1])


# Create a new chart object. In this case an embedded chart.
chart = workbook.add_chart({'type': 'line'})

# Configure a series with a secondary axis
chart.add_series({
    'name':   '=Sheet1!$A$1',
    'values': '=Sheet1!$A$2:$A$7',
    'y2_axis': 1,
})

chart.add_series({
    'name':   '=Sheet1!$B$1',
    'values': '=Sheet1!$B$2:$B$7',
})

chart.set_legend({'position': 'right'})

# Add a chart title and some axis labels.
chart.set_title({'name': 'Survey results'})
chart.set_x_axis({'name': 'Days', })
chart.set_y_axis({'name': 'Population', 'major_gridlines': {'visible': 0}})
chart.set_y2_axis({'name': 'Laser wounds'})

# Insert the chart into the worksheet (with an offset).
worksheet.insert_chart('D2', chart, {'x_offset': 25, 'y_offset': 10})

workbook.close()

```

---

### File: `tmp\xlsxwriter_old\XlsxWriter-1.4.5\examples\chart_stock.py`

```python
#######################################################################
#
# An example of creating Excel Stock charts with Python and XlsxWriter.
#
# Copyright 2013-2021, John McNamara, jmcnamara@cpan.org
#
from datetime import datetime
import xlsxwriter

workbook = xlsxwriter.Workbook('chart_stock.xlsx')
worksheet = workbook.add_worksheet()

bold = workbook.add_format({'bold': 1})
date_format = workbook.add_format({'num_format': 'dd/mm/yyyy'})

chart = workbook.add_chart({'type': 'stock'})

# Add the worksheet data that the charts will refer to.
headings = ['Date', 'High', 'Low', 'Close']
data = [
    ['2007-01-01', '2007-01-02', '2007-01-03', '2007-01-04', '2007-01-05'],
    [27.2, 25.03, 19.05, 20.34, 18.5],
    [23.49, 19.55, 15.12, 17.84, 16.34],
    [25.45, 23.05, 17.32, 20.45, 17.34],
]

worksheet.write_row('A1', headings, bold)

for row in range(5):
    date = datetime.strptime(data[0][row], "%Y-%m-%d")

    worksheet.write(row + 1, 0, date, date_format)
    worksheet.write(row + 1, 1, data[1][row])
    worksheet.write(row + 1, 2, data[2][row])
    worksheet.write(row + 1, 3, data[3][row])

worksheet.set_column('A:D', 11)

# Add a series for each of the High-Low-Close columns.
chart.add_series({
    'categories': '=Sheet1!$A$2:$A$6',
    'values': '=Sheet1!$B$2:$B$6',
})

chart.add_series({
    'categories': '=Sheet1!$A$2:$A$6',
    'values':     '=Sheet1!$C$2:$C$6',
})

chart.add_series({
    'categories': '=Sheet1!$A$2:$A$6',
    'values': '=Sheet1!$D$2:$D$6',
})

# Add a chart title and some axis labels.
chart.set_title ({'name': 'High-Low-Close'})
chart.set_x_axis({'name': 'Date'})
chart.set_y_axis({'name': 'Share price'})

worksheet.insert_chart('E9', chart)

workbook.close()

```

---

### File: `tmp\xlsxwriter_old\XlsxWriter-1.4.5\examples\chart_styles.py`

```python
#######################################################################
#
# An example showing all 48 default chart styles available in Excel 2007
# using Python and XlsxWriter. Note, these styles are not the same as
# the styles available in Excel 2013.
#
# Copyright 2013-2021, John McNamara, jmcnamara@cpan.org
#
import xlsxwriter

workbook = xlsxwriter.Workbook('chart_styles.xlsx')

# Show the styles for all of these chart types.
chart_types = ['column', 'area', 'line', 'pie']

for chart_type in chart_types:

    # Add a worksheet for each chart type.
    worksheet = workbook.add_worksheet(chart_type.title())
    worksheet.set_zoom(30)
    style_number = 1

    # Create 48 charts, each with a different style.
    for row_num in range(0, 90, 15):
        for col_num in range(0, 64, 8):

            chart = workbook.add_chart({'type': chart_type})
            chart.add_series({'values': '=Data!$A$1:$A$6'})
            chart.set_title ({'name': 'Style %d' % style_number})
            chart.set_legend({'none': True})
            chart.set_style(style_number)

            worksheet.insert_chart(row_num, col_num , chart)
            style_number += 1

# Create a worksheet with data for the charts.
data_worksheet = workbook.add_worksheet('Data')
data = [10, 40, 50, 20, 10, 50]
data_worksheet.write_column('A1', data)
data_worksheet.hide()

workbook.close()

```

---

### File: `tmp\xlsxwriter_old\XlsxWriter-1.4.5\examples\chartsheet.py`

```python
#######################################################################
#
# An example of creating an Excel chart in a chartsheet with Python
# and XlsxWriter.
#
# Copyright 2013-2021, John McNamara, jmcnamara@cpan.org
#
import xlsxwriter

workbook = xlsxwriter.Workbook('chartsheet.xlsx')

# Add a worksheet to hold the data.
worksheet = workbook.add_worksheet()

# Add a chartsheet. A worksheet that only holds a chart.
chartsheet = workbook.add_chartsheet()

# Add a format for the headings.
bold = workbook.add_format({'bold': 1})

# Add the worksheet data that the charts will refer to.
headings = ['Number', 'Batch 1', 'Batch 2']
data = [
    [2, 3, 4, 5, 6, 7],
    [10, 40, 50, 20, 10, 50],
    [30, 60, 70, 50, 40, 30],
]

worksheet.write_row('A1', headings, bold)
worksheet.write_column('A2', data[0])
worksheet.write_column('B2', data[1])
worksheet.write_column('C2', data[2])


# Create a new bar chart.
chart1 = workbook.add_chart({'type': 'bar'})

# Configure the first series.
chart1.add_series({
    'name':       '=Sheet1!$B$1',
    'categories': '=Sheet1!$A$2:$A$7',
    'values':     '=Sheet1!$B$2:$B$7',
})

# Configure a second series. Note use of alternative syntax to define ranges.
chart1.add_series({
    'name':       ['Sheet1', 0, 2],
    'categories': ['Sheet1', 1, 0, 6, 0],
    'values':     ['Sheet1', 1, 2, 6, 2],
})

# Add a chart title and some axis labels.
chart1.set_title ({'name': 'Results of sample analysis'})
chart1.set_x_axis({'name': 'Test number'})
chart1.set_y_axis({'name': 'Sample length (mm)'})

# Set an Excel chart style.
chart1.set_style(11)

# Add the chart to the chartsheet.
chartsheet.set_chart(chart1)

# Display the chartsheet as the active sheet when the workbook is opened.
chartsheet.activate();

workbook.close()

```

---

### File: `tmp\xlsxwriter_old\XlsxWriter-1.4.5\examples\check_close.py`

```python
##############################################################################
#
# A simple program demonstrating a check for exceptions when closing the file.
#
# Copyright 2013-2021, John McNamara, jmcnamara@cpan.org
#
import xlsxwriter

workbook = xlsxwriter.Workbook('check_close.xlsx')
worksheet = workbook.add_worksheet()

worksheet.write('A1', 'Hello world')

# Try to close() the file in a loop so that if there is an exception, such as
# if the file is open in Excel, we can ask the user to close the file, and
# try again to overwrite it.
while True:
    try:
        workbook.close()
    except xlsxwriter.exceptions.FileCreateError as e:
        # For Python 3 use input() instead of raw_input().
        decision = raw_input("Exception caught in workbook.close(): %s\n"
                             "Please close the file if it is open in Excel.\n"
                             "Try to write file again? [Y/n]: " % e)
        if decision != 'n':
            continue

    break

```

---

### File: `tmp\xlsxwriter_old\XlsxWriter-1.4.5\examples\comments1.py`

```python
###############################################################################
#
# An example of writing cell comments to a worksheet using Python and
# XlsxWriter.
#
# For more advanced comment options see comments2.py.
#
# Copyright 2013-2021, John McNamara, jmcnamara@cpan.org
#
import xlsxwriter

workbook = xlsxwriter.Workbook('comments1.xlsx')
worksheet = workbook.add_worksheet()

worksheet.write('A1', 'Hello')
worksheet.write_comment('A1', 'This is a comment')

workbook.close()

```

---

### File: `tmp\xlsxwriter_old\XlsxWriter-1.4.5\examples\comments2.py`

```python
###############################################################################
#
# An example of writing cell comments to a worksheet using Python and
# XlsxWriter.
#
# Each of the worksheets demonstrates different features of cell comments.
#
# Copyright 2013-2021, John McNamara, jmcnamara@cpan.org
#
import xlsxwriter

workbook = xlsxwriter.Workbook('comments.xlsx')

worksheet1 = workbook.add_worksheet()
worksheet2 = workbook.add_worksheet()
worksheet3 = workbook.add_worksheet()
worksheet4 = workbook.add_worksheet()
worksheet5 = workbook.add_worksheet()
worksheet6 = workbook.add_worksheet()
worksheet7 = workbook.add_worksheet()
worksheet8 = workbook.add_worksheet()

text_wrap = workbook.add_format({'text_wrap': 1, 'valign': 'top'})


###############################################################################
#
# Example 1. Demonstrates a simple cell comments without formatting.
#

# Set up some formatting.
worksheet1.set_column('C:C', 25)
worksheet1.set_row(2, 50)

# Simple ASCII string.
cell_text = 'Hold the mouse over this cell to see the comment.'

comment = 'This is a comment.'

worksheet1.write('C3', cell_text, text_wrap)
worksheet1.write_comment('C3', comment)


###############################################################################
#
# Example 2. Demonstrates visible and hidden comments.
#

# Set up some formatting.
worksheet2.set_column('C:C', 25)
worksheet2.set_row(2, 50)
worksheet2.set_row(5, 50)

cell_text = 'This cell comment is visible.'
comment = 'Hello.'

worksheet2.write('C3', cell_text, text_wrap)
worksheet2.write_comment('C3', comment, {'visible': True})

cell_text = "This cell comment isn't visible (the default)."

worksheet2.write('C6', cell_text, text_wrap)
worksheet2.write_comment('C6', comment)


###############################################################################
#
# Example 3. Demonstrates visible and hidden comments set at the worksheet
#            level.
#

# Set up some formatting.
worksheet3.set_column('C:C', 25)
worksheet3.set_row(2, 50)
worksheet3.set_row(5, 50)
worksheet3.set_row(8, 50)

# Make all comments on the worksheet visible.
worksheet3.show_comments()

cell_text = 'This cell comment is visible, explicitly.'
comment = 'Hello.'

worksheet3.write('C3', cell_text, text_wrap)
worksheet3.write_comment('C3', comment, {'visible': True})

cell_text = 'This cell comment is also visible because of show_comments().'

worksheet3.write('C6', cell_text, text_wrap)
worksheet3.write_comment('C6', comment)

cell_text = 'However, we can still override it locally.'

worksheet3.write('C9', cell_text, text_wrap)
worksheet3.write_comment('C9', comment, {'visible': False})


###############################################################################
#
# Example 4. Demonstrates changes to the comment box dimensions.
#

# Set up some formatting.
worksheet4.set_column('C:C', 25)
worksheet4.set_row(2, 50)
worksheet4.set_row(5, 50)
worksheet4.set_row(8, 50)
worksheet4.set_row(15, 50)
worksheet4.set_row(18, 50)

worksheet4.show_comments()

cell_text = 'This cell comment is default size.'
comment = 'Hello.'

worksheet4.write('C3', cell_text, text_wrap)
worksheet4.write_comment('C3', comment)

cell_text = 'This cell comment is twice as wide.'

worksheet4.write('C6', cell_text, text_wrap)
worksheet4.write_comment('C6', comment, {'x_scale': 2})

cell_text = 'This cell comment is twice as high.'

worksheet4.write('C9', cell_text, text_wrap)
worksheet4.write_comment('C9', comment, {'y_scale': 2})

cell_text = 'This cell comment is scaled in both directions.'

worksheet4.write('C16', cell_text, text_wrap)
worksheet4.write_comment('C16', comment, {'x_scale': 1.2, 'y_scale': 0.5})

cell_text = 'This cell comment has width and height specified in pixels.'

worksheet4.write('C19', cell_text, text_wrap)
worksheet4.write_comment('C19', comment, {'width': 200, 'height': 50})


###############################################################################
#
# Example 5. Demonstrates changes to the cell comment position.
#
worksheet5.set_column('C:C', 25)
worksheet5.set_row(2, 50)
worksheet5.set_row(5, 50)
worksheet5.set_row(8, 50)
worksheet5.set_row(11, 50)

worksheet5.show_comments()

cell_text = 'This cell comment is in the default position.'
comment = 'Hello.'

worksheet5.write('C3', cell_text, text_wrap)
worksheet5.write_comment('C3', comment)

cell_text = 'This cell comment has been moved to another cell.'

worksheet5.write('C6', cell_text, text_wrap)
worksheet5.write_comment('C6', comment, {'start_cell': 'E4'})

cell_text = 'This cell comment has been moved to another cell.'

worksheet5.write('C9', cell_text, text_wrap)
worksheet5.write_comment('C9', comment, {'start_row': 8, 'start_col': 4})

cell_text = 'This cell comment has been shifted within its default cell.'

worksheet5.write('C12', cell_text, text_wrap)
worksheet5.write_comment('C12', comment, {'x_offset': 30, 'y_offset': 12})


###############################################################################
#
# Example 6. Demonstrates changes to the comment background color.
#
worksheet6.set_column('C:C', 25)
worksheet6.set_row(2, 50)
worksheet6.set_row(5, 50)
worksheet6.set_row(8, 50)

worksheet6.show_comments()

cell_text = 'This cell comment has a different color.'
comment = 'Hello.'

worksheet6.write('C3', cell_text, text_wrap)
worksheet6.write_comment('C3', comment, {'color': 'green'})

cell_text = 'This cell comment has the default color.'

worksheet6.write('C6', cell_text, text_wrap)
worksheet6.write_comment('C6', comment)

cell_text = 'This cell comment has a different color.'

worksheet6.write('C9', cell_text, text_wrap)
worksheet6.write_comment('C9', comment, {'color': '#CCFFCC'})


###############################################################################
#
# Example 7. Demonstrates how to set the cell comment author.
#
worksheet7.set_column('C:C', 30)
worksheet7.set_row(2, 50)
worksheet7.set_row(5, 50)

author = ''
cell = 'C3'

cell_text = ("Move the mouse over this cell and you will see 'Cell commented "
             "by (blank)' in the status bar at the bottom")

comment = 'Hello.'

worksheet7.write(cell, cell_text, text_wrap)
worksheet7.write_comment(cell, comment)

author = 'Python'
cell = 'C6'
cell_text = ("Move the mouse over this cell and you will see 'Cell commented "
             "by Python' in the status bar at the bottom")

worksheet7.write(cell, cell_text, text_wrap)
worksheet7.write_comment(cell, comment, {'author': author})


###############################################################################
#
# Example 8. Demonstrates the need to explicitly set the row height.
#

# Set up some formatting.
worksheet8.set_column('C:C', 25)
worksheet8.set_row(2, 80)

worksheet8.show_comments()

cell_text = ('The height of this row has been adjusted explicitly using '
             'set_row(). The size of the comment box is adjusted '
             'accordingly by XlsxWriter.')

comment = 'Hello.'

worksheet8.write('C3', cell_text, text_wrap)
worksheet8.write_comment('C3', comment)

cell_text = ('The height of this row has been adjusted by Excel due to the '
             'text wrap property being set. Unfortunately this means that '
             'the height of the row is unknown to XlsxWriter at run time '
             "and thus the comment box is stretched as well.\n\n"
             'Use set_row() to specify the row height explicitly to avoid '
             'this problem.')

worksheet8.write('C6', cell_text, text_wrap)
worksheet8.write_comment('C6', comment)

workbook.close()

```

---

### File: `tmp\xlsxwriter_old\XlsxWriter-1.4.5\examples\conditional_format.py`

```python
###############################################################################
#
# Example of how to add conditional formatting to an XlsxWriter file.
#
# Conditional formatting allows you to apply a format to a cell or a
# range of cells based on certain criteria.
#
# Copyright 2013-2021, John McNamara, jmcnamara@cpan.org
#
import xlsxwriter

workbook = xlsxwriter.Workbook('conditional_format.xlsx')
worksheet1 = workbook.add_worksheet()
worksheet2 = workbook.add_worksheet()
worksheet3 = workbook.add_worksheet()
worksheet4 = workbook.add_worksheet()
worksheet5 = workbook.add_worksheet()
worksheet6 = workbook.add_worksheet()
worksheet7 = workbook.add_worksheet()
worksheet8 = workbook.add_worksheet()
worksheet9 = workbook.add_worksheet()

# Add a format. Light red fill with dark red text.
format1 = workbook.add_format({'bg_color': '#FFC7CE',
                               'font_color': '#9C0006'})

# Add a format. Green fill with dark green text.
format2 = workbook.add_format({'bg_color': '#C6EFCE',
                               'font_color': '#006100'})

# Some sample data to run the conditional formatting against.
data = [
    [34, 72, 38, 30, 75, 48, 75, 66, 84, 86],
    [6, 24, 1, 84, 54, 62, 60, 3, 26, 59],
    [28, 79, 97, 13, 85, 93, 93, 22, 5, 14],
    [27, 71, 40, 17, 18, 79, 90, 93, 29, 47],
    [88, 25, 33, 23, 67, 1, 59, 79, 47, 36],
    [24, 100, 20, 88, 29, 33, 38, 54, 54, 88],
    [6, 57, 88, 28, 10, 26, 37, 7, 41, 48],
    [52, 78, 1, 96, 26, 45, 47, 33, 96, 36],
    [60, 54, 81, 66, 81, 90, 80, 93, 12, 55],
    [70, 5, 46, 14, 71, 19, 66, 36, 41, 21],
]


###############################################################################
#
# Example 1.
#
caption = ('Cells with values >= 50 are in light red. '
           'Values < 50 are in light green.')

# Write the data.
worksheet1.write('A1', caption)

for row, row_data in enumerate(data):
    worksheet1.write_row(row + 2, 1, row_data)

# Write a conditional format over a range.
worksheet1.conditional_format('B3:K12', {'type': 'cell',
                                         'criteria': '>=',
                                         'value': 50,
                                         'format': format1})

# Write another conditional format over the same range.
worksheet1.conditional_format('B3:K12', {'type': 'cell',
                                         'criteria': '<',
                                         'value': 50,
                                         'format': format2})


###############################################################################
#
# Example 2.
#
caption = ('Values between 30 and 70 are in light red. '
           'Values outside that range are in light green.')

worksheet2.write('A1', caption)

for row, row_data in enumerate(data):
    worksheet2.write_row(row + 2, 1, row_data)

worksheet2.conditional_format('B3:K12', {'type': 'cell',
                                         'criteria': 'between',
                                         'minimum': 30,
                                         'maximum': 70,
                                         'format': format1})

worksheet2.conditional_format('B3:K12', {'type': 'cell',
                                         'criteria': 'not between',
                                         'minimum': 30,
                                         'maximum': 70,
                                         'format': format2})


###############################################################################
#
# Example 3.
#
caption = ('Duplicate values are in light red. '
           'Unique values are in light green.')

worksheet3.write('A1', caption)

for row, row_data in enumerate(data):
    worksheet3.write_row(row + 2, 1, row_data)

worksheet3.conditional_format('B3:K12', {'type': 'duplicate',
                                         'format': format1})

worksheet3.conditional_format('B3:K12', {'type': 'unique',
                                         'format': format2})


###############################################################################
#
# Example 4.
#
caption = ('Above average values are in light red. '
           'Below average values are in light green.')

worksheet4.write('A1', caption)

for row, row_data in enumerate(data):
    worksheet4.write_row(row + 2, 1, row_data)

worksheet4.conditional_format('B3:K12', {'type': 'average',
                                         'criteria': 'above',
                                         'format': format1})

worksheet4.conditional_format('B3:K12', {'type': 'average',
                                         'criteria': 'below',
                                         'format': format2})


###############################################################################
#
# Example 5.
#
caption = ('Top 10 values are in light red. '
           'Bottom 10 values are in light green.')

worksheet5.write('A1', caption)

for row, row_data in enumerate(data):
    worksheet5.write_row(row + 2, 1, row_data)

worksheet5.conditional_format('B3:K12', {'type': 'top',
                                         'value': '10',
                                         'format': format1})

worksheet5.conditional_format('B3:K12', {'type': 'bottom',
                                         'value': '10',
                                         'format': format2})


###############################################################################
#
# Example 6.
#
caption = ('Cells with values >= 50 are in light red. '
           'Values < 50 are in light green. Non-contiguous ranges.')

# Write the data.
worksheet6.write('A1', caption)

for row, row_data in enumerate(data):
    worksheet6.write_row(row + 2, 1, row_data)

# Write a conditional format over a range.
worksheet6.conditional_format('B3:K6', {'type': 'cell',
                                        'criteria': '>=',
                                        'value': 50,
                                        'format': format1,
                                        'multi_range': 'B3:K6 B9:K12'})

# Write another conditional format over the same range.
worksheet6.conditional_format('B3:K6', {'type': 'cell',
                                        'criteria': '<',
                                        'value': 50,
                                        'format': format2,
                                        'multi_range': 'B3:K6 B9:K12'})


###############################################################################
#
# Example 7.
#
caption = 'Examples of color scales with default and user colors.'

data = range(1, 13)

worksheet7.write('A1', caption)

worksheet7.write('B2', "2 Color Scale")
worksheet7.write('D2', "2 Color Scale + user colors")

worksheet7.write('G2', "3 Color Scale")
worksheet7.write('I2', "3 Color Scale + user colors")

for row, row_data in enumerate(data):
    worksheet7.write(row + 2, 1, row_data)
    worksheet7.write(row + 2, 3, row_data)
    worksheet7.write(row + 2, 6, row_data)
    worksheet7.write(row + 2, 8, row_data)

worksheet7.conditional_format('B3:B14', {'type': '2_color_scale'})

worksheet7.conditional_format('D3:D14', {'type': '2_color_scale',
                                         'min_color': "#FF0000",
                                         'max_color': "#00FF00"})

worksheet7.conditional_format('G3:G14', {'type': '3_color_scale'})

worksheet7.conditional_format('I3:I14', {'type': '3_color_scale',
                                         'min_color': "#C5D9F1",
                                         'mid_color': "#8DB4E3",
                                         'max_color': "#538ED5"})


###############################################################################
#
# Example 8.
#
caption = 'Examples of data bars.'

worksheet8.write('A1', caption)

worksheet8.write('B2', "Default data bars")
worksheet8.write('D2', "Bars only")
worksheet8.write('F2', "With user color")
worksheet8.write('H2', "Solid bars")
worksheet8.write('J2', "Right to left")
worksheet8.write('L2', "Excel 2010 style")
worksheet8.write('N2', "Negative same as positive")

data = range(1, 13)
for row, row_data in enumerate(data):
    worksheet8.write(row + 2, 1, row_data)
    worksheet8.write(row + 2, 3, row_data)
    worksheet8.write(row + 2, 5, row_data)
    worksheet8.write(row + 2, 7, row_data)
    worksheet8.write(row + 2, 9, row_data)

data = [-1, -2, -3, -2, -1, 0, 1, 2, 3, 2, 1, 0]
for row, row_data in enumerate(data):
    worksheet8.write(row + 2, 11, row_data)
    worksheet8.write(row + 2, 13, row_data)

worksheet8.conditional_format('B3:B14', {'type': 'data_bar'})

worksheet8.conditional_format('D3:D14', {'type': 'data_bar',
                                         'bar_only': True})

worksheet8.conditional_format('F3:F14', {'type': 'data_bar',
                                         'bar_color': '#63C384'})

worksheet8.conditional_format('H3:H14', {'type': 'data_bar',
                                         'bar_solid': True})

worksheet8.conditional_format('J3:J14', {'type': 'data_bar',
                                         'bar_direction': 'right'})

worksheet8.conditional_format('L3:L14', {'type': 'data_bar',
                                         'data_bar_2010': True})

worksheet8.conditional_format('N3:N14', {'type': 'data_bar',
                                         'bar_negative_color_same': True,
                                         'bar_negative_border_color_same': True})


###############################################################################
#
# Example 9.
#
caption = 'Examples of conditional formats with icon sets.'

data = [
    [1, 2, 3],
    [1, 2, 3],
    [1, 2, 3],
    [1, 2, 3],
    [1, 2, 3, 4],
    [1, 2, 3, 4, 5],
    [1, 2, 3, 4, 5],
]

worksheet9.write('A1', caption)

for row, row_data in enumerate(data):
    worksheet9.write_row(row + 2, 1, row_data)

worksheet9.conditional_format('B3:D3', {'type': 'icon_set',
                                        'icon_style': '3_traffic_lights'})

worksheet9.conditional_format('B4:D4', {'type': 'icon_set',
                                        'icon_style': '3_traffic_lights',
                                        'reverse_icons': True})

worksheet9.conditional_format('B5:D5', {'type': 'icon_set',
                                        'icon_style': '3_traffic_lights',
                                        'icons_only': True})

worksheet9.conditional_format('B6:D6', {'type': 'icon_set',
                                        'icon_style': '3_arrows'})

worksheet9.conditional_format('B7:E7', {'type': 'icon_set',
                                        'icon_style': '4_arrows'})

worksheet9.conditional_format('B8:F8', {'type': 'icon_set',
                                        'icon_style': '5_arrows'})

worksheet9.conditional_format('B9:F9', {'type': 'icon_set',
                                        'icon_style': '5_ratings'})

workbook.close()

```

---

### File: `tmp\xlsxwriter_old\XlsxWriter-1.4.5\examples\context_manager.py`

```python
##############################################################################
#
# A simple example using the XlsxWriter Python module and the "with" context
# manager. This doesn't require an explicit close().
#
# Copyright 2013-2021, John McNamara, jmcnamara@cpan.org
#
import xlsxwriter

with xlsxwriter.Workbook('hello_world.xlsx') as workbook:
    worksheet = workbook.add_worksheet()

    worksheet.write('A1', 'Hello world')

```

---

### File: `tmp\xlsxwriter_old\XlsxWriter-1.4.5\examples\data_validate.py`

```python
###############################################################################
#
# Example of how to add data validation and dropdown lists to an
# XlsxWriter file.
#
# Data validation is a feature of Excel which allows you to restrict
# the data that a user enters in a cell and to display help and
# warning messages. It also allows you to restrict input to values in
# a drop down list.
#
# Copyright 2013-2021, John McNamara, jmcnamara@cpan.org
#
from datetime import date, time
import xlsxwriter

workbook = xlsxwriter.Workbook('data_validate.xlsx')
worksheet = workbook.add_worksheet()

# Add a format for the header cells.
header_format = workbook.add_format({
    'border': 1,
    'bg_color': '#C6EFCE',
    'bold': True,
    'text_wrap': True,
    'valign': 'vcenter',
    'indent': 1,
})

# Set up layout of the worksheet.
worksheet.set_column('A:A', 68)
worksheet.set_column('B:B', 15)
worksheet.set_column('D:D', 15)
worksheet.set_row(0, 36)

# Write the header cells and some data that will be used in the examples.
heading1 = 'Some examples of data validation in XlsxWriter'
heading2 = 'Enter values in this column'
heading3 = 'Sample Data'

worksheet.write('A1', heading1, header_format)
worksheet.write('B1', heading2, header_format)
worksheet.write('D1', heading3, header_format)

worksheet.write_row('D3', ['Integers', 1, 10])
worksheet.write_row('D4', ['List data', 'open', 'high', 'close'])
worksheet.write_row('D5', ['Formula', '=AND(F5=50,G5=60)', 50, 60])


# Example 1. Limiting input to an integer in a fixed range.
#
txt = 'Enter an integer between 1 and 10'

worksheet.write('A3', txt)
worksheet.data_validation('B3', {'validate': 'integer',
                                 'criteria': 'between',
                                 'minimum': 1,
                                 'maximum': 10})


# Example 2. Limiting input to an integer outside a fixed range.
#
txt = 'Enter an integer that is not between 1 and 10 (using cell references)'


worksheet.write('A5', txt)
worksheet.data_validation('B5', {'validate': 'integer',
                                 'criteria': 'not between',
                                 'minimum': '=E3',
                                 'maximum': '=F3'})


# Example 3. Limiting input to an integer greater than a fixed value.
#
txt = 'Enter an integer greater than 0'

worksheet.write('A7', txt)
worksheet.data_validation('B7', {'validate': 'integer',
                                 'criteria': '>',
                                 'value': 0})


# Example 4. Limiting input to an integer less than a fixed value.
#
txt = 'Enter an integer less than 10'

worksheet.write('A9', txt)
worksheet.data_validation('B9', {'validate': 'integer',
                                 'criteria': '<',
                                 'value': 10})


# Example 5. Limiting input to a decimal in a fixed range.
#
txt = 'Enter a decimal between 0.1 and 0.5'

worksheet.write('A11', txt)
worksheet.data_validation('B11', {'validate': 'decimal',
                                  'criteria': 'between',
                                  'minimum': 0.1,
                                  'maximum': 0.5})


# Example 6. Limiting input to a value in a dropdown list.
#
txt = 'Select a value from a drop down list'

worksheet.write('A13', txt)
worksheet.data_validation('B13', {'validate': 'list',
                                  'source': ['open', 'high', 'close']})


# Example 7. Limiting input to a value in a dropdown list.
#
txt = 'Select a value from a drop down list (using a cell range)'

worksheet.write('A15', txt)
worksheet.data_validation('B15', {'validate': 'list',
                                  'source': '=$E$4:$G$4'})


# Example 8. Limiting input to a date in a fixed range.
#
txt = 'Enter a date between 1/1/2013 and 12/12/2013'

worksheet.write('A17', txt)
worksheet.data_validation('B17', {'validate': 'date',
                                  'criteria': 'between',
                                  'minimum': date(2013, 1, 1),
                                  'maximum': date(2013, 12, 12)})


# Example 9. Limiting input to a time in a fixed range.
#
txt = 'Enter a time between 6:00 and 12:00'

worksheet.write('A19', txt)
worksheet.data_validation('B19', {'validate': 'time',
                                  'criteria': 'between',
                                  'minimum': time(6, 0),
                                  'maximum': time(12, 0)})


# Example 10. Limiting input to a string greater than a fixed length.
#
txt = 'Enter a string longer than 3 characters'

worksheet.write('A21', txt)
worksheet.data_validation('B21', {'validate': 'length',
                                  'criteria': '>',
                                  'value': 3})


# Example 11. Limiting input based on a formula.
#
txt = 'Enter a value if the following is true "=AND(F5=50,G5=60)"'

worksheet.write('A23', txt)
worksheet.data_validation('B23', {'validate': 'custom',
                                  'value': '=AND(F5=50,G5=60)'})


# Example 12. Displaying and modifying data validation messages.
#
txt = 'Displays a message when you select the cell'

worksheet.write('A25', txt)
worksheet.data_validation('B25', {'validate': 'integer',
                                  'criteria': 'between',
                                  'minimum': 1,
                                  'maximum': 100,
                                  'input_title': 'Enter an integer:',
                                  'input_message': 'between 1 and 100'})


# Example 13. Displaying and modifying data validation messages.
#
txt = "Display a custom error message when integer isn't between 1 and 100"

worksheet.write('A27', txt)
worksheet.data_validation('B27', {'validate': 'integer',
                                  'criteria': 'between',
                                  'minimum': 1,
                                  'maximum': 100,
                                  'input_title': 'Enter an integer:',
                                  'input_message': 'between 1 and 100',
                                  'error_title': 'Input value is not valid!',
                                  'error_message':
                                  'It should be an integer between 1 and 100'})


# Example 14. Displaying and modifying data validation messages.
#
txt = "Display a custom info message when integer isn't between 1 and 100"

worksheet.write('A29', txt)
worksheet.data_validation('B29', {'validate': 'integer',
                                  'criteria': 'between',
                                  'minimum': 1,
                                  'maximum': 100,
                                  'input_title': 'Enter an integer:',
                                  'input_message': 'between 1 and 100',
                                  'error_title': 'Input value is not valid!',
                                  'error_message':
                                  'It should be an integer between 1 and 100',
                                  'error_type': 'information'})

workbook.close()

```

---

### File: `tmp\xlsxwriter_old\XlsxWriter-1.4.5\examples\datetimes.py`

```python
##############################################################################
#
# A simple program to write some dates and times to an Excel file
# using the XlsxWriter Python module.
#
# Copyright 2013-2021, John McNamara, jmcnamara@cpan.org
#
from datetime import datetime
import xlsxwriter

# Create a workbook and add a worksheet.
workbook = xlsxwriter.Workbook('datetimes.xlsx')
worksheet = workbook.add_worksheet()
bold = workbook.add_format({'bold': True})

# Expand the first columns so that the dates are visible.
worksheet.set_column('A:B', 30)

# Write the column headers.
worksheet.write('A1', 'Formatted date', bold)
worksheet.write('B1', 'Format', bold)

# Create a datetime object to use in the examples.

date_time = datetime.strptime('2013-01-23 12:30:05.123',
                              '%Y-%m-%d %H:%M:%S.%f')

# Examples date and time formats. In the output file compare how changing
# the format codes change the appearance of the date.
date_formats = (
    'dd/mm/yy',
    'mm/dd/yy',
    'dd m yy',
    'd mm yy',
    'd mmm yy',
    'd mmmm yy',
    'd mmmm yyy',
    'd mmmm yyyy',
    'dd/mm/yy hh:mm',
    'dd/mm/yy hh:mm:ss',
    'dd/mm/yy hh:mm:ss.000',
    'hh:mm',
    'hh:mm:ss',
    'hh:mm:ss.000',
)

# Start from first row after headers.
row = 1

# Write the same date and time using each of the above formats.
for date_format_str in date_formats:

    # Create a format for the date or time.
    date_format = workbook.add_format({'num_format': date_format_str,
                                      'align': 'left'})

    # Write the same date using different formats.
    worksheet.write_datetime(row, 0, date_time, date_format)

    # Also write the format string for comparison.
    worksheet.write_string(row, 1, date_format_str)

    row += 1

workbook.close()

```

---

### File: `tmp\xlsxwriter_old\XlsxWriter-1.4.5\examples\defined_name.py`

```python
##############################################################################
#
# Example of how to create defined names with the XlsxWriter Python module.
#
# This method is used to define a user friendly name to represent a value,
# a single cell or a range of cells in a workbook.
#
# Copyright 2013-2021, John McNamara, jmcnamara@cpan.org
#
import xlsxwriter


workbook = xlsxwriter.Workbook('defined_name.xlsx')
worksheet1 = workbook.add_worksheet()
worksheet2 = workbook.add_worksheet()

# Define some global/workbook names.
workbook.define_name('Exchange_rate', '=0.96')
workbook.define_name('Sales', '=Sheet1!$G$1:$H$10')

# Define a local/worksheet name. Over-rides the "Sales" name above.
workbook.define_name('Sheet2!Sales', '=Sheet2!$G$1:$G$10')

# Write some text in the file and one of the defined names in a formula.
for worksheet in workbook.worksheets():
    worksheet.set_column('A:A', 45)
    worksheet.write('A1', 'This worksheet contains some defined names.')
    worksheet.write('A2', 'See Formulas -> Name Manager above.')
    worksheet.write('A3', 'Example formula in cell B3 ->')

    worksheet.write('B3', '=Exchange_rate')

workbook.close()

```

---

### File: `tmp\xlsxwriter_old\XlsxWriter-1.4.5\examples\demo.py`

```python
##############################################################################
#
# A simple example of some of the features of the XlsxWriter Python module.
#
# Copyright 2013-2021, John McNamara, jmcnamara@cpan.org
#
import xlsxwriter


# Create an new Excel file and add a worksheet.
workbook = xlsxwriter.Workbook('demo.xlsx')
worksheet = workbook.add_worksheet()

# Widen the first column to make the text clearer.
worksheet.set_column('A:A', 20)

# Add a bold format to use to highlight cells.
bold = workbook.add_format({'bold': True})

# Write some simple text.
worksheet.write('A1', 'Hello')

# Text with formatting.
worksheet.write('A2', 'World', bold)

# Write some numbers, with row/column notation.
worksheet.write(2, 0, 123)
worksheet.write(3, 0, 123.456)

# Insert an image.
worksheet.insert_image('B5', 'logo.png')

workbook.close()

```

---

### File: `tmp\xlsxwriter_old\XlsxWriter-1.4.5\examples\diagonal_border.py`

```python
##############################################################################
#
# A simple formatting example that demonstrates how to add diagonal cell
# borders with XlsxWriter.
#
# Copyright 2013-2021, John McNamara, jmcnamara@cpan.org
#
import xlsxwriter

workbook = xlsxwriter.Workbook('diag_border.xlsx')
worksheet = workbook.add_worksheet()

format1 = workbook.add_format({'diag_type': 1})
format2 = workbook.add_format({'diag_type': 2})
format3 = workbook.add_format({'diag_type': 3})

format4 = workbook.add_format({
    'diag_type': 3,
    'diag_border': 7,
    'diag_color': 'red',
})

worksheet.write('B3', 'Text', format1)
worksheet.write('B6', 'Text', format2)
worksheet.write('B9', 'Text', format3)
worksheet.write('B12', 'Text', format4)

workbook.close()

```

---

### File: `tmp\xlsxwriter_old\XlsxWriter-1.4.5\examples\django_simple.py`

```python
##############################################################################
#
# A simple Django view class to write an Excel file using the XlsxWriter
# module.
#
# Copyright 2013-2021, John McNamara, jmcnamara@cpan.org
#
import io
from django.http import HttpResponse
from django.views.generic import View
import xlsxwriter


def get_simple_table_data():
    # Simulate a more complex table read.
    return [[1, 2, 3],
            [4, 5, 6],
            [7, 8, 9]]


class MyView(View):

    def get(self, request):

        # Create an in-memory output file for the new workbook.
        output = io.BytesIO()

        # Even though the final file will be in memory the module uses temp
        # files during assembly for efficiency. To avoid this on servers that
        # don't allow temp files, for example the Google APP Engine, set the
        # 'in_memory' Workbook() constructor option as shown in the docs.
        workbook = xlsxwriter.Workbook(output)
        worksheet = workbook.add_worksheet()

        # Get some data to write to the spreadsheet.
        data = get_simple_table_data()

        # Write some test data.
        for row_num, columns in enumerate(data):
            for col_num, cell_data in enumerate(columns):
                worksheet.write(row_num, col_num, cell_data)

        # Close the workbook before sending the data.
        workbook.close()

        # Rewind the buffer.
        output.seek(0)

        # Set up the Http response.
        filename = 'django_simple.xlsx'
        response = HttpResponse(
            output,
            content_type='application/vnd.openxmlformats-officedocument.spreadsheetml.sheet'
        )
        response['Content-Disposition'] = 'attachment; filename=%s' % filename

        return response

```

---

### File: `tmp\xlsxwriter_old\XlsxWriter-1.4.5\examples\doc_properties.py`

```python
##############################################################################
#
# An example of adding document properties to a XlsxWriter file.
#
# Copyright 2013-2021, John McNamara, jmcnamara@cpan.org
#
import xlsxwriter

workbook = xlsxwriter.Workbook('doc_properties.xlsx')
worksheet = workbook.add_worksheet()

workbook.set_properties({
    'title':    'This is an example spreadsheet',
    'subject':  'With document properties',
    'author':   'John McNamara',
    'manager':  'Dr. Heinz Doofenshmirtz',
    'company':  'of Wolves',
    'category': 'Example spreadsheets',
    'keywords': 'Sample, Example, Properties',
    'comments': 'Created with Python and XlsxWriter',
    'status':   'Quo',
})

worksheet.set_column('A:A', 70)
worksheet.write('A1', "Select 'Workbook Properties' to see properties.")

workbook.close()

```

---

### File: `tmp\xlsxwriter_old\XlsxWriter-1.4.5\examples\dynamic_arrays.py`

```python
#######################################################################
#
# An example of how to use the XlsxWriter module to write formulas and
# functions that create dynamic arrays. These functions are new to Excel
# 365. The examples mirror the examples in the Excel documentation on these
# functions.
#
# Copyright 2013-2021, John McNamara, jmcnamara@cpan.org
#
import xlsxwriter


def main():
    # Create a new workbook called simple.xls and add some worksheets.
    workbook = xlsxwriter.Workbook('dynamic_arrays.xlsx')

    worksheet1 = workbook.add_worksheet('Filter')
    worksheet2 = workbook.add_worksheet('Unique')
    worksheet3 = workbook.add_worksheet('Sort')
    worksheet4 = workbook.add_worksheet('Sortby')
    worksheet5 = workbook.add_worksheet('Xlookup')
    worksheet6 = workbook.add_worksheet('Xmatch')
    worksheet7 = workbook.add_worksheet('Randarray')
    worksheet8 = workbook.add_worksheet('Sequence')
    worksheet9 = workbook.add_worksheet('Spill ranges')
    worksheet10 = workbook.add_worksheet('Older functions')

    header1 = workbook.add_format({'fg_color': '#74AC4C', 'color': '#FFFFFF'})
    header2 = workbook.add_format({'fg_color': '#528FD3', 'color': '#FFFFFF'})

    #
    # Example of using the FILTER() function.
    #
    worksheet1.write('F2', '=FILTER(A1:D17,C1:C17=K2)')

    # Write the data the function will work on.
    worksheet1.write('K1', 'Product', header2)
    worksheet1.write('K2', 'Apple')
    worksheet1.write('F1', 'Region', header2)
    worksheet1.write('G1', 'Sales Rep', header2)
    worksheet1.write('H1', 'Product', header2)
    worksheet1.write('I1', 'Units', header2)

    write_worksheet_data(worksheet1, header1)
    worksheet1.set_column_pixels('E:E', 20)
    worksheet1.set_column_pixels('J:J', 20)

    #
    # Example of using the UNIQUE() function.
    #
    worksheet2.write('F2', '=UNIQUE(B2:B17)')

    # A more complex example combining SORT and UNIQUE.
    worksheet2.write('H2', '=SORT(UNIQUE(B2:B17))')

    # Write the data the function will work on.
    worksheet2.write('F1', 'Sales Rep', header2)
    worksheet2.write('H1', 'Sales Rep', header2)

    write_worksheet_data(worksheet2, header1)
    worksheet2.set_column_pixels('E:E', 20)
    worksheet2.set_column_pixels('G:G', 20)

    #
    # Example of using the SORT() function.
    #
    worksheet3.write('F2', '=SORT(B2:B17)')

    # A more complex example combining SORT and FILTER.
    worksheet3.write('H2', '=SORT(FILTER(C2:D17,D2:D17>5000,""),2,1)')

    # Write the data the function will work on.
    worksheet3.write('F1', 'Sales Rep', header2)
    worksheet3.write('H1', 'Product', header2)
    worksheet3.write('I1', 'Units', header2)

    write_worksheet_data(worksheet3, header1)
    worksheet3.set_column_pixels('E:E', 20)
    worksheet3.set_column_pixels('G:G', 20)

    #
    # Example of using the SORTBY() function.
    #
    worksheet4.write('D2', '=SORTBY(A2:B9,B2:B9)')

    # Write the data the function will work on.
    worksheet4.write('A1', 'Name', header1)
    worksheet4.write('B1', 'Age', header1)

    worksheet4.write('A2', 'Tom')
    worksheet4.write('A3', 'Fred')
    worksheet4.write('A4', 'Amy')
    worksheet4.write('A5', 'Sal')
    worksheet4.write('A6', 'Fritz')
    worksheet4.write('A7', 'Srivan')
    worksheet4.write('A8', 'Xi')
    worksheet4.write('A9', 'Hector')

    worksheet4.write('B2', 52)
    worksheet4.write('B3', 65)
    worksheet4.write('B4', 22)
    worksheet4.write('B5', 73)
    worksheet4.write('B6', 19)
    worksheet4.write('B7', 39)
    worksheet4.write('B8', 19)
    worksheet4.write('B9', 66)

    worksheet4.write('D1', 'Name', header2)
    worksheet4.write('E1', 'Age', header2)

    worksheet4.set_column_pixels('C:C', 20)

    #
    # Example of using the XLOOKUP() function.
    #
    worksheet5.write('F1', '=XLOOKUP(E1,A2:A9,C2:C9)')

    # Write the data the function will work on.
    worksheet5.write('A1', 'Country', header1)
    worksheet5.write('B1', 'Abr', header1)
    worksheet5.write('C1', 'Prefix', header1)

    worksheet5.write('A2', 'China')
    worksheet5.write('A3', 'India')
    worksheet5.write('A4', 'United States')
    worksheet5.write('A5', 'Indonesia')
    worksheet5.write('A6', 'Brazil')
    worksheet5.write('A7', 'Pakistan')
    worksheet5.write('A8', 'Nigeria')
    worksheet5.write('A9', 'Bangladesh')

    worksheet5.write('B2', 'CN')
    worksheet5.write('B3', 'IN')
    worksheet5.write('B4', 'US')
    worksheet5.write('B5', 'ID')
    worksheet5.write('B6', 'BR')
    worksheet5.write('B7', 'PK')
    worksheet5.write('B8', 'NG')
    worksheet5.write('B9', 'BD')

    worksheet5.write('C2', 86)
    worksheet5.write('C3', 91)
    worksheet5.write('C4', 1)
    worksheet5.write('C5', 62)
    worksheet5.write('C6', 55)
    worksheet5.write('C7', 92)
    worksheet5.write('C8', 234)
    worksheet5.write('C9', 880)

    worksheet5.write('E1', 'Brazil', header2)

    worksheet5.set_column_pixels('A:A', 100)
    worksheet5.set_column_pixels('D:D', 20)

    #
    # Example of using the XMATCH() function.
    #
    worksheet6.write('D2', '=XMATCH(C2,A2:A6)')

    # Write the data the function will work on.
    worksheet6.write('A1', 'Product', header1)

    worksheet6.write('A2', 'Apple')
    worksheet6.write('A3', 'Grape')
    worksheet6.write('A4', 'Pear')
    worksheet6.write('A5', 'Banana')
    worksheet6.write('A6', 'Cherry')

    worksheet6.write('C1', 'Product', header2)
    worksheet6.write('D1', 'Position', header2)
    worksheet6.write('C2', 'Grape')

    worksheet6.set_column_pixels('B:B', 20)

    #
    # Example of using the RANDARRAY() function.
    #
    worksheet7.write('A1', '=RANDARRAY(5,3,1,100, TRUE)')

    #
    # Example of using the SEQUENCE() function.
    #
    worksheet8.write('A1', '=SEQUENCE(4,5)')

    #
    # Example of using the Spill range operator.
    #
    worksheet9.write('H2', '=ANCHORARRAY(F2)')

    worksheet9.write('J2', '=COUNTA(ANCHORARRAY(F2))')

    # Write the data the to work on.
    worksheet9.write('F2', '=UNIQUE(B2:B17)')
    worksheet9.write('F1', 'Unique', header2)
    worksheet9.write('H1', 'Spill', header2)
    worksheet9.write('J1', 'Spill', header2)

    write_worksheet_data(worksheet9, header1)
    worksheet9.set_column_pixels('E:E', 20)
    worksheet9.set_column_pixels('G:G', 20)
    worksheet9.set_column_pixels('I:I', 20)

    #
    # Example of using dynamic ranges with older Excel functions.
    #
    worksheet10.write_dynamic_array_formula('B1:B3', '=LEN(A1:A3)')

    # Write the data the to work on.
    worksheet10.write('A1', 'Foo')
    worksheet10.write('A2', 'Food')
    worksheet10.write('A3', 'Frood')

    # Close the workbook.
    workbook.close()


# Utility function to write the data some of the functions work on.
def write_worksheet_data(worksheet, header):

    worksheet.write('A1', 'Region', header)
    worksheet.write('B1', 'Sales Rep', header)
    worksheet.write('C1', 'Product', header)
    worksheet.write('D1', 'Units', header)

    data = (
        ['East',  'Tom',    'Apple',  6380],
        ['West',  'Fred',   'Grape',  5619],
        ['North', 'Amy',    'Pear',   4565],
        ['South', 'Sal',    'Banana', 5323],
        ['East',  'Fritz',  'Apple',  4394],
        ['West',  'Sravan', 'Grape',  7195],
        ['North', 'Xi',     'Pear',   5231],
        ['South', 'Hector', 'Banana', 2427],
        ['East',  'Tom',    'Banana', 4213],
        ['West',  'Fred',   'Pear',   3239],
        ['North', 'Amy',    'Grape',  6520],
        ['South', 'Sal',    'Apple',  1310],
        ['East',  'Fritz',  'Banana', 6274],
        ['West',  'Sravan', 'Pear',   4894],
        ['North', 'Xi',     'Grape',  7580],
        ['South', 'Hector', 'Apple',  9814])

    row_num = 1
    for row_data in data:
        worksheet.write_row(row_num, 0, row_data)
        row_num += 1

if __name__ == "__main__":
    main()

```

---

### File: `tmp\xlsxwriter_old\XlsxWriter-1.4.5\examples\headers_footers.py`

```python
######################################################################
#
# This program shows several examples of how to set up headers and
# footers with XlsxWriter.
#
# The control characters used in the header/footer strings are:
#
#     Control             Category            Description
#     =======             ========            ===========
#     &L                  Justification       Left
#     &C                                      Center
#     &R                                      Right
#
#     &P                  Information         Page number
#     &N                                      Total number of pages
#     &D                                      Date
#     &T                                      Time
#     &F                                      File name
#     &A                                      Worksheet name
#
#     &fontsize           Font                Font size
#     &"font,style"                           Font name and style
#     &U                                      Single underline
#     &E                                      Double underline
#     &S                                      Strikethrough
#     &X                                      Superscript
#     &Y                                      Subscript
#
#     &[Picture]          Images              Image placeholder
#     &G                                      Same as &[Picture]
#
#     &&                  Miscellaneous       Literal ampersand &
#
# See the main XlsxWriter documentation for more information.
#
# Copyright 2013-2021, John McNamara, jmcnamara@cpan.org
#
import xlsxwriter

workbook = xlsxwriter.Workbook('headers_footers.xlsx')
preview = 'Select Print Preview to see the header and footer'

######################################################################
#
# A simple example to start
#
worksheet1 = workbook.add_worksheet('Simple')
header1 = '&CHere is some centered text.'
footer1 = '&LHere is some left aligned text.'

worksheet1.set_header(header1)
worksheet1.set_footer(footer1)

worksheet1.set_column('A:A', 50)
worksheet1.write('A1', preview)


######################################################################
#
# Insert a header image.
#
worksheet2 = workbook.add_worksheet('Image')
header2 = '&L&G'

# Adjust the page top margin to allow space for the header image.
worksheet2.set_margins(top=1.3)

worksheet2.set_header(header2, {'image_left': 'python-200x80.png'})

worksheet2.set_column('A:A', 50)
worksheet2.write('A1', preview)


######################################################################
#
# This is an example of some of the header/footer variables.
#
worksheet3 = workbook.add_worksheet('Variables')
header3 = '&LPage &P of &N' + '&CFilename: &F' + '&RSheetname: &A'
footer3 = '&LCurrent date: &D' + '&RCurrent time: &T'

worksheet3.set_header(header3)
worksheet3.set_footer(footer3)

worksheet3.set_column('A:A', 50)
worksheet3.write('A1', preview)
worksheet3.write('A21', 'Next sheet')
worksheet3.set_h_pagebreaks([20])

######################################################################
#
# This example shows how to use more than one font
#
worksheet4 = workbook.add_worksheet('Mixed fonts')
header4 = '&C&"Courier New,Bold"Hello &"Arial,Italic"World'
footer4 = '&C&"Symbol"e&"Arial" = mc&X2'

worksheet4.set_header(header4)
worksheet4.set_footer(footer4)

worksheet4.set_column('A:A', 50)
worksheet4.write('A1', preview)

######################################################################
#
# Example of line wrapping
#
worksheet5 = workbook.add_worksheet('Word wrap')
header5 = "&CHeading 1\nHeading 2"

worksheet5.set_header(header5)

worksheet5.set_column('A:A', 50)
worksheet5.write('A1', preview)

######################################################################
#
# Example of inserting a literal ampersand &
#
worksheet6 = workbook.add_worksheet('Ampersand')
header6 = '&CCuriouser && Curiouser - Attorneys at Law'

worksheet6.set_header(header6)

worksheet6.set_column('A:A', 50)
worksheet6.write('A1', preview)

workbook.close()

```

---

### File: `tmp\xlsxwriter_old\XlsxWriter-1.4.5\examples\hello_world.py`

```python
##############################################################################
#
# A hello world spreadsheet using the XlsxWriter Python module.
#
# Copyright 2013-2021, John McNamara, jmcnamara@cpan.org
#
import xlsxwriter

workbook = xlsxwriter.Workbook('hello_world.xlsx')
worksheet = workbook.add_worksheet()

worksheet.write('A1', 'Hello world')

workbook.close()

```

---

### File: `tmp\xlsxwriter_old\XlsxWriter-1.4.5\examples\hide_row_col.py`

```python
###############################################################################
#
# Example of how to hide rows and columns in XlsxWriter. In order to
# hide rows without setting each one, (of approximately 1 million rows),
# Excel uses an optimizations to hide all rows that don't have data.
#
# Copyright 2013-2021, John McNamara, jmcnamara@cpan.org
#
import xlsxwriter

workbook = xlsxwriter.Workbook('hide_row_col.xlsx')
worksheet = workbook.add_worksheet()

# Write some data.
worksheet.write('D1', 'Some hidden columns.')
worksheet.write('A8', 'Some hidden rows.')

# Hide all rows without data.
worksheet.set_default_row(hide_unused_rows=True)

# Set the height of empty rows that we do want to display even if it is
# the default height.
for row in range(1, 7):
    worksheet.set_row(row, 15)

# Columns can be hidden explicitly. This doesn't increase the file size..
worksheet.set_column('G:XFD', None, None, {'hidden': True})

workbook.close()

```

---

### File: `tmp\xlsxwriter_old\XlsxWriter-1.4.5\examples\hide_sheet.py`

```python
#######################################################################
#
# Example of how to hide a worksheet with XlsxWriter.
#
# Copyright 2013-2021, John McNamara, jmcnamara@cpan.org
#
import xlsxwriter

workbook = xlsxwriter.Workbook('hide_sheet.xlsx')
worksheet1 = workbook.add_worksheet()
worksheet2 = workbook.add_worksheet()
worksheet3 = workbook.add_worksheet()

worksheet1.set_column('A:A', 30)
worksheet2.set_column('A:A', 30)
worksheet3.set_column('A:A', 30)

# Hide Sheet2. It won't be visible until it is unhidden in Excel.
worksheet2.hide()

worksheet1.write('A1', 'Sheet2 is hidden')
worksheet2.write('A1', "Now it's my turn to find you!")
worksheet3.write('A1', 'Sheet2 is hidden')

# Note, you can't hide the the "active" worksheet, which generally is the
# first worksheet, since this would cause an Excel error. So, in order to hide
# the first sheet you will need to activate another worksheet:
#
#    worksheet2.activate()
#    worksheet1.hide()

workbook.close()

```

---

### File: `tmp\xlsxwriter_old\XlsxWriter-1.4.5\examples\http_server_py2.py`

```python
##############################################################################
#
# Example of using Python and XlsxWriter to create an Excel XLSX file in an in
# memory string suitable for serving via SimpleHTTPServer or Django or with
# the Google App Engine.
#
# Copyright 2013-2021, John McNamara, jmcnamara@cpan.org
#

# Note: This is a Python 2 example. For Python 3 see http_server_py3.py.

import SimpleHTTPServer
import SocketServer
import io

import xlsxwriter


class Handler(SimpleHTTPServer.SimpleHTTPRequestHandler):

    def do_GET(self):
        # Create an in-memory output file for the new workbook.
        output = io.BytesIO()

        # Even though the final file will be in memory the module uses temp
        # files during assembly for efficiency. To avoid this on servers that
        # don't allow temp files, for example the Google APP Engine, set the
        # 'in_memory' constructor option to True:
        workbook = xlsxwriter.Workbook(output, {'in_memory': True})
        worksheet = workbook.add_worksheet()

        # Write some test data.
        worksheet.write(0, 0, 'Hello, world!')

        # Close the workbook before streaming the data.
        workbook.close()

        # Rewind the buffer.
        output.seek(0)

        # Construct a server response.
        self.send_response(200)
        self.send_header('Content-Disposition', 'attachment; filename=test.xlsx')
        self.send_header('Content-type',
                         'application/vnd.openxmlformats-officedocument.spreadsheetml.sheet')
        self.end_headers()
        self.wfile.write(output.read())
        return


print('Server listening on port 8000...')
httpd = SocketServer.TCPServer(('', 8000), Handler)
httpd.serve_forever()

```

---

### File: `tmp\xlsxwriter_old\XlsxWriter-1.4.5\examples\http_server_py3.py`

```python
##############################################################################
#
# Example of using Python and XlsxWriter to create an Excel XLSX file in an in
# memory string suitable for serving via SimpleHTTPRequestHandler or Django or
# with the Google App Engine.
#
# Copyright 2013-2021, John McNamara, jmcnamara@cpan.org
#

# Note: This is a Python 3 example. For Python 2 see http_server_py2.py.

import http.server
import socketserver
import io

import xlsxwriter


class Handler(http.server.SimpleHTTPRequestHandler):

    def do_GET(self):
        # Create an in-memory output file for the new workbook.
        output = io.BytesIO()

        # Even though the final file will be in memory the module uses temp
        # files during assembly for efficiency. To avoid this on servers that
        # don't allow temp files set the 'in_memory' constructor option to True.
        #
        # The Python 3 Runtime Environment in Google App Engine now supports a
        # filesystem with read/write access to /tmp which means that the
        # 'in_memory' option isn't required. The /tmp dir isn't supported in
        # the Python 2 Runtime Environment so that option is still required
        # there. See:
        #
        # https://cloud.google.com/appengine/docs/standard/python3/runtime#filesystem
        #
        workbook = xlsxwriter.Workbook(output, {'in_memory': True})
        worksheet = workbook.add_worksheet()

        # Write some test data.
        worksheet.write(0, 0, 'Hello, world!')

        # Close the workbook before streaming the data.
        workbook.close()

        # Rewind the buffer.
        output.seek(0)

        # Construct a server response.
        self.send_response(200)
        self.send_header('Content-Disposition', 'attachment; filename=test.xlsx')
        self.send_header('Content-type',
                         'application/vnd.openxmlformats-officedocument.spreadsheetml.sheet')
        self.end_headers()
        self.wfile.write(output.read())
        return


print('Server listening on port 8000...')
httpd = socketserver.TCPServer(('', 8000), Handler)
httpd.serve_forever()

```

---

### File: `tmp\xlsxwriter_old\XlsxWriter-1.4.5\examples\hyperlink.py`

```python
###############################################################################
#
# Example of how to use the XlsxWriter module to write hyperlinks
#
# Copyright 2013-2021, John McNamara, jmcnamara@cpan.org
#
import xlsxwriter

# Create a new workbook and add a worksheet
workbook = xlsxwriter.Workbook('hyperlink.xlsx')
worksheet = workbook.add_worksheet('Hyperlinks')

# Format the first column
worksheet.set_column('A:A', 30)

# Add a sample alternative link format.
red_format = workbook.add_format({
    'font_color': 'red',
    'bold':       1,
    'underline':  1,
    'font_size':  12,
})

# Write some hyperlinks
worksheet.write_url('A1', 'http://www.python.org/')  # Implicit format.
worksheet.write_url('A3', 'http://www.python.org/', string='Python Home')
worksheet.write_url('A5', 'http://www.python.org/', tip='Click here')
worksheet.write_url('A7', 'http://www.python.org/', red_format)
worksheet.write_url('A9', 'mailto:jmcnamara@cpan.org', string='Mail me')

# Write a URL that isn't a hyperlink
worksheet.write_string('A11', 'http://www.python.org/')

workbook.close()

```

---

### File: `tmp\xlsxwriter_old\XlsxWriter-1.4.5\examples\ignore_errors.py`

```python
##############################################################################
#
# An example of turning off worksheet cells errors/warnings using the
# XlsxWriter Python module.
#
# Copyright 2013-2021, John McNamara, jmcnamara@cpan.org
#
import xlsxwriter

workbook = xlsxwriter.Workbook('ignore_errors.xlsx')
worksheet = workbook.add_worksheet()

# Write strings that looks like numbers. This will cause an Excel warning.
worksheet.write_string('C2', '123')
worksheet.write_string('C3', '123')

# Write a divide by zero formula. This will also cause an Excel warning.
worksheet.write_formula('C5', '=1/0')
worksheet.write_formula('C6', '=1/0')

# Turn off some of the warnings:
worksheet.ignore_errors({'number_stored_as_text': 'C3', 'eval_error': 'C6'})

# Write some descriptions for the cells and make the column wider for clarity.
worksheet.set_column('B:B', 16, None)
worksheet.write('B2', 'Warning:')
worksheet.write('B3', 'Warning turned off:')
worksheet.write('B5', 'Warning:')
worksheet.write('B6', 'Warning turned off:')

workbook.close()

```

---

### File: `tmp\xlsxwriter_old\XlsxWriter-1.4.5\examples\images.py`

```python
##############################################################################
#
# An example of inserting images into a worksheet using the XlsxWriter
# Python module.
#
# Copyright 2013-2021, John McNamara, jmcnamara@cpan.org
#
import xlsxwriter


# Create an new Excel file and add a worksheet.
workbook = xlsxwriter.Workbook('images.xlsx')
worksheet = workbook.add_worksheet()

# Widen the first column to make the text clearer.
worksheet.set_column('A:A', 30)

# Insert an image.
worksheet.write('A2', 'Insert an image in a cell:')
worksheet.insert_image('B2', 'python.png')

# Insert an image offset in the cell.
worksheet.write('A12', 'Insert an image with an offset:')
worksheet.insert_image('B12', 'python.png', {'x_offset': 15, 'y_offset': 10})

# Insert an image with scaling.
worksheet.write('A23', 'Insert a scaled image:')
worksheet.insert_image('B23', 'python.png', {'x_scale': 0.5, 'y_scale': 0.5})

workbook.close()

```

---

### File: `tmp\xlsxwriter_old\XlsxWriter-1.4.5\examples\images_bytesio.py`

```python
##############################################################################
#
# An example of inserting images from a Python BytesIO byte stream into a
# worksheet using the XlsxWriter module.
#
# Copyright 2013-2021, John McNamara, jmcnamara@cpan.org
#

# Import the byte stream handler.
from io import BytesIO

# Import urlopen() for either Python 2 or 3.
try:
    from urllib.request import urlopen
except ImportError:
    from urllib2 import urlopen


import xlsxwriter

# Create the workbook and add a worksheet.
workbook  = xlsxwriter.Workbook('images_bytesio.xlsx')
worksheet = workbook.add_worksheet()


# Read an image from a remote url.
url = 'https://raw.githubusercontent.com/jmcnamara/XlsxWriter/' + \
      'master/examples/logo.png'

image_data = BytesIO(urlopen(url).read())

# Write the byte stream image to a cell. Note, the filename must be
# specified. In this case it will be read from url string.
worksheet.insert_image('B2', url, {'image_data': image_data})


# Read a local image file into a a byte stream. Note, the insert_image()
# method can do this directly. This is for illustration purposes only.
filename   = 'python.png'

image_file = open(filename, 'rb')
image_data = BytesIO(image_file.read())
image_file.close()


# Write the byte stream image to a cell. The filename must  be specified.
worksheet.insert_image('B8', filename, {'image_data': image_data})


workbook.close()

```

---

### File: `tmp\xlsxwriter_old\XlsxWriter-1.4.5\examples\inheritance1.py`

```python
##############################################################################
#
# Example of how to subclass the Workbook and Worksheet objects. We also
# override the default worksheet.write() method to show how that is done.
#
# Copyright 2013-2021, John McNamara, jmcnamara@cpan.org
#
from xlsxwriter.workbook import Workbook
from xlsxwriter.worksheet import Worksheet
from xlsxwriter.worksheet import convert_cell_args
from xlsxwriter.compatibility import str_types


class MyWorksheet(Worksheet):
    """
    Subclass of the XlsxWriter Worksheet class to override the default
    write() method.

    """

    @convert_cell_args
    def write(self, row, col, *args):

        data = args[0]

        # Reverse strings to demonstrate the overridden method.
        if isinstance(data, str_types):
            data = data[::-1]
            return self.write_string(row, col, data)
        else:
            # Call the parent version of write() as usual for other data.
            return super(MyWorksheet, self).write(row, col, *args)


class MyWorkbook(Workbook):
    """
    Subclass of the XlsxWriter Workbook class to override the default
    Worksheet class with our custom class.

    """

    def add_worksheet(self, name=None):
        # Overwrite add_worksheet() to create a MyWorksheet object.
        worksheet = super(MyWorkbook, self).add_worksheet(name, MyWorksheet)

        return worksheet


# Create a new MyWorkbook object.
workbook = MyWorkbook('inheritance1.xlsx')

# The code from now on will be the same as a normal "Workbook" program.
worksheet = workbook.add_worksheet()

# Write some data to test the subclassing.
worksheet.write('A1', 'Hello')
worksheet.write('A2', 'World')
worksheet.write('A3', 123)
worksheet.write('A4', 345)

workbook.close()

```

---

### File: `tmp\xlsxwriter_old\XlsxWriter-1.4.5\examples\inheritance2.py`

```python
##############################################################################
#
# Example of how to subclass the Workbook and Worksheet objects. See also the
# simpler inheritance1.py example.
#
# In this example we see an approach to implementing a simulated autofit in a
# user application. This works by overriding the write_string() method to
# track the maximum width string in each column and then set the column
# widths.
#
# Note: THIS ISN'T A FULLY FUNCTIONAL AUTOFIT EXAMPLE. It is only a proof or
# concept or a framework to try out solutions.
#
# Copyright 2013-2021, John McNamara, jmcnamara@cpan.org
#
from xlsxwriter.workbook import Workbook
from xlsxwriter.worksheet import Worksheet
from xlsxwriter.worksheet import convert_cell_args


def excel_string_width(str):
    """
    Calculate the length of the string in Excel character units. This is only
    an example and won't give accurate results. It will need to be replaced
    by something more rigorous.

    """
    string_width = len(str)

    if string_width == 0:
        return 0
    else:
        return string_width * 1.1


class MyWorksheet(Worksheet):
    """
    Subclass of the XlsxWriter Worksheet class to override the default
    write_string() method.

    """

    @convert_cell_args
    def write_string(self, row, col, string, cell_format=None):
        # Overridden write_string() method to store the maximum string width
        # seen in each column.

        # Check that row and col are valid and store max and min values.
        if self._check_dimensions(row, col):
            return -1

        # Set the min width for the cell. In some cases this might be the
        # default width of 8.43. In this case we use 0 and adjust for all
        # string widths.
        min_width = 0

        # Check if it the string is the largest we have seen for this column.
        string_width = excel_string_width(string)
        if string_width > min_width:
            max_width = self.max_column_widths.get(col, min_width)
            if string_width > max_width:
                self.max_column_widths[col] = string_width

        # Now call the parent version of write_string() as usual.
        return super(MyWorksheet, self).write_string(row, col, string,
                                                     cell_format)


class MyWorkbook(Workbook):
    """
    Subclass of the XlsxWriter Workbook class to override the default
    Worksheet class with our custom class.

    """

    def add_worksheet(self, name=None):
        # Overwrite add_worksheet() to create a MyWorksheet object.
        # Also add an Worksheet attribute to store the column widths.
        worksheet = super(MyWorkbook, self).add_worksheet(name, MyWorksheet)
        worksheet.max_column_widths = {}

        return worksheet

    def close(self):
        # We apply the stored column widths for each worksheet when we close
        # the workbook. This will override any other set_column() values that
        # may have been applied. This could be handled in the application code
        # below, instead.
        for worksheet in self.worksheets():
            for column, width in worksheet.max_column_widths.items():
                worksheet.set_column(column, column, width)

        return super(MyWorkbook, self).close()


# Create a new MyWorkbook object.
workbook = MyWorkbook('inheritance2.xlsx')

# The code from now on will be the same as a normal "Workbook" program.
worksheet = workbook.add_worksheet()

# Write some data to test column fitting.
worksheet.write('A1', 'F')

worksheet.write('B3', 'Foo')

worksheet.write('C1', 'F')
worksheet.write('C2', 'Fo')
worksheet.write('C3', 'Foo')
worksheet.write('C4', 'Food')

worksheet.write('D1', 'This is a longer string')

# Write a string in row-col notation.
worksheet.write(0, 4, 'Hello World')

# Write a number.
worksheet.write(0, 5, 123456)

workbook.close()

```

---

### File: `tmp\xlsxwriter_old\XlsxWriter-1.4.5\examples\lambda.py`

```python
#######################################################################
#
# An example of using the new Excel LAMBDA() function with the XlsxWriter
# module. Note, this function is only currently available if you are
# subscribed to the Microsoft Office Beta Channel program.
#
# Copyright 2013-2021, John McNamara, jmcnamara@cpan.org
#
from xlsxwriter.workbook import Workbook

workbook = Workbook('lambda.xlsx')
worksheet = workbook.add_worksheet()

worksheet.write('A1',
                'Note: Lambda functions currently only work with '
                'the Beta Channel versions of Excel 365')

# Write a Lambda function to convert Fahrenheit to Celsius to a cell.
#
# Note that the lambda function parameters must be prefixed with
# "_xlpm.". These prefixes won't show up in Excel.
worksheet.write('A2', '=LAMBDA(_xlpm.temp, (5/9) * (_xlpm.temp-32))(32)')

# Create the same formula (without an argument) as a defined name and use that
# to calculate a value.
#
# Note that the formula name is prefixed with "_xlfn." (this is normally
# converted automatically by write_formula() but isn't for defined names)
# and note that the lambda function parameters are prefixed with
# "_xlpm.". These prefixes won't show up in Excel.
workbook.define_name('ToCelsius',
                     '=_xlfn.LAMBDA(_xlpm.temp, (5/9) * (_xlpm.temp-32))')

# The user defined name needs to be written explicitly as a dynamic array
# formula.
worksheet.write_dynamic_array_formula('A3', '=ToCelsius(212)')

workbook.close()

```

---

### File: `tmp\xlsxwriter_old\XlsxWriter-1.4.5\examples\macros.py`

```python
#######################################################################
#
# An example of adding macros to an XlsxWriter file using a VBA project
# file extracted from an existing Excel xlsm file.
#
# The vba_extract.py utility supplied with XlsxWriter can be used to extract
# the vbaProject.bin file.
#
# An embedded macro is connected to a form button on the worksheet.
#
# Copyright 2013-2021, John McNamara, jmcnamara@cpan.org
#
import xlsxwriter

# Note the file extension should be .xlsm.
workbook = xlsxwriter.Workbook('macros.xlsm')
worksheet = workbook.add_worksheet()

worksheet.set_column('A:A', 30)

# Add the VBA project binary.
workbook.add_vba_project('./vbaProject.bin')

# Show text for the end user.
worksheet.write('A3', 'Press the button to say hello.')

# Add a button tied to a macro in the VBA project.
worksheet.insert_button('B3', {'macro': 'say_hello',
                               'caption': 'Press Me',
                               'width': 80,
                               'height': 30})

workbook.close()

```

---

### File: `tmp\xlsxwriter_old\XlsxWriter-1.4.5\examples\merge1.py`

```python
##############################################################################
#
# A simple example of merging cells with the XlsxWriter Python module.
#
# Copyright 2013-2021, John McNamara, jmcnamara@cpan.org
#
import xlsxwriter


# Create an new Excel file and add a worksheet.
workbook = xlsxwriter.Workbook('merge1.xlsx')
worksheet = workbook.add_worksheet()

# Increase the cell size of the merged cells to highlight the formatting.
worksheet.set_column('B:D', 12)
worksheet.set_row(3, 30)
worksheet.set_row(6, 30)
worksheet.set_row(7, 30)


# Create a format to use in the merged range.
merge_format = workbook.add_format({
    'bold': 1,
    'border': 1,
    'align': 'center',
    'valign': 'vcenter',
    'fg_color': 'yellow'})


# Merge 3 cells.
worksheet.merge_range('B4:D4', 'Merged Range', merge_format)

# Merge 3 cells over two rows.
worksheet.merge_range('B7:D8', 'Merged Range', merge_format)


workbook.close()

```

---

### File: `tmp\xlsxwriter_old\XlsxWriter-1.4.5\examples\merge_rich_string.py`

```python
##############################################################################
#
# An  example of merging cells which contain a rich string using the
# XlsxWriter Python module.
#
# Copyright 2013-2021, John McNamara, jmcnamara@cpan.org
#
import xlsxwriter


# Create an new Excel file and add a worksheet.
workbook = xlsxwriter.Workbook('merge_rich_string.xlsx')
worksheet = workbook.add_worksheet()

# Set up some formats to use.
red = workbook.add_format({'color': 'red'})
blue = workbook.add_format({'color': 'blue'})
cell_format = workbook.add_format({'align': 'center',
                                   'valign': 'vcenter',
                                   'border': 1})

# We can only write simple types to merged ranges so we write a blank string.
worksheet.merge_range('B2:E5', "", cell_format)

# We then overwrite the first merged cell with a rich string. Note that we
# must also pass the cell format used in the merged cells format at the end.
worksheet.write_rich_string('B2',
                            'This is ',
                            red, 'red',
                            ' and this is ',
                            blue, 'blue',
                            cell_format)

workbook.close()

```

---

### File: `tmp\xlsxwriter_old\XlsxWriter-1.4.5\examples\outline.py`

```python
###############################################################################
#
# Example of how use Python and XlsxWriter to generate Excel outlines and
# grouping.
#
# Excel allows you to group rows or columns so that they can be hidden or
# displayed with a single mouse click. This feature is referred to as outlines.
#
# Outlines can reduce complex data down to a few salient sub-totals or
# summaries.
#
# Copyright 2013-2021, John McNamara, jmcnamara@cpan.org
#
import xlsxwriter

# Create a new workbook and add some worksheets
workbook = xlsxwriter.Workbook('outline.xlsx')
worksheet1 = workbook.add_worksheet('Outlined Rows')
worksheet2 = workbook.add_worksheet('Collapsed Rows')
worksheet3 = workbook.add_worksheet('Outline Columns')
worksheet4 = workbook.add_worksheet('Outline levels')

# Add a general format
bold = workbook.add_format({'bold': 1})


###############################################################################
#
# Example 1: A worksheet with outlined rows. It also includes SUBTOTAL()
# functions so that it looks like the type of automatic outlines that are
# generated when you use the Excel Data->SubTotals menu item.
#
# For outlines the important parameters are 'level' and 'hidden'. Rows with
# the same 'level' are grouped together. The group will be collapsed if
# 'hidden' is enabled. The parameters 'height' and 'cell_format' are assigned
# default values if they are None.
#
worksheet1.set_row(1, None, None, {'level': 2})
worksheet1.set_row(2, None, None, {'level': 2})
worksheet1.set_row(3, None, None, {'level': 2})
worksheet1.set_row(4, None, None, {'level': 2})
worksheet1.set_row(5, None, None, {'level': 1})

worksheet1.set_row(6, None, None, {'level': 2})
worksheet1.set_row(7, None, None, {'level': 2})
worksheet1.set_row(8, None, None, {'level': 2})
worksheet1.set_row(9, None, None, {'level': 2})
worksheet1.set_row(10, None, None, {'level': 1})

# Adjust the column width for clarity
worksheet1.set_column('A:A', 20)

# Add the data, labels and formulas
worksheet1.write('A1', 'Region', bold)
worksheet1.write('A2', 'North')
worksheet1.write('A3', 'North')
worksheet1.write('A4', 'North')
worksheet1.write('A5', 'North')
worksheet1.write('A6', 'North Total', bold)

worksheet1.write('B1', 'Sales', bold)
worksheet1.write('B2', 1000)
worksheet1.write('B3', 1200)
worksheet1.write('B4', 900)
worksheet1.write('B5', 1200)
worksheet1.write('B6', '=SUBTOTAL(9,B2:B5)', bold)

worksheet1.write('A7', 'South')
worksheet1.write('A8', 'South')
worksheet1.write('A9', 'South')
worksheet1.write('A10', 'South')
worksheet1.write('A11', 'South Total', bold)

worksheet1.write('B7', 400)
worksheet1.write('B8', 600)
worksheet1.write('B9', 500)
worksheet1.write('B10', 600)
worksheet1.write('B11', '=SUBTOTAL(9,B7:B10)', bold)

worksheet1.write('A12', 'Grand Total', bold)
worksheet1.write('B12', '=SUBTOTAL(9,B2:B10)', bold)


###############################################################################
#
# Example 2: A worksheet with outlined rows. This is the same as the
# previous example except that the rows are collapsed.
# Note: We need to indicate the rows that contains the collapsed symbol '+'
# with the optional parameter, 'collapsed'. The group will be then be
# collapsed if 'hidden' is True.
#
worksheet2.set_row(1, None, None, {'level': 2, 'hidden': True})
worksheet2.set_row(2, None, None, {'level': 2, 'hidden': True})
worksheet2.set_row(3, None, None, {'level': 2, 'hidden': True})
worksheet2.set_row(4, None, None, {'level': 2, 'hidden': True})
worksheet2.set_row(5, None, None, {'level': 1, 'hidden': True})

worksheet2.set_row(6, None, None, {'level': 2, 'hidden': True})
worksheet2.set_row(7, None, None, {'level': 2, 'hidden': True})
worksheet2.set_row(8, None, None, {'level': 2, 'hidden': True})
worksheet2.set_row(9, None, None, {'level': 2, 'hidden': True})
worksheet2.set_row(10, None, None, {'level': 1, 'hidden': True})
worksheet2.set_row(11, None, None, {'collapsed': True})

# Adjust the column width for clarity
worksheet2.set_column('A:A', 20)

# Add the data, labels and formulas
worksheet2.write('A1', 'Region', bold)
worksheet2.write('A2', 'North')
worksheet2.write('A3', 'North')
worksheet2.write('A4', 'North')
worksheet2.write('A5', 'North')
worksheet2.write('A6', 'North Total', bold)

worksheet2.write('B1', 'Sales', bold)
worksheet2.write('B2', 1000)
worksheet2.write('B3', 1200)
worksheet2.write('B4', 900)
worksheet2.write('B5', 1200)
worksheet2.write('B6', '=SUBTOTAL(9,B2:B5)', bold)

worksheet2.write('A7', 'South')
worksheet2.write('A8', 'South')
worksheet2.write('A9', 'South')
worksheet2.write('A10', 'South')
worksheet2.write('A11', 'South Total', bold)

worksheet2.write('B7', 400)
worksheet2.write('B8', 600)
worksheet2.write('B9', 500)
worksheet2.write('B10', 600)
worksheet2.write('B11', '=SUBTOTAL(9,B7:B10)', bold)

worksheet2.write('A12', 'Grand Total', bold)
worksheet2.write('B12', '=SUBTOTAL(9,B2:B10)', bold)


###############################################################################
#
# Example 3: Create a worksheet with outlined columns.
#
data = [
    ['Month', 'Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 'Total'],
    ['North', 50, 20, 15, 25, 65, 80, '=SUM(B2:G2)'],
    ['South', 10, 20, 30, 50, 50, 50, '=SUM(B3:G3)'],
    ['East', 45, 75, 50, 15, 75, 100, '=SUM(B4:G4)'],
    ['West', 15, 15, 55, 35, 20, 50, '=SUM(B5:G5)']]

# Add bold format to the first row.
worksheet3.set_row(0, None, bold)

# Set column formatting and the outline level.
worksheet3.set_column('A:A', 10, bold)
worksheet3.set_column('B:G', 5, None, {'level': 1})
worksheet3.set_column('H:H', 10)

# Write the data and a formula
for row, data_row in enumerate(data):
    worksheet3.write_row(row, 0, data_row)

worksheet3.write('H6', '=SUM(H2:H5)', bold)


###############################################################################
#
# Example 4: Show all possible outline levels.
#
levels = [
    'Level 1', 'Level 2', 'Level 3', 'Level 4', 'Level 5', 'Level 6',
    'Level 7', 'Level 6', 'Level 5', 'Level 4', 'Level 3', 'Level 2',
    'Level 1']

worksheet4.write_column('A1', levels)

worksheet4.set_row(0, None, None, {'level': 1})
worksheet4.set_row(1, None, None, {'level': 2})
worksheet4.set_row(2, None, None, {'level': 3})
worksheet4.set_row(3, None, None, {'level': 4})
worksheet4.set_row(4, None, None, {'level': 5})
worksheet4.set_row(5, None, None, {'level': 6})
worksheet4.set_row(6, None, None, {'level': 7})
worksheet4.set_row(7, None, None, {'level': 6})
worksheet4.set_row(8, None, None, {'level': 5})
worksheet4.set_row(9, None, None, {'level': 4})
worksheet4.set_row(10, None, None, {'level': 3})
worksheet4.set_row(11, None, None, {'level': 2})
worksheet4.set_row(12, None, None, {'level': 1})

workbook.close()

```

---

### File: `tmp\xlsxwriter_old\XlsxWriter-1.4.5\examples\outline_collapsed.py`

```python
###############################################################################
#
# Example of how to use Python and XlsxWriter to generate Excel outlines and
# grouping.
#
# These examples focus mainly on collapsed outlines. See also the
# outlines.py example program for more general examples.
#
# Copyright 2013-2021, John McNamara, jmcnamara@cpan.org
#
import xlsxwriter

# Create a new workbook and add some worksheets
workbook = xlsxwriter.Workbook('outline_collapsed.xlsx')
worksheet1 = workbook.add_worksheet('Outlined Rows')
worksheet2 = workbook.add_worksheet('Collapsed Rows 1')
worksheet3 = workbook.add_worksheet('Collapsed Rows 2')
worksheet4 = workbook.add_worksheet('Collapsed Rows 3')
worksheet5 = workbook.add_worksheet('Outline Columns')
worksheet6 = workbook.add_worksheet('Collapsed Columns')

# Add a general format
bold = workbook.add_format({'bold': 1})


# This function will generate the same data and sub-totals on each worksheet.
# Used in the first 4 examples.
#
def create_sub_totals(worksheet):
    # Adjust the column width for clarity.
    worksheet.set_column('A:A', 20)

    # Add the data, labels and formulas.
    worksheet.write('A1', 'Region', bold)
    worksheet.write('A2', 'North')
    worksheet.write('A3', 'North')
    worksheet.write('A4', 'North')
    worksheet.write('A5', 'North')
    worksheet.write('A6', 'North Total', bold)

    worksheet.write('B1', 'Sales', bold)
    worksheet.write('B2', 1000)
    worksheet.write('B3', 1200)
    worksheet.write('B4', 900)
    worksheet.write('B5', 1200)
    worksheet.write('B6', '=SUBTOTAL(9,B2:B5)', bold)

    worksheet.write('A7', 'South')
    worksheet.write('A8', 'South')
    worksheet.write('A9', 'South')
    worksheet.write('A10', 'South')
    worksheet.write('A11', 'South Total', bold)

    worksheet.write('B7', 400)
    worksheet.write('B8', 600)
    worksheet.write('B9', 500)
    worksheet.write('B10', 600)
    worksheet.write('B11', '=SUBTOTAL(9,B7:B10)', bold)

    worksheet.write('A12', 'Grand Total', bold)
    worksheet.write('B12', '=SUBTOTAL(9,B2:B10)', bold)

###############################################################################
#
# Example 1: A worksheet with outlined rows. It also includes SUBTOTAL()
# functions so that it looks like the type of automatic outlines that are
# generated when you use the Excel Data->SubTotals menu item.
#
worksheet1.set_row(1, None, None, {'level': 2})
worksheet1.set_row(2, None, None, {'level': 2})
worksheet1.set_row(3, None, None, {'level': 2})
worksheet1.set_row(4, None, None, {'level': 2})
worksheet1.set_row(5, None, None, {'level': 1})

worksheet1.set_row(6, None, None, {'level': 2})
worksheet1.set_row(7, None, None, {'level': 2})
worksheet1.set_row(8, None, None, {'level': 2})
worksheet1.set_row(9, None, None, {'level': 2})
worksheet1.set_row(10, None, None, {'level': 1})

# Write the sub-total data that is common to the row examples.
create_sub_totals(worksheet1)


###############################################################################
#
# Example 2: Create a worksheet with collapsed outlined rows.
# This is the same as the example 1  except that the all rows are collapsed.
# Note: We need to indicate the rows that contains the collapsed symbol '+'
# with the optional parameter, 'collapsed'.
#
worksheet2.set_row(1, None, None, {'level': 2, 'hidden': True})
worksheet2.set_row(2, None, None, {'level': 2, 'hidden': True})
worksheet2.set_row(3, None, None, {'level': 2, 'hidden': True})
worksheet2.set_row(4, None, None, {'level': 2, 'hidden': True})
worksheet2.set_row(5, None, None, {'level': 1, 'hidden': True})

worksheet2.set_row(6, None, None, {'level': 2, 'hidden': True})
worksheet2.set_row(7, None, None, {'level': 2, 'hidden': True})
worksheet2.set_row(8, None, None, {'level': 2, 'hidden': True})
worksheet2.set_row(9, None, None, {'level': 2, 'hidden': True})
worksheet2.set_row(10, None, None, {'level': 1, 'hidden': True})

worksheet2.set_row(11, None, None, {'collapsed': True})

# Write the sub-total data that is common to the row examples.
create_sub_totals(worksheet2)


###############################################################################
#
# Example 3: Create a worksheet with collapsed outlined rows.
# Same as the example 1  except that the two sub-totals are collapsed.
#
worksheet3.set_row(1, None, None, {'level': 2, 'hidden': True})
worksheet3.set_row(2, None, None, {'level': 2, 'hidden': True})
worksheet3.set_row(3, None, None, {'level': 2, 'hidden': True})
worksheet3.set_row(4, None, None, {'level': 2, 'hidden': True})
worksheet3.set_row(5, None, None, {'level': 1, 'collapsed': True})

worksheet3.set_row(6, None, None, {'level': 2, 'hidden': True})
worksheet3.set_row(7, None, None, {'level': 2, 'hidden': True})
worksheet3.set_row(8, None, None, {'level': 2, 'hidden': True})
worksheet3.set_row(9, None, None, {'level': 2, 'hidden': True})
worksheet3.set_row(10, None, None, {'level': 1, 'collapsed': True})

# Write the sub-total data that is common to the row examples.
create_sub_totals(worksheet3)


###############################################################################
#
# Example 4: Create a worksheet with outlined rows.
# Same as the example 1  except that the two sub-totals are collapsed.
#
worksheet4.set_row(1, None, None, {'level': 2, 'hidden': True})
worksheet4.set_row(2, None, None, {'level': 2, 'hidden': True})
worksheet4.set_row(3, None, None, {'level': 2, 'hidden': True})
worksheet4.set_row(4, None, None, {'level': 2, 'hidden': True})
worksheet4.set_row(5, None, None, {'level': 1, 'hidden': True,
                                   'collapsed': True})

worksheet4.set_row(6, None, None, {'level': 2, 'hidden': True})
worksheet4.set_row(7, None, None, {'level': 2, 'hidden': True})
worksheet4.set_row(8, None, None, {'level': 2, 'hidden': True})
worksheet4.set_row(9, None, None, {'level': 2, 'hidden': True})
worksheet4.set_row(10, None, None, {'level': 1, 'hidden': True,
                                    'collapsed': True})

worksheet4.set_row(11, None, None, {'collapsed': True})


# Write the sub-total data that is common to the row examples.
create_sub_totals(worksheet4)


###############################################################################
#
# Example 5: Create a worksheet with outlined columns.
#
data = [
    ['Month', 'Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 'Total'],
    ['North', 50, 20, 15, 25, 65, 80, '=SUM(B2:G2)'],
    ['South', 10, 20, 30, 50, 50, 50, '=SUM(B3:G3)'],
    ['East', 45, 75, 50, 15, 75, 100, '=SUM(B4:G4)'],
    ['West', 15, 15, 55, 35, 20, 50, '=SUM(B5:G5)']]

# Add bold format to the first row.
worksheet5.set_row(0, None, bold)

# Set column formatting and the outline level.
worksheet5.set_column('A:A', 10, bold)
worksheet5.set_column('B:G', 5, None, {'level': 1})
worksheet5.set_column('H:H', 10)

# Write the data and a formula.
for row, data_row in enumerate(data):
    worksheet5.write_row(row, 0, data_row)

worksheet5.write('H6', '=SUM(H2:H5)', bold)

###############################################################################
#
# Example 6: Create a worksheet with collapsed outlined columns.
# This is the same as the previous example except with collapsed columns.
#

# Reuse the data from the previous example.

# Add bold format to the first row.
worksheet6.set_row(0, None, bold)

# Set column formatting and the outline level.
worksheet6.set_column('A:A', 10, bold)
worksheet6.set_column('B:G', 5, None, {'level': 1, 'hidden': True})
worksheet6.set_column('H:H', 10, None, {'collapsed': True})

# Write the data and a formula.
for row, data_row in enumerate(data):
    worksheet6.write_row(row, 0, data_row)

worksheet6.write('H6', '=SUM(H2:H5)', bold)

workbook.close()

```

---

### File: `tmp\xlsxwriter_old\XlsxWriter-1.4.5\examples\pandas_autofilter.py`

```python
##############################################################################
#
# An example of converting a Pandas dataframe to an xlsx file with an
# autofilter and filtered data. See also autofilter.py.
#
# Copyright 2013-2021, John McNamara, jmcnamara@cpan.org
#

import pandas as pd

# Create a Pandas dataframe by reading some data from a space-separated file.
df = pd.read_csv('autofilter_data.txt', sep=r'\s+')

# Create a Pandas Excel writer using XlsxWriter as the engine.
writer = pd.ExcelWriter('pandas_autofilter.xlsx', engine='xlsxwriter')

# Convert the dataframe to an XlsxWriter Excel object. We also turn off the
# index column at the left of the output dataframe.
df.to_excel(writer, sheet_name='Sheet1', index=False)

# Get the xlsxwriter workbook and worksheet objects.
workbook  = writer.book
worksheet = writer.sheets['Sheet1']

# Get the dimensions of the dataframe.
(max_row, max_col) = df.shape

# Make the columns wider for clarity.
worksheet.set_column(0,  max_col - 1, 12)

# Set the autofilter.
worksheet.autofilter(0, 0, max_row, max_col - 1)

# Add an optional filter criteria. The placeholder "Region" in the filter
# is ignored and can be any string that adds clarity to the expression.
worksheet.filter_column(0, 'Region == East')

# It isn't enough to just apply the criteria. The rows that don't match
# must also be hidden. We use Pandas to figure our which rows to hide.
for row_num in (df.index[(df['Region'] != 'East')].tolist()):
    worksheet.set_row(row_num + 1, options={'hidden': True})

# Close the Pandas Excel writer and output the Excel file.
writer.save()

```

---

### File: `tmp\xlsxwriter_old\XlsxWriter-1.4.5\examples\pandas_chart.py`

```python
##############################################################################
#
# An example of converting a Pandas dataframe to an xlsx file with a chart
# using Pandas and XlsxWriter.
#
# Copyright 2013-2021, John McNamara, jmcnamara@cpan.org
#

import pandas as pd


# Create a Pandas dataframe from some data.
df = pd.DataFrame({'Data': [10, 20, 30, 20, 15, 30, 45]})

# Create a Pandas Excel writer using XlsxWriter as the engine.
writer = pd.ExcelWriter('pandas_chart.xlsx', engine='xlsxwriter')

# Convert the dataframe to an XlsxWriter Excel object.
df.to_excel(writer, sheet_name='Sheet1')

# Get the xlsxwriter workbook and worksheet objects.
workbook  = writer.book
worksheet = writer.sheets['Sheet1']

# Create a chart object.
chart = workbook.add_chart({'type': 'column'})

# Configure the series of the chart from the dataframe data.
chart.add_series({'values': '=Sheet1!$B$2:$B$8'})

# Insert the chart into the worksheet.
worksheet.insert_chart('D2', chart)

# Close the Pandas Excel writer and output the Excel file.
writer.save()

```

---

### File: `tmp\xlsxwriter_old\XlsxWriter-1.4.5\examples\pandas_chart_columns.py`

```python
##############################################################################
#
# An example of converting a Pandas dataframe to an xlsx file with a grouped
# column chart using Pandas and XlsxWriter.
#
# Copyright 2013-2021, John McNamara, jmcnamara@cpan.org
#

import pandas as pd

# Some sample data to plot.
farm_1 = {'Apples': 10, 'Berries': 32, 'Squash': 21, 'Melons': 13, 'Corn': 18}
farm_2 = {'Apples': 15, 'Berries': 43, 'Squash': 17, 'Melons': 10, 'Corn': 22}
farm_3 = {'Apples': 6,  'Berries': 24, 'Squash': 22, 'Melons': 16, 'Corn': 30}
farm_4 = {'Apples': 12, 'Berries': 30, 'Squash': 15, 'Melons': 9,  'Corn': 15}

data  = [farm_1, farm_2, farm_3, farm_4]
index = ['Farm 1', 'Farm 2', 'Farm 3', 'Farm 4']

# Create a Pandas dataframe from the data.
df = pd.DataFrame(data, index=index)

# Create a Pandas Excel writer using XlsxWriter as the engine.
sheet_name = 'Sheet1'
writer     = pd.ExcelWriter('pandas_chart_columns.xlsx', engine='xlsxwriter')
df.to_excel(writer, sheet_name=sheet_name)

# Access the XlsxWriter workbook and worksheet objects from the dataframe.
workbook  = writer.book
worksheet = writer.sheets[sheet_name]

# Create a chart object.
chart = workbook.add_chart({'type': 'column'})

# Some alternative colors for the chart.
colors = ['#E41A1C', '#377EB8', '#4DAF4A', '#984EA3', '#FF7F00']

# Configure the series of the chart from the dataframe data.
for col_num in range(1, len(farm_1) + 1):
    chart.add_series({
        'name':       ['Sheet1', 0, col_num],
        'categories': ['Sheet1', 1, 0, 4, 0],
        'values':     ['Sheet1', 1, col_num, 4, col_num],
        'fill':       {'color':  colors[col_num - 1]},
        'overlap':    -10,
    })

# Configure the chart axes.
chart.set_x_axis({'name': 'Total Produce'})
chart.set_y_axis({'name': 'Farms', 'major_gridlines': {'visible': False}})

# Insert the chart into the worksheet.
worksheet.insert_chart('H2', chart)

# Close the Pandas Excel writer and output the Excel file.
writer.save()

```

---

### File: `tmp\xlsxwriter_old\XlsxWriter-1.4.5\examples\pandas_chart_line.py`

```python
##############################################################################
#
# An example of converting a Pandas dataframe to an xlsx file with a line
# chart using Pandas and XlsxWriter.
#
# Copyright 2013-2021, John McNamara, jmcnamara@cpan.org
#

import pandas as pd
import random

# Create some sample data to plot.
max_row     = 21
categories  = ['Node 1', 'Node 2', 'Node 3', 'Node 4']
index_1     = range(0, max_row, 1)
multi_iter1 = {'index': index_1}

for category in categories:
    multi_iter1[category] = [random.randint(10, 100) for x in index_1]

# Create a Pandas dataframe from the data.
index_2 = multi_iter1.pop('index')
df      = pd.DataFrame(multi_iter1, index=index_2)
df      = df.reindex(columns=sorted(df.columns))

# Create a Pandas Excel writer using XlsxWriter as the engine.
sheet_name = 'Sheet1'
writer     = pd.ExcelWriter('pandas_chart_line.xlsx', engine='xlsxwriter')
df.to_excel(writer, sheet_name=sheet_name)

# Access the XlsxWriter workbook and worksheet objects from the dataframe.
workbook  = writer.book
worksheet = writer.sheets[sheet_name]

# Create a chart object.
chart = workbook.add_chart({'type': 'line'})

# Configure the series of the chart from the dataframe data.
for i in range(len(categories)):
    col = i + 1
    chart.add_series({
        'name':       ['Sheet1', 0, col],
        'categories': ['Sheet1', 1, 0,   max_row, 0],
        'values':     ['Sheet1', 1, col, max_row, col],
    })

# Configure the chart axes.
chart.set_x_axis({'name': 'Index'})
chart.set_y_axis({'name': 'Value', 'major_gridlines': {'visible': False}})

# Insert the chart into the worksheet.
worksheet.insert_chart('G2', chart)

# Close the Pandas Excel writer and output the Excel file.
writer.save()

```

---

### File: `tmp\xlsxwriter_old\XlsxWriter-1.4.5\examples\pandas_column_formats.py`

```python
##############################################################################
#
# An example of converting a Pandas dataframe to an xlsx file
# with column formats using Pandas and XlsxWriter.
#
# Copyright 2013-2021, John McNamara, jmcnamara@cpan.org
#

import pandas as pd

# Create a Pandas dataframe from some data.
df = pd.DataFrame({'Numbers':    [1010, 2020, 3030, 2020, 1515, 3030, 4545],
                   'Percentage': [.1,   .2,   .33,  .25,  .5,   .75,  .45 ],
})

# Create a Pandas Excel writer using XlsxWriter as the engine.
writer = pd.ExcelWriter("pandas_column_formats.xlsx", engine='xlsxwriter')

# Convert the dataframe to an XlsxWriter Excel object.
df.to_excel(writer, sheet_name='Sheet1')

# Get the xlsxwriter workbook and worksheet objects.
workbook  = writer.book
worksheet = writer.sheets['Sheet1']

# Add some cell formats.
format1 = workbook.add_format({'num_format': '#,##0.00'})
format2 = workbook.add_format({'num_format': '0%'})

# Note: It isn't possible to format any cells that already have a format such
# as the index or headers or any cells that contain dates or datetimes.

# Set the column width and format.
worksheet.set_column('B:B', 18, format1)

# Set the format but not the column width.
worksheet.set_column('C:C', None, format2)

# Close the Pandas Excel writer and output the Excel file.
writer.save()

```

---

### File: `tmp\xlsxwriter_old\XlsxWriter-1.4.5\examples\pandas_conditional_format.py`

```python
##############################################################################
#
# An example of converting a Pandas dataframe to an xlsx file with a
# conditional formatting using Pandas and XlsxWriter.
#
# Copyright 2013-2021, John McNamara, jmcnamara@cpan.org
#

import pandas as pd


# Create a Pandas dataframe from some data.
df = pd.DataFrame({'Data': [10, 20, 30, 20, 15, 30, 45]})

# Create a Pandas Excel writer using XlsxWriter as the engine.
writer = pd.ExcelWriter('pandas_conditional.xlsx', engine='xlsxwriter')

# Convert the dataframe to an XlsxWriter Excel object.
df.to_excel(writer, sheet_name='Sheet1')

# Get the xlsxwriter workbook and worksheet objects.
workbook  = writer.book
worksheet = writer.sheets['Sheet1']

# Apply a conditional format to the cell range.
worksheet.conditional_format('B2:B8', {'type': '3_color_scale'})

# Close the Pandas Excel writer and output the Excel file.
writer.save()

```

---

### File: `tmp\xlsxwriter_old\XlsxWriter-1.4.5\examples\pandas_datetime.py`

```python
##############################################################################
#
# An example of converting a Pandas dataframe with datetimes to an xlsx file
# with a default datetime and date format using Pandas and XlsxWriter.
#
# Copyright 2013-2021, John McNamara, jmcnamara@cpan.org
#

import pandas as pd
from datetime import datetime, date

# Create a Pandas dataframe from some datetime data.
df = pd.DataFrame({'Date and time': [datetime(2015, 1, 1, 11, 30, 55),
                                     datetime(2015, 1, 2, 1,  20, 33),
                                     datetime(2015, 1, 3, 11, 10    ),
                                     datetime(2015, 1, 4, 16, 45, 35),
                                     datetime(2015, 1, 5, 12, 10, 15)],
                   'Dates only':    [date(2015, 2, 1),
                                     date(2015, 2, 2),
                                     date(2015, 2, 3),
                                     date(2015, 2, 4),
                                     date(2015, 2, 5)],
                   })

# Create a Pandas Excel writer using XlsxWriter as the engine.
# Also set the default datetime and date formats.
writer = pd.ExcelWriter("pandas_datetime.xlsx",
                        engine='xlsxwriter',
                        datetime_format='mmm d yyyy hh:mm:ss',
                        date_format='mmmm dd yyyy')

# Convert the dataframe to an XlsxWriter Excel object.
df.to_excel(writer, sheet_name='Sheet1')

# Get the xlsxwriter workbook and worksheet objects in order to set the column
# widths, to make the dates clearer.
workbook  = writer.book
worksheet = writer.sheets['Sheet1']

worksheet.set_column('B:C', 20)

# Close the Pandas Excel writer and output the Excel file.
writer.save()

```

---

### File: `tmp\xlsxwriter_old\XlsxWriter-1.4.5\examples\pandas_header_format.py`

```python
##############################################################################
#
# An example of converting a Pandas dataframe to an xlsx file
# with a user defined header format.
#
# Copyright 2013-2021, John McNamara, jmcnamara@cpan.org
#

import pandas as pd

# Create a Pandas dataframe from some data.
data = [10, 20, 30, 40, 50, 60]
df = pd.DataFrame({'Heading': data,
                   'Longer heading that should be wrapped' : data})

# Create a Pandas Excel writer using XlsxWriter as the engine.
writer = pd.ExcelWriter("pandas_header_format.xlsx", engine='xlsxwriter')

# Convert the dataframe to an XlsxWriter Excel object. Note that we turn off
# the default header and skip one row to allow us to insert a user defined
# header.
df.to_excel(writer, sheet_name='Sheet1', startrow=1, header=False)

# Get the xlsxwriter workbook and worksheet objects.
workbook  = writer.book
worksheet = writer.sheets['Sheet1']

# Add a header format.
header_format = workbook.add_format({
    'bold': True,
    'text_wrap': True,
    'valign': 'top',
    'fg_color': '#D7E4BC',
    'border': 1})

# Write the column headers with the defined format.
for col_num, value in enumerate(df.columns.values):
    worksheet.write(0, col_num + 1, value, header_format)

# Close the Pandas Excel writer and output the Excel file.
writer.save()

```

---

### File: `tmp\xlsxwriter_old\XlsxWriter-1.4.5\examples\pandas_multiple.py`

```python
##############################################################################
#
# An example of writing multiple dataframes to worksheets using Pandas and
# XlsxWriter.
#
# Copyright 2013-2021, John McNamara, jmcnamara@cpan.org
#

import pandas as pd


# Create some Pandas dataframes from some data.
df1 = pd.DataFrame({'Data': [11, 12, 13, 14]})
df2 = pd.DataFrame({'Data': [21, 22, 23, 24]})
df3 = pd.DataFrame({'Data': [31, 32, 33, 34]})

# Create a Pandas Excel writer using XlsxWriter as the engine.
writer = pd.ExcelWriter('pandas_multiple.xlsx', engine='xlsxwriter')

# Write each dataframe to a different worksheet.
df1.to_excel(writer, sheet_name='Sheet1')
df2.to_excel(writer, sheet_name='Sheet2')
df3.to_excel(writer, sheet_name='Sheet3')

# Close the Pandas Excel writer and output the Excel file.
writer.save()

```

---

### File: `tmp\xlsxwriter_old\XlsxWriter-1.4.5\examples\pandas_positioning.py`

```python
##############################################################################
#
# An example of positioning dataframes in a worksheet using Pandas and
# XlsxWriter.
#
# Copyright 2013-2021, John McNamara, jmcnamara@cpan.org
#

import pandas as pd


# Create some Pandas dataframes from some data.
df1 = pd.DataFrame({'Data': [11, 12, 13, 14]})
df2 = pd.DataFrame({'Data': [21, 22, 23, 24]})
df3 = pd.DataFrame({'Data': [31, 32, 33, 34]})
df4 = pd.DataFrame({'Data': [41, 42, 43, 44]})

# Create a Pandas Excel writer using XlsxWriter as the engine.
writer = pd.ExcelWriter('pandas_positioning.xlsx', engine='xlsxwriter')

# Position the dataframes in the worksheet.
df1.to_excel(writer, sheet_name='Sheet1')  # Default position, cell A1.
df2.to_excel(writer, sheet_name='Sheet1', startcol=3)
df3.to_excel(writer, sheet_name='Sheet1', startrow=6)

# It is also possible to write the dataframe without the header and index.
df4.to_excel(writer, sheet_name='Sheet1',
             startrow=7, startcol=4, header=False, index=False)

# Close the Pandas Excel writer and output the Excel file.
writer.save()

```

---

### File: `tmp\xlsxwriter_old\XlsxWriter-1.4.5\examples\pandas_simple.py`

```python
##############################################################################
#
# A simple example of converting a Pandas dataframe to an xlsx file using
# Pandas and XlsxWriter.
#
# Copyright 2013-2021, John McNamara, jmcnamara@cpan.org
#

import pandas as pd


# Create a Pandas dataframe from some data.
df = pd.DataFrame({'Data': [10, 20, 30, 20, 15, 30, 45]})

# Create a Pandas Excel writer using XlsxWriter as the engine.
writer = pd.ExcelWriter('pandas_simple.xlsx', engine='xlsxwriter')

# Convert the dataframe to an XlsxWriter Excel object.
df.to_excel(writer, sheet_name='Sheet1')

# Close the Pandas Excel writer and output the Excel file.
writer.save()

```

---

### File: `tmp\xlsxwriter_old\XlsxWriter-1.4.5\examples\pandas_table.py`

```python
##############################################################################
#
# An example of adding a dataframe to an worksheet table in an xlsx file
# using Pandas and XlsxWriter.
#
# Tables in Excel are used to group rows and columns of data into a single
# structure that can be referenced in a formula or formatted collectively.
#
# Copyright 2013-2021, John McNamara, jmcnamara@cpan.org
#

import pandas as pd

# Create a Pandas dataframe from some data.
df = pd.DataFrame({
    'Country':    ['China',    'India',    'United States', 'Indonesia'],
    'Population': [1404338840, 1366938189, 330267887,       269603400],
    'Rank':       [1,          2,          3,               4]})

# Order the columns if necessary.
df = df[['Rank', 'Country', 'Population']]

# Create a Pandas Excel writer using XlsxWriter as the engine.
writer = pd.ExcelWriter('pandas_table.xlsx', engine='xlsxwriter')

# Write the dataframe data to XlsxWriter. Turn off the default header and
# index and skip one row to allow us to insert a user defined header.
df.to_excel(writer, sheet_name='Sheet1', startrow=1, header=False, index=False)

# Get the xlsxwriter workbook and worksheet objects.
workbook = writer.book
worksheet = writer.sheets['Sheet1']

# Get the dimensions of the dataframe.
(max_row, max_col) = df.shape

# Create a list of column headers, to use in add_table().
column_settings = [{'header': column} for column in df.columns]

# Add the Excel table structure. Pandas will add the data.
worksheet.add_table(0, 0, max_row, max_col - 1, {'columns': column_settings})

# Make the columns wider for clarity.
worksheet.set_column(0, max_col - 1, 12)

# Close the Pandas Excel writer and output the Excel file.
writer.save()

```

---

### File: `tmp\xlsxwriter_old\XlsxWriter-1.4.5\examples\panes.py`

```python
#######################################################################
#
# Example of using Python and the XlsxWriter module to create
# worksheet panes.
#
# Copyright 2013-2021, John McNamara, jmcnamara@cpan.org
#
import xlsxwriter

workbook = xlsxwriter.Workbook('panes.xlsx')

worksheet1 = workbook.add_worksheet('Panes 1')
worksheet2 = workbook.add_worksheet('Panes 2')
worksheet3 = workbook.add_worksheet('Panes 3')
worksheet4 = workbook.add_worksheet('Panes 4')

#######################################################################
#
# Set up some formatting and text to highlight the panes.
#
header_format = workbook.add_format({'bold': True,
                                     'align': 'center',
                                     'valign': 'vcenter',
                                     'fg_color': '#D7E4BC',
                                     'border': 1})

center_format = workbook.add_format({'align': 'center'})


#######################################################################
#
# Example 1. Freeze pane on the top row.
#
worksheet1.freeze_panes(1, 0)

# Other sheet formatting.
worksheet1.set_column('A:I', 16)
worksheet1.set_row(0, 20)
worksheet1.set_selection('C3')


# Some text to demonstrate scrolling.
for col in range(0, 9):
    worksheet1.write(0, col, 'Scroll down', header_format)

for row in range(1, 100):
    for col in range(0, 9):
        worksheet1.write(row, col, row + 1, center_format)


#######################################################################
#
# Example 2. Freeze pane on the left column.
#
worksheet2.freeze_panes(0, 1)

# Other sheet formatting.
worksheet2.set_column('A:A', 16)
worksheet2.set_selection('C3')

# Some text to demonstrate scrolling.
for row in range(0, 50):
    worksheet2.write(row, 0, 'Scroll right', header_format)
    for col in range(1, 26):
        worksheet2.write(row, col, col, center_format)


#######################################################################
#
# Example 3. Freeze pane on the top row and left column.
#
worksheet3.freeze_panes(1, 1)

# Other sheet formatting.
worksheet3.set_column('A:Z', 16)
worksheet3.set_row(0, 20)
worksheet3.set_selection('C3')
worksheet3.write(0, 0, '', header_format)

# Some text to demonstrate scrolling.
for col in range(1, 26):
    worksheet3.write(0, col, 'Scroll down', header_format)

for row in range(1, 50):
    worksheet3.write(row, 0, 'Scroll right', header_format)
    for col in range(1, 26):
        worksheet3.write(row, col, col, center_format)


#######################################################################
#
# Example 4. Split pane on the top row and left column.
#
# The divisions must be specified in terms of row and column dimensions.
# The default row height is 15 and the default column width is 8.43
#
worksheet4.split_panes(15, 8.43)

# Other sheet formatting.
worksheet4.set_selection('C3')

# Some text to demonstrate scrolling.
for col in range(1, 26):
    worksheet4.write(0, col, 'Scroll', center_format)

for row in range(1, 50):
    worksheet4.write(row, 0, 'Scroll', center_format)
    for col in range(1, 26):
        worksheet4.write(row, col, col, center_format)

workbook.close()

```

---

### File: `tmp\xlsxwriter_old\XlsxWriter-1.4.5\examples\rich_strings.py`

```python
#######################################################################
#
# An example of using Python and XlsxWriter to write some "rich strings",
# i.e., strings with multiple formats.
#
# Copyright 2013-2021, John McNamara, jmcnamara@cpan.org
#
import xlsxwriter

workbook = xlsxwriter.Workbook('rich_strings.xlsx')
worksheet = workbook.add_worksheet()

worksheet.set_column('A:A', 30)

# Set up some formats to use.
bold = workbook.add_format({'bold': True})
italic = workbook.add_format({'italic': True})
red = workbook.add_format({'color': 'red'})
blue = workbook.add_format({'color': 'blue'})
center = workbook.add_format({'align': 'center'})
superscript = workbook.add_format({'font_script': 1})

# Write some strings with multiple formats.
worksheet.write_rich_string('A1',
                            'This is ',
                            bold, 'bold',
                            ' and this is ',
                            italic, 'italic')

worksheet.write_rich_string('A3',
                            'This is ',
                            red, 'red',
                            ' and this is ',
                            blue, 'blue')

worksheet.write_rich_string('A5',
                            'Some ',
                            bold, 'bold text',
                            ' centered',
                            center)

worksheet.write_rich_string('A7',
                            italic,
                            'j = k',
                            superscript, '(n-1)',
                            center)

# If you have formats and segments in a list you can add them like this:
segments = ['This is ', bold, 'bold', ' and this is ', blue, 'blue']
worksheet.write_rich_string('A9', *segments)

workbook.close()

```

---

### File: `tmp\xlsxwriter_old\XlsxWriter-1.4.5\examples\right_to_left.py`

```python
#######################################################################
# _*_ coding: utf-8
#
# Example of how to use Python and the XlsxWriter module to change the default
# worksheet and cell text direction from left-to-right to right-to-left as
# required by some middle eastern versions of Excel.
#
# Note, this a Python2 unicode version. Remove the u'' to make this work with
# Python3. See also the unicode_python3.py example.
#
# Copyright 2013-2021, John McNamara, jmcnamara@cpan.org
#
import xlsxwriter

workbook = xlsxwriter.Workbook('right_to_left.xlsx')

# Add two worksheets.
worksheet1 = workbook.add_worksheet()
worksheet2 = workbook.add_worksheet()

# Add the cell formats.
format_left_to_right = workbook.add_format({'reading_order': 1})
format_right_to_left = workbook.add_format({'reading_order': 2})

# Make the columns wider for clarity.
worksheet1.set_column('A:A', 25)
worksheet2.set_column('A:A', 25)

# Change the direction for worksheet2.
worksheet2.right_to_left()

# Write some data to show the difference.

# Standard direction:         | A1 | B1 | C1 | ...
worksheet1.write('A1', u'  / English text')  # Default direction.
worksheet1.write('A2', u'  / English text', format_left_to_right)
worksheet1.write('A3', u'  / English text', format_right_to_left)

# Right to left direction:    ... | C1 | B1 | A1 |
worksheet2.write('A1', u'  / English text')  # Default direction.
worksheet2.write('A2', u'  / English text', format_left_to_right)
worksheet2.write('A3', u'  / English text', format_right_to_left)

workbook.close()

```

---

### File: `tmp\xlsxwriter_old\XlsxWriter-1.4.5\examples\sparklines1.py`

```python
###############################################################################
#
# Example of how to add sparklines to a Python XlsxWriter file.
#
# Sparklines are small charts that fit in a single cell and are
# used to show trends in data.
#
# See sparklines2.py for examples of more complex sparkline formatting.
#
# Copyright 2013-2021, John McNamara, jmcnamara@cpan.org
#
import xlsxwriter

workbook = xlsxwriter.Workbook('sparklines1.xlsx')
worksheet = workbook.add_worksheet()

# Some sample data to plot.
data = [
    [-2, 2, 3, -1, 0],
    [30, 20, 33, 20, 15],
    [1, -1, -1, 1, -1],
]


# Write the sample data to the worksheet.
worksheet.write_row('A1', data[0])
worksheet.write_row('A2', data[1])
worksheet.write_row('A3', data[2])


# Add a line sparkline (the default) with markers.
worksheet.add_sparkline('F1', {'range': 'Sheet1!A1:E1',
                               'markers': True})


# Add a column sparkline with non-default style.
worksheet.add_sparkline('F2', {'range': 'Sheet1!A2:E2',
                               'type': 'column',
                               'style': 12})


# Add a win/loss sparkline with negative values highlighted.
worksheet.add_sparkline('F3', {'range': 'Sheet1!A3:E3',
                               'type': 'win_loss',
                               'negative_points': True})

workbook.close()

```

---

### File: `tmp\xlsxwriter_old\XlsxWriter-1.4.5\examples\sparklines2.py`

```python
###############################################################################
#
# Example of how to add sparklines to an XlsxWriter file with Python.
#
# Sparklines are small charts that fit in a single cell and are
# used to show trends in data. This example shows the majority of
# options that can be applied to sparklines.
#
# Copyright 2013-2021, John McNamara, jmcnamara@cpan.org
#
import xlsxwriter

workbook = xlsxwriter.Workbook('sparklines2.xlsx')
worksheet1 = workbook.add_worksheet()
worksheet2 = workbook.add_worksheet()
bold = workbook.add_format({'bold': True})
row = 1

# Set the columns widths to make the output clearer.
worksheet1.set_column('A:A', 14)
worksheet1.set_column('B:B', 50)
worksheet1.set_zoom(150)

# Headings.
worksheet1.write('A1', 'Sparkline', bold)
worksheet1.write('B1', 'Description', bold)


###############################################################################
#
text = 'A default "line" sparkline.'

worksheet1.add_sparkline('A2', {'range': 'Sheet2!A1:J1'})

worksheet1.write(row, 1, text)
row += 1


###############################################################################
#
text = 'A default "column" sparkline.'

worksheet1.add_sparkline('A3', {'range': 'Sheet2!A2:J2',
                                'type': 'column'})

worksheet1.write(row, 1, text)
row += 1


###############################################################################
#
text = 'A default "win/loss" sparkline.'

worksheet1.add_sparkline('A4', {'range': 'Sheet2!A3:J3',
                                'type': 'win_loss'})

worksheet1.write(row, 1, text)
row += 2


###############################################################################
#
text = 'Line with markers.'

worksheet1.add_sparkline('A6', {'range': 'Sheet2!A1:J1',
                                'markers': True})

worksheet1.write(row, 1, text)
row += 1


###############################################################################
#
text = 'Line with high and low points.'

worksheet1.add_sparkline('A7', {'range': 'Sheet2!A1:J1',
                                'high_point': True,
                                'low_point': True})

worksheet1.write(row, 1, text)
row += 1


###############################################################################
#
text = 'Line with first and last point markers.'

worksheet1.add_sparkline('A8', {'range': 'Sheet2!A1:J1',
                                'first_point': True,
                                'last_point': True})

worksheet1.write(row, 1, text)
row += 1


###############################################################################
#
text = 'Line with negative point markers.'

worksheet1.add_sparkline('A9', {'range': 'Sheet2!A1:J1',
                                'negative_points': True})

worksheet1.write(row, 1, text)
row += 1


###############################################################################
#
text = 'Line with axis.'

worksheet1.add_sparkline('A10', {'range': 'Sheet2!A1:J1',
                                 'axis': True})

worksheet1.write(row, 1, text)
row += 2


###############################################################################
#
text = 'Column with default style (1).'

worksheet1.add_sparkline('A12', {'range': 'Sheet2!A2:J2',
                                 'type': 'column'})

worksheet1.write(row, 1, text)
row += 1


###############################################################################
#
text = 'Column with style 2.'

worksheet1.add_sparkline('A13', {'range': 'Sheet2!A2:J2',
                                 'type': 'column',
                                 'style': 2})

worksheet1.write(row, 1, text)
row += 1


###############################################################################
#
text = 'Column with style 3.'

worksheet1.add_sparkline('A14', {'range': 'Sheet2!A2:J2',
                                 'type': 'column',
                                 'style': 3})

worksheet1.write(row, 1, text)
row += 1


###############################################################################
#
text = 'Column with style 4.'

worksheet1.add_sparkline('A15', {'range': 'Sheet2!A2:J2',
                                 'type': 'column',
                                 'style': 4})

worksheet1.write(row, 1, text)
row += 1


###############################################################################
#
text = 'Column with style 5.'

worksheet1.add_sparkline('A16', {'range': 'Sheet2!A2:J2',
                                 'type': 'column',
                                 'style': 5})

worksheet1.write(row, 1, text)
row += 1


###############################################################################
#
text = 'Column with style 6.'

worksheet1.add_sparkline('A17', {'range': 'Sheet2!A2:J2',
                                 'type': 'column',
                                 'style': 6})

worksheet1.write(row, 1, text)
row += 1


###############################################################################
#
text = 'Column with a user defined color.'

worksheet1.add_sparkline('A18', {'range': 'Sheet2!A2:J2',
                                 'type': 'column',
                                 'series_color': '#E965E0'})

worksheet1.write(row, 1, text)
row += 2


###############################################################################
#
text = 'A win/loss sparkline.'

worksheet1.add_sparkline('A20', {'range': 'Sheet2!A3:J3',
                                 'type': 'win_loss'})

worksheet1.write(row, 1, text)
row += 1


###############################################################################
#
text = 'A win/loss sparkline with negative points highlighted.'

worksheet1.add_sparkline('A21', {'range': 'Sheet2!A3:J3',
                                 'type': 'win_loss',
                                 'negative_points': True})

worksheet1.write(row, 1, text)
row += 2


###############################################################################
#
text = 'A left to right column (the default).'

worksheet1.add_sparkline('A23', {'range': 'Sheet2!A4:J4',
                                 'type': 'column',
                                 'style': 20})

worksheet1.write(row, 1, text)
row += 1


###############################################################################
#
text = 'A right to left column.'

worksheet1.add_sparkline('A24', {'range': 'Sheet2!A4:J4',
                                 'type': 'column',
                                 'style': 20,
                                 'reverse': True})

worksheet1.write(row, 1, text)
row += 1


###############################################################################
#
text = 'Sparkline and text in one cell.'

worksheet1.add_sparkline('A25', {'range': 'Sheet2!A4:J4',
                                 'type': 'column',
                                 'style': 20})

worksheet1.write(row, 0, 'Growth')
worksheet1.write(row, 1, text)
row += 2


###############################################################################
#
text = 'A grouped sparkline. Changes are applied to all three.'

worksheet1.add_sparkline('A27', {'location': ['A27', 'A28', 'A29'],
                                 'range': ['Sheet2!A5:J5',
                                           'Sheet2!A6:J6',
                                           'Sheet2!A7:J7'],
                                 'markers': True})

worksheet1.write(row, 1, text)
row += 1


###############################################################################
#
# Create a second worksheet with data to plot.
#
worksheet2.set_column('A:J', 11)

data = [

    # Simple line data.
    [-2, 2, 3, -1, 0, -2, 3, 2, 1, 0],

    # Simple column data.
    [30, 20, 33, 20, 15, 5, 5, 15, 10, 15],

    # Simple win/loss data.
    [1, 1, -1, -1, 1, -1, 1, 1, 1, -1],

    # Unbalanced histogram.
    [5, 6, 7, 10, 15, 20, 30, 50, 70, 100],

    # Data for the grouped sparkline example.
    [-2, 2, 3, -1, 0, -2, 3, 2, 1, 0],
    [3, -1, 0, -2, 3, 2, 1, 0, 2, 1],
    [0, -2, 3, 2, 1, 0, 1, 2, 3, 1],

]

# Write the sample data to the worksheet.
worksheet2.write_row('A1', data[0])
worksheet2.write_row('A2', data[1])
worksheet2.write_row('A3', data[2])
worksheet2.write_row('A4', data[3])
worksheet2.write_row('A5', data[4])
worksheet2.write_row('A6', data[5])
worksheet2.write_row('A7', data[6])

workbook.close()

```

---

### File: `tmp\xlsxwriter_old\XlsxWriter-1.4.5\examples\tab_colors.py`

```python
#######################################################################
#
# Example of how to set Excel worksheet tab colors using Python
# and the XlsxWriter module.
#
# Copyright 2013-2021, John McNamara, jmcnamara@cpan.org
#
import xlsxwriter

workbook = xlsxwriter.Workbook('tab_colors.xlsx')

# Set up some worksheets.
worksheet1 = workbook.add_worksheet()
worksheet2 = workbook.add_worksheet()
worksheet3 = workbook.add_worksheet()
worksheet4 = workbook.add_worksheet()

# Set tab colors
worksheet1.set_tab_color('red')
worksheet2.set_tab_color('green')
worksheet3.set_tab_color('#FF9900')  # Orange

# worksheet4 will have the default color.

workbook.close()

```

---

### File: `tmp\xlsxwriter_old\XlsxWriter-1.4.5\examples\tables.py`

```python
###############################################################################
#
# Example of how to add tables to an XlsxWriter worksheet.
#
# Tables in Excel are used to group rows and columns of data into a single
# structure that can be referenced in a formula or formatted collectively.
#
# Copyright 2013-2021, John McNamara, jmcnamara@cpan.org
#
import xlsxwriter

workbook = xlsxwriter.Workbook('tables.xlsx')
worksheet1 = workbook.add_worksheet()
worksheet2 = workbook.add_worksheet()
worksheet3 = workbook.add_worksheet()
worksheet4 = workbook.add_worksheet()
worksheet5 = workbook.add_worksheet()
worksheet6 = workbook.add_worksheet()
worksheet7 = workbook.add_worksheet()
worksheet8 = workbook.add_worksheet()
worksheet9 = workbook.add_worksheet()
worksheet10 = workbook.add_worksheet()
worksheet11 = workbook.add_worksheet()
worksheet12 = workbook.add_worksheet()
worksheet13 = workbook.add_worksheet()

currency_format = workbook.add_format({'num_format': '$#,##0'})

# Some sample data for the table.
data = [
    ['Apples', 10000, 5000, 8000, 6000],
    ['Pears', 2000, 3000, 4000, 5000],
    ['Bananas', 6000, 6000, 6500, 6000],
    ['Oranges', 500, 300, 200, 700],

]


###############################################################################
#
# Example 1.
#
caption = 'Default table with no data.'

# Set the columns widths.
worksheet1.set_column('B:G', 12)

# Write the caption.
worksheet1.write('B1', caption)

# Add a table to the worksheet.
worksheet1.add_table('B3:F7')


###############################################################################
#
# Example 2.
#
caption = 'Default table with data.'

# Set the columns widths.
worksheet2.set_column('B:G', 12)

# Write the caption.
worksheet2.write('B1', caption)

# Add a table to the worksheet.
worksheet2.add_table('B3:F7', {'data': data})


###############################################################################
#
# Example 3.
#
caption = 'Table without default autofilter.'

# Set the columns widths.
worksheet3.set_column('B:G', 12)

# Write the caption.
worksheet3.write('B1', caption)

# Add a table to the worksheet.
worksheet3.add_table('B3:F7', {'autofilter': 0})

# Table data can also be written separately, as an array or individual cells.
worksheet3.write_row('B4', data[0])
worksheet3.write_row('B5', data[1])
worksheet3.write_row('B6', data[2])
worksheet3.write_row('B7', data[3])


###############################################################################
#
# Example 4.
#
caption = 'Table without default header row.'

# Set the columns widths.
worksheet4.set_column('B:G', 12)

# Write the caption.
worksheet4.write('B1', caption)

# Add a table to the worksheet.
worksheet4.add_table('B4:F7', {'header_row': 0})

# Table data can also be written separately, as an array or individual cells.
worksheet4.write_row('B4', data[0])
worksheet4.write_row('B5', data[1])
worksheet4.write_row('B6', data[2])
worksheet4.write_row('B7', data[3])


###############################################################################
#
# Example 5.
#
caption = 'Default table with "First Column" and "Last Column" options.'

# Set the columns widths.
worksheet5.set_column('B:G', 12)

# Write the caption.
worksheet5.write('B1', caption)

# Add a table to the worksheet.
worksheet5.add_table('B3:F7', {'first_column': 1, 'last_column': 1})

# Table data can also be written separately, as an array or individual cells.
worksheet5.write_row('B4', data[0])
worksheet5.write_row('B5', data[1])
worksheet5.write_row('B6', data[2])
worksheet5.write_row('B7', data[3])


###############################################################################
#
# Example 6.
#
caption = 'Table with banded columns but without default banded rows.'

# Set the columns widths.
worksheet6.set_column('B:G', 12)

# Write the caption.
worksheet6.write('B1', caption)

# Add a table to the worksheet.
worksheet6.add_table('B3:F7', {'banded_rows': 0, 'banded_columns': 1})

# Table data can also be written separately, as an array or individual cells.
worksheet6.write_row('B4', data[0])
worksheet6.write_row('B5', data[1])
worksheet6.write_row('B6', data[2])
worksheet6.write_row('B7', data[3])


###############################################################################
#
# Example 7.
#
caption = 'Table with user defined column headers'

# Set the columns widths.
worksheet7.set_column('B:G', 12)

# Write the caption.
worksheet7.write('B1', caption)

# Add a table to the worksheet.
worksheet7.add_table('B3:F7', {'data': data,
                               'columns': [{'header': 'Product'},
                                           {'header': 'Quarter 1'},
                                           {'header': 'Quarter 2'},
                                           {'header': 'Quarter 3'},
                                           {'header': 'Quarter 4'},
                                           ]})


###############################################################################
#
# Example 8.
#
caption = 'Table with user defined column headers'

# Set the columns widths.
worksheet8.set_column('B:G', 12)

# Write the caption.
worksheet8.write('B1', caption)

# Formula to use in the table.
formula = '=SUM(Table8[@[Quarter 1]:[Quarter 4]])'

# Add a table to the worksheet.
worksheet8.add_table('B3:G7', {'data': data,
                               'columns': [{'header': 'Product'},
                                           {'header': 'Quarter 1'},
                                           {'header': 'Quarter 2'},
                                           {'header': 'Quarter 3'},
                                           {'header': 'Quarter 4'},
                                           {'header': 'Year',
                                            'formula': formula},
                                           ]})


###############################################################################
#
# Example 9.
#
caption = 'Table with totals row (but no caption or totals).'

# Set the columns widths.
worksheet9.set_column('B:G', 12)

# Write the caption.
worksheet9.write('B1', caption)

# Formula to use in the table.
formula = '=SUM(Table9[@[Quarter 1]:[Quarter 4]])'

# Add a table to the worksheet.
worksheet9.add_table('B3:G8', {'data': data,
                               'total_row': 1,
                               'columns': [{'header': 'Product'},
                                           {'header': 'Quarter 1'},
                                           {'header': 'Quarter 2'},
                                           {'header': 'Quarter 3'},
                                           {'header': 'Quarter 4'},
                                           {'header': 'Year',
                                            'formula': formula
                                            },
                                           ]})


###############################################################################
#
# Example 10.
#
caption = 'Table with totals row with user captions and functions.'

# Set the columns widths.
worksheet10.set_column('B:G', 12)

# Write the caption.
worksheet10.write('B1', caption)

# Options to use in the table.
options = {'data': data,
           'total_row': 1,
           'columns': [{'header': 'Product', 'total_string': 'Totals'},
                       {'header': 'Quarter 1', 'total_function': 'sum'},
                       {'header': 'Quarter 2', 'total_function': 'sum'},
                       {'header': 'Quarter 3', 'total_function': 'sum'},
                       {'header': 'Quarter 4', 'total_function': 'sum'},
                       {'header': 'Year',
                        'formula': '=SUM(Table10[@[Quarter 1]:[Quarter 4]])',
                        'total_function': 'sum'
                        },
                       ]}

# Add a table to the worksheet.
worksheet10.add_table('B3:G8', options)


###############################################################################
#
# Example 11.
#
caption = 'Table with alternative Excel style.'

# Set the columns widths.
worksheet11.set_column('B:G', 12)

# Write the caption.
worksheet11.write('B1', caption)

# Options to use in the table.
options = {'data': data,
           'style': 'Table Style Light 11',
           'total_row': 1,
           'columns': [{'header': 'Product', 'total_string': 'Totals'},
                       {'header': 'Quarter 1', 'total_function': 'sum'},
                       {'header': 'Quarter 2', 'total_function': 'sum'},
                       {'header': 'Quarter 3', 'total_function': 'sum'},
                       {'header': 'Quarter 4', 'total_function': 'sum'},
                       {'header': 'Year',
                        'formula': '=SUM(Table11[@[Quarter 1]:[Quarter 4]])',
                        'total_function': 'sum'
                        },
                       ]}


# Add a table to the worksheet.
worksheet11.add_table('B3:G8', options)


###############################################################################
#
# Example 12.
#
caption = 'Table with Excel style removed.'

# Set the columns widths.
worksheet12.set_column('B:G', 12)

# Write the caption.
worksheet12.write('B1', caption)

# Options to use in the table.
options = {'data': data,
           'style': None,
           'total_row': 1,
           'columns': [{'header': 'Product', 'total_string': 'Totals'},
                       {'header': 'Quarter 1', 'total_function': 'sum'},
                       {'header': 'Quarter 2', 'total_function': 'sum'},
                       {'header': 'Quarter 3', 'total_function': 'sum'},
                       {'header': 'Quarter 4', 'total_function': 'sum'},
                       {'header': 'Year',
                        'formula': '=SUM(Table12[@[Quarter 1]:[Quarter 4]])',
                        'total_function': 'sum'
                        },
                       ]}


# Add a table to the worksheet.
worksheet12.add_table('B3:G8', options)


###############################################################################
#
# Example 13.
#
caption = 'Table with column formats.'

# Set the columns widths.
worksheet13.set_column('B:G', 12)

# Write the caption.
worksheet13.write('B1', caption)

# Options to use in the table.
options = {'data': data,
           'total_row': 1,
           'columns': [{'header': 'Product', 'total_string': 'Totals'},
                       {'header': 'Quarter 1',
                        'total_function': 'sum',
                        'format': currency_format,
                        },
                       {'header': 'Quarter 2',
                        'total_function': 'sum',
                        'format': currency_format,
                        },
                       {'header': 'Quarter 3',
                        'total_function': 'sum',
                        'format': currency_format,
                        },
                       {'header': 'Quarter 4',
                        'total_function': 'sum',
                        'format': currency_format,
                        },
                       {'header': 'Year',
                        'formula': '=SUM(Table13[@[Quarter 1]:[Quarter 4]])',
                        'total_function': 'sum',
                        'format': currency_format,
                        },
                       ]}

# Add a table to the worksheet.
worksheet13.add_table('B3:G8', options)

workbook.close()

```

---

### File: `tmp\xlsxwriter_old\XlsxWriter-1.4.5\examples\text_indent.py`

```python
##############################################################################
#
# A simple formatting example using XlsxWriter.
#
# This program demonstrates the indentation cell format.
#
# Copyright 2013-2021, John McNamara, jmcnamara@cpan.org
#
import xlsxwriter

workbook = xlsxwriter.Workbook('text_indent.xlsx')

worksheet = workbook.add_worksheet()
indent1 = workbook.add_format({'indent': 1})
indent2 = workbook.add_format({'indent': 2})

worksheet.set_column('A:A', 40)

worksheet.write('A1', "This text is indented 1 level", indent1)
worksheet.write('A2', "This text is indented 2 levels", indent2)

workbook.close()

```

---

### File: `tmp\xlsxwriter_old\XlsxWriter-1.4.5\examples\textbox.py`

```python
#######################################################################
#
# An example of inserting textboxes into an Excel worksheet using
# Python and XlsxWriter.
#
# Copyright 2013-2021, John McNamara, jmcnamara@cpan.org
#
import xlsxwriter

workbook = xlsxwriter.Workbook('textbox.xlsx')
worksheet = workbook.add_worksheet()
row = 4
col = 1

# The examples below show different textbox options and formatting. In each
# example the text describes the formatting.


# Example
text = 'A simple textbox with some text'
worksheet.insert_textbox(row, col, text)
row += 10

# Example
text = 'A textbox with changed dimensions'
options = {
    'width': 256,
    'height': 100,
}
worksheet.insert_textbox(row, col, text, options)
row += 10

# Example
text = 'A textbox with an offset in the cell'
options = {
    'x_offset': 10,
    'y_offset': 10,
}
worksheet.insert_textbox(row, col, text, options)
row += 10

# Example
text = 'A textbox with scaling'
options = {
    'x_scale': 1.5,
    'y_scale': 0.8,
}
worksheet.insert_textbox(row, col, text, options)
row += 10

# Example
text = 'A textbox with some long text that wraps around onto several lines'
worksheet.insert_textbox(row, col, text)
row += 10

# Example
text = 'A textbox\nwith some\nnewlines\n\nand paragraphs'
worksheet.insert_textbox(row, col, text)
row += 10

# Example
text = 'A textbox with a solid fill background'
options = {
    'fill': {'color': 'red'},
}
worksheet.insert_textbox(row, col, text, options)
row += 10

# Example
text = 'A textbox with a no fill background'
options = {
    'fill': {'none': True},
}
worksheet.insert_textbox(row, col, text, options)
row += 10

# Example
text = 'A textbox with a gradient fill background'
options = {
    'gradient': {'colors': ['#DDEBCF',
                            '#9CB86E',
                            '#156B13']},
}
worksheet.insert_textbox(row, col, text, options)
row += 10

# Example
text = 'A textbox with a user defined border line'
options = {
    'border': {'color': 'red',
               'width': 3,
               'dash_type': 'round_dot'},
}
worksheet.insert_textbox(row, col, text, options)
row += 10

# Example
text = 'A textbox with no border line'
options = {
    'border': {'none': True},
}
worksheet.insert_textbox(row, col, text, options)
row += 10

# Example
text = 'Default alignment: top - left'
worksheet.insert_textbox(row, col, text)
row += 10

# Example
text = 'Alignment: top - center'
options = {
    'align': {'horizontal': 'center'},
}
worksheet.insert_textbox(row, col, text, options)
row += 10

# Example
text = 'Alignment: middle - center'
options = {
    'align': {'vertical': 'middle',
               'horizontal': 'center'},
}
worksheet.insert_textbox(row, col, text, options)
row += 10

# Example
text = 'Alignment: long text line that wraps and is centered'
options = {
    'align': {'vertical': 'middle',
               'horizontal': 'center',
               'text': 'center'},
}
worksheet.insert_textbox(row, col, text, options)
row += 10

# Example
text = 'Font properties: bold'
options = {
    'font': {'bold': True},
}
worksheet.insert_textbox(row, col, text, options)
row += 10

# Example
text = 'Font properties: various'
options = {
    'font': {'bold': True},
}
worksheet.insert_textbox(row, col, text, options)
row += 10

# Example
text = 'Font properties: various'
options = {
    'font': {'bold': True,
             'italic': True,
             'underline': True,
             'name': 'Arial',
             'color': 'red',
             'size': 12}
}
worksheet.insert_textbox(row, col, text, options)
row += 10

# Example
text = 'Some text in a textbox with formatting'
options = {
    'font': {'color': 'white'},
    'align': {'vertical': 'middle',
              'horizontal': 'center'
              },
    'gradient': {'colors': ['red', 'blue']},
}
worksheet.insert_textbox(row, col, text, options)
row += 10

# Example
text = ''
options = {
    'textlink': '=$F$185',
}
worksheet.write('F185', 'Text in a cell')
worksheet.insert_textbox(row, col, text, options)
row += 10

# Example
text = 'Text rotated up'
options = {
    'text_rotation': 90
}
worksheet.insert_textbox(row, col, text, options)
row += 10

# Example
text = 'Text rotated down'
options = {
    'text_rotation': -90
}
worksheet.insert_textbox(row, col, text, options)
row += 10

# Example
text = 'Text rotated vertically'
options = {
    'text_rotation': 270
}
worksheet.insert_textbox(row, col, text, options)
row += 10

# Example
text = 'Textbox with hyperlink'
options = {
    'url': 'https://github.com/jmcnamara',
    'tip': 'GitHub'
}
worksheet.insert_textbox(row, col, text, options)
row += 10

workbook.close()

```

---

### File: `tmp\xlsxwriter_old\XlsxWriter-1.4.5\examples\tutorial1.py`

```python
##############################################################################
#
# A simple program to write some data to an Excel file using the XlsxWriter
# Python module.
#
# This program is shown, with explanations, in Tutorial 1 of the XlsxWriter
# documentation.
#
# Copyright 2013-2021, John McNamara, jmcnamara@cpan.org
#
import xlsxwriter

# Create a workbook and add a worksheet.
workbook = xlsxwriter.Workbook('Expenses01.xlsx')
worksheet = workbook.add_worksheet()

# Some data we want to write to the worksheet.
expenses = (
    ['Rent', 1000],
    ['Gas', 100],
    ['Food', 300],
    ['Gym', 50],
)

# Start from the first cell. Rows and columns are zero indexed.
row = 0
col = 0

# Iterate over the data and write it out row by row.
for item, cost in (expenses):
    worksheet.write(row, col, item)
    worksheet.write(row, col + 1, cost)
    row += 1

# Write a total using a formula.
worksheet.write(row, 0, 'Total')
worksheet.write(row, 1, '=SUM(B1:B4)')

workbook.close()

```

---

### File: `tmp\xlsxwriter_old\XlsxWriter-1.4.5\examples\tutorial2.py`

```python
##############################################################################
#
# A simple program to write some data to an Excel file using the XlsxWriter
# Python module.
#
# This program is shown, with explanations, in Tutorial 2 of the XlsxWriter
# documentation.
#
# Copyright 2013-2021, John McNamara, jmcnamara@cpan.org
#
import xlsxwriter

# Create a workbook and add a worksheet.
workbook = xlsxwriter.Workbook('Expenses02.xlsx')
worksheet = workbook.add_worksheet()

# Add a bold format to use to highlight cells.
bold = workbook.add_format({'bold': True})

# Add a number format for cells with money.
money = workbook.add_format({'num_format': '$#,##0'})

# Write some data header.
worksheet.write('A1', 'Item', bold)
worksheet.write('B1', 'Cost', bold)

# Some data we want to write to the worksheet.
expenses = (
    ['Rent', 1000],
    ['Gas', 100],
    ['Food', 300],
    ['Gym', 50],
)

# Start from the first cell below the headers.
row = 1
col = 0

# Iterate over the data and write it out row by row.
for item, cost in (expenses):
    worksheet.write(row, col, item)
    worksheet.write(row, col + 1, cost, money)
    row += 1

# Write a total using a formula.
worksheet.write(row, 0, 'Total', bold)
worksheet.write(row, 1, '=SUM(B2:B5)', money)

workbook.close()

```

---

### File: `tmp\xlsxwriter_old\XlsxWriter-1.4.5\examples\tutorial3.py`

```python
##############################################################################
#
# A simple program to write some data to an Excel file using the XlsxWriter
# Python module.
#
# This program is shown, with explanations, in Tutorial 3 of the XlsxWriter
# documentation.
#
# Copyright 2013-2021, John McNamara, jmcnamara@cpan.org
#
from datetime import datetime
import xlsxwriter

# Create a workbook and add a worksheet.
workbook = xlsxwriter.Workbook('Expenses03.xlsx')
worksheet = workbook.add_worksheet()

# Add a bold format to use to highlight cells.
bold = workbook.add_format({'bold': 1})

# Add a number format for cells with money.
money_format = workbook.add_format({'num_format': '$#,##0'})

# Add an Excel date format.
date_format = workbook.add_format({'num_format': 'mmmm d yyyy'})

# Adjust the column width.
worksheet.set_column(1, 1, 15)

# Write some data headers.
worksheet.write('A1', 'Item', bold)
worksheet.write('B1', 'Date', bold)
worksheet.write('C1', 'Cost', bold)

# Some data we want to write to the worksheet.
expenses = (
    ['Rent', '2013-01-13', 1000],
    ['Gas', '2013-01-14', 100],
    ['Food', '2013-01-16', 300],
    ['Gym', '2013-01-20', 50],
)

# Start from the first cell below the headers.
row = 1
col = 0

for item, date_str, cost in (expenses):
    # Convert the date string into a datetime object.
    date = datetime.strptime(date_str, "%Y-%m-%d")

    worksheet.write_string(row, col, item)
    worksheet.write_datetime(row, col + 1, date, date_format)
    worksheet.write_number(row, col + 2, cost, money_format)
    row += 1

# Write a total using a formula.
worksheet.write(row, 0, 'Total', bold)
worksheet.write(row, 2, '=SUM(C2:C5)', money_format)

workbook.close()

```

---

### File: `tmp\xlsxwriter_old\XlsxWriter-1.4.5\examples\unicode_polish_utf8.py`

```python
##############################################################################
#
# A simple example of converting some Unicode text to an Excel file using
# the XlsxWriter Python module.
#
# This example generates a spreadsheet with some Polish text from a file
# with UTF8 encoded text.
#
# Copyright 2013-2021, John McNamara, jmcnamara@cpan.org
#
import codecs
import xlsxwriter

# Open the input file with the correct encoding.
textfile = codecs.open('unicode_polish_utf8.txt', 'r', 'utf-8')

# Create an new Excel file and convert the text data.
workbook = xlsxwriter.Workbook('unicode_polish_utf8.xlsx')
worksheet = workbook.add_worksheet()

# Widen the first column to make the text clearer.
worksheet.set_column('A:A', 50)

# Start from the first cell.
row = 0
col = 0

# Read the text file and write it to the worksheet.
for line in textfile:
    # Ignore the comments in the text file.
    if line.startswith('#'):
        continue

    # Write any other lines to the worksheet.
    worksheet.write(row, col, line.rstrip("\n"))
    row += 1

workbook.close()

```

---

### File: `tmp\xlsxwriter_old\XlsxWriter-1.4.5\examples\unicode_python2.py`

```python
###############################################################################
# _*_ coding: utf-8
#
# A simple Unicode spreadsheet in Python 2 using the XlsxWriter Python module.
#
# Copyright 2013-2021, John McNamara, jmcnamara@cpan.org
#

# To write Unicode text in UTF-8 to a xlsxwriter file in Python 2:
#
# 1. Encode the file as UTF-8.
# 2. Include the "coding" directive at the start of the file.
# 3. Use u'' to indicate a Unicode string.

import xlsxwriter

workbook = xlsxwriter.Workbook('unicode_python2.xlsx')
worksheet = workbook.add_worksheet()

worksheet.write('B3', u'   !')

workbook.close()

```

---

### File: `tmp\xlsxwriter_old\XlsxWriter-1.4.5\examples\unicode_python3.py`

```python
###############################################################################
#
#
# A simple Unicode spreadsheet in Python 3 using the XlsxWriter Python module.
#
# Copyright 2013-2021, John McNamara, jmcnamara@cpan.org
#

# To write Unicode text in UTF-8 to a xlsxwriter file in Python 3:
#
# 1. Encode the file as UTF-8.
#
#

import xlsxwriter

workbook = xlsxwriter.Workbook('unicode_python3.xlsx')
worksheet = workbook.add_worksheet()

worksheet.write('B3', '   !')

workbook.close()

```

---

### File: `tmp\xlsxwriter_old\XlsxWriter-1.4.5\examples\unicode_shift_jis.py`

```python
##############################################################################
#
# A simple example of converting some Unicode text to an Excel file using
# the XlsxWriter Python module.
#
# This example generates a spreadsheet with some Japanese text from a file
# with Shift-JIS encoded text.
#
# Copyright 2013-2021, John McNamara, jmcnamara@cpan.org
#
import codecs
import xlsxwriter

# Open the input file with the correct encoding.
textfile = codecs.open('unicode_shift_jis.txt', 'r', 'shift_jis')

# Create an new Excel file and convert the text data.
workbook = xlsxwriter.Workbook('unicode_shift_jis.xlsx')
worksheet = workbook.add_worksheet()

# Widen the first column to make the text clearer.
worksheet.set_column('A:A', 50)

# Start from the first cell.
row = 0
col = 0

# Read the text file and write it to the worksheet.
for line in textfile:
    # Ignore the comments in the text file.
    if line.startswith('#'):
        continue

    # Write any other lines to the worksheet.
    worksheet.write(row, col, line.rstrip("\n"))
    row += 1

workbook.close()

```

---

### File: `tmp\xlsxwriter_old\XlsxWriter-1.4.5\examples\user_types1.py`

```python
##############################################################################
#
# An example of adding support for user defined types to the XlsxWriter write()
# method.
#
# Copyright 2013-2021, John McNamara, jmcnamara@cpan.org
#
import xlsxwriter
import uuid

# Create a function that will behave like a worksheet write() method.
#
# This function takes a UUID and writes it as as string. It should take the
# parameters shown below and return the return value from the called worksheet
# write_*() method. In this case it changes the UUID to a string and calls
# write_string() to write it.
#
def write_uuid(worksheet, row, col, token, format=None):
    return worksheet.write_string(row, col, str(token), format)

# Set up the workbook as usual.
workbook = xlsxwriter.Workbook('user_types1.xlsx')
worksheet = workbook.add_worksheet()

# Make the first column wider for clarity.
worksheet.set_column('A:A', 40)

# Add the write() handler/callback to the worksheet.
worksheet.add_write_handler(uuid.UUID, write_uuid)

# Create a UUID.
my_uuid = uuid.uuid3(uuid.NAMESPACE_DNS, 'python.org')

# Write the UUID. This would raise a TypeError without the handler.
worksheet.write('A1', my_uuid)

workbook.close()

```

---

### File: `tmp\xlsxwriter_old\XlsxWriter-1.4.5\examples\user_types2.py`

```python
##############################################################################
#
# An example of adding support for user defined types to the XlsxWriter write()
# method.
#
# Copyright 2013-2021, John McNamara, jmcnamara@cpan.org
#
import xlsxwriter
import math

# Create a function that will behave like a worksheet write() method.
#
# This function takes a float and if it is NaN then it writes a blank cell
# instead. It should take the parameters shown below and return the return
# value from the called worksheet write_*() method.
#
def ignore_nan(worksheet, row, col, number, format=None):
    if math.isnan(number):
        return worksheet.write_blank(row, col, None, format)
    else:
        # Return control to the calling write() method for any other number.
        return None

# Set up the workbook as usual.
workbook = xlsxwriter.Workbook('user_types2.xlsx')
worksheet = workbook.add_worksheet()


# Add the write() handler/callback to the worksheet.
worksheet.add_write_handler(float, ignore_nan)

# Create some data to write.
my_data = [1, 2, float('nan'), 4, 5]

# Write the data. Note that write_row() calls write() so this will work as
# expected. Writing NaN values would raise a TypeError without the handler.
worksheet.write_row('A1', my_data)

workbook.close()

```

---

### File: `tmp\xlsxwriter_old\XlsxWriter-1.4.5\examples\user_types3.py`

```python
##############################################################################
#
# An example of adding support for user defined types to the XlsxWriter write()
# method.
#
# Copyright 2013-2021, John McNamara, jmcnamara@cpan.org
#
import xlsxwriter
import math

# Create a function that changes the worksheet write() method so that it
# hides/replaces user passwords when writing string data. The password data,
# based on the sample data structure, will be data in the second column, apart
# from the header row.
def hide_password(worksheet, row, col, string, format=None):
    if col == 1 and row > 0:
        return worksheet.write_string(row, col, '****', format)
    else:
        return worksheet.write_string(row, col, string, format)

# Set up the workbook as usual.
workbook = xlsxwriter.Workbook('user_types3.xlsx')
worksheet = workbook.add_worksheet()

# Make the headings in the first row bold.
bold = workbook.add_format({'bold': True})
worksheet.set_row(0, None, bold)

# Add the write() handler/callback to the worksheet. In Python 2 the type
# would be better as 'basestring' if we also wanted to match the 'unicode'
# type.
worksheet.add_write_handler(str, hide_password)

# Create some data to write.
my_data = [
    ['Name',    'Password',  'City'],
    ['Sara',    '$5%^6&',    'Rome'],
    ['Michele', '123abc',    'Milano'],
    ['Maria',   'juvexme',   'Torino'],
    ['Paolo',   'qwerty',    'Fano']
]

# Write the data. Note that write_row() calls write() so this will work as
# expected.
for row_num, row_data in enumerate(my_data):
    worksheet.write_row(row_num, 0, row_data)

workbook.close()

```

---

### File: `tmp\xlsxwriter_old\XlsxWriter-1.4.5\examples\vba_extract.py`

```python
#!python

##############################################################################
#
# vba_extract - A simple utility to extract a vbaProject.bin binary from an
# Excel 2007+ xlsm file for insertion into an XlsxWriter file.
#
# Copyright 2013-2021, John McNamara, jmcnamara@cpan.org
#
import sys
from zipfile import ZipFile
from zipfile import BadZipfile

# The VBA project file we want to extract.
vba_filename = 'vbaProject.bin'

# Get the xlsm file name from the commandline.
if len(sys.argv) > 1:
    xlsm_file = sys.argv[1]
else:
    print("\nUtility to extract a vbaProject.bin binary from an Excel 2007+ "
          "xlsm macro file for insertion into an XlsxWriter file."
          "\n"
          "See: https://xlsxwriter.readthedocs.io/working_with_macros.html\n"
          "\n"
          "Usage: vba_extract file.xlsm\n")
    exit()

try:
    # Open the Excel xlsm file as a zip file.
    xlsm_zip = ZipFile(xlsm_file, 'r')

    # Read the xl/vbaProject.bin file.
    vba_data = xlsm_zip.read('xl/' + vba_filename)

    # Write the vba data to a local file.
    vba_file = open(vba_filename, "wb")
    vba_file.write(vba_data)
    vba_file.close()

except IOError as e:
    print("File error: %s" % str(e))
    exit()

except KeyError as e:
    # Usually when there isn't a xl/vbaProject.bin member in the file.
    print("File error: %s" % str(e))
    print("File may not be an Excel xlsm macro file: '%s'" % xlsm_file)
    exit()

except BadZipfile as e:
    # Usually if the file is an xls file and not an xlsm file.
    print("File error: %s: '%s'" % (str(e), xlsm_file))
    print("File may not be an Excel xlsm macro file.")
    exit()

except Exception as e:
    # Catch any other exceptions.
    print("File error: %s" % str(e))
    exit()

print("Extracted: %s" % vba_filename)

```

---

### File: `tmp\xlsxwriter_old\XlsxWriter-1.4.5\examples\worksheet_protection.py`

```python
########################################################################
#
# Example of cell locking and formula hiding in an Excel worksheet
# using Python and the XlsxWriter module.
#
# Copyright 2013-2021, John McNamara, jmcnamara@cpan.org
#
import xlsxwriter

workbook = xlsxwriter.Workbook('protection.xlsx')
worksheet = workbook.add_worksheet()

# Create some cell formats with protection properties.
unlocked = workbook.add_format({'locked': False})
hidden = workbook.add_format({'hidden': True})

# Format the columns to make the text more visible.
worksheet.set_column('A:A', 40)

# Turn worksheet protection on.
worksheet.protect()

# Write a locked, unlocked and hidden cell.
worksheet.write('A1', 'Cell B1 is locked. It cannot be edited.')
worksheet.write('A2', 'Cell B2 is unlocked. It can be edited.')
worksheet.write('A3', "Cell B3 is hidden. The formula isn't visible.")

worksheet.write_formula('B1', '=1+2')  # Locked by default.
worksheet.write_formula('B2', '=1+2', unlocked)
worksheet.write_formula('B3', '=1+2', hidden)

workbook.close()

```

---

### File: `tmp\xlsxwriter_old\XlsxWriter-1.4.5\setup.py`

```python
import sys
import subprocess
from warnings import warn

try:
    from setuptools import setup, Command
except ImportError:
    from distutils.core import setup, Command

if sys.version_info < (2, 7, 0):
    warn("The minimum Python version supported by XlsxWriter is 2.7.")
    exit()


class PyTest(Command):

    user_options = []

    def initialize_options(self):
        pass

    def finalize_options(self):
        pass

    def run(self):
        errno = subprocess.call(['python',  '-m', 'unittest', 'discover'])
        raise SystemExit(errno)

setup(
    name='XlsxWriter',
    version='1.4.5',
    author='John McNamara',
    author_email='jmcnamara@cpan.org',
    url='https://github.com/jmcnamara/XlsxWriter',
    packages=['xlsxwriter'],
    scripts=['examples/vba_extract.py'],
    cmdclass={'test': PyTest},
    license='BSD',
    description='A Python module for creating Excel XLSX files.',
    long_description=open('README.rst').read(),
    classifiers=[
        'Development Status :: 5 - Production/Stable',
        'License :: OSI Approved :: BSD License',
        'Programming Language :: Python',
        'Programming Language :: Python :: 2',
        'Programming Language :: Python :: 2.7',
        'Programming Language :: Python :: 3',
        'Programming Language :: Python :: 3.4',
        'Programming Language :: Python :: 3.5',
        'Programming Language :: Python :: 3.6',
        'Programming Language :: Python :: 3.7',
        'Programming Language :: Python :: 3.8',
        'Programming Language :: Python :: 3.9',
    ],
)

```

---

### File: `tmp\xlsxwriter_old\XlsxWriter-1.4.5\xlsxwriter\__init__.py`

```python
__version__ = '1.4.5'
__VERSION__ = __version__
from .workbook import Workbook

```

---

### File: `tmp\xlsxwriter_old\XlsxWriter-1.4.5\xlsxwriter\app.py`

```python
###############################################################################
#
# App - A class for writing the Excel XLSX App file.
#
# Copyright 2013-2021, John McNamara, jmcnamara@cpan.org
#

# Package imports.
from . import xmlwriter


class App(xmlwriter.XMLwriter):
    """
    A class for writing the Excel XLSX App file.


    """

    ###########################################################################
    #
    # Public API.
    #
    ###########################################################################

    def __init__(self):
        """
        Constructor.

        """

        super(App, self).__init__()

        self.part_names = []
        self.heading_pairs = []
        self.properties = {}
        self.doc_security = 0

    def _add_part_name(self, part_name):
        # Add the name of a workbook Part such as 'Sheet1' or 'Print_Titles'.
        self.part_names.append(part_name)

    def _add_heading_pair(self, heading_pair):
        # Add the name of a workbook Heading Pair such as 'Worksheets',
        # 'Charts' or 'Named Ranges'.

        # Ignore empty pairs such as chartsheets.
        if not heading_pair[1]:
            return

        self.heading_pairs.append(('lpstr', heading_pair[0]))
        self.heading_pairs.append(('i4', heading_pair[1]))

    def _set_properties(self, properties):
        # Set the document properties.
        self.properties = properties

    ###########################################################################
    #
    # Private API.
    #
    ###########################################################################

    def _assemble_xml_file(self):
        # Assemble and write the XML file.

        # Write the XML declaration.
        self._xml_declaration()

        self._write_properties()
        self._write_application()
        self._write_doc_security()
        self._write_scale_crop()
        self._write_heading_pairs()
        self._write_titles_of_parts()
        self._write_manager()
        self._write_company()
        self._write_links_up_to_date()
        self._write_shared_doc()
        self._write_hyperlink_base()
        self._write_hyperlinks_changed()
        self._write_app_version()

        self._xml_end_tag('Properties')

        # Close the file.
        self._xml_close()

    ###########################################################################
    #
    # XML methods.
    #
    ###########################################################################

    def _write_properties(self):
        # Write the <Properties> element.
        schema = 'http://schemas.openxmlformats.org/officeDocument/2006/'
        xmlns = schema + 'extended-properties'
        xmlns_vt = schema + 'docPropsVTypes'

        attributes = [
            ('xmlns', xmlns),
            ('xmlns:vt', xmlns_vt),
        ]

        self._xml_start_tag('Properties', attributes)

    def _write_application(self):
        # Write the <Application> element.
        self._xml_data_element('Application', 'Microsoft Excel')

    def _write_doc_security(self):
        # Write the <DocSecurity> element.
        self._xml_data_element('DocSecurity', self.doc_security)

    def _write_scale_crop(self):
        # Write the <ScaleCrop> element.
        self._xml_data_element('ScaleCrop', 'false')

    def _write_heading_pairs(self):
        # Write the <HeadingPairs> element.
        self._xml_start_tag('HeadingPairs')
        self._write_vt_vector('variant', self.heading_pairs)
        self._xml_end_tag('HeadingPairs')

    def _write_titles_of_parts(self):
        # Write the <TitlesOfParts> element.
        parts_data = []

        self._xml_start_tag('TitlesOfParts')

        for part_name in self.part_names:
            parts_data.append(('lpstr', part_name))

        self._write_vt_vector('lpstr', parts_data)

        self._xml_end_tag('TitlesOfParts')

    def _write_vt_vector(self, base_type, vector_data):
        # Write the <vt:vector> element.
        attributes = [
            ('size', len(vector_data)),
            ('baseType', base_type),
        ]

        self._xml_start_tag('vt:vector', attributes)

        for vt_data in vector_data:
            if base_type == 'variant':
                self._xml_start_tag('vt:variant')

            self._write_vt_data(vt_data)

            if base_type == 'variant':
                self._xml_end_tag('vt:variant')

        self._xml_end_tag('vt:vector')

    def _write_vt_data(self, vt_data):
        # Write the <vt:*> elements such as <vt:lpstr> and <vt:if>.
        self._xml_data_element("vt:%s" % vt_data[0], vt_data[1])

    def _write_company(self):
        company = self.properties.get('company', '')

        self._xml_data_element('Company', company)

    def _write_manager(self):
        # Write the <Manager> element.
        if 'manager' not in self.properties:
            return

        self._xml_data_element('Manager', self.properties['manager'])

    def _write_links_up_to_date(self):
        # Write the <LinksUpToDate> element.
        self._xml_data_element('LinksUpToDate', 'false')

    def _write_shared_doc(self):
        # Write the <SharedDoc> element.
        self._xml_data_element('SharedDoc', 'false')

    def _write_hyperlink_base(self):
        # Write the <HyperlinkBase> element.
        hyperlink_base = self.properties.get('hyperlink_base')

        if hyperlink_base is None:
            return

        self._xml_data_element('HyperlinkBase', hyperlink_base)

    def _write_hyperlinks_changed(self):
        # Write the <HyperlinksChanged> element.
        self._xml_data_element('HyperlinksChanged', 'false')

    def _write_app_version(self):
        # Write the <AppVersion> element.
        self._xml_data_element('AppVersion', '12.0000')

```

---

### File: `tmp\xlsxwriter_old\XlsxWriter-1.4.5\xlsxwriter\chart.py`

```python
###############################################################################
#
# Chart - A class for writing the Excel XLSX Worksheet file.
#
# Copyright 2013-2021, John McNamara, jmcnamara@cpan.org
#
import re
import copy
from warnings import warn

from .shape import Shape
from . import xmlwriter
from .utility import get_rgb_color
from .utility import xl_rowcol_to_cell
from .utility import xl_range_formula
from .utility import supported_datetime
from .utility import datetime_to_excel_datetime
from .utility import quote_sheetname


class Chart(xmlwriter.XMLwriter):
    """
    A class for writing the Excel XLSX Chart file.


    """

    ###########################################################################
    #
    # Public API.
    #
    ###########################################################################

    def __init__(self, options=None):
        """
        Constructor.

        """

        super(Chart, self).__init__()

        self.subtype = None
        self.sheet_type = 0x0200
        self.orientation = 0x0
        self.series = []
        self.embedded = 0
        self.id = -1
        self.series_index = 0
        self.style_id = 2
        self.axis_ids = []
        self.axis2_ids = []
        self.cat_has_num_fmt = 0
        self.requires_category = False
        self.legend = {}
        self.cat_axis_position = 'b'
        self.val_axis_position = 'l'
        self.formula_ids = {}
        self.formula_data = []
        self.horiz_cat_axis = 0
        self.horiz_val_axis = 1
        self.protection = 0
        self.chartarea = {}
        self.plotarea = {}
        self.x_axis = {}
        self.y_axis = {}
        self.y2_axis = {}
        self.x2_axis = {}
        self.chart_name = ''
        self.show_blanks = 'gap'
        self.show_hidden = 0
        self.show_crosses = 1
        self.width = 480
        self.height = 288
        self.x_scale = 1
        self.y_scale = 1
        self.x_offset = 0
        self.y_offset = 0
        self.table = None
        self.cross_between = 'between'
        self.default_marker = None
        self.series_gap_1 = None
        self.series_gap_2 = None
        self.series_overlap_1 = None
        self.series_overlap_2 = None
        self.drop_lines = None
        self.hi_low_lines = None
        self.up_down_bars = None
        self.smooth_allowed = False
        self.title_font = None
        self.title_name = None
        self.title_formula = None
        self.title_data_id = None
        self.title_layout = None
        self.title_overlay = None
        self.title_none = False
        self.date_category = False
        self.date_1904 = False
        self.remove_timezone = False
        self.label_positions = {}
        self.label_position_default = ''
        self.already_inserted = False
        self.combined = None
        self.is_secondary = False
        self.warn_sheetname = True
        self._set_default_properties()

    def add_series(self, options=None):
        """
        Add a data series to a chart.

        Args:
            options:  A dictionary of chart series options.

        Returns:
            Nothing.

        """
        # Add a series and it's properties to a chart.
        if options is None:
            options = {}

        # Check that the required input has been specified.
        if 'values' not in options:
            warn("Must specify 'values' in add_series()")
            return

        if self.requires_category and 'categories' not in options:
            warn("Must specify 'categories' in add_series() "
                 "for this chart type")
            return

        if len(self.series) == 255:
            warn("The maximum number of series that can be added to an "
                 "Excel Chart is 255")
            return

        # Convert list into a formula string.
        values = self._list_to_formula(options.get('values'))
        categories = self._list_to_formula(options.get('categories'))

        # Switch name and name_formula parameters if required.
        name, name_formula = self._process_names(options.get('name'),
                                                 options.get('name_formula'))

        # Get an id for the data equivalent to the range formula.
        cat_id = self._get_data_id(categories, options.get('categories_data'))
        val_id = self._get_data_id(values, options.get('values_data'))
        name_id = self._get_data_id(name_formula, options.get('name_data'))

        # Set the line properties for the series.
        line = Shape._get_line_properties(options.get('line'))

        # Allow 'border' as a synonym for 'line' in bar/column style charts.
        if options.get('border'):
            line = Shape._get_line_properties(options['border'])

        # Set the fill properties for the series.
        fill = Shape._get_fill_properties(options.get('fill'))

        # Set the pattern fill properties for the series.
        pattern = Shape._get_pattern_properties(options.get('pattern'))

        # Set the gradient fill properties for the series.
        gradient = Shape._get_gradient_properties(options.get('gradient'))

        # Pattern fill overrides solid fill.
        if pattern:
            self.fill = None

        # Gradient fill overrides the solid and pattern fill.
        if gradient:
            pattern = None
            fill = None

        # Set the marker properties for the series.
        marker = self._get_marker_properties(options.get('marker'))

        # Set the trendline properties for the series.
        trendline = self._get_trendline_properties(options.get('trendline'))

        # Set the line smooth property for the series.
        smooth = options.get('smooth')

        # Set the error bars properties for the series.
        y_error_bars = self._get_error_bars_props(options.get('y_error_bars'))
        x_error_bars = self._get_error_bars_props(options.get('x_error_bars'))

        error_bars = {'x_error_bars': x_error_bars,
                      'y_error_bars': y_error_bars}

        # Set the point properties for the series.
        points = self._get_points_properties(options.get('points'))

        # Set the labels properties for the series.
        labels = self._get_labels_properties(options.get('data_labels'))

        # Set the "invert if negative" fill property.
        invert_if_neg = options.get('invert_if_negative', False)

        # Set the secondary axis properties.
        x2_axis = options.get('x2_axis')
        y2_axis = options.get('y2_axis')

        # Store secondary status for combined charts.
        if x2_axis or y2_axis:
            self.is_secondary = True

        # Set the gap for Bar/Column charts.
        if options.get('gap') is not None:
            if y2_axis:
                self.series_gap_2 = options['gap']
            else:
                self.series_gap_1 = options['gap']

        # Set the overlap for Bar/Column charts.
        if options.get('overlap'):
            if y2_axis:
                self.series_overlap_2 = options['overlap']
            else:
                self.series_overlap_1 = options['overlap']

        # Add the user supplied data to the internal structures.
        series = {
            'values': values,
            'categories': categories,
            'name': name,
            'name_formula': name_formula,
            'name_id': name_id,
            'val_data_id': val_id,
            'cat_data_id': cat_id,
            'line': line,
            'fill': fill,
            'pattern': pattern,
            'gradient': gradient,
            'marker': marker,
            'trendline': trendline,
            'labels': labels,
            'invert_if_neg': invert_if_neg,
            'x2_axis': x2_axis,
            'y2_axis': y2_axis,
            'points': points,
            'error_bars': error_bars,
            'smooth': smooth
        }

        self.series.append(series)

    def set_x_axis(self, options):
        """
        Set the chart X axis options.

        Args:
            options:  A dictionary of axis options.

        Returns:
            Nothing.

        """
        axis = self._convert_axis_args(self.x_axis, options)

        self.x_axis = axis

    def set_y_axis(self, options):
        """
        Set the chart Y axis options.

        Args:
            options: A dictionary of axis options.

        Returns:
            Nothing.

        """
        axis = self._convert_axis_args(self.y_axis, options)

        self.y_axis = axis

    def set_x2_axis(self, options):
        """
        Set the chart secondary X axis options.

        Args:
            options: A dictionary of axis options.

        Returns:
            Nothing.

        """
        axis = self._convert_axis_args(self.x2_axis, options)

        self.x2_axis = axis

    def set_y2_axis(self, options):
        """
        Set the chart secondary Y axis options.

        Args:
            options: A dictionary of axis options.

        Returns:
            Nothing.

        """
        axis = self._convert_axis_args(self.y2_axis, options)

        self.y2_axis = axis

    def set_title(self, options=None):
        """
        Set the chart title options.

        Args:
            options: A dictionary of chart title options.

        Returns:
            Nothing.

        """
        if options is None:
            options = {}

        name, name_formula = self._process_names(options.get('name'),
                                                 options.get('name_formula'))

        data_id = self._get_data_id(name_formula, options.get('data'))

        self.title_name = name
        self.title_formula = name_formula
        self.title_data_id = data_id

        # Set the font properties if present.
        self.title_font = self._convert_font_args(options.get('name_font'))

        # Set the axis name layout.
        self.title_layout = self._get_layout_properties(options.get('layout'),
                                                        True)
        # Set the title overlay option.
        self.title_overlay = options.get('overlay')

        # Set the automatic title option.
        self.title_none = options.get('none')

    def set_legend(self, options):
        """
        Set the chart legend options.

        Args:
            options: A dictionary of chart legend options.

        Returns:
            Nothing.
        """
        # Convert the user defined properties to internal properties.
        self.legend = self._get_legend_properties(options)

    def set_plotarea(self, options):
        """
        Set the chart plot area options.

        Args:
            options: A dictionary of chart plot area options.

        Returns:
            Nothing.
        """
        # Convert the user defined properties to internal properties.
        self.plotarea = self._get_area_properties(options)

    def set_chartarea(self, options):
        """
        Set the chart area options.

        Args:
            options: A dictionary of chart area options.

        Returns:
            Nothing.
        """
        # Convert the user defined properties to internal properties.
        self.chartarea = self._get_area_properties(options)

    def set_style(self, style_id):
        """
        Set the chart style type.

        Args:
            style_id: An int representing the chart style.

        Returns:
            Nothing.
        """
        # Set one of the 48 built-in Excel chart styles. The default is 2.
        if style_id is None:
            style_id = 2

        if style_id < 0 or style_id > 48:
            style_id = 2

        self.style_id = style_id

    def show_blanks_as(self, option):
        """
        Set the option for displaying blank data in a chart.

        Args:
            option: A string representing the display option.

        Returns:
            Nothing.
        """
        if not option:
            return

        valid_options = {
            'gap': 1,
            'zero': 1,
            'span': 1,
        }

        if option not in valid_options:
            warn("Unknown show_blanks_as() option '%s'" % option)
            return

        self.show_blanks = option

    def show_hidden_data(self):
        """
        Display data on charts from hidden rows or columns.

        Args:
            option: A string representing the display option.

        Returns:
            Nothing.
        """
        self.show_hidden = 1

    def set_size(self, options=None):
        """
        Set size or scale of the chart.

        Args:
            options: A dictionary of chart size options.

        Returns:
            Nothing.
        """
        if options is None:
            options = {}

        # Set dimensions or scale for the chart.
        self.width = options.get('width', self.width)
        self.height = options.get('height', self.height)
        self.x_scale = options.get('x_scale', 1)
        self.y_scale = options.get('y_scale', 1)
        self.x_offset = options.get('x_offset', 0)
        self.y_offset = options.get('y_offset', 0)

    def set_table(self, options=None):
        """
        Set properties for an axis data table.

        Args:
            options: A dictionary of axis table options.

        Returns:
            Nothing.

        """
        if options is None:
            options = {}

        table = {}

        table['horizontal'] = options.get('horizontal', 1)
        table['vertical'] = options.get('vertical', 1)
        table['outline'] = options.get('outline', 1)
        table['show_keys'] = options.get('show_keys', 0)
        table['font'] = self._convert_font_args(options.get('font'))

        self.table = table

    def set_up_down_bars(self, options=None):
        """
        Set properties for the chart up-down bars.

        Args:
            options: A dictionary of options.

        Returns:
            Nothing.

        """
        if options is None:
            options = {}

        # Defaults.
        up_line = None
        up_fill = None
        down_line = None
        down_fill = None

        # Set properties for 'up' bar.
        if options.get('up'):
            if 'border' in options['up']:
                # Map border to line.
                up_line = Shape._get_line_properties(options['up']['border'])

            if 'line' in options['up']:
                up_line = Shape._get_line_properties(options['up']['line'])

            if 'fill' in options['up']:
                up_fill = Shape._get_fill_properties(options['up']['fill'])

        # Set properties for 'down' bar.
        if options.get('down'):
            if 'border' in options['down']:
                # Map border to line.
                down_line = \
                    Shape._get_line_properties(options['down']['border'])

            if 'line' in options['down']:
                down_line = Shape._get_line_properties(options['down']['line'])

            if 'fill' in options['down']:
                down_fill = Shape._get_fill_properties(options['down']['fill'])

        self.up_down_bars = {'up': {'line': up_line,
                                    'fill': up_fill,
                                    },
                             'down': {'line': down_line,
                                      'fill': down_fill,
                                      },
                             }

    def set_drop_lines(self, options=None):
        """
        Set properties for the chart drop lines.

        Args:
            options: A dictionary of options.

        Returns:
            Nothing.

        """
        if options is None:
            options = {}

        line = Shape._get_line_properties(options.get('line'))
        fill = Shape._get_fill_properties(options.get('fill'))

        # Set the pattern fill properties for the series.
        pattern = Shape._get_pattern_properties(options.get('pattern'))

        # Set the gradient fill properties for the series.
        gradient = Shape._get_gradient_properties(options.get('gradient'))

        # Pattern fill overrides solid fill.
        if pattern:
            self.fill = None

        # Gradient fill overrides the solid and pattern fill.
        if gradient:
            pattern = None
            fill = None

        self.drop_lines = {'line': line,
                           'fill': fill,
                           'pattern': pattern,
                           'gradient': gradient}

    def set_high_low_lines(self, options=None):
        """
        Set properties for the chart high-low lines.

        Args:
            options: A dictionary of options.

        Returns:
            Nothing.

        """
        if options is None:
            options = {}

        line = Shape._get_line_properties(options.get('line'))
        fill = Shape._get_fill_properties(options.get('fill'))

        # Set the pattern fill properties for the series.
        pattern = Shape._get_pattern_properties(options.get('pattern'))

        # Set the gradient fill properties for the series.
        gradient = Shape._get_gradient_properties(options.get('gradient'))

        # Pattern fill overrides solid fill.
        if pattern:
            self.fill = None

        # Gradient fill overrides the solid and pattern fill.
        if gradient:
            pattern = None
            fill = None

        self.hi_low_lines = {'line': line,
                             'fill': fill,
                             'pattern': pattern,
                             'gradient': gradient}

    def combine(self, chart=None):
        """
        Create a combination chart with a secondary chart.

        Args:
            chart: The secondary chart to combine with the primary chart.

        Returns:
            Nothing.

        """
        if chart is None:
            return

        self.combined = chart

    ###########################################################################
    #
    # Private API.
    #
    ###########################################################################

    def _assemble_xml_file(self):
        # Assemble and write the XML file.

        # Write the XML declaration.
        self._xml_declaration()

        # Write the c:chartSpace element.
        self._write_chart_space()

        # Write the c:lang element.
        self._write_lang()

        # Write the c:style element.
        self._write_style()

        # Write the c:protection element.
        self._write_protection()

        # Write the c:chart element.
        self._write_chart()

        # Write the c:spPr element for the chartarea formatting.
        self._write_sp_pr(self.chartarea)

        # Write the c:printSettings element.
        if self.embedded:
            self._write_print_settings()

        # Close the worksheet tag.
        self._xml_end_tag('c:chartSpace')
        # Close the file.
        self._xml_close()

    def _convert_axis_args(self, axis, user_options):
        # Convert user defined axis values into private hash values.
        options = axis['defaults'].copy()
        options.update(user_options)

        name, name_formula = self._process_names(options.get('name'),
                                                 options.get('name_formula'))

        data_id = self._get_data_id(name_formula, options.get('data'))

        axis = {
            'defaults': axis['defaults'],
            'name': name,
            'formula': name_formula,
            'data_id': data_id,
            'reverse': options.get('reverse'),
            'min': options.get('min'),
            'max': options.get('max'),
            'minor_unit': options.get('minor_unit'),
            'major_unit': options.get('major_unit'),
            'minor_unit_type': options.get('minor_unit_type'),
            'major_unit_type': options.get('major_unit_type'),
            'display_units': options.get('display_units'),
            'log_base': options.get('log_base'),
            'crossing': options.get('crossing'),
            'position_axis': options.get('position_axis'),
            'position': options.get('position'),
            'label_position': options.get('label_position'),
            'label_align': options.get('label_align'),
            'num_format': options.get('num_format'),
            'num_format_linked': options.get('num_format_linked'),
            'interval_unit': options.get('interval_unit'),
            'interval_tick': options.get('interval_tick'),
            'text_axis': False,
        }

        if 'visible' in options:
            axis['visible'] = options.get('visible')
        else:
            axis['visible'] = 1

        # Convert the display units.
        axis['display_units'] = self._get_display_units(axis['display_units'])
        axis['display_units_visible'] = \
            options.get('display_units_visible', True)

        # Map major_gridlines properties.
        if (options.get('major_gridlines')
                and options['major_gridlines']['visible']):
            axis['major_gridlines'] = \
                self._get_gridline_properties(options['major_gridlines'])

        # Map minor_gridlines properties.
        if (options.get('minor_gridlines')
                and options['minor_gridlines']['visible']):
            axis['minor_gridlines'] = \
                self._get_gridline_properties(options['minor_gridlines'])

        # Only use the first letter of bottom, top, left or right.
        if axis.get('position'):
            axis['position'] = axis['position'].lower()[0]

        # Set the position for a category axis on or between the tick marks.
        if axis.get('position_axis'):
            if axis['position_axis'] == 'on_tick':
                axis['position_axis'] = 'midCat'
            elif axis['position_axis'] == 'between':
                # Doesn't need to be modified.
                pass
            else:
                # Otherwise use the default value.
                axis['position_axis'] = None

        # Set the category axis as a date axis.
        if options.get('date_axis'):
            self.date_category = True

        # Set the category axis as a text axis.
        if options.get('text_axis'):
            self.date_category = False
            axis['text_axis'] = True

        # Convert datetime args if required.
        if axis.get('min') and supported_datetime(axis['min']):
            axis['min'] = datetime_to_excel_datetime(axis['min'],
                                                     self.date_1904,
                                                     self.remove_timezone)
        if axis.get('max') and supported_datetime(axis['max']):
            axis['max'] = datetime_to_excel_datetime(axis['max'],
                                                     self.date_1904,
                                                     self.remove_timezone)
        if axis.get('crossing') and supported_datetime(axis['crossing']):
            axis['crossing'] = datetime_to_excel_datetime(axis['crossing'],
                                                          self.date_1904,
                                                          self.remove_timezone)

        # Set the font properties if present.
        axis['num_font'] = self._convert_font_args(options.get('num_font'))
        axis['name_font'] = self._convert_font_args(options.get('name_font'))

        # Set the axis name layout.
        axis['name_layout'] = \
            self._get_layout_properties(options.get('name_layout'), True)

        # Set the line properties for the axis.
        axis['line'] = Shape._get_line_properties(options.get('line'))

        # Set the fill properties for the axis.
        axis['fill'] = Shape._get_fill_properties(options.get('fill'))

        # Set the pattern fill properties for the series.
        axis['pattern'] = Shape._get_pattern_properties(options.get('pattern'))

        # Set the gradient fill properties for the series.
        axis['gradient'] = \
            Shape._get_gradient_properties(options.get('gradient'))

        # Pattern fill overrides solid fill.
        if axis.get('pattern'):
            axis['fill'] = None

        # Gradient fill overrides the solid and pattern fill.
        if axis.get('gradient'):
            axis['pattern'] = None
            axis['fill'] = None

        # Set the tick marker types.
        axis['minor_tick_mark'] = \
            self._get_tick_type(options.get('minor_tick_mark'))
        axis['major_tick_mark'] = \
            self._get_tick_type(options.get('major_tick_mark'))

        return axis

    def _convert_font_args(self, options):
        # Convert user defined font values into private dict values.
        if not options:
            return

        font = {
            'name': options.get('name'),
            'color': options.get('color'),
            'size': options.get('size'),
            'bold': options.get('bold'),
            'italic': options.get('italic'),
            'underline': options.get('underline'),
            'pitch_family': options.get('pitch_family'),
            'charset': options.get('charset'),
            'baseline': options.get('baseline', 0),
            'rotation': options.get('rotation'),
        }

        # Convert font size units.
        if font['size']:
            font['size'] = int(font['size'] * 100)

        # Convert rotation into 60,000ths of a degree.
        if font['rotation']:
            font['rotation'] = 60000 * int(font['rotation'])

        return font

    def _list_to_formula(self, data):
        # Convert and list of row col values to a range formula.

        # If it isn't an array ref it is probably a formula already.
        if type(data) is not list:
            # Check for unquoted sheetnames.
            if (data and ' ' in data and "'" not in data
                    and self.warn_sheetname):
                warn("Sheetname in '%s' contains spaces but isn't quoted. "
                     "This may cause errors in Excel." % data)
            return data

        formula = xl_range_formula(*data)

        return formula

    def _process_names(self, name, name_formula):
        # Switch name and name_formula parameters if required.

        if name is not None:
            if isinstance(name, list):
                # Convert an list of values into a name formula.
                cell = xl_rowcol_to_cell(name[1], name[2], True, True)
                name_formula = quote_sheetname(name[0]) + '!' + cell
                name = ''
            elif re.match(r'^=?[^!]+!\$?[A-Z]+\$?[0-9]+', name):
                # Name looks like a formula, use it to set name_formula.
                name_formula = name
                name = ''

        return name, name_formula

    def _get_data_type(self, data):
        # Find the overall type of the data associated with a series.

        # Check for no data in the series.
        if data is None or len(data) == 0:
            return 'none'

        if isinstance(data[0], list):
            return 'multi_str'

        # Determine if data is numeric or strings.
        for token in data:
            if token is None:
                continue

            try:
                float(token)
            except ValueError:
                # Not a number. Assume entire data series is string data.
                return 'str'

        # The series data was all numeric.
        return 'num'

    def _get_data_id(self, formula, data):
        # Assign an id to a each unique series formula or title/axis formula.
        # Repeated formulas such as for categories get the same id. If the
        # series or title has user specified data associated with it then
        # that is also stored. This data is used to populate cached Excel
        # data when creating a chart. If there is no user defined data then
        # it will be populated by the parent Workbook._add_chart_data().

        # Ignore series without a range formula.
        if not formula:
            return

        # Strip the leading '=' from the formula.
        if formula.startswith('='):
            formula = formula.lstrip('=')

        # Store the data id in a hash keyed by the formula and store the data
        # in a separate array with the same id.
        if formula not in self.formula_ids:
            # Haven't seen this formula before.
            formula_id = len(self.formula_data)

            self.formula_data.append(data)
            self.formula_ids[formula] = formula_id
        else:
            # Formula already seen. Return existing id.
            formula_id = self.formula_ids[formula]

            # Store user defined data if it isn't already there.
            if self.formula_data[formula_id] is None:
                self.formula_data[formula_id] = data

        return formula_id

    def _get_marker_properties(self, marker):
        # Convert user marker properties to the structure required internally.

        if not marker:
            return

        # Copy the user defined properties since they will be modified.
        marker = copy.deepcopy(marker)

        types = {
            'automatic': 'automatic',
            'none': 'none',
            'square': 'square',
            'diamond': 'diamond',
            'triangle': 'triangle',
            'x': 'x',
            'star': 'star',
            'dot': 'dot',
            'short_dash': 'dot',
            'dash': 'dash',
            'long_dash': 'dash',
            'circle': 'circle',
            'plus': 'plus',
            'picture': 'picture',
        }

        # Check for valid types.
        marker_type = marker.get('type')

        if marker_type is not None:

            if marker_type in types:
                marker['type'] = types[marker_type]
            else:
                warn("Unknown marker type '%s" % marker_type)
                return

        # Set the line properties for the marker.
        line = Shape._get_line_properties(marker.get('line'))

        # Allow 'border' as a synonym for 'line'.
        if 'border' in marker:
            line = Shape._get_line_properties(marker['border'])

        # Set the fill properties for the marker.
        fill = Shape._get_fill_properties(marker.get('fill'))

        # Set the pattern fill properties for the series.
        pattern = Shape._get_pattern_properties(marker.get('pattern'))

        # Set the gradient fill properties for the series.
        gradient = Shape._get_gradient_properties(marker.get('gradient'))

        # Pattern fill overrides solid fill.
        if pattern:
            self.fill = None

        # Gradient fill overrides the solid and pattern fill.
        if gradient:
            pattern = None
            fill = None

        marker['line'] = line
        marker['fill'] = fill
        marker['pattern'] = pattern
        marker['gradient'] = gradient

        return marker

    def _get_trendline_properties(self, trendline):
        # Convert user trendline properties to structure required internally.

        if not trendline:
            return

        # Copy the user defined properties since they will be modified.
        trendline = copy.deepcopy(trendline)

        types = {
            'exponential': 'exp',
            'linear': 'linear',
            'log': 'log',
            'moving_average': 'movingAvg',
            'polynomial': 'poly',
            'power': 'power',
        }

        # Check the trendline type.
        trend_type = trendline.get('type')

        if trend_type in types:
            trendline['type'] = types[trend_type]
        else:
            warn("Unknown trendline type '%s'" % trend_type)
            return

        # Set the line properties for the trendline.
        line = Shape._get_line_properties(trendline.get('line'))

        # Allow 'border' as a synonym for 'line'.
        if 'border' in trendline:
            line = Shape._get_line_properties(trendline['border'])

        # Set the fill properties for the trendline.
        fill = Shape._get_fill_properties(trendline.get('fill'))

        # Set the pattern fill properties for the series.
        pattern = Shape._get_pattern_properties(trendline.get('pattern'))

        # Set the gradient fill properties for the series.
        gradient = Shape._get_gradient_properties(trendline.get('gradient'))

        # Pattern fill overrides solid fill.
        if pattern:
            self.fill = None

        # Gradient fill overrides the solid and pattern fill.
        if gradient:
            pattern = None
            fill = None

        trendline['line'] = line
        trendline['fill'] = fill
        trendline['pattern'] = pattern
        trendline['gradient'] = gradient

        return trendline

    def _get_error_bars_props(self, options):
        # Convert user error bars properties to structure required internally.
        if not options:
            return

        # Default values.
        error_bars = {
            'type': 'fixedVal',
            'value': 1,
            'endcap': 1,
            'direction': 'both'
        }

        types = {
            'fixed': 'fixedVal',
            'percentage': 'percentage',
            'standard_deviation': 'stdDev',
            'standard_error': 'stdErr',
            'custom': 'cust',
        }

        # Check the error bars type.
        error_type = options['type']

        if error_type in types:
            error_bars['type'] = types[error_type]
        else:
            warn("Unknown error bars type '%s" % error_type)
            return

        # Set the value for error types that require it.
        if 'value' in options:
            error_bars['value'] = options['value']

        # Set the end-cap style.
        if 'end_style' in options:
            error_bars['endcap'] = options['end_style']

        # Set the error bar direction.
        if 'direction' in options:
            if options['direction'] == 'minus':
                error_bars['direction'] = 'minus'
            elif options['direction'] == 'plus':
                error_bars['direction'] = 'plus'
            else:
                # Default to 'both'.
                pass

        # Set any custom values.
        error_bars['plus_values'] = options.get('plus_values')
        error_bars['minus_values'] = options.get('minus_values')
        error_bars['plus_data'] = options.get('plus_data')
        error_bars['minus_data'] = options.get('minus_data')

        # Set the line properties for the error bars.
        error_bars['line'] = Shape._get_line_properties(options.get('line'))

        return error_bars

    def _get_gridline_properties(self, options):
        # Convert user gridline properties to structure required internally.

        # Set the visible property for the gridline.
        gridline = {'visible': options.get('visible')}

        # Set the line properties for the gridline.
        gridline['line'] = Shape._get_line_properties(options.get('line'))

        return gridline

    def _get_labels_properties(self, labels):
        # Convert user labels properties to the structure required internally.

        if not labels:
            return None

        # Copy the user defined properties since they will be modified.
        labels = copy.deepcopy(labels)

        # Map user defined label positions to Excel positions.
        position = labels.get('position')

        if position:
            if position in self.label_positions:
                if position == self.label_position_default:
                    labels['position'] = None
                else:
                    labels['position'] = self.label_positions[position]
            else:
                warn("Unsupported label position '%s' for this chart type"
                     % position)
                return

        # Map the user defined label separator to the Excel separator.
        separator = labels.get('separator')
        separators = {
            ',': ', ',
            ';': '; ',
            '.': '. ',
            "\n": "\n",
            ' ': ' ',
        }

        if separator:
            if separator in separators:
                labels['separator'] = separators[separator]
            else:
                warn("Unsupported label separator")
                return

        # Set the font properties if present.
        labels['font'] = self._convert_font_args(labels.get('font'))

        # Set the line properties for the labels.
        line = Shape._get_line_properties(labels.get('line'))

        # Allow 'border' as a synonym for 'line'.
        if 'border' in labels:
            line = Shape._get_line_properties(labels['border'])

        # Set the fill properties for the labels.
        fill = Shape._get_fill_properties(labels.get('fill'))

        # Set the pattern fill properties for the labels.
        pattern = Shape._get_pattern_properties(labels.get('pattern'))

        # Set the gradient fill properties for the labels.
        gradient = Shape._get_gradient_properties(labels.get('gradient'))

        # Pattern fill overrides solid fill.
        if pattern:
            self.fill = None

        # Gradient fill overrides the solid and pattern fill.
        if gradient:
            pattern = None
            fill = None

        labels['line'] = line
        labels['fill'] = fill
        labels['pattern'] = pattern
        labels['gradient'] = gradient

        if labels.get('custom'):

            for label in labels['custom']:
                if label is None:
                    continue

                value = label.get('value')
                if value and re.match(r'^=?[^!]+!\$?[A-Z]+\$?[0-9]+',
                                      str(value)):
                    label['formula'] = value

                formula = label.get('formula')
                if formula and formula.startswith('='):
                    label['formula'] = formula.lstrip('=')

                data_id = self._get_data_id(formula, label.get('data'))
                label['data_id'] = data_id

                label['font'] = self._convert_font_args(label.get('font'))

                # Set the line properties for the label.
                line = Shape._get_line_properties(label.get('line'))

                # Allow 'border' as a synonym for 'line'.
                if 'border' in label:
                    line = Shape._get_line_properties(label['border'])

                # Set the fill properties for the label.
                fill = Shape._get_fill_properties(label.get('fill'))

                # Set the pattern fill properties for the label.
                pattern = Shape._get_pattern_properties(label.get('pattern'))

                # Set the gradient fill properties for the label.
                gradient = Shape._get_gradient_properties(
                    label.get('gradient'))

                # Pattern fill overrides solid fill.
                if pattern:
                    self.fill = None

                # Gradient fill overrides the solid and pattern fill.
                if gradient:
                    pattern = None
                    fill = None

                label['line'] = line
                label['fill'] = fill
                label['pattern'] = pattern
                label['gradient'] = gradient

        return labels

    def _get_area_properties(self, options):
        # Convert user area properties to the structure required internally.
        area = {}

        # Set the line properties for the chartarea.
        line = Shape._get_line_properties(options.get('line'))

        # Allow 'border' as a synonym for 'line'.
        if options.get('border'):
            line = Shape._get_line_properties(options['border'])

        # Set the fill properties for the chartarea.
        fill = Shape._get_fill_properties(options.get('fill'))

        # Set the pattern fill properties for the series.
        pattern = Shape._get_pattern_properties(options.get('pattern'))

        # Set the gradient fill properties for the series.
        gradient = Shape._get_gradient_properties(options.get('gradient'))

        # Pattern fill overrides solid fill.
        if pattern:
            self.fill = None

        # Gradient fill overrides the solid and pattern fill.
        if gradient:
            pattern = None
            fill = None

        # Set the plotarea layout.
        layout = self._get_layout_properties(options.get('layout'), False)

        area['line'] = line
        area['fill'] = fill
        area['pattern'] = pattern
        area['layout'] = layout
        area['gradient'] = gradient

        return area

    def _get_legend_properties(self, options=None):
        # Convert user legend properties to the structure required internally.
        legend = {}

        if options is None:
            options = {}

        legend['position'] = options.get('position', 'right')
        legend['delete_series'] = options.get('delete_series')
        legend['font'] = self._convert_font_args(options.get('font'))
        legend['layout'] = self._get_layout_properties(options.get('layout'),
                                                       False)

        # Turn off the legend.
        if options.get('none'):
            legend['position'] = 'none'

        # Set the line properties for the legend.
        line = Shape._get_line_properties(options.get('line'))

        # Allow 'border' as a synonym for 'line'.
        if options.get('border'):
            line = Shape._get_line_properties(options['border'])

        # Set the fill properties for the legend.
        fill = Shape._get_fill_properties(options.get('fill'))

        # Set the pattern fill properties for the series.
        pattern = Shape._get_pattern_properties(options.get('pattern'))

        # Set the gradient fill properties for the series.
        gradient = Shape._get_gradient_properties(options.get('gradient'))

        # Pattern fill overrides solid fill.
        if pattern:
            self.fill = None

        # Gradient fill overrides the solid and pattern fill.
        if gradient:
            pattern = None
            fill = None

        # Set the legend layout.
        layout = self._get_layout_properties(options.get('layout'), False)

        legend['line'] = line
        legend['fill'] = fill
        legend['pattern'] = pattern
        legend['layout'] = layout
        legend['gradient'] = gradient

        return legend

    def _get_layout_properties(self, args, is_text):
        # Convert user defined layout properties to format used internally.
        layout = {}

        if not args:
            return

        if is_text:
            properties = ('x', 'y')
        else:
            properties = ('x', 'y', 'width', 'height')

        # Check for valid properties.
        for key in args.keys():
            if key not in properties:
                warn("Property '%s' allowed not in layout options" % key)
                return

        # Set the layout properties.
        for prop in properties:
            if prop not in args.keys():
                warn("Property '%s' must be specified in layout options"
                     % prop)
                return

            value = args[prop]

            try:
                float(value)
            except ValueError:
                warn("Property '%s' value '%s' must be numeric in layout" %
                     (prop, value))
                return

            if value < 0 or value > 1:
                warn("Property '%s' value '%s' must be in range "
                     "0 < x <= 1 in layout options" % (prop, value))
                return

            # Convert to the format used by Excel for easier testing
            layout[prop] = "%.17g" % value

        return layout

    def _get_points_properties(self, user_points):
        # Convert user points properties to structure required internally.
        points = []

        if not user_points:
            return

        for user_point in user_points:
            point = {}

            if user_point is not None:

                # Set the line properties for the point.
                line = Shape._get_line_properties(user_point.get('line'))

                # Allow 'border' as a synonym for 'line'.
                if 'border' in user_point:
                    line = Shape._get_line_properties(user_point['border'])

                # Set the fill properties for the chartarea.
                fill = Shape._get_fill_properties(user_point.get('fill'))

                # Set the pattern fill properties for the series.
                pattern = \
                    Shape._get_pattern_properties(user_point.get('pattern'))

                # Set the gradient fill properties for the series.
                gradient = \
                    Shape._get_gradient_properties(user_point.get('gradient'))

                # Pattern fill overrides solid fill.
                if pattern:
                    self.fill = None

                # Gradient fill overrides the solid and pattern fill.
                if gradient:
                    pattern = None
                    fill = None

                point['line'] = line
                point['fill'] = fill
                point['pattern'] = pattern
                point['gradient'] = gradient

            points.append(point)

        return points

    def _has_fill_formatting(self, element):
        # Check if a chart element has line, fill or gradient formatting.
        has_fill = False
        has_line = False
        has_pattern = element.get('pattern')
        has_gradient = element.get('gradient')

        if element.get('fill') and element['fill']['defined']:
            has_fill = True

        if element.get('line') and element['line']['defined']:
            has_line = True

        if (not has_fill and not has_line and not has_pattern
                and not has_gradient):
            return False
        else:
            return True

    def _get_display_units(self, display_units):
        # Convert user defined display units to internal units.
        if not display_units:
            return

        types = {
            'hundreds': 'hundreds',
            'thousands': 'thousands',
            'ten_thousands': 'tenThousands',
            'hundred_thousands': 'hundredThousands',
            'millions': 'millions',
            'ten_millions': 'tenMillions',
            'hundred_millions': 'hundredMillions',
            'billions': 'billions',
            'trillions': 'trillions',
        }

        if display_units in types:
            display_units = types[display_units]
        else:
            warn("Unknown display_units type '%s'" % display_units)
            return

        return display_units

    def _get_tick_type(self, tick_type):
        # Convert user defined display units to internal units.
        if not tick_type:
            return

        types = {
            'outside': 'out',
            'inside': 'in',
            'none': 'none',
            'cross': 'cross',
        }

        if tick_type in types:
            tick_type = types[tick_type]
        else:
            warn("Unknown tick_type  '%s'" % tick_type)
            return

        return tick_type

    def _get_primary_axes_series(self):
        # Returns series which use the primary axes.
        primary_axes_series = []

        for series in self.series:
            if not series['y2_axis']:
                primary_axes_series.append(series)

        return primary_axes_series

    def _get_secondary_axes_series(self):
        # Returns series which use the secondary axes.
        secondary_axes_series = []

        for series in self.series:
            if series['y2_axis']:
                secondary_axes_series.append(series)

        return secondary_axes_series

    def _add_axis_ids(self, args):
        # Add unique ids for primary or secondary axes
        chart_id = 5001 + int(self.id)
        axis_count = 1 + len(self.axis2_ids) + len(self.axis_ids)

        id1 = '%04d%04d' % (chart_id, axis_count)
        id2 = '%04d%04d' % (chart_id, axis_count + 1)

        if args['primary_axes']:
            self.axis_ids.append(id1)
            self.axis_ids.append(id2)

        if not args['primary_axes']:
            self.axis2_ids.append(id1)
            self.axis2_ids.append(id2)

    def _set_default_properties(self):
        # Setup the default properties for a chart.

        self.x_axis['defaults'] = {
            'num_format': 'General',
            'major_gridlines': {'visible': 0}
        }

        self.y_axis['defaults'] = {
            'num_format': 'General',
            'major_gridlines': {'visible': 1}
        }

        self.x2_axis['defaults'] = {
            'num_format': 'General',
            'label_position': 'none',
            'crossing': 'max',
            'visible': 0
        }

        self.y2_axis['defaults'] = {
            'num_format': 'General',
            'major_gridlines': {'visible': 0},
            'position': 'right',
            'visible': 1
        }

        self.set_x_axis({})
        self.set_y_axis({})

        self.set_x2_axis({})
        self.set_y2_axis({})

    ###########################################################################
    #
    # XML methods.
    #
    ###########################################################################

    def _write_chart_space(self):
        # Write the <c:chartSpace> element.
        schema = 'http://schemas.openxmlformats.org/'
        xmlns_c = schema + 'drawingml/2006/chart'
        xmlns_a = schema + 'drawingml/2006/main'
        xmlns_r = schema + 'officeDocument/2006/relationships'

        attributes = [
            ('xmlns:c', xmlns_c),
            ('xmlns:a', xmlns_a),
            ('xmlns:r', xmlns_r),
        ]

        self._xml_start_tag('c:chartSpace', attributes)

    def _write_lang(self):
        # Write the <c:lang> element.
        val = 'en-US'

        attributes = [('val', val)]

        self._xml_empty_tag('c:lang', attributes)

    def _write_style(self):
        # Write the <c:style> element.
        style_id = self.style_id

        # Don't write an element for the default style, 2.
        if style_id == 2:
            return

        attributes = [('val', style_id)]

        self._xml_empty_tag('c:style', attributes)

    def _write_chart(self):
        # Write the <c:chart> element.
        self._xml_start_tag('c:chart')

        if self.title_none:
            # Turn off the title.
            self._write_c_auto_title_deleted()
        else:
            # Write the chart title elements.
            if self.title_formula is not None:
                self._write_title_formula(self.title_formula,
                                          self.title_data_id,
                                          None,
                                          self.title_font,
                                          self.title_layout,
                                          self.title_overlay)
            elif self.title_name is not None:
                self._write_title_rich(self.title_name,
                                       None,
                                       self.title_font,
                                       self.title_layout,
                                       self.title_overlay)

        # Write the c:plotArea element.
        self._write_plot_area()

        # Write the c:legend element.
        self._write_legend()

        # Write the c:plotVisOnly element.
        self._write_plot_vis_only()

        # Write the c:dispBlanksAs element.
        self._write_disp_blanks_as()

        self._xml_end_tag('c:chart')

    def _write_disp_blanks_as(self):
        # Write the <c:dispBlanksAs> element.
        val = self.show_blanks

        # Ignore the default value.
        if val == 'gap':
            return

        attributes = [('val', val)]

        self._xml_empty_tag('c:dispBlanksAs', attributes)

    def _write_plot_area(self):
        # Write the <c:plotArea> element.
        self._xml_start_tag('c:plotArea')

        # Write the c:layout element.
        self._write_layout(self.plotarea.get('layout'), 'plot')

        # Write  subclass chart type elements for primary and secondary axes.
        self._write_chart_type({'primary_axes': True})
        self._write_chart_type({'primary_axes': False})

        # Configure a combined chart if present.
        second_chart = self.combined
        if second_chart:
            # Secondary axis has unique id otherwise use same as primary.
            if second_chart.is_secondary:
                second_chart.id = 1000 + self.id
            else:
                second_chart.id = self.id

            # Share the same filehandle for writing.
            second_chart.fh = self.fh

            # Share series index with primary chart.
            second_chart.series_index = self.series_index

            # Write the subclass chart type elements for combined chart.
            second_chart._write_chart_type({'primary_axes': True})
            second_chart._write_chart_type({'primary_axes': False})

        # Write the category and value elements for the primary axes.
        args = {'x_axis': self.x_axis,
                'y_axis': self.y_axis,
                'axis_ids': self.axis_ids}

        if self.date_category:
            self._write_date_axis(args)
        else:
            self._write_cat_axis(args)

        self._write_val_axis(args)

        # Write the category and value elements for the secondary axes.
        args = {'x_axis': self.x2_axis,
                'y_axis': self.y2_axis,
                'axis_ids': self.axis2_ids}

        self._write_val_axis(args)

        # Write the secondary axis for the secondary chart.
        if second_chart and second_chart.is_secondary:
            args = {'x_axis': second_chart.x2_axis,
                    'y_axis': second_chart.y2_axis,
                    'axis_ids': second_chart.axis2_ids}

            second_chart._write_val_axis(args)

        if self.date_category:
            self._write_date_axis(args)
        else:
            self._write_cat_axis(args)

        # Write the c:dTable element.
        self._write_d_table()

        # Write the c:spPr element for the plotarea formatting.
        self._write_sp_pr(self.plotarea)

        self._xml_end_tag('c:plotArea')

    def _write_layout(self, layout, layout_type):
        # Write the <c:layout> element.

        if not layout:
            # Automatic layout.
            self._xml_empty_tag('c:layout')
        else:
            # User defined manual layout.
            self._xml_start_tag('c:layout')
            self._write_manual_layout(layout, layout_type)
            self._xml_end_tag('c:layout')

    def _write_manual_layout(self, layout, layout_type):
        # Write the <c:manualLayout> element.
        self._xml_start_tag('c:manualLayout')

        # Plotarea has a layoutTarget element.
        if layout_type == 'plot':
            self._xml_empty_tag('c:layoutTarget', [('val', 'inner')])

        # Set the x, y positions.
        self._xml_empty_tag('c:xMode', [('val', 'edge')])
        self._xml_empty_tag('c:yMode', [('val', 'edge')])
        self._xml_empty_tag('c:x', [('val', layout['x'])])
        self._xml_empty_tag('c:y', [('val', layout['y'])])

        # For plotarea and legend set the width and height.
        if layout_type != 'text':
            self._xml_empty_tag('c:w', [('val', layout['width'])])
            self._xml_empty_tag('c:h', [('val', layout['height'])])

        self._xml_end_tag('c:manualLayout')

    def _write_chart_type(self, options):
        # Write the chart type element. This method should be overridden
        # by the subclasses.
        return

    def _write_grouping(self, val):
        # Write the <c:grouping> element.
        attributes = [('val', val)]

        self._xml_empty_tag('c:grouping', attributes)

    def _write_series(self, series):
        # Write the series elements.
        self._write_ser(series)

    def _write_ser(self, series):
        # Write the <c:ser> element.
        index = self.series_index
        self.series_index += 1

        self._xml_start_tag('c:ser')

        # Write the c:idx element.
        self._write_idx(index)

        # Write the c:order element.
        self._write_order(index)

        # Write the series name.
        self._write_series_name(series)

        # Write the c:spPr element.
        self._write_sp_pr(series)

        # Write the c:marker element.
        self._write_marker(series['marker'])

        # Write the c:invertIfNegative element.
        self._write_c_invert_if_negative(series['invert_if_neg'])

        # Write the c:dPt element.
        self._write_d_pt(series['points'])

        # Write the c:dLbls element.
        self._write_d_lbls(series['labels'])

        # Write the c:trendline element.
        self._write_trendline(series['trendline'])

        # Write the c:errBars element.
        self._write_error_bars(series['error_bars'])

        # Write the c:cat element.
        self._write_cat(series)

        # Write the c:val element.
        self._write_val(series)

        # Write the c:smooth element.
        if self.smooth_allowed:
            self._write_c_smooth(series['smooth'])

        self._xml_end_tag('c:ser')

    def _write_idx(self, val):
        # Write the <c:idx> element.

        attributes = [('val', val)]

        self._xml_empty_tag('c:idx', attributes)

    def _write_order(self, val):
        # Write the <c:order> element.

        attributes = [('val', val)]

        self._xml_empty_tag('c:order', attributes)

    def _write_series_name(self, series):
        # Write the series name.

        if series['name_formula'] is not None:
            self._write_tx_formula(series['name_formula'], series['name_id'])
        elif series['name'] is not None:
            self._write_tx_value(series['name'])

    def _write_c_smooth(self, smooth):
        # Write the <c:smooth> element.

        if smooth:
            self._xml_empty_tag('c:smooth', [('val', '1')])

    def _write_cat(self, series):
        # Write the <c:cat> element.
        formula = series['categories']
        data_id = series['cat_data_id']
        data = None

        if data_id is not None:
            data = self.formula_data[data_id]

        # Ignore <c:cat> elements for charts without category values.
        if not formula:
            return

        self._xml_start_tag('c:cat')

        # Check the type of cached data.
        cat_type = self._get_data_type(data)

        if cat_type == 'str':
            self.cat_has_num_fmt = 0
            # Write the c:numRef element.
            self._write_str_ref(formula, data, cat_type)

        elif cat_type == 'multi_str':
            self.cat_has_num_fmt = 0
            # Write the c:numRef element.
            self._write_multi_lvl_str_ref(formula, data)

        else:
            self.cat_has_num_fmt = 1
            # Write the c:numRef element.
            self._write_num_ref(formula, data, cat_type)

        self._xml_end_tag('c:cat')

    def _write_val(self, series):
        # Write the <c:val> element.
        formula = series['values']
        data_id = series['val_data_id']
        data = self.formula_data[data_id]

        self._xml_start_tag('c:val')

        # Unlike Cat axes data should only be numeric.
        # Write the c:numRef element.
        self._write_num_ref(formula, data, 'num')

        self._xml_end_tag('c:val')

    def _write_num_ref(self, formula, data, ref_type):
        # Write the <c:numRef> element.
        self._xml_start_tag('c:numRef')

        # Write the c:f element.
        self._write_series_formula(formula)

        if ref_type == 'num':
            # Write the c:numCache element.
            self._write_num_cache(data)
        elif ref_type == 'str':
            # Write the c:strCache element.
            self._write_str_cache(data)

        self._xml_end_tag('c:numRef')

    def _write_str_ref(self, formula, data, ref_type):
        # Write the <c:strRef> element.

        self._xml_start_tag('c:strRef')

        # Write the c:f element.
        self._write_series_formula(formula)

        if ref_type == 'num':
            # Write the c:numCache element.
            self._write_num_cache(data)
        elif ref_type == 'str':
            # Write the c:strCache element.
            self._write_str_cache(data)

        self._xml_end_tag('c:strRef')

    def _write_multi_lvl_str_ref(self, formula, data):
        # Write the <c:multiLvlStrRef> element.

        if not data:
            return

        self._xml_start_tag('c:multiLvlStrRef')

        # Write the c:f element.
        self._write_series_formula(formula)

        self._xml_start_tag('c:multiLvlStrCache')

        # Write the c:ptCount element.
        count = len(data[-1])
        self._write_pt_count(count)

        for cat_data in reversed(data):

            self._xml_start_tag('c:lvl')

            for i, point in enumerate(cat_data):
                # Write the c:pt element.
                self._write_pt(i, cat_data[i])

            self._xml_end_tag('c:lvl')

        self._xml_end_tag('c:multiLvlStrCache')
        self._xml_end_tag('c:multiLvlStrRef')

    def _write_series_formula(self, formula):
        # Write the <c:f> element.

        # Strip the leading '=' from the formula.
        if formula.startswith('='):
            formula = formula.lstrip('=')

        self._xml_data_element('c:f', formula)

    def _write_axis_ids(self, args):
        # Write the <c:axId> elements for the primary or secondary axes.

        # Generate the axis ids.
        self._add_axis_ids(args)

        if args['primary_axes']:
            # Write the axis ids for the primary axes.
            self._write_axis_id(self.axis_ids[0])
            self._write_axis_id(self.axis_ids[1])
        else:
            # Write the axis ids for the secondary axes.
            self._write_axis_id(self.axis2_ids[0])
            self._write_axis_id(self.axis2_ids[1])

    def _write_axis_id(self, val):
        # Write the <c:axId> element.

        attributes = [('val', val)]

        self._xml_empty_tag('c:axId', attributes)

    def _write_cat_axis(self, args):
        # Write the <c:catAx> element. Usually the X axis.
        x_axis = args['x_axis']
        y_axis = args['y_axis']
        axis_ids = args['axis_ids']

        # If there are no axis_ids then we don't need to write this element.
        if axis_ids is None or not len(axis_ids):
            return

        position = self.cat_axis_position
        is_y_axis = self.horiz_cat_axis

        # Overwrite the default axis position with a user supplied value.
        if x_axis.get('position'):
            position = x_axis['position']

        self._xml_start_tag('c:catAx')

        self._write_axis_id(axis_ids[0])

        # Write the c:scaling element.
        self._write_scaling(x_axis.get('reverse'),
                            None,
                            None,
                            None)

        if not x_axis.get('visible'):
            self._write_delete(1)

        # Write the c:axPos element.
        self._write_axis_pos(position, y_axis.get('reverse'))

        # Write the c:majorGridlines element.
        self._write_major_gridlines(x_axis.get('major_gridlines'))

        # Write the c:minorGridlines element.
        self._write_minor_gridlines(x_axis.get('minor_gridlines'))

        # Write the axis title elements.
        if x_axis['formula'] is not None:
            self._write_title_formula(x_axis['formula'],
                                      x_axis['data_id'],
                                      is_y_axis,
                                      x_axis['name_font'],
                                      x_axis['name_layout'])
        elif x_axis['name'] is not None:
            self._write_title_rich(x_axis['name'],
                                   is_y_axis,
                                   x_axis['name_font'],
                                   x_axis['name_layout'])

        # Write the c:numFmt element.
        self._write_cat_number_format(x_axis)

        # Write the c:majorTickMark element.
        self._write_major_tick_mark(x_axis.get('major_tick_mark'))

        # Write the c:minorTickMark element.
        self._write_minor_tick_mark(x_axis.get('minor_tick_mark'))

        # Write the c:tickLblPos element.
        self._write_tick_label_pos(x_axis.get('label_position'))

        # Write the c:spPr element for the axis line.
        self._write_sp_pr(x_axis)

        # Write the axis font elements.
        self._write_axis_font(x_axis.get('num_font'))

        # Write the c:crossAx element.
        self._write_cross_axis(axis_ids[1])

        if self.show_crosses or x_axis.get('visible'):

            # Note, the category crossing comes from the value axis.
            if (y_axis.get('crossing') is None
                    or y_axis.get('crossing') == 'max'
                    or y_axis['crossing'] == 'min'):

                # Write the c:crosses element.
                self._write_crosses(y_axis.get('crossing'))
            else:

                # Write the c:crossesAt element.
                self._write_c_crosses_at(y_axis.get('crossing'))

        # Write the c:auto element.
        if not x_axis.get('text_axis'):
            self._write_auto(1)

        # Write the c:labelAlign element.
        self._write_label_align(x_axis.get('label_align'))

        # Write the c:labelOffset element.
        self._write_label_offset(100)

        # Write the c:tickLblSkip element.
        self._write_c_tick_lbl_skip(x_axis.get('interval_unit'))

        # Write the c:tickMarkSkip element.
        self._write_c_tick_mark_skip(x_axis.get('interval_tick'))

        self._xml_end_tag('c:catAx')

    def _write_val_axis(self, args):
        # Write the <c:valAx> element. Usually the Y axis.
        x_axis = args['x_axis']
        y_axis = args['y_axis']
        axis_ids = args['axis_ids']
        position = args.get('position', self.val_axis_position)
        is_y_axis = self.horiz_val_axis

        # If there are no axis_ids then we don't need to write this element.
        if axis_ids is None or not len(axis_ids):
            return

        # Overwrite the default axis position with a user supplied value.
        position = y_axis.get('position') or position

        self._xml_start_tag('c:valAx')

        self._write_axis_id(axis_ids[1])

        # Write the c:scaling element.
        self._write_scaling(y_axis.get('reverse'),
                            y_axis.get('min'),
                            y_axis.get('max'),
                            y_axis.get('log_base'))

        if not y_axis.get('visible'):
            self._write_delete(1)

        # Write the c:axPos element.
        self._write_axis_pos(position, x_axis.get('reverse'))

        # Write the c:majorGridlines element.
        self._write_major_gridlines(y_axis.get('major_gridlines'))

        # Write the c:minorGridlines element.
        self._write_minor_gridlines(y_axis.get('minor_gridlines'))

        # Write the axis title elements.
        if y_axis['formula'] is not None:
            self._write_title_formula(y_axis['formula'],
                                      y_axis['data_id'],
                                      is_y_axis,
                                      y_axis['name_font'],
                                      y_axis['name_layout'])
        elif y_axis['name'] is not None:
            self._write_title_rich(y_axis['name'],
                                   is_y_axis,
                                   y_axis.get('name_font'),
                                   y_axis.get('name_layout'))

        # Write the c:numberFormat element.
        self._write_number_format(y_axis)

        # Write the c:majorTickMark element.
        self._write_major_tick_mark(y_axis.get('major_tick_mark'))

        # Write the c:minorTickMark element.
        self._write_minor_tick_mark(y_axis.get('minor_tick_mark'))

        # Write the c:tickLblPos element.
        self._write_tick_label_pos(y_axis.get('label_position'))

        # Write the c:spPr element for the axis line.
        self._write_sp_pr(y_axis)

        # Write the axis font elements.
        self._write_axis_font(y_axis.get('num_font'))

        # Write the c:crossAx element.
        self._write_cross_axis(axis_ids[0])

        # Note, the category crossing comes from the value axis.
        if (x_axis.get('crossing') is None
                or x_axis['crossing'] == 'max'
                or x_axis['crossing'] == 'min'):

            # Write the c:crosses element.
            self._write_crosses(x_axis.get('crossing'))
        else:

            # Write the c:crossesAt element.
            self._write_c_crosses_at(x_axis.get('crossing'))

        # Write the c:crossBetween element.
        self._write_cross_between(x_axis.get('position_axis'))

        # Write the c:majorUnit element.
        self._write_c_major_unit(y_axis.get('major_unit'))

        # Write the c:minorUnit element.
        self._write_c_minor_unit(y_axis.get('minor_unit'))

        # Write the c:dispUnits element.
        self._write_disp_units(y_axis.get('display_units'),
                               y_axis.get('display_units_visible'))

        self._xml_end_tag('c:valAx')

    def _write_cat_val_axis(self, args):
        # Write the <c:valAx> element. This is for the second valAx
        # in scatter plots. Usually the X axis.
        x_axis = args['x_axis']
        y_axis = args['y_axis']
        axis_ids = args['axis_ids']
        position = args['position'] or self.val_axis_position
        is_y_axis = self.horiz_val_axis

        # If there are no axis_ids then we don't need to write this element.
        if axis_ids is None or not len(axis_ids):
            return

        # Overwrite the default axis position with a user supplied value.
        position = x_axis.get('position') or position

        self._xml_start_tag('c:valAx')

        self._write_axis_id(axis_ids[0])

        # Write the c:scaling element.
        self._write_scaling(x_axis.get('reverse'),
                            x_axis.get('min'),
                            x_axis.get('max'),
                            x_axis.get('log_base'))

        if not x_axis.get('visible'):
            self._write_delete(1)

        # Write the c:axPos element.
        self._write_axis_pos(position, y_axis.get('reverse'))

        # Write the c:majorGridlines element.
        self._write_major_gridlines(x_axis.get('major_gridlines'))

        # Write the c:minorGridlines element.
        self._write_minor_gridlines(x_axis.get('minor_gridlines'))

        # Write the axis title elements.
        if x_axis['formula'] is not None:
            self._write_title_formula(x_axis['formula'],
                                      x_axis['data_id'],
                                      is_y_axis,
                                      x_axis['name_font'],
                                      x_axis['name_layout'])
        elif x_axis['name'] is not None:
            self._write_title_rich(x_axis['name'],
                                   is_y_axis,
                                   x_axis['name_font'],
                                   x_axis['name_layout'])

        # Write the c:numberFormat element.
        self._write_number_format(x_axis)

        # Write the c:majorTickMark element.
        self._write_major_tick_mark(x_axis.get('major_tick_mark'))

        # Write the c:minorTickMark element.
        self._write_minor_tick_mark(x_axis.get('minor_tick_mark'))

        # Write the c:tickLblPos element.
        self._write_tick_label_pos(x_axis.get('label_position'))

        # Write the c:spPr element for the axis line.
        self._write_sp_pr(x_axis)

        # Write the axis font elements.
        self._write_axis_font(x_axis.get('num_font'))

        # Write the c:crossAx element.
        self._write_cross_axis(axis_ids[1])

        # Note, the category crossing comes from the value axis.
        if (y_axis.get('crossing') is None
                or y_axis['crossing'] == 'max'
                or y_axis['crossing'] == 'min'):

            # Write the c:crosses element.
            self._write_crosses(y_axis.get('crossing'))
        else:

            # Write the c:crossesAt element.
            self._write_c_crosses_at(y_axis.get('crossing'))

        # Write the c:crossBetween element.
        self._write_cross_between(y_axis.get('position_axis'))

        # Write the c:majorUnit element.
        self._write_c_major_unit(x_axis.get('major_unit'))

        # Write the c:minorUnit element.
        self._write_c_minor_unit(x_axis.get('minor_unit'))

        # Write the c:dispUnits element.
        self._write_disp_units(x_axis.get('display_units'),
                               x_axis.get('display_units_visible'))

        self._xml_end_tag('c:valAx')

    def _write_date_axis(self, args):
        # Write the <c:dateAx> element. Usually the X axis.
        x_axis = args['x_axis']
        y_axis = args['y_axis']
        axis_ids = args['axis_ids']

        # If there are no axis_ids then we don't need to write this element.
        if axis_ids is None or not len(axis_ids):
            return

        position = self.cat_axis_position

        # Overwrite the default axis position with a user supplied value.
        position = x_axis.get('position') or position

        self._xml_start_tag('c:dateAx')

        self._write_axis_id(axis_ids[0])

        # Write the c:scaling element.
        self._write_scaling(x_axis.get('reverse'),
                            x_axis.get('min'),
                            x_axis.get('max'),
                            x_axis.get('log_base'))

        if not x_axis.get('visible'):
            self._write_delete(1)

        # Write the c:axPos element.
        self._write_axis_pos(position, y_axis.get('reverse'))

        # Write the c:majorGridlines element.
        self._write_major_gridlines(x_axis.get('major_gridlines'))

        # Write the c:minorGridlines element.
        self._write_minor_gridlines(x_axis.get('minor_gridlines'))

        # Write the axis title elements.
        if x_axis['formula'] is not None:
            self._write_title_formula(x_axis['formula'],
                                      x_axis['data_id'],
                                      None,
                                      x_axis['name_font'],
                                      x_axis['name_layout'])
        elif x_axis['name'] is not None:
            self._write_title_rich(x_axis['name'],
                                   None,
                                   x_axis['name_font'],
                                   x_axis['name_layout'])

        # Write the c:numFmt element.
        self._write_number_format(x_axis)

        # Write the c:majorTickMark element.
        self._write_major_tick_mark(x_axis.get('major_tick_mark'))

        # Write the c:minorTickMark element.
        self._write_minor_tick_mark(x_axis.get('minor_tick_mark'))

        # Write the c:tickLblPos element.
        self._write_tick_label_pos(x_axis.get('label_position'))

        # Write the c:spPr element for the axis line.
        self._write_sp_pr(x_axis)

        # Write the axis font elements.
        self._write_axis_font(x_axis.get('num_font'))

        # Write the c:crossAx element.
        self._write_cross_axis(axis_ids[1])

        if self.show_crosses or x_axis.get('visible'):

            # Note, the category crossing comes from the value axis.
            if (y_axis.get('crossing') is None
                    or y_axis.get('crossing') == 'max'
                    or y_axis['crossing'] == 'min'):

                # Write the c:crosses element.
                self._write_crosses(y_axis.get('crossing'))
            else:

                # Write the c:crossesAt element.
                self._write_c_crosses_at(y_axis.get('crossing'))

        # Write the c:auto element.
        self._write_auto(1)

        # Write the c:labelOffset element.
        self._write_label_offset(100)

        # Write the c:tickLblSkip element.
        self._write_c_tick_lbl_skip(x_axis.get('interval_unit'))

        # Write the c:tickMarkSkip element.
        self._write_c_tick_mark_skip(x_axis.get('interval_tick'))

        # Write the c:majorUnit element.
        self._write_c_major_unit(x_axis.get('major_unit'))

        # Write the c:majorTimeUnit element.
        if x_axis.get('major_unit'):
            self._write_c_major_time_unit(x_axis['major_unit_type'])

        # Write the c:minorUnit element.
        self._write_c_minor_unit(x_axis.get('minor_unit'))

        # Write the c:minorTimeUnit element.
        if x_axis.get('minor_unit'):
            self._write_c_minor_time_unit(x_axis['minor_unit_type'])

        self._xml_end_tag('c:dateAx')

    def _write_scaling(self, reverse, min_val, max_val, log_base):
        # Write the <c:scaling> element.

        self._xml_start_tag('c:scaling')

        # Write the c:logBase element.
        self._write_c_log_base(log_base)

        # Write the c:orientation element.
        self._write_orientation(reverse)

        # Write the c:max element.
        self._write_c_max(max_val)

        # Write the c:min element.
        self._write_c_min(min_val)

        self._xml_end_tag('c:scaling')

    def _write_c_log_base(self, val):
        # Write the <c:logBase> element.

        if not val:
            return

        attributes = [('val', val)]

        self._xml_empty_tag('c:logBase', attributes)

    def _write_orientation(self, reverse):
        # Write the <c:orientation> element.
        val = 'minMax'

        if reverse:
            val = 'maxMin'

        attributes = [('val', val)]

        self._xml_empty_tag('c:orientation', attributes)

    def _write_c_max(self, max_val):
        # Write the <c:max> element.

        if max_val is None:
            return

        attributes = [('val', max_val)]

        self._xml_empty_tag('c:max', attributes)

    def _write_c_min(self, min_val):
        # Write the <c:min> element.

        if min_val is None:
            return

        attributes = [('val', min_val)]

        self._xml_empty_tag('c:min', attributes)

    def _write_axis_pos(self, val, reverse):
        # Write the <c:axPos> element.

        if reverse:
            if val == 'l':
                val = 'r'
            if val == 'b':
                val = 't'

        attributes = [('val', val)]

        self._xml_empty_tag('c:axPos', attributes)

    def _write_number_format(self, axis):
        # Write the <c:numberFormat> element. Note: It is assumed that if
        # a user defined number format is supplied (i.e., non-default) then
        # the sourceLinked attribute is 0.
        # The user can override this if required.
        format_code = axis.get('num_format')
        source_linked = 1

        # Check if a user defined number format has been set.
        if (format_code is not None
                and format_code != axis['defaults']['num_format']):
            source_linked = 0

        # User override of sourceLinked.
        if axis.get('num_format_linked'):
            source_linked = 1

        attributes = [
            ('formatCode', format_code),
            ('sourceLinked', source_linked),
        ]

        self._xml_empty_tag('c:numFmt', attributes)

    def _write_cat_number_format(self, axis):
        # Write the <c:numFmt> element. Special case handler for category
        # axes which don't always have a number format.
        format_code = axis.get('num_format')
        source_linked = 1
        default_format = 1

        # Check if a user defined number format has been set.
        if (format_code is not None
                and format_code != axis['defaults']['num_format']):
            source_linked = 0
            default_format = 0

        # User override of sourceLinked.
        if axis.get('num_format_linked'):
            source_linked = 1

        # Skip if cat doesn't have a num format (unless it is non-default).
        if not self.cat_has_num_fmt and default_format:
            return

        attributes = [
            ('formatCode', format_code),
            ('sourceLinked', source_linked),
        ]

        self._xml_empty_tag('c:numFmt', attributes)

    def _write_data_label_number_format(self, format_code):
        # Write the <c:numberFormat> element for data labels.
        source_linked = 0

        attributes = [
            ('formatCode', format_code),
            ('sourceLinked', source_linked),
        ]

        self._xml_empty_tag('c:numFmt', attributes)

    def _write_major_tick_mark(self, val):
        # Write the <c:majorTickMark> element.

        if not val:
            return

        attributes = [('val', val)]

        self._xml_empty_tag('c:majorTickMark', attributes)

    def _write_minor_tick_mark(self, val):
        # Write the <c:minorTickMark> element.

        if not val:
            return

        attributes = [('val', val)]

        self._xml_empty_tag('c:minorTickMark', attributes)

    def _write_tick_label_pos(self, val=None):
        # Write the <c:tickLblPos> element.
        if val is None or val == 'next_to':
            val = 'nextTo'

        attributes = [('val', val)]

        self._xml_empty_tag('c:tickLblPos', attributes)

    def _write_cross_axis(self, val):
        # Write the <c:crossAx> element.

        attributes = [('val', val)]

        self._xml_empty_tag('c:crossAx', attributes)

    def _write_crosses(self, val=None):
        # Write the <c:crosses> element.
        if val is None:
            val = 'autoZero'

        attributes = [('val', val)]

        self._xml_empty_tag('c:crosses', attributes)

    def _write_c_crosses_at(self, val):
        # Write the <c:crossesAt> element.

        attributes = [('val', val)]

        self._xml_empty_tag('c:crossesAt', attributes)

    def _write_auto(self, val):
        # Write the <c:auto> element.

        attributes = [('val', val)]

        self._xml_empty_tag('c:auto', attributes)

    def _write_label_align(self, val=None):
        # Write the <c:labelAlign> element.

        if val is None:
            val = 'ctr'

        if val == 'right':
            val = 'r'

        if val == 'left':
            val = 'l'

        attributes = [('val', val)]

        self._xml_empty_tag('c:lblAlgn', attributes)

    def _write_label_offset(self, val):
        # Write the <c:labelOffset> element.

        attributes = [('val', val)]

        self._xml_empty_tag('c:lblOffset', attributes)

    def _write_c_tick_lbl_skip(self, val):
        # Write the <c:tickLblSkip> element.
        if val is None:
            return

        attributes = [('val', val)]

        self._xml_empty_tag('c:tickLblSkip', attributes)

    def _write_c_tick_mark_skip(self, val):
        # Write the <c:tickMarkSkip> element.
        if val is None:
            return

        attributes = [('val', val)]

        self._xml_empty_tag('c:tickMarkSkip', attributes)

    def _write_major_gridlines(self, gridlines):
        # Write the <c:majorGridlines> element.

        if not gridlines:
            return

        if not gridlines['visible']:
            return

        if gridlines['line']['defined']:
            self._xml_start_tag('c:majorGridlines')

            # Write the c:spPr element.
            self._write_sp_pr(gridlines)

            self._xml_end_tag('c:majorGridlines')
        else:
            self._xml_empty_tag('c:majorGridlines')

    def _write_minor_gridlines(self, gridlines):
        # Write the <c:minorGridlines> element.

        if not gridlines:
            return

        if not gridlines['visible']:
            return

        if gridlines['line']['defined']:
            self._xml_start_tag('c:minorGridlines')

            # Write the c:spPr element.
            self._write_sp_pr(gridlines)

            self._xml_end_tag('c:minorGridlines')
        else:
            self._xml_empty_tag('c:minorGridlines')

    def _write_cross_between(self, val):
        # Write the <c:crossBetween> element.
        if val is None:
            val = self.cross_between

        attributes = [('val', val)]

        self._xml_empty_tag('c:crossBetween', attributes)

    def _write_c_major_unit(self, val):
        # Write the <c:majorUnit> element.

        if not val:
            return

        attributes = [('val', val)]

        self._xml_empty_tag('c:majorUnit', attributes)

    def _write_c_minor_unit(self, val):
        # Write the <c:minorUnit> element.

        if not val:
            return

        attributes = [('val', val)]

        self._xml_empty_tag('c:minorUnit', attributes)

    def _write_c_major_time_unit(self, val=None):
        # Write the <c:majorTimeUnit> element.
        if val is None:
            val = 'days'

        attributes = [('val', val)]

        self._xml_empty_tag('c:majorTimeUnit', attributes)

    def _write_c_minor_time_unit(self, val=None):
        # Write the <c:minorTimeUnit> element.
        if val is None:
            val = 'days'

        attributes = [('val', val)]

        self._xml_empty_tag('c:minorTimeUnit', attributes)

    def _write_legend(self):
        # Write the <c:legend> element.
        legend = self.legend
        position = legend.get('position', 'right')
        font = legend.get('font')
        delete_series = []
        overlay = 0

        if (legend.get('delete_series')
                and type(legend['delete_series']) is list):
            delete_series = legend['delete_series']

        if position.startswith('overlay_'):
            position = position.replace('overlay_', '')
            overlay = 1

        allowed = {
            'right': 'r',
            'left': 'l',
            'top': 't',
            'bottom': 'b',
            'top_right': 'tr',
        }

        if position == 'none':
            return

        if position not in allowed:
            return

        position = allowed[position]

        self._xml_start_tag('c:legend')

        # Write the c:legendPos element.
        self._write_legend_pos(position)

        # Remove series labels from the legend.
        for index in delete_series:
            # Write the c:legendEntry element.
            self._write_legend_entry(index)

        # Write the c:layout element.
        self._write_layout(legend.get('layout'), 'legend')

        # Write the c:overlay element.
        if overlay:
            self._write_overlay()

        if font:
            self._write_tx_pr(font)

        # Write the c:spPr element.
        self._write_sp_pr(legend)

        self._xml_end_tag('c:legend')

    def _write_legend_pos(self, val):
        # Write the <c:legendPos> element.

        attributes = [('val', val)]

        self._xml_empty_tag('c:legendPos', attributes)

    def _write_legend_entry(self, index):
        # Write the <c:legendEntry> element.

        self._xml_start_tag('c:legendEntry')

        # Write the c:idx element.
        self._write_idx(index)

        # Write the c:delete element.
        self._write_delete(1)

        self._xml_end_tag('c:legendEntry')

    def _write_overlay(self):
        # Write the <c:overlay> element.
        val = 1

        attributes = [('val', val)]

        self._xml_empty_tag('c:overlay', attributes)

    def _write_plot_vis_only(self):
        # Write the <c:plotVisOnly> element.
        val = 1

        # Ignore this element if we are plotting hidden data.
        if self.show_hidden:
            return

        attributes = [('val', val)]

        self._xml_empty_tag('c:plotVisOnly', attributes)

    def _write_print_settings(self):
        # Write the <c:printSettings> element.
        self._xml_start_tag('c:printSettings')

        # Write the c:headerFooter element.
        self._write_header_footer()

        # Write the c:pageMargins element.
        self._write_page_margins()

        # Write the c:pageSetup element.
        self._write_page_setup()

        self._xml_end_tag('c:printSettings')

    def _write_header_footer(self):
        # Write the <c:headerFooter> element.
        self._xml_empty_tag('c:headerFooter')

    def _write_page_margins(self):
        # Write the <c:pageMargins> element.
        bottom = 0.75
        left = 0.7
        right = 0.7
        top = 0.75
        header = 0.3
        footer = 0.3

        attributes = [
            ('b', bottom),
            ('l', left),
            ('r', right),
            ('t', top),
            ('header', header),
            ('footer', footer),
        ]

        self._xml_empty_tag('c:pageMargins', attributes)

    def _write_page_setup(self):
        # Write the <c:pageSetup> element.
        self._xml_empty_tag('c:pageSetup')

    def _write_c_auto_title_deleted(self):
        # Write the <c:autoTitleDeleted> element.
        self._xml_empty_tag('c:autoTitleDeleted', [('val', 1)])

    def _write_title_rich(self, title, is_y_axis, font, layout, overlay=False):
        # Write the <c:title> element for a rich string.

        self._xml_start_tag('c:title')

        # Write the c:tx element.
        self._write_tx_rich(title, is_y_axis, font)

        # Write the c:layout element.
        self._write_layout(layout, 'text')

        # Write the c:overlay element.
        if overlay:
            self._write_overlay()

        self._xml_end_tag('c:title')

    def _write_title_formula(self, title, data_id, is_y_axis, font, layout,
                             overlay=False):
        # Write the <c:title> element for a rich string.

        self._xml_start_tag('c:title')

        # Write the c:tx element.
        self._write_tx_formula(title, data_id)

        # Write the c:layout element.
        self._write_layout(layout, 'text')

        # Write the c:overlay element.
        if overlay:
            self._write_overlay()

        # Write the c:txPr element.
        self._write_tx_pr(font, is_y_axis)

        self._xml_end_tag('c:title')

    def _write_tx_rich(self, title, is_y_axis, font):
        # Write the <c:tx> element.

        self._xml_start_tag('c:tx')

        # Write the c:rich element.
        self._write_rich(title, font, is_y_axis, ignore_rich_pr=False)

        self._xml_end_tag('c:tx')

    def _write_tx_value(self, title):
        # Write the <c:tx> element with a value such as for series names.

        self._xml_start_tag('c:tx')

        # Write the c:v element.
        self._write_v(title)

        self._xml_end_tag('c:tx')

    def _write_tx_formula(self, title, data_id):
        # Write the <c:tx> element.
        data = None

        if data_id is not None:
            data = self.formula_data[data_id]

        self._xml_start_tag('c:tx')

        # Write the c:strRef element.
        self._write_str_ref(title, data, 'str')

        self._xml_end_tag('c:tx')

    def _write_rich(self, title, font, is_y_axis, ignore_rich_pr):
        # Write the <c:rich> element.

        if font and font.get('rotation') is not None:
            rotation = font['rotation']
        else:
            rotation = None

        self._xml_start_tag('c:rich')

        # Write the a:bodyPr element.
        self._write_a_body_pr(rotation, is_y_axis)

        # Write the a:lstStyle element.
        self._write_a_lst_style()

        # Write the a:p element.
        self._write_a_p_rich(title, font, ignore_rich_pr)

        self._xml_end_tag('c:rich')

    def _write_a_body_pr(self, rotation, is_y_axis):
        # Write the <a:bodyPr> element.
        attributes = []

        if rotation is None and is_y_axis:
            rotation = -5400000

        if rotation is not None:
            if rotation == 16200000:
                # 270 deg/stacked angle.
                attributes.append(('rot', 0))
                attributes.append(('vert', 'wordArtVert'))
            elif rotation == 16260000:
                # 271 deg/East Asian vertical.
                attributes.append(('rot', 0))
                attributes.append(('vert', 'eaVert'))
            else:
                attributes.append(('rot', rotation))
                attributes.append(('vert', 'horz'))

        self._xml_empty_tag('a:bodyPr', attributes)

    def _write_a_lst_style(self):
        # Write the <a:lstStyle> element.
        self._xml_empty_tag('a:lstStyle')

    def _write_a_p_rich(self, title, font, ignore_rich_pr):
        # Write the <a:p> element for rich string titles.

        self._xml_start_tag('a:p')

        # Write the a:pPr element.
        if not ignore_rich_pr:
            self._write_a_p_pr_rich(font)

        # Write the a:r element.
        self._write_a_r(title, font)

        self._xml_end_tag('a:p')

    def _write_a_p_formula(self, font):
        # Write the <a:p> element for formula titles.

        self._xml_start_tag('a:p')

        # Write the a:pPr element.
        self._write_a_p_pr_formula(font)

        # Write the a:endParaRPr element.
        self._write_a_end_para_rpr()

        self._xml_end_tag('a:p')

    def _write_a_p_pr_rich(self, font):
        # Write the <a:pPr> element for rich string titles.

        self._xml_start_tag('a:pPr')

        # Write the a:defRPr element.
        self._write_a_def_rpr(font)

        self._xml_end_tag('a:pPr')

    def _write_a_p_pr_formula(self, font):
        # Write the <a:pPr> element for formula titles.

        self._xml_start_tag('a:pPr')

        # Write the a:defRPr element.
        self._write_a_def_rpr(font)

        self._xml_end_tag('a:pPr')

    def _write_a_def_rpr(self, font):
        # Write the <a:defRPr> element.
        has_color = 0

        style_attributes = Shape._get_font_style_attributes(font)
        latin_attributes = Shape._get_font_latin_attributes(font)

        if font and font.get('color') is not None:
            has_color = 1

        if latin_attributes or has_color:
            self._xml_start_tag('a:defRPr', style_attributes)

            if has_color:
                self._write_a_solid_fill({'color': font['color']})

            if latin_attributes:
                self._write_a_latin(latin_attributes)

            self._xml_end_tag('a:defRPr')
        else:
            self._xml_empty_tag('a:defRPr', style_attributes)

    def _write_a_end_para_rpr(self):
        # Write the <a:endParaRPr> element.
        lang = 'en-US'

        attributes = [('lang', lang)]

        self._xml_empty_tag('a:endParaRPr', attributes)

    def _write_a_r(self, title, font):
        # Write the <a:r> element.

        self._xml_start_tag('a:r')

        # Write the a:rPr element.
        self._write_a_r_pr(font)

        # Write the a:t element.
        self._write_a_t(title)

        self._xml_end_tag('a:r')

    def _write_a_r_pr(self, font):
        # Write the <a:rPr> element.
        has_color = 0
        lang = 'en-US'

        style_attributes = Shape._get_font_style_attributes(font)
        latin_attributes = Shape._get_font_latin_attributes(font)

        if font and font['color'] is not None:
            has_color = 1

        # Add the lang type to the attributes.
        style_attributes.insert(0, ('lang', lang))

        if latin_attributes or has_color:
            self._xml_start_tag('a:rPr', style_attributes)

            if has_color:
                self._write_a_solid_fill({'color': font['color']})

            if latin_attributes:
                self._write_a_latin(latin_attributes)

            self._xml_end_tag('a:rPr')
        else:
            self._xml_empty_tag('a:rPr', style_attributes)

    def _write_a_t(self, title):
        # Write the <a:t> element.

        self._xml_data_element('a:t', title)

    def _write_tx_pr(self, font, is_y_axis=False):
        # Write the <c:txPr> element.

        if font and font.get('rotation') is not None:
            rotation = font['rotation']
        else:
            rotation = None

        self._xml_start_tag('c:txPr')

        # Write the a:bodyPr element.
        self._write_a_body_pr(rotation, is_y_axis)

        # Write the a:lstStyle element.
        self._write_a_lst_style()

        # Write the a:p element.
        self._write_a_p_formula(font)

        self._xml_end_tag('c:txPr')

    def _write_marker(self, marker):
        # Write the <c:marker> element.
        if marker is None:
            marker = self.default_marker

        if not marker:
            return

        if marker['type'] == 'automatic':
            return

        self._xml_start_tag('c:marker')

        # Write the c:symbol element.
        self._write_symbol(marker['type'])

        # Write the c:size element.
        if marker.get('size'):
            self._write_marker_size(marker['size'])

        # Write the c:spPr element.
        self._write_sp_pr(marker)

        self._xml_end_tag('c:marker')

    def _write_marker_size(self, val):
        # Write the <c:size> element.

        attributes = [('val', val)]

        self._xml_empty_tag('c:size', attributes)

    def _write_symbol(self, val):
        # Write the <c:symbol> element.

        attributes = [('val', val)]

        self._xml_empty_tag('c:symbol', attributes)

    def _write_sp_pr(self, series):
        # Write the <c:spPr> element.

        if not self._has_fill_formatting(series):
            return

        self._xml_start_tag('c:spPr')

        # Write the fill elements for solid charts such as pie and bar.
        if series.get('fill') and series['fill']['defined']:
            if 'none' in series['fill']:
                # Write the a:noFill element.
                self._write_a_no_fill()
            else:
                # Write the a:solidFill element.
                self._write_a_solid_fill(series['fill'])

        if series.get('pattern'):
            # Write the a:gradFill element.
            self._write_a_patt_fill(series['pattern'])

        if series.get('gradient'):
            # Write the a:gradFill element.
            self._write_a_grad_fill(series['gradient'])

        # Write the a:ln element.
        if series.get('line') and series['line']['defined']:
            self._write_a_ln(series['line'])

        self._xml_end_tag('c:spPr')

    def _write_a_ln(self, line):
        # Write the <a:ln> element.
        attributes = []

        # Add the line width as an attribute.
        width = line.get('width')

        if width:
            # Round width to nearest 0.25, like Excel.
            width = int((width + 0.125) * 4) / 4.0

            # Convert to internal units.
            width = int(0.5 + (12700 * width))

            attributes = [('w', width)]

        self._xml_start_tag('a:ln', attributes)

        # Write the line fill.
        if 'none' in line:
            # Write the a:noFill element.
            self._write_a_no_fill()
        elif 'color' in line:
            # Write the a:solidFill element.
            self._write_a_solid_fill(line)

        # Write the line/dash type.
        line_type = line.get('dash_type')
        if line_type:
            # Write the a:prstDash element.
            self._write_a_prst_dash(line_type)

        self._xml_end_tag('a:ln')

    def _write_a_no_fill(self):
        # Write the <a:noFill> element.
        self._xml_empty_tag('a:noFill')

    def _write_a_solid_fill(self, fill):
        # Write the <a:solidFill> element.

        self._xml_start_tag('a:solidFill')

        if 'color' in fill:
            color = get_rgb_color(fill['color'])
            transparency = fill.get('transparency')
            # Write the a:srgbClr element.
            self._write_a_srgb_clr(color, transparency)

        self._xml_end_tag('a:solidFill')

    def _write_a_srgb_clr(self, val, transparency=None):
        # Write the <a:srgbClr> element.
        attributes = [('val', val)]

        if transparency:
            self._xml_start_tag('a:srgbClr', attributes)

            # Write the a:alpha element.
            self._write_a_alpha(transparency)

            self._xml_end_tag('a:srgbClr')
        else:
            self._xml_empty_tag('a:srgbClr', attributes)

    def _write_a_alpha(self, val):
        # Write the <a:alpha> element.

        val = int((100 - int(val)) * 1000)

        attributes = [('val', val)]

        self._xml_empty_tag('a:alpha', attributes)

    def _write_a_prst_dash(self, val):
        # Write the <a:prstDash> element.

        attributes = [('val', val)]

        self._xml_empty_tag('a:prstDash', attributes)

    def _write_trendline(self, trendline):
        # Write the <c:trendline> element.

        if not trendline:
            return

        self._xml_start_tag('c:trendline')

        # Write the c:name element.
        self._write_name(trendline.get('name'))

        # Write the c:spPr element.
        self._write_sp_pr(trendline)

        # Write the c:trendlineType element.
        self._write_trendline_type(trendline['type'])

        # Write the c:order element for polynomial trendlines.
        if trendline['type'] == 'poly':
            self._write_trendline_order(trendline.get('order'))

        # Write the c:period element for moving average trendlines.
        if trendline['type'] == 'movingAvg':
            self._write_period(trendline.get('period'))

        # Write the c:forward element.
        self._write_forward(trendline.get('forward'))

        # Write the c:backward element.
        self._write_backward(trendline.get('backward'))

        if 'intercept' in trendline:
            # Write the c:intercept element.
            self._write_c_intercept(trendline['intercept'])

        if trendline.get('display_r_squared'):
            # Write the c:dispRSqr element.
            self._write_c_disp_rsqr()

        if trendline.get('display_equation'):
            # Write the c:dispEq element.
            self._write_c_disp_eq()

            # Write the c:trendlineLbl element.
            self._write_c_trendline_lbl()

        self._xml_end_tag('c:trendline')

    def _write_trendline_type(self, val):
        # Write the <c:trendlineType> element.

        attributes = [('val', val)]

        self._xml_empty_tag('c:trendlineType', attributes)

    def _write_name(self, data):
        # Write the <c:name> element.

        if data is None:
            return

        self._xml_data_element('c:name', data)

    def _write_trendline_order(self, val):
        # Write the <c:order> element.
        if val < 2:
            val = 2

        attributes = [('val', val)]

        self._xml_empty_tag('c:order', attributes)

    def _write_period(self, val):
        # Write the <c:period> element.
        if val < 2:
            val = 2

        attributes = [('val', val)]

        self._xml_empty_tag('c:period', attributes)

    def _write_forward(self, val):
        # Write the <c:forward> element.

        if not val:
            return

        attributes = [('val', val)]

        self._xml_empty_tag('c:forward', attributes)

    def _write_backward(self, val):
        # Write the <c:backward> element.

        if not val:
            return

        attributes = [('val', val)]

        self._xml_empty_tag('c:backward', attributes)

    def _write_c_intercept(self, val):
        # Write the <c:intercept> element.
        attributes = [('val', val)]

        self._xml_empty_tag('c:intercept', attributes)

    def _write_c_disp_eq(self):
        # Write the <c:dispEq> element.
        attributes = [('val', 1)]

        self._xml_empty_tag('c:dispEq', attributes)

    def _write_c_disp_rsqr(self):
        # Write the <c:dispRSqr> element.
        attributes = [('val', 1)]

        self._xml_empty_tag('c:dispRSqr', attributes)

    def _write_c_trendline_lbl(self):
        # Write the <c:trendlineLbl> element.
        self._xml_start_tag('c:trendlineLbl')

        # Write the c:layout element.
        self._write_layout(None, None)

        # Write the c:numFmt element.
        self._write_trendline_num_fmt()

        self._xml_end_tag('c:trendlineLbl')

    def _write_trendline_num_fmt(self):
        # Write the <c:numFmt> element.
        attributes = [
            ('formatCode', 'General'),
            ('sourceLinked', 0),
        ]

        self._xml_empty_tag('c:numFmt', attributes)

    def _write_hi_low_lines(self):
        # Write the <c:hiLowLines> element.
        hi_low_lines = self.hi_low_lines

        if hi_low_lines is None:
            return

        if 'line' in hi_low_lines and hi_low_lines['line']['defined']:

            self._xml_start_tag('c:hiLowLines')

            # Write the c:spPr element.
            self._write_sp_pr(hi_low_lines)

            self._xml_end_tag('c:hiLowLines')
        else:
            self._xml_empty_tag('c:hiLowLines')

    def _write_drop_lines(self):
        # Write the <c:dropLines> element.
        drop_lines = self.drop_lines

        if drop_lines is None:
            return

        if drop_lines['line']['defined']:

            self._xml_start_tag('c:dropLines')

            # Write the c:spPr element.
            self._write_sp_pr(drop_lines)

            self._xml_end_tag('c:dropLines')
        else:
            self._xml_empty_tag('c:dropLines')

    def _write_overlap(self, val):
        # Write the <c:overlap> element.

        if val is None:
            return

        attributes = [('val', val)]

        self._xml_empty_tag('c:overlap', attributes)

    def _write_num_cache(self, data):
        # Write the <c:numCache> element.
        if data:
            count = len(data)
        else:
            count = 0

        self._xml_start_tag('c:numCache')

        # Write the c:formatCode element.
        self._write_format_code('General')

        # Write the c:ptCount element.
        self._write_pt_count(count)

        for i in range(count):
            token = data[i]

            if token is None:
                continue

            try:
                float(token)
            except ValueError:
                # Write non-numeric data as 0.
                token = 0

            # Write the c:pt element.
            self._write_pt(i, token)

        self._xml_end_tag('c:numCache')

    def _write_str_cache(self, data):
        # Write the <c:strCache> element.
        count = len(data)

        self._xml_start_tag('c:strCache')

        # Write the c:ptCount element.
        self._write_pt_count(count)

        for i in range(count):
            # Write the c:pt element.
            self._write_pt(i, data[i])

        self._xml_end_tag('c:strCache')

    def _write_format_code(self, data):
        # Write the <c:formatCode> element.

        self._xml_data_element('c:formatCode', data)

    def _write_pt_count(self, val):
        # Write the <c:ptCount> element.

        attributes = [('val', val)]

        self._xml_empty_tag('c:ptCount', attributes)

    def _write_pt(self, idx, value):
        # Write the <c:pt> element.

        if value is None:
            return

        attributes = [('idx', idx)]

        self._xml_start_tag('c:pt', attributes)

        # Write the c:v element.
        self._write_v(value)

        self._xml_end_tag('c:pt')

    def _write_v(self, data):
        # Write the <c:v> element.

        self._xml_data_element('c:v', data)

    def _write_protection(self):
        # Write the <c:protection> element.
        if not self.protection:
            return

        self._xml_empty_tag('c:protection')

    def _write_d_pt(self, points):
        # Write the <c:dPt> elements.
        index = -1

        if not points:
            return

        for point in points:
            index += 1
            if not point:
                continue

            self._write_d_pt_point(index, point)

    def _write_d_pt_point(self, index, point):
        # Write an individual <c:dPt> element.

        self._xml_start_tag('c:dPt')

        # Write the c:idx element.
        self._write_idx(index)

        # Write the c:spPr element.
        self._write_sp_pr(point)

        self._xml_end_tag('c:dPt')

    def _write_d_lbls(self, labels):
        # Write the <c:dLbls> element.

        if not labels:
            return

        self._xml_start_tag('c:dLbls')

        # Write the custom c:dLbl elements.
        if labels.get('custom'):
            self._write_custom_labels(labels, labels['custom'])

        # Write the c:numFmt element.
        if labels.get('num_format'):
            self._write_data_label_number_format(labels['num_format'])

        # Write the c:spPr element for the plotarea formatting.
        self._write_sp_pr(labels)

        # Write the data label font elements.
        if labels.get('font'):
            self._write_axis_font(labels['font'])

        # Write the c:dLblPos element.
        if labels.get('position'):
            self._write_d_lbl_pos(labels['position'])

        # Write the c:showLegendKey element.
        if labels.get('legend_key'):
            self._write_show_legend_key()

        # Write the c:showVal element.
        if labels.get('value'):
            self._write_show_val()

        # Write the c:showCatName element.
        if labels.get('category'):
            self._write_show_cat_name()

        # Write the c:showSerName element.
        if labels.get('series_name'):
            self._write_show_ser_name()

        # Write the c:showPercent element.
        if labels.get('percentage'):
            self._write_show_percent()

        # Write the c:separator element.
        if labels.get('separator'):
            self._write_separator(labels['separator'])

        # Write the c:showLeaderLines element.
        if labels.get('leader_lines'):
            self._write_show_leader_lines()

        self._xml_end_tag('c:dLbls')

    def _write_custom_labels(self, parent, labels):
        # Write the <c:showLegendKey> element.
        index = 0

        for label in labels:
            index += 1

            if label is None:
                continue

            self._xml_start_tag('c:dLbl')

            # Write the c:idx element.
            self._write_idx(index - 1)

            delete_label = label.get('delete')

            if delete_label:
                self._write_delete(1)

            elif label.get('formula'):
                self._write_custom_label_formula(label)

                if parent.get('position'):
                    self._write_d_lbl_pos(parent['position'])

                if parent.get('value'):
                    self._write_show_val()
                if parent.get('category'):
                    self._write_show_cat_name()
                if parent.get('series_name'):
                    self._write_show_ser_name()

            elif label.get('value'):
                self._write_custom_label_str(label)

                if parent.get('position'):
                    self._write_d_lbl_pos(parent['position'])

                if parent.get('value'):
                    self._write_show_val()
                if parent.get('category'):
                    self._write_show_cat_name()
                if parent.get('series_name'):
                    self._write_show_ser_name()
            else:
                self._write_custom_label_format_only(label)

            self._xml_end_tag('c:dLbl')

    def _write_custom_label_str(self, label):
        # Write parts of the <c:dLbl> element for strings.
        title = label.get('value')
        font = label.get('font')
        has_formatting = self._has_fill_formatting(label)

        # Write the c:layout element.
        self._write_layout(None, None)

        self._xml_start_tag('c:tx')

        # Write the c:rich element.
        self._write_rich(title, font, False, not has_formatting)

        self._xml_end_tag('c:tx')

        # Write the c:spPr element.
        self._write_sp_pr(label)

    def _write_custom_label_formula(self, label):
        # Write parts of the <c:dLbl> element for formulas.
        font = label.get('font')
        formula = label.get('formula')
        data_id = label.get('data_id')
        has_formatting = self._has_fill_formatting(label)
        data = None

        if data_id is not None:
            data = self.formula_data[data_id]

        # Write the c:layout element.
        self._write_layout(None, None)

        self._xml_start_tag('c:tx')

        # Write the c:strRef element.
        self._write_str_ref(formula, data, 'str')

        self._xml_end_tag('c:tx')

        # Write the data label formatting, if any.
        self._write_custom_label_format_only(label)

    def _write_custom_label_format_only(self, label):
        # Write parts of the <c:dLbl> labels with changed formatting.
        font = label.get('font')
        has_formatting = self._has_fill_formatting(label)

        if has_formatting:
            self._write_sp_pr(label)
            self._write_tx_pr(font)
        elif font:
            self._xml_empty_tag('c:spPr')
            self._write_tx_pr(font)

    def _write_show_legend_key(self):
        # Write the <c:showLegendKey> element.
        val = '1'

        attributes = [('val', val)]

        self._xml_empty_tag('c:showLegendKey', attributes)

    def _write_show_val(self):
        # Write the <c:showVal> element.
        val = 1

        attributes = [('val', val)]

        self._xml_empty_tag('c:showVal', attributes)

    def _write_show_cat_name(self):
        # Write the <c:showCatName> element.
        val = 1

        attributes = [('val', val)]

        self._xml_empty_tag('c:showCatName', attributes)

    def _write_show_ser_name(self):
        # Write the <c:showSerName> element.
        val = 1

        attributes = [('val', val)]

        self._xml_empty_tag('c:showSerName', attributes)

    def _write_show_percent(self):
        # Write the <c:showPercent> element.
        val = 1

        attributes = [('val', val)]

        self._xml_empty_tag('c:showPercent', attributes)

    def _write_separator(self, data):
        # Write the <c:separator> element.
        self._xml_data_element('c:separator', data)

    def _write_show_leader_lines(self):
        # Write the <c:showLeaderLines> element.
        val = 1

        attributes = [('val', val)]

        self._xml_empty_tag('c:showLeaderLines', attributes)

    def _write_d_lbl_pos(self, val):
        # Write the <c:dLblPos> element.

        attributes = [('val', val)]

        self._xml_empty_tag('c:dLblPos', attributes)

    def _write_delete(self, val):
        # Write the <c:delete> element.

        attributes = [('val', val)]

        self._xml_empty_tag('c:delete', attributes)

    def _write_c_invert_if_negative(self, invert):
        # Write the <c:invertIfNegative> element.
        val = 1

        if not invert:
            return

        attributes = [('val', val)]

        self._xml_empty_tag('c:invertIfNegative', attributes)

    def _write_axis_font(self, font):
        # Write the axis font elements.

        if not font:
            return

        self._xml_start_tag('c:txPr')
        self._write_a_body_pr(font.get('rotation'), None)
        self._write_a_lst_style()
        self._xml_start_tag('a:p')

        self._write_a_p_pr_rich(font)

        self._write_a_end_para_rpr()
        self._xml_end_tag('a:p')
        self._xml_end_tag('c:txPr')

    def _write_a_latin(self, attributes):
        # Write the <a:latin> element.
        self._xml_empty_tag('a:latin', attributes)

    def _write_d_table(self):
        # Write the <c:dTable> element.
        table = self.table

        if not table:
            return

        self._xml_start_tag('c:dTable')

        if table['horizontal']:
            # Write the c:showHorzBorder element.
            self._write_show_horz_border()

        if table['vertical']:
            # Write the c:showVertBorder element.
            self._write_show_vert_border()

        if table['outline']:
            # Write the c:showOutline element.
            self._write_show_outline()

        if table['show_keys']:
            # Write the c:showKeys element.
            self._write_show_keys()

        if table['font']:
            # Write the table font.
            self._write_tx_pr(table['font'])

        self._xml_end_tag('c:dTable')

    def _write_show_horz_border(self):
        # Write the <c:showHorzBorder> element.
        attributes = [('val', 1)]

        self._xml_empty_tag('c:showHorzBorder', attributes)

    def _write_show_vert_border(self):
        # Write the <c:showVertBorder> element.
        attributes = [('val', 1)]

        self._xml_empty_tag('c:showVertBorder', attributes)

    def _write_show_outline(self):
        # Write the <c:showOutline> element.
        attributes = [('val', 1)]

        self._xml_empty_tag('c:showOutline', attributes)

    def _write_show_keys(self):
        # Write the <c:showKeys> element.
        attributes = [('val', 1)]

        self._xml_empty_tag('c:showKeys', attributes)

    def _write_error_bars(self, error_bars):
        # Write the X and Y error bars.

        if not error_bars:
            return

        if error_bars['x_error_bars']:
            self._write_err_bars('x', error_bars['x_error_bars'])

        if error_bars['y_error_bars']:
            self._write_err_bars('y', error_bars['y_error_bars'])

    def _write_err_bars(self, direction, error_bars):
        # Write the <c:errBars> element.

        if not error_bars:
            return

        self._xml_start_tag('c:errBars')

        # Write the c:errDir element.
        self._write_err_dir(direction)

        # Write the c:errBarType element.
        self._write_err_bar_type(error_bars['direction'])

        # Write the c:errValType element.
        self._write_err_val_type(error_bars['type'])

        if not error_bars['endcap']:
            # Write the c:noEndCap element.
            self._write_no_end_cap()

        if error_bars['type'] == 'stdErr':
            # Don't need to write a c:errValType tag.
            pass
        elif error_bars['type'] == 'cust':
            # Write the custom error tags.
            self._write_custom_error(error_bars)
        else:
            # Write the c:val element.
            self._write_error_val(error_bars['value'])

        # Write the c:spPr element.
        self._write_sp_pr(error_bars)

        self._xml_end_tag('c:errBars')

    def _write_err_dir(self, val):
        # Write the <c:errDir> element.

        attributes = [('val', val)]

        self._xml_empty_tag('c:errDir', attributes)

    def _write_err_bar_type(self, val):
        # Write the <c:errBarType> element.

        attributes = [('val', val)]

        self._xml_empty_tag('c:errBarType', attributes)

    def _write_err_val_type(self, val):
        # Write the <c:errValType> element.

        attributes = [('val', val)]

        self._xml_empty_tag('c:errValType', attributes)

    def _write_no_end_cap(self):
        # Write the <c:noEndCap> element.
        attributes = [('val', 1)]

        self._xml_empty_tag('c:noEndCap', attributes)

    def _write_error_val(self, val):
        # Write the <c:val> element for error bars.

        attributes = [('val', val)]

        self._xml_empty_tag('c:val', attributes)

    def _write_custom_error(self, error_bars):
        # Write the custom error bars tags.

        if error_bars['plus_values']:
            # Write the c:plus element.
            self._xml_start_tag('c:plus')

            if isinstance(error_bars['plus_values'], list):
                self._write_num_lit(error_bars['plus_values'])
            else:
                self._write_num_ref(error_bars['plus_values'],
                                    error_bars['plus_data'],
                                    'num')
            self._xml_end_tag('c:plus')

        if error_bars['minus_values']:
            # Write the c:minus element.
            self._xml_start_tag('c:minus')

            if isinstance(error_bars['minus_values'], list):
                self._write_num_lit(error_bars['minus_values'])
            else:
                self._write_num_ref(error_bars['minus_values'],
                                    error_bars['minus_data'],
                                    'num')
            self._xml_end_tag('c:minus')

    def _write_num_lit(self, data):
        # Write the <c:numLit> element for literal number list elements.
        count = len(data)

        # Write the c:numLit element.
        self._xml_start_tag('c:numLit')

        # Write the c:formatCode element.
        self._write_format_code('General')

        # Write the c:ptCount element.
        self._write_pt_count(count)

        for i in range(count):
            token = data[i]

            if token is None:
                continue

            try:
                float(token)
            except ValueError:
                # Write non-numeric data as 0.
                token = 0

            # Write the c:pt element.
            self._write_pt(i, token)

        self._xml_end_tag('c:numLit')

    def _write_up_down_bars(self):
        # Write the <c:upDownBars> element.
        up_down_bars = self.up_down_bars

        if up_down_bars is None:
            return

        self._xml_start_tag('c:upDownBars')

        # Write the c:gapWidth element.
        self._write_gap_width(150)

        # Write the c:upBars element.
        self._write_up_bars(up_down_bars.get('up'))

        # Write the c:downBars element.
        self._write_down_bars(up_down_bars.get('down'))

        self._xml_end_tag('c:upDownBars')

    def _write_gap_width(self, val):
        # Write the <c:gapWidth> element.

        if val is None:
            return

        attributes = [('val', val)]

        self._xml_empty_tag('c:gapWidth', attributes)

    def _write_up_bars(self, bar_format):
        # Write the <c:upBars> element.

        if bar_format['line'] and bar_format['line']['defined']:
            self._xml_start_tag('c:upBars')

            # Write the c:spPr element.
            self._write_sp_pr(bar_format)

            self._xml_end_tag('c:upBars')
        else:
            self._xml_empty_tag('c:upBars')

    def _write_down_bars(self, bar_format):
        # Write the <c:downBars> element.

        if bar_format['line'] and bar_format['line']['defined']:
            self._xml_start_tag('c:downBars')

            # Write the c:spPr element.
            self._write_sp_pr(bar_format)

            self._xml_end_tag('c:downBars')
        else:
            self._xml_empty_tag('c:downBars')

    def _write_disp_units(self, units, display):
        # Write the <c:dispUnits> element.

        if not units:
            return

        attributes = [('val', units)]

        self._xml_start_tag('c:dispUnits')
        self._xml_empty_tag('c:builtInUnit', attributes)

        if display:
            self._xml_start_tag('c:dispUnitsLbl')
            self._xml_empty_tag('c:layout')
            self._xml_end_tag('c:dispUnitsLbl')

        self._xml_end_tag('c:dispUnits')

    def _write_a_grad_fill(self, gradient):
        # Write the <a:gradFill> element.

        attributes = [('flip', 'none'), ('rotWithShape', '1')]

        if gradient['type'] == 'linear':
            attributes = []

        self._xml_start_tag('a:gradFill', attributes)

        # Write the a:gsLst element.
        self._write_a_gs_lst(gradient)

        if gradient['type'] == 'linear':
            # Write the a:lin element.
            self._write_a_lin(gradient['angle'])
        else:
            # Write the a:path element.
            self._write_a_path(gradient['type'])

            # Write the a:tileRect element.
            self._write_a_tile_rect(gradient['type'])

        self._xml_end_tag('a:gradFill')

    def _write_a_gs_lst(self, gradient):
        # Write the <a:gsLst> element.
        positions = gradient['positions']
        colors = gradient['colors']

        self._xml_start_tag('a:gsLst')

        for i in range(len(colors)):
            pos = int(positions[i] * 1000)
            attributes = [('pos', pos)]
            self._xml_start_tag('a:gs', attributes)

            # Write the a:srgbClr element.
            # TODO: Wait for a feature request to support transparency.
            color = get_rgb_color(colors[i])
            self._write_a_srgb_clr(color)

            self._xml_end_tag('a:gs')

        self._xml_end_tag('a:gsLst')

    def _write_a_lin(self, angle):
        # Write the <a:lin> element.

        angle = int(60000 * angle)

        attributes = [
            ('ang', angle),
            ('scaled', '0'),
        ]

        self._xml_empty_tag('a:lin', attributes)

    def _write_a_path(self, gradient_type):
        # Write the <a:path> element.

        attributes = [('path', gradient_type)]

        self._xml_start_tag('a:path', attributes)

        # Write the a:fillToRect element.
        self._write_a_fill_to_rect(gradient_type)

        self._xml_end_tag('a:path')

    def _write_a_fill_to_rect(self, gradient_type):
        # Write the <a:fillToRect> element.

        if gradient_type == 'shape':
            attributes = [
                ('l', '50000'),
                ('t', '50000'),
                ('r', '50000'),
                ('b', '50000'),
            ]
        else:
            attributes = [
                ('l', '100000'),
                ('t', '100000'),
            ]

        self._xml_empty_tag('a:fillToRect', attributes)

    def _write_a_tile_rect(self, gradient_type):
        # Write the <a:tileRect> element.

        if gradient_type == 'shape':
            attributes = []
        else:
            attributes = [
                ('r', '-100000'),
                ('b', '-100000'),
            ]

        self._xml_empty_tag('a:tileRect', attributes)

    def _write_a_patt_fill(self, pattern):
        # Write the <a:pattFill> element.

        attributes = [('prst', pattern['pattern'])]

        self._xml_start_tag('a:pattFill', attributes)

        # Write the a:fgClr element.
        self._write_a_fg_clr(pattern['fg_color'])

        # Write the a:bgClr element.
        self._write_a_bg_clr(pattern['bg_color'])

        self._xml_end_tag('a:pattFill')

    def _write_a_fg_clr(self, color):
        # Write the <a:fgClr> element.

        color = get_rgb_color(color)

        self._xml_start_tag('a:fgClr')

        # Write the a:srgbClr element.
        self._write_a_srgb_clr(color)

        self._xml_end_tag('a:fgClr')

    def _write_a_bg_clr(self, color):
        # Write the <a:bgClr> element.

        color = get_rgb_color(color)

        self._xml_start_tag('a:bgClr')

        # Write the a:srgbClr element.
        self._write_a_srgb_clr(color)

        self._xml_end_tag('a:bgClr')

```

---

### File: `tmp\xlsxwriter_old\XlsxWriter-1.4.5\xlsxwriter\chart_area.py`

```python
###############################################################################
#
# ChartArea - A class for writing the Excel XLSX Area charts.
#
# Copyright 2013-2021, John McNamara, jmcnamara@cpan.org
#

from . import chart


class ChartArea(chart.Chart):
    """
    A class for writing the Excel XLSX Area charts.


    """

    ###########################################################################
    #
    # Public API.
    #
    ###########################################################################

    def __init__(self, options=None):
        """
        Constructor.

        """
        super(ChartArea, self).__init__()

        if options is None:
            options = {}

        self.subtype = options.get('subtype')

        if not self.subtype:
            self.subtype = 'standard'

        self.cross_between = 'midCat'
        self.show_crosses = 0

        # Override and reset the default axis values.
        if self.subtype == 'percent_stacked':
            self.y_axis['defaults']['num_format'] = '0%'

        # Set the available data label positions for this chart type.
        self.label_position_default = 'center'
        self.label_positions = {'center': 'ctr'}

        self.set_y_axis({})

    ###########################################################################
    #
    # Private API.
    #
    ###########################################################################

    def _write_chart_type(self, args):
        # Override the virtual superclass method with a chart specific method.
        # Write the c:areaChart element.
        self._write_area_chart(args)

    ###########################################################################
    #
    # XML methods.
    #
    ###########################################################################
    #
    def _write_area_chart(self, args):
        # Write the <c:areaChart> element.

        if args['primary_axes']:
            series = self._get_primary_axes_series()
        else:
            series = self._get_secondary_axes_series()

        if not len(series):
            return

        subtype = self.subtype

        if subtype == 'percent_stacked':
            subtype = 'percentStacked'

        self._xml_start_tag('c:areaChart')

        # Write the c:grouping element.
        self._write_grouping(subtype)

        # Write the series elements.
        for data in series:
            self._write_ser(data)

        # Write the c:dropLines element.
        self._write_drop_lines()

        # Write the c:axId elements
        self._write_axis_ids(args)

        self._xml_end_tag('c:areaChart')

```

---

### File: `tmp\xlsxwriter_old\XlsxWriter-1.4.5\xlsxwriter\chart_bar.py`

```python
###############################################################################
#
# ChartBar - A class for writing the Excel XLSX Bar charts.
#
# Copyright 2013-2021, John McNamara, jmcnamara@cpan.org
#

from . import chart
from warnings import warn


class ChartBar(chart.Chart):
    """
    A class for writing the Excel XLSX Bar charts.


    """

    ###########################################################################
    #
    # Public API.
    #
    ###########################################################################

    def __init__(self, options=None):
        """
        Constructor.

        """
        super(ChartBar, self).__init__()

        if options is None:
            options = {}

        self.subtype = options.get('subtype')

        if not self.subtype:
            self.subtype = 'clustered'

        self.cat_axis_position = 'l'
        self.val_axis_position = 'b'
        self.horiz_val_axis = 0
        self.horiz_cat_axis = 1
        self.show_crosses = 0

        # Override and reset the default axis values.
        self.x_axis['defaults']['major_gridlines'] = {'visible': 1}
        self.y_axis['defaults']['major_gridlines'] = {'visible': 0}

        if self.subtype == 'percent_stacked':
            self.x_axis['defaults']['num_format'] = '0%'

        # Set the available data label positions for this chart type.
        self.label_position_default = 'outside_end'
        self.label_positions = {
            'center': 'ctr',
            'inside_base': 'inBase',
            'inside_end': 'inEnd',
            'outside_end': 'outEnd'}

        self.set_x_axis({})
        self.set_y_axis({})

    def combine(self, chart=None):
        """
        Create a combination chart with a secondary chart.

        Note: Override parent method to add an extra check that is required
        for Bar charts to ensure that their combined chart is on a secondary
        axis.

        Args:
            chart: The secondary chart to combine with the primary chart.

        Returns:
            Nothing.

        """
        if chart is None:
            return

        if not chart.is_secondary:
            warn('Charts combined with Bar charts must be on a secondary axis')

        self.combined = chart

    ###########################################################################
    #
    # Private API.
    #
    ###########################################################################

    def _write_chart_type(self, args):
        # Override the virtual superclass method with a chart specific method.
        if args['primary_axes']:
            # Reverse X and Y axes for Bar charts.
            tmp = self.y_axis
            self.y_axis = self.x_axis
            self.x_axis = tmp

            if self.y2_axis['position'] == 'r':
                self.y2_axis['position'] = 't'

        # Write the c:barChart element.
        self._write_bar_chart(args)

    def _write_bar_chart(self, args):
        # Write the <c:barChart> element.

        if args['primary_axes']:
            series = self._get_primary_axes_series()
        else:
            series = self._get_secondary_axes_series()

        if not len(series):
            return

        subtype = self.subtype
        if subtype == 'percent_stacked':
            subtype = 'percentStacked'

        # Set a default overlap for stacked charts.
        if 'stacked' in self.subtype:
            if self.series_overlap_1 is None:
                self.series_overlap_1 = 100

        self._xml_start_tag('c:barChart')

        # Write the c:barDir element.
        self._write_bar_dir()

        # Write the c:grouping element.
        self._write_grouping(subtype)

        # Write the c:ser elements.
        for data in series:
            self._write_ser(data)

        # Write the c:gapWidth element.
        if args['primary_axes']:
            self._write_gap_width(self.series_gap_1)
        else:
            self._write_gap_width(self.series_gap_2)

        # Write the c:overlap element.
        if args['primary_axes']:
            self._write_overlap(self.series_overlap_1)
        else:
            self._write_overlap(self.series_overlap_2)

        # Write the c:axId elements
        self._write_axis_ids(args)

        self._xml_end_tag('c:barChart')

    ###########################################################################
    #
    # XML methods.
    #
    ###########################################################################

    def _write_bar_dir(self):
        # Write the <c:barDir> element.
        val = 'bar'

        attributes = [('val', val)]

        self._xml_empty_tag('c:barDir', attributes)

    def _write_err_dir(self, val):
        # Overridden from Chart class since it is not used in Bar charts.
        pass

```

---

### File: `tmp\xlsxwriter_old\XlsxWriter-1.4.5\xlsxwriter\chart_column.py`

```python
###############################################################################
#
# ChartColumn - A class for writing the Excel XLSX Column charts.
#
# Copyright 2013-2021, John McNamara, jmcnamara@cpan.org
#

from . import chart


class ChartColumn(chart.Chart):
    """
    A class for writing the Excel XLSX Column charts.


    """

    ###########################################################################
    #
    # Public API.
    #
    ###########################################################################

    def __init__(self, options=None):
        """
        Constructor.

        """
        super(ChartColumn, self).__init__()

        if options is None:
            options = {}

        self.subtype = options.get('subtype')

        if not self.subtype:
            self.subtype = 'clustered'

        self.horiz_val_axis = 0

        if self.subtype == 'percent_stacked':
            self.y_axis['defaults']['num_format'] = '0%'

        # Set the available data label positions for this chart type.
        self.label_position_default = 'outside_end'
        self.label_positions = {
            'center': 'ctr',
            'inside_base': 'inBase',
            'inside_end': 'inEnd',
            'outside_end': 'outEnd'}

        self.set_y_axis({})

    ###########################################################################
    #
    # Private API.
    #
    ###########################################################################

    def _write_chart_type(self, args):
        # Override the virtual superclass method with a chart specific method.

        # Write the c:barChart element.
        self._write_bar_chart(args)

    def _write_bar_chart(self, args):
        # Write the <c:barChart> element.

        if args['primary_axes']:
            series = self._get_primary_axes_series()
        else:
            series = self._get_secondary_axes_series()

        if not len(series):
            return

        subtype = self.subtype
        if subtype == 'percent_stacked':
            subtype = 'percentStacked'

        # Set a default overlap for stacked charts.
        if 'stacked' in self.subtype:
            if self.series_overlap_1 is None:
                self.series_overlap_1 = 100

        self._xml_start_tag('c:barChart')

        # Write the c:barDir element.
        self._write_bar_dir()

        # Write the c:grouping element.
        self._write_grouping(subtype)

        # Write the c:ser elements.
        for data in series:
            self._write_ser(data)

        # Write the c:gapWidth element.
        if args['primary_axes']:
            self._write_gap_width(self.series_gap_1)
        else:
            self._write_gap_width(self.series_gap_2)

        # Write the c:overlap element.
        if args['primary_axes']:
            self._write_overlap(self.series_overlap_1)
        else:
            self._write_overlap(self.series_overlap_2)

        # Write the c:axId elements
        self._write_axis_ids(args)

        self._xml_end_tag('c:barChart')

    ###########################################################################
    #
    # XML methods.
    #
    ###########################################################################

    def _write_bar_dir(self):
        # Write the <c:barDir> element.
        val = 'col'

        attributes = [('val', val)]

        self._xml_empty_tag('c:barDir', attributes)

    def _write_err_dir(self, val):
        # Overridden from Chart class since it is not used in Column charts.
        pass

```

---

### File: `tmp\xlsxwriter_old\XlsxWriter-1.4.5\xlsxwriter\chart_doughnut.py`

```python
###############################################################################
#
# ChartDoughnut - A class for writing the Excel XLSX Doughnut charts.
#
# Copyright 2013-2021, John McNamara, jmcnamara@cpan.org
#

from warnings import warn
from . import chart_pie


class ChartDoughnut(chart_pie.ChartPie):
    """
    A class for writing the Excel XLSX Doughnut charts.


    """

    ###########################################################################
    #
    # Public API.
    #
    ###########################################################################

    def __init__(self, options=None):
        """
        Constructor.

        """
        super(ChartDoughnut, self).__init__()

        self.vary_data_color = 1
        self.rotation = 0
        self.hole_size = 50

    def set_hole_size(self, size):
        """
        Set the Doughnut chart hole size.

        Args:
            size: 10 <= size <= 90.

        Returns:
            Nothing.

        """
        if size is None:
            return

        # Ensure the size is in Excel's range.
        if size < 10 or size > 90:
            warn("Chart hole size %d outside Excel range: 10 <= size <= 90"
                 % size)
            return

        self.hole_size = int(size)

    ###########################################################################
    #
    # Private API.
    #
    ###########################################################################

    def _write_chart_type(self, args):
        # Override the virtual superclass method with a chart specific method.
        # Write the c:doughnutChart element.
        self._write_doughnut_chart(args)

    ###########################################################################
    #
    # XML methods.
    #
    ###########################################################################

    def _write_doughnut_chart(self, args):
        # Write the <c:doughnutChart> element.  Over-ridden method to remove
        # axis_id code since Doughnut charts don't require val and cat axes.
        self._xml_start_tag('c:doughnutChart')

        # Write the c:varyColors element.
        self._write_vary_colors()

        # Write the series elements.
        for data in self.series:
            self._write_ser(data)

        # Write the c:firstSliceAng element.
        self._write_first_slice_ang()

        # Write the c:holeSize element.
        self._write_c_hole_size()

        self._xml_end_tag('c:doughnutChart')

    def _write_c_hole_size(self):
        # Write the <c:holeSize> element.
        attributes = [('val', self.hole_size)]

        self._xml_empty_tag('c:holeSize', attributes)

```

---

### File: `tmp\xlsxwriter_old\XlsxWriter-1.4.5\xlsxwriter\chart_line.py`

```python
###############################################################################
#
# ChartLine - A class for writing the Excel XLSX Line charts.
#
# Copyright 2013-2021, John McNamara, jmcnamara@cpan.org
#

from . import chart


class ChartLine(chart.Chart):
    """
    A class for writing the Excel XLSX Line charts.


    """

    ###########################################################################
    #
    # Public API.
    #
    ###########################################################################

    def __init__(self, options=None):
        """
        Constructor.

        """
        super(ChartLine, self).__init__()

        if options is None:
            options = {}

        self.subtype = options.get('subtype')

        if not self.subtype:
            self.subtype = 'standard'

        self.default_marker = {'type': 'none'}
        self.smooth_allowed = True

        # Override and reset the default axis values.
        if self.subtype == 'percent_stacked':
            self.y_axis['defaults']['num_format'] = '0%'

        # Set the available data label positions for this chart type.
        self.label_position_default = 'right'
        self.label_positions = {
            'center': 'ctr',
            'right': 'r',
            'left': 'l',
            'above': 't',
            'below': 'b',
            # For backward compatibility.
            'top': 't',
            'bottom': 'b'}

        self.set_y_axis({})

    ###########################################################################
    #
    # Private API.
    #
    ###########################################################################

    def _write_chart_type(self, args):
        # Override the virtual superclass method with a chart specific method.
        # Write the c:lineChart element.
        self._write_line_chart(args)

    ###########################################################################
    #
    # XML methods.
    #
    ###########################################################################

    def _write_line_chart(self, args):
        # Write the <c:lineChart> element.

        if args['primary_axes']:
            series = self._get_primary_axes_series()
        else:
            series = self._get_secondary_axes_series()

        if not len(series):
            return

        subtype = self.subtype

        if subtype == 'percent_stacked':
            subtype = 'percentStacked'

        self._xml_start_tag('c:lineChart')

        # Write the c:grouping element.
        self._write_grouping(subtype)

        # Write the series elements.
        for data in series:
            self._write_ser(data)

        # Write the c:dropLines element.
        self._write_drop_lines()

        # Write the c:hiLowLines element.
        self._write_hi_low_lines()

        # Write the c:upDownBars element.
        self._write_up_down_bars()

        # Write the c:marker element.
        self._write_marker_value()

        # Write the c:axId elements
        self._write_axis_ids(args)

        self._xml_end_tag('c:lineChart')

    def _write_d_pt_point(self, index, point):
        # Write an individual <c:dPt> element. Override the parent method to
        # add markers.

        self._xml_start_tag('c:dPt')

        # Write the c:idx element.
        self._write_idx(index)

        self._xml_start_tag('c:marker')

        # Write the c:spPr element.
        self._write_sp_pr(point)

        self._xml_end_tag('c:marker')

        self._xml_end_tag('c:dPt')

    def _write_marker_value(self):
        # Write the <c:marker> element without a sub-element.
        attributes = [('val', 1)]

        self._xml_empty_tag('c:marker', attributes)

```

---

### File: `tmp\xlsxwriter_old\XlsxWriter-1.4.5\xlsxwriter\chart_pie.py`

```python
###############################################################################
#
# ChartPie - A class for writing the Excel XLSX Pie charts.
#
# Copyright 2013-2021, John McNamara, jmcnamara@cpan.org
#

from warnings import warn
from . import chart


class ChartPie(chart.Chart):
    """
    A class for writing the Excel XLSX Pie charts.


    """

    ###########################################################################
    #
    # Public API.
    #
    ###########################################################################

    def __init__(self, options=None):
        """
        Constructor.

        """
        super(ChartPie, self).__init__()

        self.vary_data_color = 1
        self.rotation = 0

        # Set the available data label positions for this chart type.
        self.label_position_default = 'best_fit'
        self.label_positions = {
            'center': 'ctr',
            'inside_end': 'inEnd',
            'outside_end': 'outEnd',
            'best_fit': 'bestFit'}

    def set_rotation(self, rotation):
        """
        Set the Pie/Doughnut chart rotation: the angle of the first slice.

        Args:
            rotation: First segment angle: 0 <= rotation <= 360.

        Returns:
            Nothing.

        """
        if rotation is None:
            return

        # Ensure the rotation is in Excel's range.
        if rotation < 0 or rotation > 360:
            warn("Chart rotation %d outside Excel range: 0 <= rotation <= 360"
                 % rotation)
            return

        self.rotation = int(rotation)

    ###########################################################################
    #
    # Private API.
    #
    ###########################################################################

    def _write_chart_type(self, args):
        # Override the virtual superclass method with a chart specific method.
        # Write the c:pieChart element.
        self._write_pie_chart(args)

    ###########################################################################
    #
    # XML methods.
    #
    ###########################################################################

    def _write_pie_chart(self, args):
        # Write the <c:pieChart> element.  Over-ridden method to remove
        # axis_id code since Pie charts don't require val and cat axes.
        self._xml_start_tag('c:pieChart')

        # Write the c:varyColors element.
        self._write_vary_colors()

        # Write the series elements.
        for data in self.series:
            self._write_ser(data)

        # Write the c:firstSliceAng element.
        self._write_first_slice_ang()

        self._xml_end_tag('c:pieChart')

    def _write_plot_area(self):
        # Over-ridden method to remove the cat_axis() and val_axis() code
        # since Pie charts don't require those axes.
        #
        # Write the <c:plotArea> element.

        self._xml_start_tag('c:plotArea')

        # Write the c:layout element.
        self._write_layout(self.plotarea.get('layout'), 'plot')

        # Write the subclass chart type element.
        self._write_chart_type(None)
        # Configure a combined chart if present.
        second_chart = self.combined

        if second_chart:
            # Secondary axis has unique id otherwise use same as primary.
            if second_chart.is_secondary:
                second_chart.id = 1000 + self.id
            else:
                second_chart.id = self.id

            # Share the same filehandle for writing.
            second_chart.fh = self.fh

            # Share series index with primary chart.
            second_chart.series_index = self.series_index

            # Write the subclass chart type elements for combined chart.
            second_chart._write_chart_type(None)

        # Write the c:spPr element for the plotarea formatting.
        self._write_sp_pr(self.plotarea)

        self._xml_end_tag('c:plotArea')

    def _write_legend(self):
        # Over-ridden method to add <c:txPr> to legend.
        # Write the <c:legend> element.
        legend = self.legend
        position = legend.get('position', 'right')
        font = legend.get('font')
        delete_series = []
        overlay = 0

        if (legend.get('delete_series')
                and type(legend['delete_series']) is list):
            delete_series = legend['delete_series']

        if position.startswith('overlay_'):
            position = position.replace('overlay_', '')
            overlay = 1

        allowed = {
            'right': 'r',
            'left': 'l',
            'top': 't',
            'bottom': 'b',
            'top_right': 'tr',
        }

        if position == 'none':
            return

        if position not in allowed:
            return

        position = allowed[position]

        self._xml_start_tag('c:legend')

        # Write the c:legendPos element.
        self._write_legend_pos(position)

        # Remove series labels from the legend.
        for index in delete_series:
            # Write the c:legendEntry element.
            self._write_legend_entry(index)

        # Write the c:layout element.
        self._write_layout(legend.get('layout'), 'legend')

        # Write the c:overlay element.
        if overlay:
            self._write_overlay()

        # Write the c:spPr element.
        self._write_sp_pr(legend)

        # Write the c:txPr element. Over-ridden.
        self._write_tx_pr_legend(None, font)

        self._xml_end_tag('c:legend')

    def _write_tx_pr_legend(self, horiz, font):
        # Write the <c:txPr> element for legends.

        if font and font.get('rotation'):
            rotation = font['rotation']
        else:
            rotation = None

        self._xml_start_tag('c:txPr')

        # Write the a:bodyPr element.
        self._write_a_body_pr(rotation, horiz)

        # Write the a:lstStyle element.
        self._write_a_lst_style()

        # Write the a:p element.
        self._write_a_p_legend(font)

        self._xml_end_tag('c:txPr')

    def _write_a_p_legend(self, font):
        # Write the <a:p> element for legends.

        self._xml_start_tag('a:p')

        # Write the a:pPr element.
        self._write_a_p_pr_legend(font)

        # Write the a:endParaRPr element.
        self._write_a_end_para_rpr()

        self._xml_end_tag('a:p')

    def _write_a_p_pr_legend(self, font):
        # Write the <a:pPr> element for legends.
        attributes = [('rtl', 0)]

        self._xml_start_tag('a:pPr', attributes)

        # Write the a:defRPr element.
        self._write_a_def_rpr(font)

        self._xml_end_tag('a:pPr')

    def _write_vary_colors(self):
        # Write the <c:varyColors> element.
        attributes = [('val', 1)]

        self._xml_empty_tag('c:varyColors', attributes)

    def _write_first_slice_ang(self):
        # Write the <c:firstSliceAng> element.
        attributes = [('val', self.rotation)]

        self._xml_empty_tag('c:firstSliceAng', attributes)

```

---

### File: `tmp\xlsxwriter_old\XlsxWriter-1.4.5\xlsxwriter\chart_radar.py`

```python
###############################################################################
#
# ChartRadar - A class for writing the Excel XLSX Radar charts.
#
# Copyright 2013-2021, John McNamara, jmcnamara@cpan.org
#

from . import chart


class ChartRadar(chart.Chart):
    """
    A class for writing the Excel XLSX Radar charts.


    """

    ###########################################################################
    #
    # Public API.
    #
    ###########################################################################

    def __init__(self, options=None):
        """
        Constructor.

        """
        super(ChartRadar, self).__init__()

        if options is None:
            options = {}

        self.subtype = options.get('subtype')

        if not self.subtype:
            self.subtype = 'marker'
            self.default_marker = {'type': 'none'}

        # Override and reset the default axis values.
        self.x_axis['defaults']['major_gridlines'] = {'visible': 1}
        self.set_x_axis({})

        # Set the available data label positions for this chart type.
        self.label_position_default = 'center'
        self.label_positions = {'center': 'ctr'}

        # Hardcode major_tick_mark for now until there is an accessor.
        self.y_axis['major_tick_mark'] = 'cross'

    ###########################################################################
    #
    # Private API.
    #
    ###########################################################################

    def _write_chart_type(self, args):
        # Write the c:radarChart element.
        self._write_radar_chart(args)

    ###########################################################################
    #
    # XML methods.
    #
    ###########################################################################

    def _write_radar_chart(self, args):
        # Write the <c:radarChart> element.

        if args['primary_axes']:
            series = self._get_primary_axes_series()
        else:
            series = self._get_secondary_axes_series()

        if not len(series):
            return

        self._xml_start_tag('c:radarChart')

        # Write the c:radarStyle element.
        self._write_radar_style()

        # Write the series elements.
        for data in series:
            self._write_ser(data)

        # Write the c:axId elements
        self._write_axis_ids(args)

        self._xml_end_tag('c:radarChart')

    def _write_radar_style(self):
        # Write the <c:radarStyle> element.
        val = 'marker'

        if self.subtype == 'filled':
            val = 'filled'

        attributes = [('val', val)]

        self._xml_empty_tag('c:radarStyle', attributes)

```

---

### File: `tmp\xlsxwriter_old\XlsxWriter-1.4.5\xlsxwriter\chart_scatter.py`

```python
###############################################################################
#
# ChartScatter - A class for writing the Excel XLSX Scatter charts.
#
# Copyright 2013-2021, John McNamara, jmcnamara@cpan.org
#

from . import chart
from warnings import warn


class ChartScatter(chart.Chart):
    """
    A class for writing the Excel XLSX Scatter charts.


    """

    ###########################################################################
    #
    # Public API.
    #
    ###########################################################################

    def __init__(self, options=None):
        """
        Constructor.

        """
        super(ChartScatter, self).__init__()

        if options is None:
            options = {}

        self.subtype = options.get('subtype')

        if not self.subtype:
            self.subtype = 'marker_only'

        self.cross_between = 'midCat'
        self.horiz_val_axis = 0
        self.val_axis_position = 'b'
        self.smooth_allowed = True
        self.requires_category = True

        # Set the available data label positions for this chart type.
        self.label_position_default = 'right'
        self.label_positions = {
            'center': 'ctr',
            'right': 'r',
            'left': 'l',
            'above': 't',
            'below': 'b',
            # For backward compatibility.
            'top': 't',
            'bottom': 'b'}

    def combine(self, chart=None):
        """
        Create a combination chart with a secondary chart.

        Note: Override parent method to add a warning.

        Args:
            chart: The secondary chart to combine with the primary chart.

        Returns:
            Nothing.

        """
        if chart is None:
            return

        warn('Combined chart not currently supported with scatter chart '
             'as the primary chart')

    ###########################################################################
    #
    # Private API.
    #
    ###########################################################################

    def _write_chart_type(self, args):
        # Override the virtual superclass method with a chart specific method.
        # Write the c:scatterChart element.
        self._write_scatter_chart(args)

    ###########################################################################
    #
    # XML methods.
    #
    ###########################################################################

    def _write_scatter_chart(self, args):
        # Write the <c:scatterChart> element.

        if args['primary_axes']:
            series = self._get_primary_axes_series()
        else:
            series = self._get_secondary_axes_series()

        if not len(series):
            return

        style = 'lineMarker'
        subtype = self.subtype

        # Set the user defined chart subtype.
        if subtype == 'marker_only':
            style = 'lineMarker'

        if subtype == 'straight_with_markers':
            style = 'lineMarker'

        if subtype == 'straight':
            style = 'lineMarker'
            self.default_marker = {'type': 'none'}

        if subtype == 'smooth_with_markers':
            style = 'smoothMarker'

        if subtype == 'smooth':
            style = 'smoothMarker'
            self.default_marker = {'type': 'none'}

        # Add default formatting to the series data.
        self._modify_series_formatting()

        self._xml_start_tag('c:scatterChart')

        # Write the c:scatterStyle element.
        self._write_scatter_style(style)

        # Write the series elements.
        for data in series:
            self._write_ser(data)

        # Write the c:axId elements
        self._write_axis_ids(args)

        self._xml_end_tag('c:scatterChart')

    def _write_ser(self, series):
        # Over-ridden to write c:xVal/c:yVal instead of c:cat/c:val elements.
        # Write the <c:ser> element.

        index = self.series_index
        self.series_index += 1

        self._xml_start_tag('c:ser')

        # Write the c:idx element.
        self._write_idx(index)

        # Write the c:order element.
        self._write_order(index)

        # Write the series name.
        self._write_series_name(series)

        # Write the c:spPr element.
        self._write_sp_pr(series)

        # Write the c:marker element.
        self._write_marker(series.get('marker'))

        # Write the c:dPt element.
        self._write_d_pt(series.get('points'))

        # Write the c:dLbls element.
        self._write_d_lbls(series.get('labels'))

        # Write the c:trendline element.
        self._write_trendline(series.get('trendline'))

        # Write the c:errBars element.
        self._write_error_bars(series.get('error_bars'))

        # Write the c:xVal element.
        self._write_x_val(series)

        # Write the c:yVal element.
        self._write_y_val(series)

        # Write the c:smooth element.
        if 'smooth' in self.subtype and series['smooth'] is None:
            # Default is on for smooth scatter charts.
            self._write_c_smooth(True)
        else:
            self._write_c_smooth(series['smooth'])

        self._xml_end_tag('c:ser')

    def _write_plot_area(self):
        # Over-ridden to have 2 valAx elements for scatter charts instead
        # of catAx/valAx.
        #
        # Write the <c:plotArea> element.
        self._xml_start_tag('c:plotArea')

        # Write the c:layout element.
        self._write_layout(self.plotarea.get('layout'), 'plot')

        # Write the subclass chart elements for primary and secondary axes.
        self._write_chart_type({'primary_axes': 1})
        self._write_chart_type({'primary_axes': 0})

        # Write c:catAx and c:valAx elements for series using primary axes.
        self._write_cat_val_axis({'x_axis': self.x_axis,
                                  'y_axis': self.y_axis,
                                  'axis_ids': self.axis_ids,
                                  'position': 'b',
                                  })

        tmp = self.horiz_val_axis
        self.horiz_val_axis = 1

        self._write_val_axis({'x_axis': self.x_axis,
                              'y_axis': self.y_axis,
                              'axis_ids': self.axis_ids,
                              'position': 'l',
                              })

        self.horiz_val_axis = tmp

        # Write c:valAx and c:catAx elements for series using secondary axes
        self._write_cat_val_axis({'x_axis': self.x2_axis,
                                  'y_axis': self.y2_axis,
                                  'axis_ids': self.axis2_ids,
                                  'position': 'b',
                                  })
        self.horiz_val_axis = 1
        self._write_val_axis({'x_axis': self.x2_axis,
                              'y_axis': self.y2_axis,
                              'axis_ids': self.axis2_ids,
                              'position': 'l',
                              })

        # Write the c:spPr element for the plotarea formatting.
        self._write_sp_pr(self.plotarea)

        self._xml_end_tag('c:plotArea')

    def _write_x_val(self, series):
        # Write the <c:xVal> element.
        formula = series.get('categories')
        data_id = series.get('cat_data_id')
        data = self.formula_data[data_id]

        self._xml_start_tag('c:xVal')

        # Check the type of cached data.
        data_type = self._get_data_type(data)

        # TODO. Can a scatter plot have non-numeric data.
        if data_type == 'str':
            # Write the c:numRef element.
            self._write_str_ref(formula, data, data_type)
        else:
            # Write the c:numRef element.
            self._write_num_ref(formula, data, data_type)

        self._xml_end_tag('c:xVal')

    def _write_y_val(self, series):
        # Write the <c:yVal> element.
        formula = series.get('values')
        data_id = series.get('val_data_id')
        data = self.formula_data[data_id]

        self._xml_start_tag('c:yVal')

        # Unlike Cat axes data should only be numeric.
        # Write the c:numRef element.
        self._write_num_ref(formula, data, 'num')

        self._xml_end_tag('c:yVal')

    def _write_scatter_style(self, val):
        # Write the <c:scatterStyle> element.
        attributes = [('val', val)]

        self._xml_empty_tag('c:scatterStyle', attributes)

    def _modify_series_formatting(self):
        # Add default formatting to the series data unless it has already been
        # specified by the user.
        subtype = self.subtype

        # The default scatter style "markers only" requires a line type.
        if subtype == 'marker_only':

            # Go through each series and define default values.
            for series in self.series:

                # Set a line type unless there is already a user defined type.
                if not series['line']['defined']:
                    series['line'] = {'width': 2.25,
                                      'none': 1,
                                      'defined': 1,
                                      }

    def _write_d_pt_point(self, index, point):
        # Write an individual <c:dPt> element. Override the parent method to
        # add markers.

        self._xml_start_tag('c:dPt')

        # Write the c:idx element.
        self._write_idx(index)

        self._xml_start_tag('c:marker')

        # Write the c:spPr element.
        self._write_sp_pr(point)

        self._xml_end_tag('c:marker')

        self._xml_end_tag('c:dPt')

```

---

### File: `tmp\xlsxwriter_old\XlsxWriter-1.4.5\xlsxwriter\chart_stock.py`

```python
###############################################################################
#
# ChartStock - A class for writing the Excel XLSX Stock charts.
#
# Copyright 2013-2021, John McNamara, jmcnamara@cpan.org
#

from . import chart


class ChartStock(chart.Chart):
    """
    A class for writing the Excel XLSX Stock charts.

    """

    ###########################################################################
    #
    # Public API.
    #
    ###########################################################################

    def __init__(self, options=None):
        """
        Constructor.

        """
        super(ChartStock, self).__init__()

        self.show_crosses = 0
        self.hi_low_lines = {}
        self.date_category = True

        # Override and reset the default axis values.
        self.x_axis['defaults']['num_format'] = 'dd/mm/yyyy'
        self.x2_axis['defaults']['num_format'] = 'dd/mm/yyyy'

        # Set the available data label positions for this chart type.
        self.label_position_default = 'right'
        self.label_positions = {
            'center': 'ctr',
            'right': 'r',
            'left': 'l',
            'above': 't',
            'below': 'b',
            # For backward compatibility.
            'top': 't',
            'bottom': 'b'}

        self.set_x_axis({})
        self.set_x2_axis({})

    ###########################################################################
    #
    # Private API.
    #
    ###########################################################################

    def _write_chart_type(self, args):
        # Override the virtual superclass method with a chart specific method.
        # Write the c:stockChart element.
        self._write_stock_chart(args)

    ###########################################################################
    #
    # XML methods.
    #
    ###########################################################################

    def _write_stock_chart(self, args):
        # Write the <c:stockChart> element.
        # Overridden to add hi_low_lines().

        if args['primary_axes']:
            series = self._get_primary_axes_series()
        else:
            series = self._get_secondary_axes_series()

        if not len(series):
            return

        # Add default formatting to the series data.
        self._modify_series_formatting()

        self._xml_start_tag('c:stockChart')

        # Write the series elements.
        for data in series:
            self._write_ser(data)

        # Write the c:dropLines element.
        self._write_drop_lines()

        # Write the c:hiLowLines element.
        if args.get('primary_axes'):
            self._write_hi_low_lines()

        # Write the c:upDownBars element.
        self._write_up_down_bars()

        # Write the c:axId elements
        self._write_axis_ids(args)

        self._xml_end_tag('c:stockChart')

    def _modify_series_formatting(self):
        # Add default formatting to the series data.

        index = 0

        for series in self.series:
            if index % 4 != 3:
                if not series['line']['defined']:
                    series['line'] = {'width': 2.25,
                                      'none': 1,
                                      'defined': 1}

                if series['marker'] is None:
                    if index % 4 == 2:
                        series['marker'] = {'type': 'dot', 'size': 3}
                    else:
                        series['marker'] = {'type': 'none'}

            index += 1

```

---

### File: `tmp\xlsxwriter_old\XlsxWriter-1.4.5\xlsxwriter\chartsheet.py`

```python
###############################################################################
#
# Chartsheet - A class for writing the Excel XLSX Worksheet file.
#
# Copyright 2013-2021, John McNamara, jmcnamara@cpan.org
#

from . import worksheet
from .drawing import Drawing


class Chartsheet(worksheet.Worksheet):
    """
    A class for writing the Excel XLSX Chartsheet file.


    """

    ###########################################################################
    #
    # Public API.
    #
    ###########################################################################

    def __init__(self):
        """
        Constructor.

        """

        super(Chartsheet, self).__init__()

        self.is_chartsheet = True
        self.drawing = None
        self.chart = None
        self.charts = []
        self.zoom_scale_normal = 0
        self.orientation = 0
        self.protection = False

    def set_chart(self, chart):
        """
        Set the chart object for the chartsheet.
        Args:
            chart:  Chart object.
        Returns:
            chart:  A reference to the chart object.
        """
        chart.embedded = False
        chart.protection = self.protection
        self.chart = chart
        self.charts.append([0, 0, chart, 0, 0, 1, 1])
        return chart

    def protect(self, password='', options=None):
        """
        Set the password and protection options of the worksheet.

        Args:
            password: An optional password string.
            options:  A dictionary of worksheet objects to protect.

        Returns:
            Nothing.

        """
        # This method is overridden from parent worksheet class.

        # Chartsheets only allow a reduced set of protect options.
        copy = {}

        if not options:
            options = {}

        if options.get('objects') is None:
            copy['objects'] = False
        else:
            # Objects are default on for chartsheets, so reverse state.
            copy['objects'] = not options['objects']

        if options.get('content') is None:
            copy['content'] = True
        else:
            copy['content'] = options['content']

        copy['sheet'] = False
        copy['scenarios'] = True

        # If objects and content are both off then the chartsheet isn't
        # protected, unless it has a password.
        if password == '' and copy['objects'] and not copy['content']:
            return

        if self.chart:
            self.chart.protection = True
        else:
            self.protection = True

        # Call the parent method.
        super(Chartsheet, self).protect(password, copy)

    ###########################################################################
    #
    # Private API.
    #
    ###########################################################################
    def _assemble_xml_file(self):
        # Assemble and write the XML file.

        # Write the XML declaration.
        self._xml_declaration()

        # Write the root worksheet element.
        self._write_chartsheet()

        # Write the worksheet properties.
        self._write_sheet_pr()

        # Write the sheet view properties.
        self._write_sheet_views()

        # Write the sheetProtection element.
        self._write_sheet_protection()

        # Write the printOptions element.
        self._write_print_options()

        # Write the worksheet page_margins.
        self._write_page_margins()

        # Write the worksheet page setup.
        self._write_page_setup()

        # Write the headerFooter element.
        self._write_header_footer()

        # Write the drawing element.
        self._write_drawings()

        # Close the worksheet tag.
        self._xml_end_tag('chartsheet')

        # Close the file.
        self._xml_close()

    def _prepare_chart(self, index, chart_id, drawing_id):
        # Set up chart/drawings.

        self.chart.id = chart_id - 1

        self.drawing = Drawing()
        self.drawing.orientation = self.orientation

        self.external_drawing_links.append(['/drawing',
                                            '../drawings/drawing'
                                            + str(drawing_id)
                                            + '.xml'])

        self.drawing_links.append(['/chart',
                                   '../charts/chart'
                                   + str(chart_id)
                                   + '.xml'])

    ###########################################################################
    #
    # XML methods.
    #
    ###########################################################################

    def _write_chartsheet(self):
        # Write the <worksheet> element. This is the root element.

        schema = 'http://schemas.openxmlformats.org/'
        xmlns = schema + 'spreadsheetml/2006/main'
        xmlns_r = schema + 'officeDocument/2006/relationships'

        attributes = [
            ('xmlns', xmlns),
            ('xmlns:r', xmlns_r)]

        self._xml_start_tag('chartsheet', attributes)

    def _write_sheet_pr(self):
        # Write the <sheetPr> element for Sheet level properties.
        attributes = []

        if self.filter_on:
            attributes.append(('filterMode', 1))

        if (self.fit_page or self.tab_color):
            self._xml_start_tag('sheetPr', attributes)
            self._write_tab_color()
            self._write_page_set_up_pr()
            self._xml_end_tag('sheetPr')
        else:
            self._xml_empty_tag('sheetPr', attributes)

```

---

### File: `tmp\xlsxwriter_old\XlsxWriter-1.4.5\xlsxwriter\comments.py`

```python
###############################################################################
#
# Comments - A class for writing the Excel XLSX Worksheet file.
#
# Copyright 2013-2021, John McNamara, jmcnamara@cpan.org
#

import re

from . import xmlwriter
from .utility import preserve_whitespace
from .utility import xl_rowcol_to_cell


class Comments(xmlwriter.XMLwriter):
    """
    A class for writing the Excel XLSX Comments file.


    """

    ###########################################################################
    #
    # Public API.
    #
    ###########################################################################

    def __init__(self):
        """
        Constructor.

        """

        super(Comments, self).__init__()
        self.author_ids = {}

    ###########################################################################
    #
    # Private API.
    #
    ###########################################################################

    def _assemble_xml_file(self, comments_data=[]):
        # Assemble and write the XML file.

        # Write the XML declaration.
        self._xml_declaration()

        # Write the comments element.
        self._write_comments()

        # Write the authors element.
        self._write_authors(comments_data)

        # Write the commentList element.
        self._write_comment_list(comments_data)

        self._xml_end_tag('comments')

        # Close the file.
        self._xml_close()

    ###########################################################################
    #
    # XML methods.
    #
    ###########################################################################

    def _write_comments(self):
        # Write the <comments> element.
        xmlns = 'http://schemas.openxmlformats.org/spreadsheetml/2006/main'

        attributes = [('xmlns', xmlns)]

        self._xml_start_tag('comments', attributes)

    def _write_authors(self, comment_data):
        # Write the <authors> element.
        author_count = 0

        self._xml_start_tag('authors')

        for comment in comment_data:
            author = comment[3]

            if author is not None and author not in self.author_ids:
                # Store the author id.
                self.author_ids[author] = author_count
                author_count += 1

                # Write the author element.
                self._write_author(author)

        self._xml_end_tag('authors')

    def _write_author(self, data):
        # Write the <author> element.
        self._xml_data_element('author', data)

    def _write_comment_list(self, comment_data):
        # Write the <commentList> element.
        self._xml_start_tag('commentList')

        for comment in comment_data:
            row = comment[0]
            col = comment[1]
            text = comment[2]
            author = comment[3]
            font_name = comment[6]
            font_size = comment[7]
            font_family = comment[8]

            # Look up the author id.
            author_id = None
            if author is not None:
                author_id = self.author_ids[author]

            # Write the comment element.
            font = (font_name, font_size, font_family)
            self._write_comment(row, col, text, author_id, font)

        self._xml_end_tag('commentList')

    def _write_comment(self, row, col, text, author_id, font):
        # Write the <comment> element.
        ref = xl_rowcol_to_cell(row, col)

        attributes = [('ref', ref)]

        if author_id is not None:
            attributes.append(('authorId', author_id))

        self._xml_start_tag('comment', attributes)

        # Write the text element.
        self._write_text(text, font)

        self._xml_end_tag('comment')

    def _write_text(self, text, font):
        # Write the <text> element.
        self._xml_start_tag('text')

        # Write the text r element.
        self._write_text_r(text, font)

        self._xml_end_tag('text')

    def _write_text_r(self, text, font):
        # Write the <r> element.
        self._xml_start_tag('r')

        # Write the rPr element.
        self._write_r_pr(font)

        # Write the text r element.
        self._write_text_t(text)

        self._xml_end_tag('r')

    def _write_text_t(self, text):
        # Write the text <t> element.
        attributes = []

        if preserve_whitespace(text):
            attributes.append(('xml:space', 'preserve'))

        self._xml_data_element('t', text, attributes)

    def _write_r_pr(self, font):
        # Write the <rPr> element.
        self._xml_start_tag('rPr')

        # Write the sz element.
        self._write_sz(font[1])

        # Write the color element.
        self._write_color()

        # Write the rFont element.
        self._write_r_font(font[0])

        # Write the family element.
        self._write_family(font[2])

        self._xml_end_tag('rPr')

    def _write_sz(self, font_size):
        # Write the <sz> element.
        attributes = [('val', font_size)]

        self._xml_empty_tag('sz', attributes)

    def _write_color(self):
        # Write the <color> element.
        attributes = [('indexed', 81)]

        self._xml_empty_tag('color', attributes)

    def _write_r_font(self, font_name):
        # Write the <rFont> element.
        attributes = [('val', font_name)]

        self._xml_empty_tag('rFont', attributes)

    def _write_family(self, font_family):
        # Write the <family> element.
        attributes = [('val', font_family)]

        self._xml_empty_tag('family', attributes)

```

---

### File: `tmp\xlsxwriter_old\XlsxWriter-1.4.5\xlsxwriter\compatibility.py`

```python
###############################################################################
#
# Python 2/3 compatibility functions for XlsxWriter.
#
# Copyright (c), 2013-2021, John McNamara, jmcnamara@cpan.org
#

import sys
from decimal import Decimal
from fractions import Fraction

try:
    # For compatibility between Python 2 and 3.
    from StringIO import StringIO
except ImportError:
    from io import StringIO

# Types to check in Python 2/3.
if sys.version_info[0] == 2:
    int_types = (int, long)
    num_types = (float, int, long, Decimal, Fraction)
    str_types = basestring
else:
    int_types = (int)
    num_types = (float, int, Decimal, Fraction)
    str_types = str


def force_unicode(string):
    """Return string as a native string"""
    if sys.version_info[0] == 2:
        if isinstance(string, unicode):
            return string.encode('utf-8')
    return string

```

---

### File: `tmp\xlsxwriter_old\XlsxWriter-1.4.5\xlsxwriter\contenttypes.py`

```python
###############################################################################
#
# ContentTypes - A class for writing the Excel XLSX ContentTypes file.
#
# Copyright 2013-2021, John McNamara, jmcnamara@cpan.org
#

import copy
from . import xmlwriter

# Long namespace strings used in the class.
app_package = 'application/vnd.openxmlformats-package.'
app_document = 'application/vnd.openxmlformats-officedocument.'

defaults = [
    ['rels', app_package + 'relationships+xml'],
    ['xml', 'application/xml'],
]

overrides = [
    ['/docProps/app.xml', app_document + 'extended-properties+xml'],
    ['/docProps/core.xml', app_package + 'core-properties+xml'],
    ['/xl/styles.xml', app_document + 'spreadsheetml.styles+xml'],
    ['/xl/theme/theme1.xml', app_document + 'theme+xml'],
    ['/xl/workbook.xml', app_document + 'spreadsheetml.sheet.main+xml'],
]


class ContentTypes(xmlwriter.XMLwriter):
    """
    A class for writing the Excel XLSX ContentTypes file.


    """

    ###########################################################################
    #
    # Public API.
    #
    ###########################################################################

    def __init__(self):
        """
        Constructor.

        """

        super(ContentTypes, self).__init__()

        # Copy the defaults in case we need to change them.
        self.defaults = copy.deepcopy(defaults)
        self.overrides = copy.deepcopy(overrides)

    ###########################################################################
    #
    # Private API.
    #
    ###########################################################################

    def _assemble_xml_file(self):
        # Assemble and write the XML file.

        # Write the XML declaration.
        self._xml_declaration()

        self._write_types()
        self._write_defaults()
        self._write_overrides()

        self._xml_end_tag('Types')

        # Close the file.
        self._xml_close()

    def _add_default(self, default):
        # Add elements to the ContentTypes defaults.
        self.defaults.append(default)

    def _add_override(self, override):
        # Add elements to the ContentTypes overrides.
        self.overrides.append(override)

    def _add_worksheet_name(self, worksheet_name):
        # Add the name of a worksheet to the ContentTypes overrides.
        worksheet_name = "/xl/worksheets/" + worksheet_name + ".xml"

        self._add_override((worksheet_name,
                           app_document + 'spreadsheetml.worksheet+xml'))

    def _add_chartsheet_name(self, chartsheet_name):
        # Add the name of a chartsheet to the ContentTypes overrides.
        chartsheet_name = "/xl/chartsheets/" + chartsheet_name + ".xml"

        self._add_override((chartsheet_name,
                           app_document + 'spreadsheetml.chartsheet+xml'))

    def _add_chart_name(self, chart_name):
        # Add the name of a chart to the ContentTypes overrides.
        chart_name = "/xl/charts/" + chart_name + ".xml"

        self._add_override((chart_name, app_document + 'drawingml.chart+xml'))

    def _add_drawing_name(self, drawing_name):
        # Add the name of a drawing to the ContentTypes overrides.
        drawing_name = "/xl/drawings/" + drawing_name + ".xml"

        self._add_override((drawing_name, app_document + 'drawing+xml'))

    def _add_vml_name(self):
        # Add the name of a VML drawing to the ContentTypes defaults.
        self._add_default(('vml', app_document + 'vmlDrawing'))

    def _add_comment_name(self, comment_name):
        # Add the name of a comment to the ContentTypes overrides.
        comment_name = "/xl/" + comment_name + ".xml"

        self._add_override((comment_name,
                           app_document + 'spreadsheetml.comments+xml'))

    def _add_shared_strings(self):
        # Add the sharedStrings link to the ContentTypes overrides.
        self._add_override(('/xl/sharedStrings.xml',
                           app_document + 'spreadsheetml.sharedStrings+xml'))

    def _add_calc_chain(self):
        # Add the calcChain link to the ContentTypes overrides.
        self._add_override(('/xl/calcChain.xml',
                           app_document + 'spreadsheetml.calcChain+xml'))

    def _add_image_types(self, image_types):
        # Add the image default types.
        for image_type in image_types:
            extension = image_type

            if image_type in ('wmf', 'emf'):
                image_type = 'x-' + image_type

            self._add_default((extension, 'image/' + image_type))

    def _add_table_name(self, table_name):
        # Add the name of a table to the ContentTypes overrides.
        table_name = "/xl/tables/" + table_name + ".xml"

        self._add_override((table_name,
                           app_document + 'spreadsheetml.table+xml'))

    def _add_vba_project(self):
        # Add a vbaProject to the ContentTypes defaults.

        # Change the workbook.xml content-type from xlsx to xlsm.
        for i, override in enumerate(self.overrides):
            if override[0] == '/xl/workbook.xml':
                self.overrides[i][1] = 'application/vnd.ms-excel.' \
                    'sheet.macroEnabled.main+xml'

        self._add_default(('bin', 'application/vnd.ms-office.vbaProject'))

    def _add_custom_properties(self):
        # Add the custom properties to the ContentTypes overrides.
        self._add_override(('/docProps/custom.xml',
                           app_document + 'custom-properties+xml'))

    def _add_metadata(self):
        # Add the metadata file to the ContentTypes overrides.
        self._add_override(('/xl/metadata.xml',
                           app_document + 'spreadsheetml.sheetMetadata+xml'))

    ###########################################################################
    #
    # XML methods.
    #
    ###########################################################################

    def _write_defaults(self):
        # Write out all of the <Default> types.

        for extension, content_type in self.defaults:
            self._xml_empty_tag('Default',
                                [('Extension', extension),
                                 ('ContentType', content_type)])

    def _write_overrides(self):
        # Write out all of the <Override> types.
        for part_name, content_type in self.overrides:
            self._xml_empty_tag('Override',
                                [('PartName', part_name),
                                 ('ContentType', content_type)])

    def _write_types(self):
        # Write the <Types> element.
        xmlns = 'http://schemas.openxmlformats.org/package/2006/content-types'

        attributes = [('xmlns', xmlns,)]
        self._xml_start_tag('Types', attributes)

    def _write_default(self, extension, content_type):
        # Write the <Default> element.
        attributes = [
            ('Extension', extension),
            ('ContentType', content_type),
        ]

        self._xml_empty_tag('Default', attributes)

    def _write_override(self, part_name, content_type):
        # Write the <Override> element.
        attributes = [
            ('PartName', part_name),
            ('ContentType', content_type),
        ]

        self._xml_empty_tag('Override', attributes)

```

---

### File: `tmp\xlsxwriter_old\XlsxWriter-1.4.5\xlsxwriter\core.py`

```python
###############################################################################
#
# Core - A class for writing the Excel XLSX Worksheet file.
#
# Copyright 2013-2021, John McNamara, jmcnamara@cpan.org
#

# Standard packages.
from datetime import datetime

# Package imports.
from . import xmlwriter


class Core(xmlwriter.XMLwriter):
    """
    A class for writing the Excel XLSX Core file.


    """

    ###########################################################################
    #
    # Public API.
    #
    ###########################################################################

    def __init__(self):
        """
        Constructor.

        """

        super(Core, self).__init__()

        self.properties = {}

    ###########################################################################
    #
    # Private API.
    #
    ###########################################################################

    def _assemble_xml_file(self):
        # Assemble and write the XML file.

        # Write the XML declaration.
        self._xml_declaration()

        self._write_cp_core_properties()
        self._write_dc_title()
        self._write_dc_subject()
        self._write_dc_creator()
        self._write_cp_keywords()
        self._write_dc_description()
        self._write_cp_last_modified_by()
        self._write_dcterms_created()
        self._write_dcterms_modified()
        self._write_cp_category()
        self._write_cp_content_status()

        self._xml_end_tag('cp:coreProperties')

        # Close the file.
        self._xml_close()

    def _set_properties(self, properties):
        # Set the document properties.
        self.properties = properties

    def _datetime_to_iso8601_date(self, date):
        # Convert to a ISO 8601 style "2010-01-01T00:00:00Z" date.
        if not date:
            date = datetime.utcnow()

        return date.strftime("%Y-%m-%dT%H:%M:%SZ")

    ###########################################################################
    #
    # XML methods.
    #
    ###########################################################################

    def _write_cp_core_properties(self):
        # Write the <cp:coreProperties> element.

        xmlns_cp = ('http://schemas.openxmlformats.org/package/2006/' +
                    'metadata/core-properties')
        xmlns_dc = 'http://purl.org/dc/elements/1.1/'
        xmlns_dcterms = 'http://purl.org/dc/terms/'
        xmlns_dcmitype = 'http://purl.org/dc/dcmitype/'
        xmlns_xsi = 'http://www.w3.org/2001/XMLSchema-instance'

        attributes = [
            ('xmlns:cp', xmlns_cp),
            ('xmlns:dc', xmlns_dc),
            ('xmlns:dcterms', xmlns_dcterms),
            ('xmlns:dcmitype', xmlns_dcmitype),
            ('xmlns:xsi', xmlns_xsi),
        ]

        self._xml_start_tag('cp:coreProperties', attributes)

    def _write_dc_creator(self):
        # Write the <dc:creator> element.
        data = self.properties.get('author', '')

        self._xml_data_element('dc:creator', data)

    def _write_cp_last_modified_by(self):
        # Write the <cp:lastModifiedBy> element.
        data = self.properties.get('author', '')

        self._xml_data_element('cp:lastModifiedBy', data)

    def _write_dcterms_created(self):
        # Write the <dcterms:created> element.
        date = self.properties.get('created', datetime.utcnow())

        xsi_type = 'dcterms:W3CDTF'

        date = self._datetime_to_iso8601_date(date)

        attributes = [('xsi:type', xsi_type,)]

        self._xml_data_element('dcterms:created', date, attributes)

    def _write_dcterms_modified(self):
        # Write the <dcterms:modified> element.
        date = self.properties.get('created', datetime.utcnow())

        xsi_type = 'dcterms:W3CDTF'

        date = self._datetime_to_iso8601_date(date)

        attributes = [('xsi:type', xsi_type,)]

        self._xml_data_element('dcterms:modified', date, attributes)

    def _write_dc_title(self):
        # Write the <dc:title> element.
        if 'title' in self.properties:
            data = self.properties['title']
        else:
            return

        self._xml_data_element('dc:title', data)

    def _write_dc_subject(self):
        # Write the <dc:subject> element.
        if 'subject' in self.properties:
            data = self.properties['subject']
        else:
            return

        self._xml_data_element('dc:subject', data)

    def _write_cp_keywords(self):
        # Write the <cp:keywords> element.
        if 'keywords' in self.properties:
            data = self.properties['keywords']
        else:
            return

        self._xml_data_element('cp:keywords', data)

    def _write_dc_description(self):
        # Write the <dc:description> element.
        if 'comments' in self.properties:
            data = self.properties['comments']
        else:
            return

        self._xml_data_element('dc:description', data)

    def _write_cp_category(self):
        # Write the <cp:category> element.
        if 'category' in self.properties:
            data = self.properties['category']
        else:
            return

        self._xml_data_element('cp:category', data)

    def _write_cp_content_status(self):
        # Write the <cp:contentStatus> element.
        if 'status' in self.properties:
            data = self.properties['status']
        else:
            return

        self._xml_data_element('cp:contentStatus', data)

```

---

### File: `tmp\xlsxwriter_old\XlsxWriter-1.4.5\xlsxwriter\custom.py`

```python
###############################################################################
#
# Custom - A class for writing the Excel XLSX Custom Property file.
#
# Copyright 2013-2021, John McNamara, jmcnamara@cpan.org
#

# Package imports.
from . import xmlwriter


class Custom(xmlwriter.XMLwriter):
    """
    A class for writing the Excel XLSX Custom Workbook Property file.


    """

    ###########################################################################
    #
    # Public API.
    #
    ###########################################################################

    def __init__(self):
        """
        Constructor.

        """

        super(Custom, self).__init__()

        self.properties = []
        self.pid = 1

    def _set_properties(self, properties):
        # Set the document properties.
        self.properties = properties

    ###########################################################################
    #
    # Private API.
    #
    ###########################################################################

    def _assemble_xml_file(self):
        # Assemble and write the XML file.

        # Write the XML declaration.
        self._xml_declaration()

        self._write_properties()

        self._xml_end_tag('Properties')

        # Close the file.
        self._xml_close()

    ###########################################################################
    #
    # XML methods.
    #
    ###########################################################################

    def _write_properties(self):
        # Write the <Properties> element.
        schema = 'http://schemas.openxmlformats.org/officeDocument/2006/'
        xmlns = schema + 'custom-properties'
        xmlns_vt = schema + 'docPropsVTypes'

        attributes = [
            ('xmlns', xmlns),
            ('xmlns:vt', xmlns_vt),
        ]

        self._xml_start_tag('Properties', attributes)

        for custom_property in self.properties:
            # Write the property element.
            self._write_property(custom_property)

    def _write_property(self, custom_property):
        # Write the <property> element.

        fmtid = '{D5CDD505-2E9C-101B-9397-08002B2CF9AE}'

        name, value, property_type = custom_property
        self.pid += 1

        attributes = [
            ('fmtid', fmtid),
            ('pid', self.pid),
            ('name', name),
        ]

        self._xml_start_tag('property', attributes)

        if property_type == 'number_int':
            # Write the vt:i4 element.
            self._write_vt_i4(value)
        elif property_type == 'number':
            # Write the vt:r8 element.
            self._write_vt_r8(value)
        elif property_type == 'date':
            # Write the vt:filetime element.
            self._write_vt_filetime(value)
        elif property_type == 'bool':
            # Write the vt:bool element.
            self._write_vt_bool(value)
        else:
            # Write the vt:lpwstr element.
            self._write_vt_lpwstr(value)

        self._xml_end_tag('property')

    def _write_vt_lpwstr(self, value):
        # Write the <vt:lpwstr> element.
        self._xml_data_element('vt:lpwstr', value)

    def _write_vt_filetime(self, value):
        # Write the <vt:filetime> element.
        self._xml_data_element('vt:filetime', value)

    def _write_vt_i4(self, value):
        # Write the <vt:i4> element.
        self._xml_data_element('vt:i4', value)

    def _write_vt_r8(self, value):
        # Write the <vt:r8> element.
        self._xml_data_element('vt:r8', value)

    def _write_vt_bool(self, value):
        # Write the <vt:bool> element.

        if value:
            value = 'true'
        else:
            value = 'false'

        self._xml_data_element('vt:bool', value)

```

---

### File: `tmp\xlsxwriter_old\XlsxWriter-1.4.5\xlsxwriter\drawing.py`

```python
###############################################################################
#
# Drawing - A class for writing the Excel XLSX Drawing file.
#
# Copyright 2013-2021, John McNamara, jmcnamara@cpan.org
#

from . import xmlwriter
from .shape import Shape
from .utility import get_rgb_color


class Drawing(xmlwriter.XMLwriter):
    """
    A class for writing the Excel XLSX Drawing file.


    """

    ###########################################################################
    #
    # Public API.
    #
    ###########################################################################

    def __init__(self):
        """
        Constructor.

        """

        super(Drawing, self).__init__()

        self.drawings = []
        self.embedded = 0
        self.orientation = 0

    ###########################################################################
    #
    # Private API.
    #
    ###########################################################################

    def _assemble_xml_file(self):
        # Assemble and write the XML file.

        # Write the XML declaration.
        self._xml_declaration()

        # Write the xdr:wsDr element.
        self._write_drawing_workspace()

        if self.embedded:
            index = 0
            for drawing_properties in self.drawings:
                # Write the xdr:twoCellAnchor element.
                index += 1
                self._write_two_cell_anchor(index, drawing_properties)

        else:
            # Write the xdr:absoluteAnchor element.
            self._write_absolute_anchor(1)

        self._xml_end_tag('xdr:wsDr')

        # Close the file.
        self._xml_close()

    def _add_drawing_object(self):
        # Add a chart, image or shape sub object to the drawing.

        drawing_object = {
            'anchor_type': None,
            'dimensions': [],
            'width': 0,
            'height': 0,
            'shape': None,
            'anchor': None,
            'rel_index': 0,
            'url_rel_index': 0,
            'tip': None,
            'name': None,
            'description': None,
            'decorative': False
        }

        self.drawings.append(drawing_object)

        return drawing_object

    ###########################################################################
    #
    # XML methods.
    #
    ###########################################################################

    def _write_drawing_workspace(self):
        # Write the <xdr:wsDr> element.
        schema = 'http://schemas.openxmlformats.org/drawingml/'
        xmlns_xdr = schema + '2006/spreadsheetDrawing'
        xmlns_a = schema + '2006/main'

        attributes = [
            ('xmlns:xdr', xmlns_xdr),
            ('xmlns:a', xmlns_a),
        ]

        self._xml_start_tag('xdr:wsDr', attributes)

    def _write_two_cell_anchor(self, index, drawing_properties):
        # Write the <xdr:twoCellAnchor> element.
        anchor_type = drawing_properties['type']
        dimensions = drawing_properties['dimensions']
        col_from = dimensions[0]
        row_from = dimensions[1]
        col_from_offset = dimensions[2]
        row_from_offset = dimensions[3]
        col_to = dimensions[4]
        row_to = dimensions[5]
        col_to_offset = dimensions[6]
        row_to_offset = dimensions[7]
        col_absolute = dimensions[8]
        row_absolute = dimensions[9]
        width = drawing_properties['width']
        height = drawing_properties['height']
        shape = drawing_properties['shape']
        anchor = drawing_properties['anchor']
        rel_index = drawing_properties['rel_index']
        url_rel_index = drawing_properties['url_rel_index']
        tip = drawing_properties['tip']
        name = drawing_properties['name']
        description = drawing_properties['description']
        decorative = drawing_properties['decorative']

        attributes = []

        # Add attribute for positioning.
        if anchor == 2:
            attributes.append(('editAs', 'oneCell'))
        elif anchor == 3:
            attributes.append(('editAs', 'absolute'))

        # Add editAs attribute for shapes.
        if shape and shape.edit_as:
            attributes.append(('editAs', shape.edit_as))

        self._xml_start_tag('xdr:twoCellAnchor', attributes)

        # Write the xdr:from element.
        self._write_from(
            col_from,
            row_from,
            col_from_offset,
            row_from_offset)

        # Write the xdr:from element.
        self._write_to(
            col_to,
            row_to,
            col_to_offset,
            row_to_offset)

        if anchor_type == 1:
            # Graphic frame.
            # Write the xdr:graphicFrame element for charts.
            self._write_graphic_frame(index, rel_index, name,
                                      description, decorative)
        elif anchor_type == 2:
            # Write the xdr:pic element.
            self._write_pic(index,
                            rel_index,
                            col_absolute,
                            row_absolute,
                            width,
                            height,
                            shape,
                            description,
                            url_rel_index,
                            tip,
                            decorative)
        else:
            # Write the xdr:sp element for shapes.
            self._write_sp(index,
                           col_absolute,
                           row_absolute,
                           width,
                           height,
                           shape,
                           description,
                           url_rel_index,
                           tip,
                           decorative)

        # Write the xdr:clientData element.
        self._write_client_data()

        self._xml_end_tag('xdr:twoCellAnchor')

    def _write_absolute_anchor(self, frame_index):
        self._xml_start_tag('xdr:absoluteAnchor')
        # Write the <xdr:absoluteAnchor> element.

        # Different co-ordinates for horizontal (= 0) and vertical (= 1).
        if self.orientation == 0:
            # Write the xdr:pos element.
            self._write_pos(0, 0)

            # Write the xdr:ext element.
            self._write_xdr_ext(9308969, 6078325)

        else:
            # Write the xdr:pos element.
            self._write_pos(0, -47625)

            # Write the xdr:ext element.
            self._write_xdr_ext(6162675, 6124575)

        # Write the xdr:graphicFrame element.
        self._write_graphic_frame(frame_index, frame_index)

        # Write the xdr:clientData element.
        self._write_client_data()

        self._xml_end_tag('xdr:absoluteAnchor')

    def _write_from(self, col, row, col_offset, row_offset):
        # Write the <xdr:from> element.
        self._xml_start_tag('xdr:from')

        # Write the xdr:col element.
        self._write_col(col)

        # Write the xdr:colOff element.
        self._write_col_off(col_offset)

        # Write the xdr:row element.
        self._write_row(row)

        # Write the xdr:rowOff element.
        self._write_row_off(row_offset)

        self._xml_end_tag('xdr:from')

    def _write_to(self, col, row, col_offset, row_offset):
        # Write the <xdr:to> element.
        self._xml_start_tag('xdr:to')

        # Write the xdr:col element.
        self._write_col(col)

        # Write the xdr:colOff element.
        self._write_col_off(col_offset)

        # Write the xdr:row element.
        self._write_row(row)

        # Write the xdr:rowOff element.
        self._write_row_off(row_offset)

        self._xml_end_tag('xdr:to')

    def _write_col(self, data):
        # Write the <xdr:col> element.
        self._xml_data_element('xdr:col', data)

    def _write_col_off(self, data):
        # Write the <xdr:colOff> element.
        self._xml_data_element('xdr:colOff', data)

    def _write_row(self, data):
        # Write the <xdr:row> element.
        self._xml_data_element('xdr:row', data)

    def _write_row_off(self, data):
        # Write the <xdr:rowOff> element.
        self._xml_data_element('xdr:rowOff', data)

    def _write_pos(self, x, y):
        # Write the <xdr:pos> element.

        attributes = [('x', x), ('y', y)]

        self._xml_empty_tag('xdr:pos', attributes)

    def _write_xdr_ext(self, cx, cy):
        # Write the <xdr:ext> element.

        attributes = [('cx', cx), ('cy', cy)]

        self._xml_empty_tag('xdr:ext', attributes)

    def _write_graphic_frame(self, index, rel_index, name=None,
                             description=None, decorative=None):
        # Write the <xdr:graphicFrame> element.
        attributes = [('macro', '')]

        self._xml_start_tag('xdr:graphicFrame', attributes)

        # Write the xdr:nvGraphicFramePr element.
        self._write_nv_graphic_frame_pr(index, name, description, decorative)

        # Write the xdr:xfrm element.
        self._write_xfrm()

        # Write the a:graphic element.
        self._write_atag_graphic(rel_index)

        self._xml_end_tag('xdr:graphicFrame')

    def _write_nv_graphic_frame_pr(self, index, name, description, decorative):
        # Write the <xdr:nvGraphicFramePr> element.

        if not name:
            name = 'Chart ' + str(index)

        self._xml_start_tag('xdr:nvGraphicFramePr')

        # Write the xdr:cNvPr element.
        self._write_c_nv_pr(index + 1, name, description,
                            None, None, decorative)

        # Write the xdr:cNvGraphicFramePr element.
        self._write_c_nv_graphic_frame_pr()

        self._xml_end_tag('xdr:nvGraphicFramePr')

    def _write_c_nv_pr(self, index, name, description, url_rel_index,
                       tip, decorative):
        # Write the <xdr:cNvPr> element.
        attributes = [('id', index), ('name', name)]

        # Add description attribute for images.
        if description and not decorative:
            attributes.append(('descr', description))

        if url_rel_index or decorative:
            self._xml_start_tag('xdr:cNvPr', attributes)

            if url_rel_index:
                self._write_a_hlink_click(url_rel_index, tip)

            if decorative:
                self._write_decorative()

            self._xml_end_tag('xdr:cNvPr')
        else:
            self._xml_empty_tag('xdr:cNvPr', attributes)

    def _write_decorative(self):

        self._xml_start_tag('a:extLst')

        self._write_uri_ext('{FF2B5EF4-FFF2-40B4-BE49-F238E27FC236}')
        self._write_a16_creation_id()
        self._xml_end_tag('a:ext')

        self._write_uri_ext('{C183D7F6-B498-43B3-948B-1728B52AA6E4}')
        self._write_adec_decorative()
        self._xml_end_tag('a:ext')

        self._xml_end_tag('a:extLst')

    def _write_uri_ext(self, uri):
        # Write the <a:ext> element.
        attributes = [('uri', uri)]

        self._xml_start_tag('a:ext', attributes)

    def _write_adec_decorative(self):
        # Write the <adec:decorative> element.
        xmlns = 'http://schemas.microsoft.com/office/drawing/2017/decorative'
        val = '1'

        attributes = [
            ('xmlns:adec', xmlns),
            ('val', val),
        ]

        self._xml_empty_tag('adec:decorative', attributes)

    def _write_a16_creation_id(self):
        # Write the <a16:creationId> element.

        xmlns_a_16 = 'http://schemas.microsoft.com/office/drawing/2014/main'
        id = '{00000000-0008-0000-0000-000002000000}'

        attributes = [
            ('xmlns:a16', xmlns_a_16),
            ('id', id),
        ]

        self._xml_empty_tag('a16:creationId', attributes)

    def _write_a_hlink_click(self, rel_index, tip):
        # Write the <a:hlinkClick> element.
        schema = 'http://schemas.openxmlformats.org/officeDocument/'
        xmlns_r = schema + '2006/relationships'

        attributes = [
            ('xmlns:r', xmlns_r),
            ('r:id', 'rId' + str(rel_index)),
        ]

        if tip:
            attributes.append(('tooltip', tip))

        self._xml_empty_tag('a:hlinkClick', attributes)

    def _write_c_nv_graphic_frame_pr(self):
        # Write the <xdr:cNvGraphicFramePr> element.
        if self.embedded:
            self._xml_empty_tag('xdr:cNvGraphicFramePr')
        else:
            self._xml_start_tag('xdr:cNvGraphicFramePr')

            # Write the a:graphicFrameLocks element.
            self._write_a_graphic_frame_locks()

            self._xml_end_tag('xdr:cNvGraphicFramePr')

    def _write_a_graphic_frame_locks(self):
        # Write the <a:graphicFrameLocks> element.
        attributes = [('noGrp', 1)]

        self._xml_empty_tag('a:graphicFrameLocks', attributes)

    def _write_xfrm(self):
        # Write the <xdr:xfrm> element.
        self._xml_start_tag('xdr:xfrm')

        # Write the xfrmOffset element.
        self._write_xfrm_offset()

        # Write the xfrmOffset element.
        self._write_xfrm_extension()

        self._xml_end_tag('xdr:xfrm')

    def _write_xfrm_offset(self):
        # Write the <a:off> xfrm sub-element.

        attributes = [
            ('x', 0),
            ('y', 0),
        ]

        self._xml_empty_tag('a:off', attributes)

    def _write_xfrm_extension(self):
        # Write the <a:ext> xfrm sub-element.

        attributes = [
            ('cx', 0),
            ('cy', 0),
        ]

        self._xml_empty_tag('a:ext', attributes)

    def _write_atag_graphic(self, index):
        # Write the <a:graphic> element.
        self._xml_start_tag('a:graphic')

        # Write the a:graphicData element.
        self._write_atag_graphic_data(index)

        self._xml_end_tag('a:graphic')

    def _write_atag_graphic_data(self, index):
        # Write the <a:graphicData> element.
        uri = 'http://schemas.openxmlformats.org/drawingml/2006/chart'

        attributes = [('uri', uri,)]

        self._xml_start_tag('a:graphicData', attributes)

        # Write the c:chart element.
        self._write_c_chart('rId' + str(index))

        self._xml_end_tag('a:graphicData')

    def _write_c_chart(self, r_id):
        # Write the <c:chart> element.

        schema = 'http://schemas.openxmlformats.org/'
        xmlns_c = schema + 'drawingml/2006/chart'
        xmlns_r = schema + 'officeDocument/2006/relationships'

        attributes = [
            ('xmlns:c', xmlns_c),
            ('xmlns:r', xmlns_r),
            ('r:id', r_id),
        ]

        self._xml_empty_tag('c:chart', attributes)

    def _write_client_data(self):
        # Write the <xdr:clientData> element.
        self._xml_empty_tag('xdr:clientData')

    def _write_sp(self, index, col_absolute, row_absolute,
                  width, height, shape, description,
                  url_rel_index, tip, decorative):
        # Write the <xdr:sp> element.

        if shape and shape.connect:
            attributes = [('macro', '')]
            self._xml_start_tag('xdr:cxnSp', attributes)

            # Write the xdr:nvCxnSpPr element.
            self._write_nv_cxn_sp_pr(index, shape)

            # Write the xdr:spPr element.
            self._write_xdr_sp_pr(index, col_absolute, row_absolute, width,
                                  height, shape)

            self._xml_end_tag('xdr:cxnSp')
        else:
            # Add attribute for shapes.
            attributes = [('macro', ''),
                          ('textlink', shape.textlink)]

            self._xml_start_tag('xdr:sp', attributes)

            # Write the xdr:nvSpPr element.
            self._write_nv_sp_pr(index, shape, url_rel_index, tip,
                                 description, decorative)

            # Write the xdr:spPr element.
            self._write_xdr_sp_pr(index, col_absolute, row_absolute, width,
                                  height, shape)

            # Write the xdr:style element.
            self._write_style()

            # Write the xdr:txBody element.
            if shape.text is not None:
                self._write_tx_body(col_absolute, row_absolute, width, height,
                                    shape)

            self._xml_end_tag('xdr:sp')

    def _write_nv_cxn_sp_pr(self, index, shape):
        # Write the <xdr:nvCxnSpPr> element.
        self._xml_start_tag('xdr:nvCxnSpPr')

        name = shape.name + ' ' + str(index)
        if name is not None:
            self._write_c_nv_pr(index, name, None, None, None, None)

        self._xml_start_tag('xdr:cNvCxnSpPr')

        attributes = [('noChangeShapeType', '1')]
        self._xml_empty_tag('a:cxnSpLocks', attributes)

        if shape.start:
            attributes = [('id', shape.start), ('idx', shape.start_index)]
            self._xml_empty_tag('a:stCxn', attributes)

        if shape.end:
            attributes = [('id', shape.end), ('idx', shape.end_index)]
            self._xml_empty_tag('a:endCxn', attributes)

        self._xml_end_tag('xdr:cNvCxnSpPr')
        self._xml_end_tag('xdr:nvCxnSpPr')

    def _write_nv_sp_pr(self, index, shape, url_rel_index, tip,
                        description, decorative):
        # Write the <xdr:NvSpPr> element.
        attributes = []

        self._xml_start_tag('xdr:nvSpPr')

        name = shape.name + ' ' + str(index)

        self._write_c_nv_pr(index + 1, name, description,
                            url_rel_index, tip, decorative)

        if shape.name == 'TextBox':
            attributes = [('txBox', 1)]

        self._xml_empty_tag('xdr:cNvSpPr', attributes)

        self._xml_end_tag('xdr:nvSpPr')

    def _write_pic(self, index, rel_index, col_absolute, row_absolute,
                   width, height, shape, description, url_rel_index,
                   tip, decorative):
        # Write the <xdr:pic> element.
        self._xml_start_tag('xdr:pic')

        # Write the xdr:nvPicPr element.
        self._write_nv_pic_pr(index, rel_index, description,
                              url_rel_index, tip, decorative)
        # Write the xdr:blipFill element.
        self._write_blip_fill(rel_index)

        # Write the xdr:spPr element.
        self._write_sp_pr(col_absolute, row_absolute, width, height,
                          shape)

        self._xml_end_tag('xdr:pic')

    def _write_nv_pic_pr(self, index, rel_index, description,
                         url_rel_index, tip, decorative):
        # Write the <xdr:nvPicPr> element.
        self._xml_start_tag('xdr:nvPicPr')

        # Write the xdr:cNvPr element.
        self._write_c_nv_pr(index + 1, 'Picture ' + str(index), description,
                            url_rel_index, tip, decorative)

        # Write the xdr:cNvPicPr element.
        self._write_c_nv_pic_pr()

        self._xml_end_tag('xdr:nvPicPr')

    def _write_c_nv_pic_pr(self):
        # Write the <xdr:cNvPicPr> element.
        self._xml_start_tag('xdr:cNvPicPr')

        # Write the a:picLocks element.
        self._write_a_pic_locks()

        self._xml_end_tag('xdr:cNvPicPr')

    def _write_a_pic_locks(self):
        # Write the <a:picLocks> element.
        attributes = [('noChangeAspect', 1)]

        self._xml_empty_tag('a:picLocks', attributes)

    def _write_blip_fill(self, index):
        # Write the <xdr:blipFill> element.
        self._xml_start_tag('xdr:blipFill')

        # Write the a:blip element.
        self._write_a_blip(index)

        # Write the a:stretch element.
        self._write_a_stretch()

        self._xml_end_tag('xdr:blipFill')

    def _write_a_blip(self, index):
        # Write the <a:blip> element.
        schema = 'http://schemas.openxmlformats.org/officeDocument/'
        xmlns_r = schema + '2006/relationships'
        r_embed = 'rId' + str(index)

        attributes = [
            ('xmlns:r', xmlns_r),
            ('r:embed', r_embed)]

        self._xml_empty_tag('a:blip', attributes)

    def _write_a_stretch(self):
        # Write the <a:stretch> element.
        self._xml_start_tag('a:stretch')

        # Write the a:fillRect element.
        self._write_a_fill_rect()

        self._xml_end_tag('a:stretch')

    def _write_a_fill_rect(self):
        # Write the <a:fillRect> element.
        self._xml_empty_tag('a:fillRect')

    def _write_sp_pr(self, col_absolute, row_absolute, width, height,
                     shape=None):
        # Write the <xdr:spPr> element, for charts.

        self._xml_start_tag('xdr:spPr')

        # Write the a:xfrm element.
        self._write_a_xfrm(col_absolute, row_absolute, width, height)

        # Write the a:prstGeom element.
        self._write_a_prst_geom(shape)

        self._xml_end_tag('xdr:spPr')

    def _write_xdr_sp_pr(self, index, col_absolute, row_absolute, width,
                         height, shape):
        # Write the <xdr:spPr> element for shapes.

        attributes = []
        # attributes = [('bwMode', 'auto')]

        self._xml_start_tag('xdr:spPr', attributes)

        # Write the a:xfrm element.
        self._write_a_xfrm(col_absolute, row_absolute, width, height, shape)

        # Write the a:prstGeom element.
        self._write_a_prst_geom(shape)

        if shape.fill:
            if not shape.fill['defined']:
                # Write the a:solidFill element.
                self._write_a_solid_fill_scheme('lt1')
            elif 'none' in shape.fill:
                # Write the a:noFill element.
                self._xml_empty_tag('a:noFill')
            elif 'color' in shape.fill:
                # Write the a:solidFill element.
                self._write_a_solid_fill(get_rgb_color(shape.fill['color']))

        if shape.gradient:
            # Write the a:gradFill element.
            self._write_a_grad_fill(shape.gradient)

        # Write the a:ln element.
        self._write_a_ln(shape.line)

        self._xml_end_tag('xdr:spPr')

    def _write_a_xfrm(self, col_absolute, row_absolute, width, height,
                      shape=None):
        # Write the <a:xfrm> element.
        attributes = []

        if shape:
            if shape.rotation:
                rotation = shape.rotation
                rotation *= 60000
                attributes.append(('rot', rotation))

            if shape.flip_h:
                attributes.append(('flipH', 1))
            if shape.flip_v:
                attributes.append(('flipV', 1))

        self._xml_start_tag('a:xfrm', attributes)

        # Write the a:off element.
        self._write_a_off(col_absolute, row_absolute)

        # Write the a:ext element.
        self._write_a_ext(width, height)

        self._xml_end_tag('a:xfrm')

    def _write_a_off(self, x, y):
        # Write the <a:off> element.
        attributes = [
            ('x', x),
            ('y', y),
        ]

        self._xml_empty_tag('a:off', attributes)

    def _write_a_ext(self, cx, cy):
        # Write the <a:ext> element.
        attributes = [
            ('cx', cx),
            ('cy', cy),
        ]

        self._xml_empty_tag('a:ext', attributes)

    def _write_a_prst_geom(self, shape=None):
        # Write the <a:prstGeom> element.
        attributes = [('prst', 'rect')]

        self._xml_start_tag('a:prstGeom', attributes)

        # Write the a:avLst element.
        self._write_a_av_lst(shape)

        self._xml_end_tag('a:prstGeom')

    def _write_a_av_lst(self, shape=None):
        # Write the <a:avLst> element.
        adjustments = []

        if shape and shape.adjustments:
            adjustments = shape.adjustments

        if adjustments:
            self._xml_start_tag('a:avLst')

            i = 0
            for adj in adjustments:
                i += 1
                # Only connectors have multiple adjustments.
                if shape.connect:
                    suffix = i
                else:
                    suffix = ''

                # Scale Adjustments: 100,000 = 100%.
                adj_int = str(int(adj * 1000))

                attributes = [('name', 'adj' + suffix),
                              ('fmla', 'val' + adj_int)]

                self._xml_empty_tag('a:gd', attributes)

            self._xml_end_tag('a:avLst')
        else:
            self._xml_empty_tag('a:avLst')

    def _write_a_solid_fill(self, rgb):
        # Write the <a:solidFill> element.
        if rgb is None:
            rgb = 'FFFFFF'

        self._xml_start_tag('a:solidFill')

        # Write the a:srgbClr element.
        self._write_a_srgb_clr(rgb)

        self._xml_end_tag('a:solidFill')

    def _write_a_solid_fill_scheme(self, color, shade=None):

        attributes = [('val', color)]

        self._xml_start_tag('a:solidFill')

        if shade:
            self._xml_start_tag('a:schemeClr', attributes)
            self._write_a_shade(shade)
            self._xml_end_tag('a:schemeClr')
        else:
            self._xml_empty_tag('a:schemeClr', attributes)

        self._xml_end_tag('a:solidFill')

    def _write_a_ln(self, line):
        # Write the <a:ln> element.
        width = line.get('width', 0.75)

        # Round width to nearest 0.25, like Excel.
        width = int((width + 0.125) * 4) / 4.0

        # Convert to internal units.
        width = int(0.5 + (12700 * width))

        attributes = [
            ('w', width),
            ('cmpd', 'sng')
        ]

        self._xml_start_tag('a:ln', attributes)

        if 'none' in line:
            # Write the a:noFill element.
            self._xml_empty_tag('a:noFill')

        elif 'color' in line:
            # Write the a:solidFill element.
            self._write_a_solid_fill(get_rgb_color(line['color']))

        else:
            # Write the a:solidFill element.
            self._write_a_solid_fill_scheme('lt1', '50000')

        # Write the line/dash type.
        line_type = line.get('dash_type')
        if line_type:
            # Write the a:prstDash element.
            self._write_a_prst_dash(line_type)

        self._xml_end_tag('a:ln')

    def _write_tx_body(self, col_absolute, row_absolute, width, height, shape):
        # Write the <xdr:txBody> element.
        attributes = []

        if shape.text_rotation != 0:
            if shape.text_rotation == 90:
                attributes.append(('vert', 'vert270'))
            if shape.text_rotation == -90:
                attributes.append(('vert', 'vert'))
            if shape.text_rotation == 270:
                attributes.append(('vert', 'wordArtVert'))
            if shape.text_rotation == 271:
                attributes.append(('vert', 'eaVert'))

        attributes.append(('wrap', 'square'))
        attributes.append(('rtlCol', "0"))

        if not shape.align['defined']:
            attributes.append(('anchor', 't'))
        else:

            if 'vertical' in shape.align:
                align = shape.align['vertical']
                if align == 'top':
                    attributes.append(('anchor', 't'))
                elif align == 'middle':
                    attributes.append(('anchor', 'ctr'))
                elif align == 'bottom':
                    attributes.append(('anchor', 'b'))
            else:
                attributes.append(('anchor', 't'))

            if 'horizontal' in shape.align:
                align = shape.align['horizontal']
                if align == 'center':
                    attributes.append(('anchorCtr', '1'))
            else:
                attributes.append(('anchorCtr', '0'))

        self._xml_start_tag('xdr:txBody')
        self._xml_empty_tag('a:bodyPr', attributes)
        self._xml_empty_tag('a:lstStyle')

        lines = shape.text.split('\n')

        # Set the font attributes.
        font = shape.font
        style_attrs = Shape._get_font_style_attributes(font)
        latin_attrs = Shape._get_font_latin_attributes(font)
        style_attrs.insert(0, ('lang', font['lang']))

        if shape.textlink != '':
            attributes = [
                ('id', '{B8ADDEFE-BF52-4FD4-8C5D-6B85EF6FF707}'),
                ('type', 'TxLink')]

            self._xml_start_tag('a:p')
            self._xml_start_tag('a:fld', attributes)

            self._write_font_run(font, style_attrs, latin_attrs, 'a:rPr')

            self._xml_data_element('a:t', shape.text)
            self._xml_end_tag('a:fld')

            self._write_font_run(font, style_attrs, latin_attrs,
                                 'a:endParaRPr')

            self._xml_end_tag('a:p')
        else:
            for line in lines:
                self._xml_start_tag('a:p')

                if line == '':
                    self._write_font_run(font, style_attrs, latin_attrs,
                                         'a:endParaRPr')
                    self._xml_end_tag('a:p')
                    continue
                elif 'text' in shape.align:
                    if shape.align['text'] == 'left':
                        self._xml_empty_tag('a:pPr', [('algn', 'l')])
                    if shape.align['text'] == 'center':
                        self._xml_empty_tag('a:pPr', [('algn', 'ctr')])
                    if shape.align['text'] == 'right':
                        self._xml_empty_tag('a:pPr', [('algn', 'r')])

                self._xml_start_tag('a:r')

                self._write_font_run(font, style_attrs, latin_attrs, 'a:rPr')

                self._xml_data_element('a:t', line)

                self._xml_end_tag('a:r')
                self._xml_end_tag('a:p')

        self._xml_end_tag('xdr:txBody')

    def _write_font_run(self, font, style_attrs, latin_attrs, run_type):
        # Write a:rPr or a:endParaRPr.
        if font.get('color') is not None:
            has_color = True
        else:
            has_color = False

        if latin_attrs or has_color:
            self._xml_start_tag(run_type, style_attrs)

            if has_color:
                self._write_a_solid_fill(get_rgb_color(font['color']))

            if latin_attrs:
                self._write_a_latin(latin_attrs)
                self._write_a_cs(latin_attrs)

            self._xml_end_tag(run_type)
        else:
            self._xml_empty_tag(run_type, style_attrs)

    def _write_style(self):
        # Write the <xdr:style> element.
        self._xml_start_tag('xdr:style')

        # Write the a:lnRef element.
        self._write_a_ln_ref()

        # Write the a:fillRef element.
        self._write_a_fill_ref()

        # Write the a:effectRef element.
        self._write_a_effect_ref()

        # Write the a:fontRef element.
        self._write_a_font_ref()

        self._xml_end_tag('xdr:style')

    def _write_a_ln_ref(self):
        # Write the <a:lnRef> element.
        attributes = [('idx', '0')]

        self._xml_start_tag('a:lnRef', attributes)

        # Write the a:scrgbClr element.
        self._write_a_scrgb_clr()

        self._xml_end_tag('a:lnRef')

    def _write_a_fill_ref(self):
        # Write the <a:fillRef> element.
        attributes = [('idx', '0')]

        self._xml_start_tag('a:fillRef', attributes)

        # Write the a:scrgbClr element.
        self._write_a_scrgb_clr()

        self._xml_end_tag('a:fillRef')

    def _write_a_effect_ref(self):
        # Write the <a:effectRef> element.
        attributes = [('idx', '0')]

        self._xml_start_tag('a:effectRef', attributes)

        # Write the a:scrgbClr element.
        self._write_a_scrgb_clr()

        self._xml_end_tag('a:effectRef')

    def _write_a_scrgb_clr(self):
        # Write the <a:scrgbClr> element.

        attributes = [
            ('r', '0'),
            ('g', '0'),
            ('b', '0'),
        ]

        self._xml_empty_tag('a:scrgbClr', attributes)

    def _write_a_font_ref(self):
        # Write the <a:fontRef> element.
        attributes = [('idx', 'minor')]

        self._xml_start_tag('a:fontRef', attributes)

        # Write the a:schemeClr element.
        self._write_a_scheme_clr('dk1')

        self._xml_end_tag('a:fontRef')

    def _write_a_scheme_clr(self, val):
        # Write the <a:schemeClr> element.
        attributes = [('val', val)]

        self._xml_empty_tag('a:schemeClr', attributes)

    def _write_a_shade(self, shade):
        # Write the <a:shade> element.
        attributes = [('val', shade)]

        self._xml_empty_tag('a:shade', attributes)

    def _write_a_prst_dash(self, val):
        # Write the <a:prstDash> element.

        attributes = [('val', val)]

        self._xml_empty_tag('a:prstDash', attributes)

    def _write_a_grad_fill(self, gradient):
        # Write the <a:gradFill> element.

        attributes = [('flip', 'none'), ('rotWithShape', '1')]

        if gradient['type'] == 'linear':
            attributes = []

        self._xml_start_tag('a:gradFill', attributes)

        # Write the a:gsLst element.
        self._write_a_gs_lst(gradient)

        if gradient['type'] == 'linear':
            # Write the a:lin element.
            self._write_a_lin(gradient['angle'])
        else:
            # Write the a:path element.
            self._write_a_path(gradient['type'])

            # Write the a:tileRect element.
            self._write_a_tile_rect(gradient['type'])

        self._xml_end_tag('a:gradFill')

    def _write_a_gs_lst(self, gradient):
        # Write the <a:gsLst> element.
        positions = gradient['positions']
        colors = gradient['colors']

        self._xml_start_tag('a:gsLst')

        for i in range(len(colors)):
            pos = int(positions[i] * 1000)
            attributes = [('pos', pos)]
            self._xml_start_tag('a:gs', attributes)

            # Write the a:srgbClr element.
            # TODO: Wait for a feature request to support transparency.
            color = get_rgb_color(colors[i])
            self._write_a_srgb_clr(color)

            self._xml_end_tag('a:gs')

        self._xml_end_tag('a:gsLst')

    def _write_a_lin(self, angle):
        # Write the <a:lin> element.

        angle = int(60000 * angle)

        attributes = [
            ('ang', angle),
            ('scaled', '0'),
        ]

        self._xml_empty_tag('a:lin', attributes)

    def _write_a_path(self, gradient_type):
        # Write the <a:path> element.

        attributes = [('path', gradient_type)]

        self._xml_start_tag('a:path', attributes)

        # Write the a:fillToRect element.
        self._write_a_fill_to_rect(gradient_type)

        self._xml_end_tag('a:path')

    def _write_a_fill_to_rect(self, gradient_type):
        # Write the <a:fillToRect> element.

        if gradient_type == 'shape':
            attributes = [
                ('l', '50000'),
                ('t', '50000'),
                ('r', '50000'),
                ('b', '50000'),
            ]
        else:
            attributes = [
                ('l', '100000'),
                ('t', '100000'),
            ]

        self._xml_empty_tag('a:fillToRect', attributes)

    def _write_a_tile_rect(self, gradient_type):
        # Write the <a:tileRect> element.

        if gradient_type == 'shape':
            attributes = []
        else:
            attributes = [
                ('r', '-100000'),
                ('b', '-100000'),
            ]

        self._xml_empty_tag('a:tileRect', attributes)

    def _write_a_srgb_clr(self, val):
        # Write the <a:srgbClr> element.

        attributes = [('val', val)]

        self._xml_empty_tag('a:srgbClr', attributes)

    def _write_a_latin(self, attributes):
        # Write the <a:latin> element.
        self._xml_empty_tag('a:latin', attributes)

    def _write_a_cs(self, attributes):
        # Write the <a:latin> element.
        self._xml_empty_tag('a:cs', attributes)

```

---

### File: `tmp\xlsxwriter_old\XlsxWriter-1.4.5\xlsxwriter\exceptions.py`

```python
###############################################################################
#
# Exceptions - A class for XlsxWriter exceptions.
#
# Copyright 2013-2021, John McNamara, jmcnamara@cpan.org
#


class XlsxWriterException(Exception):
    """Base exception for XlsxWriter."""


class XlsxInputError(XlsxWriterException):
    """Base exception for all input data related errors."""


class XlsxFileError(XlsxWriterException):
    """Base exception for all file related errors."""


class EmptyChartSeries(XlsxInputError):
    """Chart must contain at least one data series."""


class DuplicateTableName(XlsxInputError):
    """Worksheet table name already exists."""


class InvalidWorksheetName(XlsxInputError):
    """Worksheet name is too long or contains restricted characters."""


class DuplicateWorksheetName(XlsxInputError):
    """Worksheet name already exists."""


class UndefinedImageSize(XlsxFileError):
    """No size data found in image file."""


class UnsupportedImageFormat(XlsxFileError):
    """Unsupported image file format."""


class FileCreateError(XlsxFileError):
    """IO error when creating xlsx file."""


class FileSizeError(XlsxFileError):
    """Filesize would require ZIP64 extensions. Use workbook.use_zip64()."""

```

---

### File: `tmp\xlsxwriter_old\XlsxWriter-1.4.5\xlsxwriter\format.py`

```python
###############################################################################
#
# Format - A class for writing the Excel XLSX Worksheet file.
#
# Copyright 2013-2021, John McNamara, jmcnamara@cpan.org
#

# Package imports.
from . import xmlwriter
from warnings import warn


class Format(xmlwriter.XMLwriter):
    """
    A class for writing the Excel XLSX Format file.


    """

    ###########################################################################
    #
    # Public API.
    #
    ###########################################################################

    def __init__(self, properties=None, xf_indices=None, dxf_indices=None):
        """
        Constructor.

        """
        if properties is None:
            properties = {}

        super(Format, self).__init__()

        self.xf_format_indices = xf_indices
        self.dxf_format_indices = dxf_indices
        self.xf_index = None
        self.dxf_index = None

        self.num_format = 'General'
        self.num_format_index = 0
        self.font_index = 0
        self.has_font = 0
        self.has_dxf_font = 0

        self.bold = 0
        self.underline = 0
        self.italic = 0
        self.font_name = 'Calibri'
        self.font_size = 11
        self.font_color = 0x0
        self.font_strikeout = 0
        self.font_outline = 0
        self.font_shadow = 0
        self.font_script = 0
        self.font_family = 2
        self.font_charset = 0
        self.font_scheme = 'minor'
        self.font_condense = 0
        self.font_extend = 0
        self.theme = 0
        self.hyperlink = False
        self.xf_id = 0

        self.hidden = 0
        self.locked = 1

        self.text_h_align = 0
        self.text_wrap = 0
        self.text_v_align = 0
        self.text_justlast = 0
        self.rotation = 0

        self.fg_color = 0
        self.bg_color = 0
        self.pattern = 0
        self.has_fill = 0
        self.has_dxf_fill = 0
        self.fill_index = 0
        self.fill_count = 0

        self.border_index = 0
        self.has_border = 0
        self.has_dxf_border = 0
        self.border_count = 0

        self.bottom = 0
        self.bottom_color = 0
        self.diag_border = 0
        self.diag_color = 0
        self.diag_type = 0
        self.left = 0
        self.left_color = 0
        self.right = 0
        self.right_color = 0
        self.top = 0
        self.top_color = 0

        self.indent = 0
        self.shrink = 0
        self.merge_range = 0
        self.reading_order = 0
        self.just_distrib = 0
        self.color_indexed = 0
        self.font_only = 0

        # Convert properties in the constructor to method calls.
        for key, value in properties.items():
            getattr(self, 'set_' + key)(value)

        self._format_key = None

    ###########################################################################
    #
    # Format properties.
    #
    ###########################################################################

    def set_font_name(self, font_name):
        """
        Set the Format font_name property such as 'Time New Roman'. The
        default Excel font is 'Calibri'.

        Args:
            font_name: String with the font name. No default.

        Returns:
            Nothing.

        """
        self.font_name = font_name

    def set_font_size(self, font_size=11):
        """
        Set the Format font_size property. The default Excel font size is 11.

        Args:
            font_size: Int with font size. No default.

        Returns:
            Nothing.

        """
        self.font_size = font_size

    def set_font_color(self, font_color):
        """
        Set the Format font_color property. The Excel default is black.

        Args:
            font_color: String with the font color. No default.

        Returns:
            Nothing.

        """
        self.font_color = self._get_color(font_color)

    def set_bold(self, bold=True):
        """
        Set the Format bold property.

        Args:
            bold: Default is True, turns property on.

        Returns:
            Nothing.

        """
        self.bold = bold

    def set_italic(self, italic=True):
        """
        Set the Format italic property.

        Args:
            italic: Default is True, turns property on.

        Returns:
            Nothing.

        """
        self.italic = italic

    def set_underline(self, underline=1):
        """
        Set the Format underline property.

        Args:
            underline: Default is 1, single underline.

        Returns:
            Nothing.

        """
        self.underline = underline

    def set_font_strikeout(self, font_strikeout=True):
        """
        Set the Format font_strikeout property.

        Args:
            font_strikeout: Default is True, turns property on.

        Returns:
            Nothing.

        """
        self.font_strikeout = font_strikeout

    def set_font_script(self, font_script=1):
        """
        Set the Format font_script property.

        Args:
            font_script: Default is 1, superscript.

        Returns:
            Nothing.

        """
        self.font_script = font_script

    def set_font_outline(self, font_outline=True):
        """
        Set the Format font_outline property.

        Args:
            font_outline: Default is True, turns property on.

        Returns:
            Nothing.

        """
        self.font_outline = font_outline

    def set_font_shadow(self, font_shadow=True):
        """
        Set the Format font_shadow property.

        Args:
            font_shadow: Default is True, turns property on.

        Returns:
            Nothing.

        """
        self.font_shadow = font_shadow

    def set_num_format(self, num_format):
        """
        Set the Format num_format property such as '#,##0'.

        Args:
            num_format: String representing the number format. No default.

        Returns:
            Nothing.

        """
        self.num_format = num_format

    def set_locked(self, locked=True):
        """
        Set the Format locked property.

        Args:
            locked: Default is True, turns property on.

        Returns:
            Nothing.

        """
        self.locked = locked

    def set_hidden(self, hidden=True):
        """
        Set the Format hidden property.

        Args:
            hidden: Default is True, turns property on.

        Returns:
            Nothing.

        """
        self.hidden = hidden

    def set_align(self, alignment):
        """
        Set the Format cell alignment.

        Args:
            alignment: String representing alignment. No default.

        Returns:
            Nothing.
        """
        alignment = alignment.lower()

        # Set horizontal alignment properties.
        if alignment == 'left':
            self.set_text_h_align(1)
        if alignment == 'centre':
            self.set_text_h_align(2)
        if alignment == 'center':
            self.set_text_h_align(2)
        if alignment == 'right':
            self.set_text_h_align(3)
        if alignment == 'fill':
            self.set_text_h_align(4)
        if alignment == 'justify':
            self.set_text_h_align(5)
        if alignment == 'center_across':
            self.set_text_h_align(6)
        if alignment == 'centre_across':
            self.set_text_h_align(6)
        if alignment == 'distributed':
            self.set_text_h_align(7)
        if alignment == 'justify_distributed':
            self.set_text_h_align(7)

        if alignment == 'justify_distributed':
            self.just_distrib = 1

        # Set vertical alignment properties.
        if alignment == 'top':
            self.set_text_v_align(1)
        if alignment == 'vcentre':
            self.set_text_v_align(2)
        if alignment == 'vcenter':
            self.set_text_v_align(2)
        if alignment == 'bottom':
            self.set_text_v_align(3)
        if alignment == 'vjustify':
            self.set_text_v_align(4)
        if alignment == 'vdistributed':
            self.set_text_v_align(5)

    def set_center_across(self, align_type=None):
        """
        Set the Format center_across property.

        Returns:
            Nothing.

        """
        self.set_text_h_align(6)

    def set_text_wrap(self, text_wrap=True):
        """
        Set the Format text_wrap property.

        Args:
            text_wrap: Default is True, turns property on.

        Returns:
            Nothing.

        """
        self.text_wrap = text_wrap

    def set_rotation(self, rotation):
        """
        Set the Format rotation property.

        Args:
            rotation: Rotation angle. No default.

        Returns:
            Nothing.

        """
        rotation = int(rotation)

        # Map user angle to Excel angle.
        if rotation == 270:
            rotation = 255
        elif -90 <= rotation <= 90:
            if rotation < 0:
                rotation = -rotation + 90
        else:
            warn("Rotation rotation outside range: -90 <= angle <= 90")
            return

        self.rotation = rotation

    def set_indent(self, indent=1):
        """
        Set the Format indent property.

        Args:
            indent: Default is 1, first indentation level.

        Returns:
            Nothing.

        """
        self.indent = indent

    def set_shrink(self, shrink=True):
        """
        Set the Format shrink property.

        Args:
            shrink: Default is True, turns property on.

        Returns:
            Nothing.

        """
        self.shrink = shrink

    def set_text_justlast(self, text_justlast=True):
        """
        Set the Format text_justlast property.

        Args:
            text_justlast: Default is True, turns property on.

        Returns:
            Nothing.

        """
        self.text_justlast = text_justlast

    def set_pattern(self, pattern=1):
        """
        Set the Format pattern property.

        Args:
            pattern: Default is 1, solid fill.

        Returns:
            Nothing.

        """
        self.pattern = pattern

    def set_bg_color(self, bg_color):
        """
        Set the Format bg_color property.

        Args:
            bg_color: Background color. No default.

        Returns:
            Nothing.

        """
        self.bg_color = self._get_color(bg_color)

    def set_fg_color(self, fg_color):
        """
        Set the Format fg_color property.

        Args:
            fg_color: Foreground color. No default.

        Returns:
            Nothing.

        """
        self.fg_color = self._get_color(fg_color)

    # set_border(style) Set cells borders to the same style
    def set_border(self, style=1):
        """
        Set the Format bottom property.

        Args:
            bottom: Default is 1, border type 1.

        Returns:
            Nothing.

        """
        self.set_bottom(style)
        self.set_top(style)
        self.set_left(style)
        self.set_right(style)

    # set_border_color(color) Set cells border to the same color
    def set_border_color(self, color):
        """
        Set the Format bottom property.

        Args:
            color: Color string. No default.

        Returns:
            Nothing.

        """
        self.set_bottom_color(color)
        self.set_top_color(color)
        self.set_left_color(color)
        self.set_right_color(color)

    def set_bottom(self, bottom=1):
        """
        Set the Format bottom property.

        Args:
            bottom: Default is 1, border type 1.

        Returns:
            Nothing.

        """
        self.bottom = bottom

    def set_bottom_color(self, bottom_color):
        """
        Set the Format bottom_color property.

        Args:
            bottom_color: Color string. No default.

        Returns:
            Nothing.

        """
        self.bottom_color = self._get_color(bottom_color)

    def set_diag_type(self, diag_type=1):
        """
        Set the Format diag_type property.

        Args:
            diag_type: Default is 1, border type 1.

        Returns:
            Nothing.

        """
        self.diag_type = diag_type

    def set_left(self, left=1):
        """
        Set the Format left property.

        Args:
            left: Default is 1, border type 1.

        Returns:
            Nothing.

        """
        self.left = left

    def set_left_color(self, left_color):
        """
        Set the Format left_color property.

        Args:
            left_color: Color string. No default.

        Returns:
            Nothing.

        """
        self.left_color = self._get_color(left_color)

    def set_right(self, right=1):
        """
        Set the Format right property.

        Args:
            right: Default is 1, border type 1.

        Returns:
            Nothing.

        """
        self.right = right

    def set_right_color(self, right_color):
        """
        Set the Format right_color property.

        Args:
            right_color: Color string. No default.

        Returns:
            Nothing.

        """
        self.right_color = self._get_color(right_color)

    def set_top(self, top=1):
        """
        Set the Format top property.

        Args:
            top: Default is 1, border type 1.

        Returns:
            Nothing.

        """
        self.top = top

    def set_top_color(self, top_color):
        """
        Set the Format top_color property.

        Args:
            top_color: Color string. No default.

        Returns:
            Nothing.

        """
        self.top_color = self._get_color(top_color)

    def set_diag_color(self, diag_color):
        """
        Set the Format diag_color property.

        Args:
            diag_color: Color string. No default.

        Returns:
            Nothing.

        """
        self.diag_color = self._get_color(diag_color)

    def set_diag_border(self, diag_border=1):
        """
        Set the Format diag_border property.

        Args:
            diag_border: Default is 1, border type 1.

        Returns:
            Nothing.

        """
        self.diag_border = diag_border

    ###########################################################################
    #
    # Internal Format properties. These aren't documented since they are
    # either only used internally or else are unlikely to be set by the user.
    #
    ###########################################################################

    def set_has_font(self, has_font=True):
        # Set the has_font property.
        self.has_font = has_font

    def set_has_fill(self, has_fill=True):
        # Set the has_fill property.
        self.has_fill = has_fill

    def set_font_index(self, font_index):
        # Set the font_index property.
        self.font_index = font_index

    def set_xf_index(self, xf_index):
        # Set the xf_index property.
        self.xf_index = xf_index

    def set_dxf_index(self, dxf_index):
        # Set the xf_index property.
        self.dxf_index = dxf_index

    def set_num_format_index(self, num_format_index):
        # Set the num_format_index property.
        self.num_format_index = num_format_index

    def set_text_h_align(self, text_h_align):
        # Set the text_h_align property.
        self.text_h_align = text_h_align

    def set_text_v_align(self, text_v_align):
        # Set the text_v_align property.
        self.text_v_align = text_v_align

    def set_reading_order(self, direction=0):
        # Set the reading_order property.
        self.reading_order = direction

    def set_valign(self, align):
        # Set vertical cell alignment. This is required by the constructor
        # properties dict to differentiate between the vertical and horizontal
        # properties.
        self.set_align(align)

    def set_font_family(self, font_family):
        # Set the Format font_family property.
        self.font_family = font_family

    def set_font_charset(self, font_charset):
        # Set the Format font_charset property.
        self.font_charset = font_charset

    def set_font_scheme(self, font_scheme):
        # Set the Format font_scheme property.
        self.font_scheme = font_scheme

    def set_font_condense(self, font_condense):
        # Set the Format font_condense property.
        self.font_condense = font_condense

    def set_font_extend(self, font_extend):
        # Set the Format font_extend property.
        self.font_extend = font_extend

    def set_theme(self, theme):
        # Set the Format theme property.
        self.theme = theme

    def set_hyperlink(self, hyperlink=True):
        # Set the properties for the hyperlink style. This isn't
        # currently public. To be fixed when styles are supported.
        self.xf_id = 1
        self.set_underline(1)
        self.set_theme(10)
        self.hyperlink = hyperlink

    def set_color_indexed(self, color_index):
        # Used in the cell comment format.
        self.color_indexed = color_index

    def set_font_only(self, font_only=True):
        # Used in the cell comment format.
        self.font_only = font_only

    # Compatibility methods.
    def set_font(self, font_name):
        #  For compatibility with Excel::Writer::XLSX.
        self.font_name = font_name

    def set_size(self, font_size):
        #  For compatibility with Excel::Writer::XLSX.
        self.font_size = font_size

    def set_color(self, font_color):
        #  For compatibility with Excel::Writer::XLSX.
        self.font_color = self._get_color(font_color)

    ###########################################################################
    #
    # Private API.
    #
    ###########################################################################

    def _get_align_properties(self):
        # Return properties for an Style xf <alignment> sub-element.
        changed = 0
        align = []

        # Check if any alignment options in the format have been changed.
        if (self.text_h_align or self.text_v_align or self.indent
                or self.rotation or self.text_wrap or self.shrink
                or self.reading_order):
            changed = 1
        else:
            return changed, align

        # Indent is only allowed for horizontal left, right and distributed.
        # If it is defined for any other alignment or no alignment has
        # been set then default to left alignment.
        if (self.indent
                and self.text_h_align != 1
                and self.text_h_align != 3
                and self.text_h_align != 7):
            self.text_h_align = 1

        # Check for properties that are mutually exclusive.
        if self.text_wrap:
            self.shrink = 0
        if self.text_h_align == 4:
            self.shrink = 0
        if self.text_h_align == 5:
            self.shrink = 0
        if self.text_h_align == 7:
            self.shrink = 0
        if self.text_h_align != 7:
            self.just_distrib = 0
        if self.indent:
            self.just_distrib = 0

        continuous = 'centerContinuous'

        if self.text_h_align == 1:
            align.append(('horizontal', 'left'))
        if self.text_h_align == 2:
            align.append(('horizontal', 'center'))
        if self.text_h_align == 3:
            align.append(('horizontal', 'right'))
        if self.text_h_align == 4:
            align.append(('horizontal', 'fill'))
        if self.text_h_align == 5:
            align.append(('horizontal', 'justify'))
        if self.text_h_align == 6:
            align.append(('horizontal', continuous))
        if self.text_h_align == 7:
            align.append(('horizontal', 'distributed'))

        if self.just_distrib:
            align.append(('justifyLastLine', 1))

        # Property 'vertical' => 'bottom' is a default. It sets applyAlignment
        # without an alignment sub-element.
        if self.text_v_align == 1:
            align.append(('vertical', 'top'))
        if self.text_v_align == 2:
            align.append(('vertical', 'center'))
        if self.text_v_align == 4:
            align.append(('vertical', 'justify'))
        if self.text_v_align == 5:
            align.append(('vertical', 'distributed'))

        if self.indent:
            align.append(('indent', self.indent))
        if self.rotation:
            align.append(('textRotation', self.rotation))

        if self.text_wrap:
            align.append(('wrapText', 1))
        if self.shrink:
            align.append(('shrinkToFit', 1))

        if self.reading_order == 1:
            align.append(('readingOrder', 1))
        if self.reading_order == 2:
            align.append(('readingOrder', 2))

        return changed, align

    def _get_protection_properties(self):
        # Return properties for an Excel XML <Protection> element.
        attribs = []

        if not self.locked:
            attribs.append(('locked', 0))
        if self.hidden:
            attribs.append(('hidden', 1))

        return attribs

    def _get_format_key(self):
        # Returns a unique hash key for a font. Used by Workbook.
        if self._format_key is None:
            self._format_key = ':'.join(self._to_string(x) for x in (
                self._get_font_key(),
                self._get_border_key(),
                self._get_fill_key(),
                self._get_alignment_key(),
                self.num_format,
                self.locked,
                self.hidden))

        return self._format_key

    def _get_font_key(self):
        # Returns a unique hash key for a font. Used by Workbook.
        key = ':'.join(self._to_string(x) for x in (
            self.bold,
            self.font_color,
            self.font_charset,
            self.font_family,
            self.font_outline,
            self.font_script,
            self.font_shadow,
            self.font_strikeout,
            self.font_name,
            self.italic,
            self.font_size,
            self.underline,
            self.theme))

        return key

    def _get_border_key(self):
        # Returns a unique hash key for a border style. Used by Workbook.
        key = ':'.join(self._to_string(x) for x in (
            self.bottom,
            self.bottom_color,
            self.diag_border,
            self.diag_color,
            self.diag_type,
            self.left,
            self.left_color,
            self.right,
            self.right_color,
            self.top,
            self.top_color))

        return key

    def _get_fill_key(self):
        # Returns a unique hash key for a fill style. Used by Workbook.
        key = ':'.join(self._to_string(x) for x in (
            self.pattern,
            self.bg_color,
            self.fg_color))

        return key

    def _get_alignment_key(self):
        # Returns a unique hash key for alignment formats.

        key = ':'.join(self._to_string(x) for x in (
            self.text_h_align,
            self.text_v_align,
            self.indent,
            self.rotation,
            self.text_wrap,
            self.shrink,
            self.reading_order))

        return key

    def _get_xf_index(self):
        # Returns the XF index number used by Excel to identify a format.
        if self.xf_index is not None:
            # Format already has an index number so return it.
            return self.xf_index
        else:
            # Format doesn't have an index number so assign one.
            key = self._get_format_key()

            if key in self.xf_format_indices:
                # Format matches existing format with an index.
                return self.xf_format_indices[key]
            else:
                # New format requiring an index. Note. +1 since Excel
                # has an implicit "General" format at index 0.
                index = 1 + len(self.xf_format_indices)
                self.xf_format_indices[key] = index
                self.xf_index = index
                return index

    def _get_dxf_index(self):
        # Returns the DXF index number used by Excel to identify a format.
        if self.dxf_index is not None:
            # Format already has an index number so return it.
            return self.dxf_index
        else:
            # Format doesn't have an index number so assign one.
            key = self._get_format_key()

            if key in self.dxf_format_indices:
                # Format matches existing format with an index.
                return self.dxf_format_indices[key]
            else:
                # New format requiring an index.
                index = len(self.dxf_format_indices)
                self.dxf_format_indices[key] = index
                self.dxf_index = index
                return index

    def _get_color(self, color):
        # Used in conjunction with the set_xxx_color methods to convert a
        # color name into an RGB formatted string. These colors are for
        # backward compatibility with older versions of Excel.
        named_colors = {
            'black': '#000000',
            'blue': '#0000FF',
            'brown': '#800000',
            'cyan': '#00FFFF',
            'gray': '#808080',
            'green': '#008000',
            'lime': '#00FF00',
            'magenta': '#FF00FF',
            'navy': '#000080',
            'orange': '#FF6600',
            'pink': '#FF00FF',
            'purple': '#800080',
            'red': '#FF0000',
            'silver': '#C0C0C0',
            'white': '#FFFFFF',
            'yellow': '#FFFF00',
        }

        if color in named_colors:
            color = named_colors[color]

        return color

    def _to_string(self, value):
        # Convert number to a string but allow for utf-8 strings in Python 2.
        try:
            return str(value)
        except UnicodeEncodeError:
            return value.encode('utf-8')

    ###########################################################################
    #
    # XML methods.
    #
    ###########################################################################

```

---

### File: `tmp\xlsxwriter_old\XlsxWriter-1.4.5\xlsxwriter\metadata.py`

```python
###############################################################################
#
# Metadata - A class for writing the Excel XLSX Metadata file.
#
# Copyright 2013-2021, John McNamara, jmcnamara@cpan.org
#

from . import xmlwriter


class Metadata(xmlwriter.XMLwriter):
    """
    A class for writing the Excel XLSX Metadata file.


    """

    ###########################################################################
    #
    # Public API.
    #
    ###########################################################################

    def __init__(self):
        """
        Constructor.

        """

        super(Metadata, self).__init__()

    ###########################################################################
    #
    # Private API.
    #
    ###########################################################################

    def _assemble_xml_file(self):
        # Assemble and write the XML file.

        # Write the XML declaration.
        self._xml_declaration()

        # Write the metadata element.
        self._write_metadata()

        # Write the metadataTypes element.
        self._write_metadata_types()

        # Write the futureMetadata element.
        self._write_future_metadata()

        # Write the cellMetadata element.
        self._write_cell_metadata()

        self._xml_end_tag('metadata')

        # Close the file.
        self._xml_close()

    ###########################################################################
    #
    # XML methods.
    #
    ###########################################################################

    def _write_metadata(self):
        # Write the <metadata> element.
        xmlns = 'http://schemas.openxmlformats.org/spreadsheetml/2006/main'
        schema = 'http://schemas.microsoft.com/office'
        xmlns_xda = schema + '/spreadsheetml/2017/dynamicarray'

        attributes = [
            ('xmlns', xmlns),
            ('xmlns:xda', xmlns_xda),
        ]

        self._xml_start_tag('metadata', attributes)

    def _write_metadata_types(self):
        # Write the <metadataTypes> element.
        attributes = [('count', 1)]

        self._xml_start_tag('metadataTypes', attributes)

        # Write the metadataType element.
        self._write_metadata_type()

        self._xml_end_tag('metadataTypes')

    def _write_metadata_type(self):
        # Write the <metadataType> element.
        attributes = [
            ('name', 'XLDAPR'),
            ('minSupportedVersion', 120000),
            ('copy', 1),
            ('pasteAll', 1),
            ('pasteValues', 1),
            ('merge', 1),
            ('splitFirst', 1),
            ('rowColShift', 1),
            ('clearFormats', 1),
            ('clearComments', 1),
            ('assign', 1),
            ('coerce', 1),
            ('cellMeta', 1),
        ]

        self._xml_empty_tag('metadataType', attributes)

    def _write_future_metadata(self):
        # Write the <futureMetadata> element.
        attributes = [
            ('name', 'XLDAPR'),
            ('count', 1),
        ]

        self._xml_start_tag('futureMetadata', attributes)
        self._xml_start_tag('bk')
        self._xml_start_tag('extLst')

        # Write the ext element.
        self._write_ext()

        self._xml_end_tag('extLst')
        self._xml_end_tag('bk')
        self._xml_end_tag('futureMetadata')

    def _write_ext(self):
        # Write the <ext> element.
        attributes = [('uri', '{bdbb8cdc-fa1e-496e-a857-3c3f30c029c3}')]

        self._xml_start_tag('ext', attributes)

        # Write the xda:dynamicArrayProperties element.
        self._write_xda_dynamic_array_properties()

        self._xml_end_tag('ext')

    def _write_xda_dynamic_array_properties(self):
        # Write the <xda:dynamicArrayProperties> element.
        attributes = [
            ('fDynamic', 1),
            ('fCollapsed', 0),
        ]

        self._xml_empty_tag('xda:dynamicArrayProperties', attributes)

    def _write_cell_metadata(self):
        # Write the <cellMetadata> element.
        attributes = [('count', 1)]

        self._xml_start_tag('cellMetadata', attributes)
        self._xml_start_tag('bk')

        # Write the rc element.
        self._write_rc()

        self._xml_end_tag('bk')
        self._xml_end_tag('cellMetadata')

    def _write_rc(self):
        # Write the <rc> element.
        attributes = [
            ('t', 1),
            ('v', 0),
        ]

        self._xml_empty_tag('rc', attributes)

```

---

### File: `tmp\xlsxwriter_old\XlsxWriter-1.4.5\xlsxwriter\packager.py`

```python
###############################################################################
#
# Packager - A class for writing the Excel XLSX Worksheet file.
#
# Copyright 2013-2021, John McNamara, jmcnamara@cpan.org
#

# Standard packages.
import os
import stat
import tempfile
from shutil import copy

from .compatibility import StringIO
from io import BytesIO

# Package imports.
from .app import App
from .contenttypes import ContentTypes
from .core import Core
from .custom import Custom
from .metadata import Metadata
from .relationships import Relationships
from .sharedstrings import SharedStrings
from .styles import Styles
from .theme import Theme
from .vml import Vml
from .table import Table
from .comments import Comments
from .exceptions import EmptyChartSeries


class Packager(object):
    """
    A class for writing the Excel XLSX Packager file.

    This module is used in conjunction with XlsxWriter to create an
    Excel XLSX container file.

    From Wikipedia: The Open Packaging Conventions (OPC) is a
    container-file technology initially created by Microsoft to store
    a combination of XML and non-XML files that together form a single
    entity such as an Open XML Paper Specification (OpenXPS)
    document. http://en.wikipedia.org/wiki/Open_Packaging_Conventions.

    At its simplest an Excel XLSX file contains the following elements::

         ____ [Content_Types].xml
        |
        |____ docProps
        | |____ app.xml
        | |____ core.xml
        |
        |____ xl
        | |____ workbook.xml
        | |____ worksheets
        | | |____ sheet1.xml
        | |
        | |____ styles.xml
        | |
        | |____ theme
        | | |____ theme1.xml
        | |
        | |_____rels
        | |____ workbook.xml.rels
        |
        |_____rels
          |____ .rels

    The Packager class coordinates the classes that represent the
    elements of the package and writes them into the XLSX file.

    """

    ###########################################################################
    #
    # Public API.
    #
    ###########################################################################

    def __init__(self):
        """
        Constructor.

        """

        super(Packager, self).__init__()

        self.tmpdir = ''
        self.in_memory = False
        self.workbook = None
        self.worksheet_count = 0
        self.chartsheet_count = 0
        self.chart_count = 0
        self.drawing_count = 0
        self.table_count = 0
        self.num_vml_files = 0
        self.num_comment_files = 0
        self.named_ranges = []
        self.filenames = []

    ###########################################################################
    #
    # Private API.
    #
    ###########################################################################

    def _set_tmpdir(self, tmpdir):
        # Set an optional user defined temp directory.
        self.tmpdir = tmpdir

    def _set_in_memory(self, in_memory):
        # Set the optional 'in_memory' mode.
        self.in_memory = in_memory

    def _add_workbook(self, workbook):
        # Add the Excel::Writer::XLSX::Workbook object to the package.
        self.workbook = workbook
        self.chart_count = len(workbook.charts)
        self.drawing_count = len(workbook.drawings)
        self.num_vml_files = workbook.num_vml_files
        self.num_comment_files = workbook.num_comment_files
        self.named_ranges = workbook.named_ranges

        for worksheet in self.workbook.worksheets():
            if worksheet.is_chartsheet:
                self.chartsheet_count += 1
            else:
                self.worksheet_count += 1

    def _create_package(self):
        # Write the xml files that make up the XLSX OPC package.
        self._write_content_types_file()
        self._write_root_rels_file()
        self._write_workbook_rels_file()
        self._write_worksheet_files()
        self._write_chartsheet_files()
        self._write_workbook_file()
        self._write_chart_files()
        self._write_drawing_files()
        self._write_vml_files()
        self._write_comment_files()
        self._write_table_files()
        self._write_shared_strings_file()
        self._write_styles_file()
        self._write_custom_file()
        self._write_theme_file()
        self._write_worksheet_rels_files()
        self._write_chartsheet_rels_files()
        self._write_drawing_rels_files()
        self._add_image_files()
        self._add_vba_project()
        self._write_core_file()
        self._write_app_file()
        self._write_metadata_file()

        return self.filenames

    def _filename(self, xml_filename):
        # Create a temp filename to write the XML data to and store the Excel
        # filename to use as the name in the Zip container.
        if self.in_memory:
            os_filename = StringIO()
        else:
            (fd, os_filename) = tempfile.mkstemp(dir=self.tmpdir)
            os.close(fd)

        self.filenames.append((os_filename, xml_filename, False))

        return os_filename

    def _write_workbook_file(self):
        # Write the workbook.xml file.
        workbook = self.workbook

        workbook._set_xml_writer(self._filename('xl/workbook.xml'))
        workbook._assemble_xml_file()

    def _write_worksheet_files(self):
        # Write the worksheet files.
        index = 1
        for worksheet in self.workbook.worksheets():
            if worksheet.is_chartsheet:
                continue

            if worksheet.constant_memory:
                worksheet._opt_reopen()
                worksheet._write_single_row()

            worksheet._set_xml_writer(self._filename('xl/worksheets/sheet'
                                                     + str(index) + '.xml'))
            worksheet._assemble_xml_file()
            index += 1

    def _write_chartsheet_files(self):
        # Write the chartsheet files.
        index = 1
        for worksheet in self.workbook.worksheets():
            if not worksheet.is_chartsheet:
                continue

            worksheet._set_xml_writer(self._filename('xl/chartsheets/sheet'
                                                     + str(index) + '.xml'))
            worksheet._assemble_xml_file()
            index += 1

    def _write_chart_files(self):
        # Write the chart files.
        if not self.workbook.charts:
            return

        index = 1
        for chart in self.workbook.charts:
            # Check that the chart has at least one data series.
            if not chart.series:
                raise EmptyChartSeries("Chart%d must contain at least one "
                                       "data series. See chart.add_series()."
                                       % index)

            chart._set_xml_writer(self._filename('xl/charts/chart'
                                                 + str(index) + '.xml'))
            chart._assemble_xml_file()
            index += 1

    def _write_drawing_files(self):
        # Write the drawing files.
        if not self.drawing_count:
            return

        index = 1
        for drawing in self.workbook.drawings:
            drawing._set_xml_writer(self._filename('xl/drawings/drawing'
                                                   + str(index) + '.xml'))
            drawing._assemble_xml_file()
            index += 1

    def _write_vml_files(self):
        # Write the comment VML files.
        index = 1
        for worksheet in self.workbook.worksheets():
            if not worksheet.has_vml and not worksheet.has_header_vml:
                continue
            if worksheet.has_vml:
                vml = Vml()
                vml._set_xml_writer(self._filename('xl/drawings/vmlDrawing'
                                                   + str(index) + '.vml'))
                vml._assemble_xml_file(worksheet.vml_data_id,
                                       worksheet.vml_shape_id,
                                       worksheet.comments_list,
                                       worksheet.buttons_list)
                index += 1

            if worksheet.has_header_vml:
                vml = Vml()

                vml._set_xml_writer(self._filename('xl/drawings/vmlDrawing'
                                                   + str(index) + '.vml'))
                vml._assemble_xml_file(worksheet.vml_header_id,
                                       worksheet.vml_header_id * 1024,
                                       None,
                                       None,
                                       worksheet.header_images_list)

                self._write_vml_drawing_rels_file(worksheet, index)
                index += 1

    def _write_comment_files(self):
        # Write the comment files.
        index = 1
        for worksheet in self.workbook.worksheets():
            if not worksheet.has_comments:
                continue

            comment = Comments()
            comment._set_xml_writer(self._filename('xl/comments'
                                                   + str(index) + '.xml'))
            comment._assemble_xml_file(worksheet.comments_list)
            index += 1

    def _write_shared_strings_file(self):
        # Write the sharedStrings.xml file.
        sst = SharedStrings()
        sst.string_table = self.workbook.str_table

        if not self.workbook.str_table.count:
            return

        sst._set_xml_writer(self._filename('xl/sharedStrings.xml'))
        sst._assemble_xml_file()

    def _write_app_file(self):
        # Write the app.xml file.
        properties = self.workbook.doc_properties
        app = App()

        # Add the Worksheet heading pairs.
        app._add_heading_pair(['Worksheets', self.worksheet_count])

        # Add the Chartsheet heading pairs.
        app._add_heading_pair(['Charts', self.chartsheet_count])

        # Add the Worksheet parts.
        for worksheet in self.workbook.worksheets():
            if worksheet.is_chartsheet:
                continue
            app._add_part_name(worksheet.name)

        # Add the Chartsheet parts.
        for worksheet in self.workbook.worksheets():
            if not worksheet.is_chartsheet:
                continue
            app._add_part_name(worksheet.name)

        # Add the Named Range heading pairs.
        if self.named_ranges:
            app._add_heading_pair(['Named Ranges', len(self.named_ranges)])

        # Add the Named Ranges parts.
        for named_range in self.named_ranges:
            app._add_part_name(named_range)

        app._set_properties(properties)
        app.doc_security = self.workbook.read_only

        app._set_xml_writer(self._filename('docProps/app.xml'))
        app._assemble_xml_file()

    def _write_core_file(self):
        # Write the core.xml file.
        properties = self.workbook.doc_properties
        core = Core()

        core._set_properties(properties)
        core._set_xml_writer(self._filename('docProps/core.xml'))
        core._assemble_xml_file()

    def _write_metadata_file(self):
        # Write the metadata.xml file.
        if not self.workbook.has_metadata:
            return

        metadata = Metadata()
        metadata._set_xml_writer(self._filename('xl/metadata.xml'))
        metadata._assemble_xml_file()

    def _write_custom_file(self):
        # Write the custom.xml file.
        properties = self.workbook.custom_properties
        custom = Custom()

        if not len(properties):
            return

        custom._set_properties(properties)
        custom._set_xml_writer(self._filename('docProps/custom.xml'))
        custom._assemble_xml_file()

    def _write_content_types_file(self):
        # Write the ContentTypes.xml file.
        content = ContentTypes()
        content._add_image_types(self.workbook.image_types)

        self._get_table_count()

        worksheet_index = 1
        chartsheet_index = 1
        for worksheet in self.workbook.worksheets():
            if worksheet.is_chartsheet:
                content._add_chartsheet_name('sheet' + str(chartsheet_index))
                chartsheet_index += 1
            else:
                content._add_worksheet_name('sheet' + str(worksheet_index))
                worksheet_index += 1

        for i in range(1, self.chart_count + 1):
            content._add_chart_name('chart' + str(i))

        for i in range(1, self.drawing_count + 1):
            content._add_drawing_name('drawing' + str(i))

        if self.num_vml_files:
            content._add_vml_name()

        for i in range(1, self.table_count + 1):
            content._add_table_name('table' + str(i))

        for i in range(1, self.num_comment_files + 1):
            content._add_comment_name('comments' + str(i))

        # Add the sharedString rel if there is string data in the workbook.
        if self.workbook.str_table.count:
            content._add_shared_strings()

        # Add vbaProject if present.
        if self.workbook.vba_project:
            content._add_vba_project()

        # Add the custom properties if present.
        if self.workbook.custom_properties:
            content._add_custom_properties()

        # Add the metadata file if present.
        if self.workbook.has_metadata:
            content._add_metadata()

        content._set_xml_writer(self._filename('[Content_Types].xml'))
        content._assemble_xml_file()

    def _write_styles_file(self):
        # Write the style xml file.
        xf_formats = self.workbook.xf_formats
        palette = self.workbook.palette
        font_count = self.workbook.font_count
        num_format_count = self.workbook.num_format_count
        border_count = self.workbook.border_count
        fill_count = self.workbook.fill_count
        custom_colors = self.workbook.custom_colors
        dxf_formats = self.workbook.dxf_formats
        has_comments = self.workbook.has_comments

        styles = Styles()
        styles._set_style_properties([
            xf_formats,
            palette,
            font_count,
            num_format_count,
            border_count,
            fill_count,
            custom_colors,
            dxf_formats,
            has_comments])

        styles._set_xml_writer(self._filename('xl/styles.xml'))
        styles._assemble_xml_file()

    def _write_theme_file(self):
        # Write the theme xml file.
        theme = Theme()

        theme._set_xml_writer(self._filename('xl/theme/theme1.xml'))
        theme._assemble_xml_file()

    def _write_table_files(self):
        # Write the table files.
        index = 1
        for worksheet in self.workbook.worksheets():
            table_props = worksheet.tables

            if not table_props:
                continue

            for table_props in table_props:
                table = Table()
                table._set_xml_writer(self._filename('xl/tables/table'
                                                     + str(index) + '.xml'))
                table._set_properties(table_props)
                table._assemble_xml_file()
                index += 1

    def _get_table_count(self):
        # Count the table files. Required for the [Content_Types] file.
        for worksheet in self.workbook.worksheets():
            for table_props in worksheet.tables:
                self.table_count += 1

    def _write_root_rels_file(self):
        # Write the _rels/.rels xml file.
        rels = Relationships()

        rels._add_document_relationship('/officeDocument', 'xl/workbook.xml')

        rels._add_package_relationship('/metadata/core-properties',
                                       'docProps/core.xml')

        rels._add_document_relationship('/extended-properties',
                                        'docProps/app.xml')

        if self.workbook.custom_properties:
            rels._add_document_relationship('/custom-properties',
                                            'docProps/custom.xml')

        rels._set_xml_writer(self._filename('_rels/.rels'))

        rels._assemble_xml_file()

    def _write_workbook_rels_file(self):
        # Write the _rels/.rels xml file.
        rels = Relationships()

        worksheet_index = 1
        chartsheet_index = 1

        for worksheet in self.workbook.worksheets():
            if worksheet.is_chartsheet:
                rels._add_document_relationship('/chartsheet',
                                                'chartsheets/sheet'
                                                + str(chartsheet_index)
                                                + '.xml')
                chartsheet_index += 1
            else:
                rels._add_document_relationship('/worksheet',
                                                'worksheets/sheet'
                                                + str(worksheet_index)
                                                + '.xml')
                worksheet_index += 1

        rels._add_document_relationship('/theme', 'theme/theme1.xml')
        rels._add_document_relationship('/styles', 'styles.xml')

        # Add the sharedString rel if there is string data in the workbook.
        if self.workbook.str_table.count:
            rels._add_document_relationship('/sharedStrings',
                                            'sharedStrings.xml')

        # Add vbaProject if present.
        if self.workbook.vba_project:
            rels._add_ms_package_relationship('/vbaProject', 'vbaProject.bin')

        # Add the metadata file if required.
        if self.workbook.has_metadata:
            rels._add_document_relationship('/sheetMetadata', 'metadata.xml')

        rels._set_xml_writer(self._filename('xl/_rels/workbook.xml.rels'))
        rels._assemble_xml_file()

    def _write_worksheet_rels_files(self):
        # Write data such as hyperlinks or drawings.
        index = 0
        for worksheet in self.workbook.worksheets():

            if worksheet.is_chartsheet:
                continue

            index += 1

            external_links = (worksheet.external_hyper_links +
                              worksheet.external_drawing_links +
                              worksheet.external_vml_links +
                              worksheet.external_table_links +
                              worksheet.external_background_links +
                              worksheet.external_comment_links)

            if not external_links:
                continue

            # Create the worksheet .rels dirs.
            rels = Relationships()

            for link_data in external_links:
                rels._add_worksheet_relationship(*link_data)

            # Create .rels file such as /xl/worksheets/_rels/sheet1.xml.rels.
            rels._set_xml_writer(self._filename('xl/worksheets/_rels/sheet'
                                                + str(index) + '.xml.rels'))
            rels._assemble_xml_file()

    def _write_chartsheet_rels_files(self):
        # Write the chartsheet .rels files for links to drawing files.
        index = 0
        for worksheet in self.workbook.worksheets():

            if not worksheet.is_chartsheet:
                continue

            index += 1

            external_links = worksheet.external_drawing_links

            if not external_links:
                continue

            # Create the chartsheet .rels xlsx_dir.
            rels = Relationships()

            for link_data in external_links:
                rels._add_worksheet_relationship(*link_data)

            # Create .rels file such as /xl/chartsheets/_rels/sheet1.xml.rels.
            rels._set_xml_writer(self._filename('xl/chartsheets/_rels/sheet'
                                                + str(index) + '.xml.rels'))
            rels._assemble_xml_file()

    def _write_drawing_rels_files(self):
        # Write the drawing .rels files for worksheets with charts or drawings.
        index = 0
        for worksheet in self.workbook.worksheets():
            if worksheet.drawing:
                index += 1

            if not worksheet.drawing_links:
                continue

            # Create the drawing .rels xlsx_dir.
            rels = Relationships()

            for drawing_data in worksheet.drawing_links:
                rels._add_document_relationship(*drawing_data)

            # Create .rels file such as /xl/drawings/_rels/sheet1.xml.rels.
            rels._set_xml_writer(self._filename('xl/drawings/_rels/drawing'
                                                + str(index) + '.xml.rels'))
            rels._assemble_xml_file()

    def _write_vml_drawing_rels_file(self, worksheet, index):
        # Write the vmlDdrawing .rels files for worksheets with images in
        # headers or footers.

        # Create the drawing .rels dir.
        rels = Relationships()

        for drawing_data in worksheet.vml_drawing_links:
            rels._add_document_relationship(*drawing_data)

        # Create .rels file such as /xl/drawings/_rels/vmlDrawing1.vml.rels.
        rels._set_xml_writer(self._filename('xl/drawings/_rels/vmlDrawing'
                                            + str(index)
                                            + '.vml.rels'))
        rels._assemble_xml_file()

    def _add_image_files(self):
        # Write the /xl/media/image?.xml files.
        workbook = self.workbook
        index = 1

        for image in workbook.images:
            filename = image[0]
            ext = '.' + image[1]
            image_data = image[2]

            xml_image_name = 'xl/media/image' + str(index) + ext

            if not self.in_memory:
                # In file mode we just write or copy the image file.
                os_filename = self._filename(xml_image_name)

                if image_data:
                    # The data is in a byte stream. Write it to the target.
                    os_file = open(os_filename, mode='wb')
                    os_file.write(image_data.getvalue())
                    os_file.close()
                else:
                    copy(filename, os_filename)

                    # Allow copies of Windows read-only images to be deleted.
                    try:
                        os.chmod(os_filename,
                                 os.stat(os_filename).st_mode | stat.S_IWRITE)
                    except OSError:
                        pass
            else:
                # For in-memory mode we read the image into a stream.
                if image_data:
                    # The data is already in a byte stream.
                    os_filename = image_data
                else:
                    image_file = open(filename, mode='rb')
                    image_data = image_file.read()
                    os_filename = BytesIO(image_data)
                    image_file.close()

                self.filenames.append((os_filename, xml_image_name, True))

            index += 1

    def _add_vba_project(self):
        # Copy in a vbaProject.bin file.
        vba_project = self.workbook.vba_project
        vba_is_stream = self.workbook.vba_is_stream

        if not vba_project:
            return

        xml_vba_name = 'xl/vbaProject.bin'

        if not self.in_memory:
            # In file mode we just write or copy the VBA file.
            os_filename = self._filename(xml_vba_name)

            if vba_is_stream:
                # The data is in a byte stream. Write it to the target.
                os_file = open(os_filename, mode='wb')
                os_file.write(vba_project.getvalue())
                os_file.close()
            else:
                copy(vba_project, os_filename)

        else:
            # For in-memory mode we read the vba into a stream.
            if vba_is_stream:
                # The data is already in a byte stream.
                os_filename = vba_project
            else:
                vba_file = open(vba_project, mode='rb')
                vba_data = vba_file.read()
                os_filename = BytesIO(vba_data)
                vba_file.close()

            self.filenames.append((os_filename, xml_vba_name, True))

```

---

### File: `tmp\xlsxwriter_old\XlsxWriter-1.4.5\xlsxwriter\relationships.py`

```python
###############################################################################
#
# Relationships - A class for writing the Excel XLSX Worksheet file.
#
# Copyright 2013-2021, John McNamara, jmcnamara@cpan.org
#

# Package imports.
from . import xmlwriter

# Long namespace strings used in the class.
schema_root = 'http://schemas.openxmlformats.org'
package_schema = schema_root + '/package/2006/relationships'
document_schema = schema_root + '/officeDocument/2006/relationships'


class Relationships(xmlwriter.XMLwriter):
    """
    A class for writing the Excel XLSX Relationships file.


    """

    ###########################################################################
    #
    # Public API.
    #
    ###########################################################################

    def __init__(self):
        """
        Constructor.

        """

        super(Relationships, self).__init__()

        self.relationships = []
        self.id = 1

    ###########################################################################
    #
    # Private API.
    #
    ###########################################################################

    def _assemble_xml_file(self):
        # Assemble and write the XML file.

        # Write the XML declaration.
        self._xml_declaration()

        self._write_relationships()

        # Close the file.
        self._xml_close()

    def _add_document_relationship(self, rel_type, target, target_mode=None):
        # Add container relationship to XLSX .rels xml files.
        rel_type = document_schema + rel_type

        self.relationships.append((rel_type, target, target_mode))

    def _add_package_relationship(self, rel_type, target):
        # Add container relationship to XLSX .rels xml files.
        rel_type = package_schema + rel_type

        self.relationships.append((rel_type, target, None))

    def _add_ms_package_relationship(self, rel_type, target):
        # Add container relationship to XLSX .rels xml files. Uses MS schema.
        schema = 'http://schemas.microsoft.com/office/2006/relationships'
        rel_type = schema + rel_type

        self.relationships.append((rel_type, target, None))

    def _add_worksheet_relationship(self, rel_type, target, target_mode=None):
        # Add worksheet relationship to sheet.rels xml files.
        rel_type = document_schema + rel_type

        self.relationships.append((rel_type, target, target_mode))

    ###########################################################################
    #
    # XML methods.
    #
    ###########################################################################

    def _write_relationships(self):
        # Write the <Relationships> element.
        attributes = [('xmlns', package_schema,)]

        self._xml_start_tag('Relationships', attributes)

        for relationship in self.relationships:
            self._write_relationship(relationship)

        self._xml_end_tag('Relationships')

    def _write_relationship(self, relationship):
        # Write the <Relationship> element.
        rel_type, target, target_mode = relationship

        attributes = [
            ('Id', 'rId' + str(self.id)),
            ('Type', rel_type),
            ('Target', target),
        ]

        self.id += 1

        if target_mode:
            attributes.append(('TargetMode', target_mode))

        self._xml_empty_tag('Relationship', attributes)

```

---

### File: `tmp\xlsxwriter_old\XlsxWriter-1.4.5\xlsxwriter\shape.py`

```python
###############################################################################
#
# Shape - A class for to represent Excel XLSX shape objects.
#
# Copyright 2013-2021, John McNamara, jmcnamara@cpan.org
#
import copy
from warnings import warn


class Shape(object):
    """
    A class for to represent Excel XLSX shape objects.


    """

    ###########################################################################
    #
    # Public API.
    #
    ###########################################################################

    def __init__(self, shape_type, name, options):
        """
        Constructor.

        """
        super(Shape, self).__init__()
        self.name = name
        self.shape_type = shape_type
        self.connect = 0
        self.drawing = 0
        self.edit_as = ''
        self.id = 0
        self.text = ''
        self.textlink = ''
        self.stencil = 1
        self.element = -1
        self.start = None
        self.start_index = None
        self.end = None
        self.end_index = None
        self.adjustments = []
        self.start_side = ''
        self.end_side = ''
        self.flip_h = 0
        self.flip_v = 0
        self.rotation = 0
        self.text_rotation = 0
        self.textbox = False

        self.align = None
        self.fill = None
        self.font = None
        self.format = None
        self.line = None
        self.url_rel_index = None
        self.tip = None

        self._set_options(options)

    ###########################################################################
    #
    # Private API.
    #
    ###########################################################################

    def _set_options(self, options):

        self.align = self._get_align_properties(options.get('align'))
        self.fill = self._get_fill_properties(options.get('fill'))
        self.font = self._get_font_properties(options.get('font'))
        self.gradient = self._get_gradient_properties(options.get('gradient'))
        self.line = self._get_line_properties(options.get('line'))

        self.text_rotation = options.get('text_rotation', 0)

        self.textlink = options.get('textlink', '')
        if self.textlink.startswith('='):
            self.textlink = self.textlink.lstrip('=')

        if options.get('border'):
            self.line = self._get_line_properties(options['border'])

        # Gradient fill overrides solid fill.
        if self.gradient:
            self.fill = None

    ###########################################################################
    #
    # Static methods for processing chart/shape style properties.
    #
    ###########################################################################

    @staticmethod
    def _get_line_properties(line):
        # Convert user line properties to the structure required internally.

        if not line:
            return {'defined': False}

        # Copy the user defined properties since they will be modified.
        line = copy.deepcopy(line)

        dash_types = {
            'solid': 'solid',
            'round_dot': 'sysDot',
            'square_dot': 'sysDash',
            'dash': 'dash',
            'dash_dot': 'dashDot',
            'long_dash': 'lgDash',
            'long_dash_dot': 'lgDashDot',
            'long_dash_dot_dot': 'lgDashDotDot',
            'dot': 'dot',
            'system_dash_dot': 'sysDashDot',
            'system_dash_dot_dot': 'sysDashDotDot',
        }

        # Check the dash type.
        dash_type = line.get('dash_type')

        if dash_type is not None:
            if dash_type in dash_types:
                line['dash_type'] = dash_types[dash_type]
            else:
                warn("Unknown dash type '%s'" % dash_type)
                return

        line['defined'] = True

        return line

    @staticmethod
    def _get_fill_properties(fill):
        # Convert user fill properties to the structure required internally.

        if not fill:
            return {'defined': False}

        # Copy the user defined properties since they will be modified.
        fill = copy.deepcopy(fill)

        fill['defined'] = True

        return fill

    @staticmethod
    def _get_pattern_properties(pattern):
        # Convert user defined pattern to the structure required internally.

        if not pattern:
            return

        # Copy the user defined properties since they will be modified.
        pattern = copy.deepcopy(pattern)

        if not pattern.get('pattern'):
            warn("Pattern must include 'pattern'")
            return

        if not pattern.get('fg_color'):
            warn("Pattern must include 'fg_color'")
            return

        types = {
            'percent_5': 'pct5',
            'percent_10': 'pct10',
            'percent_20': 'pct20',
            'percent_25': 'pct25',
            'percent_30': 'pct30',
            'percent_40': 'pct40',
            'percent_50': 'pct50',
            'percent_60': 'pct60',
            'percent_70': 'pct70',
            'percent_75': 'pct75',
            'percent_80': 'pct80',
            'percent_90': 'pct90',
            'light_downward_diagonal': 'ltDnDiag',
            'light_upward_diagonal': 'ltUpDiag',
            'dark_downward_diagonal': 'dkDnDiag',
            'dark_upward_diagonal': 'dkUpDiag',
            'wide_downward_diagonal': 'wdDnDiag',
            'wide_upward_diagonal': 'wdUpDiag',
            'light_vertical': 'ltVert',
            'light_horizontal': 'ltHorz',
            'narrow_vertical': 'narVert',
            'narrow_horizontal': 'narHorz',
            'dark_vertical': 'dkVert',
            'dark_horizontal': 'dkHorz',
            'dashed_downward_diagonal': 'dashDnDiag',
            'dashed_upward_diagonal': 'dashUpDiag',
            'dashed_horizontal': 'dashHorz',
            'dashed_vertical': 'dashVert',
            'small_confetti': 'smConfetti',
            'large_confetti': 'lgConfetti',
            'zigzag': 'zigZag',
            'wave': 'wave',
            'diagonal_brick': 'diagBrick',
            'horizontal_brick': 'horzBrick',
            'weave': 'weave',
            'plaid': 'plaid',
            'divot': 'divot',
            'dotted_grid': 'dotGrid',
            'dotted_diamond': 'dotDmnd',
            'shingle': 'shingle',
            'trellis': 'trellis',
            'sphere': 'sphere',
            'small_grid': 'smGrid',
            'large_grid': 'lgGrid',
            'small_check': 'smCheck',
            'large_check': 'lgCheck',
            'outlined_diamond': 'openDmnd',
            'solid_diamond': 'solidDmnd',
        }

        # Check for valid types.
        if not pattern['pattern'] in types:
            warn("unknown pattern type '%s'" % pattern['pattern'])
            return
        else:
            pattern['pattern'] = types[pattern['pattern']]

        # Specify a default background color.
        pattern['bg_color'] = pattern.get('bg_color', '#FFFFFF')

        return pattern

    @staticmethod
    def _get_gradient_properties(gradient):
        # Convert user defined gradient to the structure required internally.

        if not gradient:
            return

        # Copy the user defined properties since they will be modified.
        gradient = copy.deepcopy(gradient)

        types = {
            'linear': 'linear',
            'radial': 'circle',
            'rectangular': 'rect',
            'path': 'shape'
        }

        # Check the colors array exists and is valid.
        if 'colors' not in gradient or type(gradient['colors']) != list:
            warn("Gradient must include colors list")
            return

        # Check the colors array has the required number of entries.
        if not 2 <= len(gradient['colors']) <= 10:
            warn("Gradient colors list must at least 2 values "
                 "and not more than 10")
            return

        if 'positions' in gradient:
            # Check the positions array has the right number of entries.
            if len(gradient['positions']) != len(gradient['colors']):
                warn("Gradient positions not equal to number of colors")
                return

            # Check the positions are in the correct range.
            for pos in gradient['positions']:
                if not 0 <= pos <= 100:
                    warn("Gradient position must be in the range "
                         "0 <= position <= 100")
                    return
        else:
            # Use the default gradient positions.
            if len(gradient['colors']) == 2:
                gradient['positions'] = [0, 100]

            elif len(gradient['colors']) == 3:
                gradient['positions'] = [0, 50, 100]

            elif len(gradient['colors']) == 4:
                gradient['positions'] = [0, 33, 66, 100]

            else:
                warn("Must specify gradient positions")
                return

        angle = gradient.get('angle')
        if angle:
            if not 0 <= angle < 360:
                warn("Gradient angle must be in the range "
                     "0 <= angle < 360")
                return
        else:
            gradient['angle'] = 90

        # Check for valid types.
        gradient_type = gradient.get('type')

        if gradient_type is not None:

            if gradient_type in types:
                gradient['type'] = types[gradient_type]
            else:
                warn("Unknown gradient type '%s" % gradient_type)
                return
        else:
            gradient['type'] = 'linear'

        return gradient

    @staticmethod
    def _get_font_properties(options):
        # Convert user defined font values into private dict values.
        if options is None:
            options = {}

        font = {
            'name': options.get('name'),
            'color': options.get('color'),
            'size': options.get('size', 11),
            'bold': options.get('bold'),
            'italic': options.get('italic'),
            'underline': options.get('underline'),
            'pitch_family': options.get('pitch_family'),
            'charset': options.get('charset'),
            'baseline': options.get('baseline', -1),
            'lang': options.get('lang', 'en-US'),
        }

        # Convert font size units.
        if font['size']:
            font['size'] = int(font['size'] * 100)

        return font

    @staticmethod
    def _get_font_style_attributes(font):
        # _get_font_style_attributes.
        attributes = []

        if not font:
            return attributes

        if font.get('size'):
            attributes.append(('sz', font['size']))

        if font.get('bold') is not None:
            attributes.append(('b', 0 + font['bold']))

        if font.get('italic') is not None:
            attributes.append(('i', 0 + font['italic']))

        if font.get('underline') is not None:
            attributes.append(('u', 'sng'))

        if font.get('baseline') != -1:
            attributes.append(('baseline', font['baseline']))

        return attributes

    @staticmethod
    def _get_font_latin_attributes(font):
        # _get_font_latin_attributes.
        attributes = []

        if not font:
            return attributes

        if font['name'] is not None:
            attributes.append(('typeface', font['name']))

        if font['pitch_family'] is not None:
            attributes.append(('pitchFamily', font['pitch_family']))

        if font['charset'] is not None:
            attributes.append(('charset', font['charset']))

        return attributes

    @staticmethod
    def _get_align_properties(align):
        # Convert user defined align to the structure required internally.
        if not align:
            return {'defined': False}

        # Copy the user defined properties since they will be modified.
        align = copy.deepcopy(align)

        if 'vertical' in align:
            align_type = align['vertical']

            align_types = {
                'top': 'top',
                'middle': 'middle',
                'bottom': 'bottom',
            }

            if align_type in align_types:
                align['vertical'] = align_types[align_type]
            else:
                warn("Unknown alignment type '%s'" % align_type)
                return {'defined': False}

        if 'horizontal' in align:
            align_type = align['horizontal']

            align_types = {
                'left': 'left',
                'center': 'center',
                'right': 'right',
            }

            if align_type in align_types:
                align['horizontal'] = align_types[align_type]
            else:
                warn("Unknown alignment type '%s'" % align_type)
                return {'defined': False}

        align['defined'] = True

        return align

```

---

### File: `tmp\xlsxwriter_old\XlsxWriter-1.4.5\xlsxwriter\sharedstrings.py`

```python
###############################################################################
#
# SharedStrings - A class for writing the Excel XLSX sharedStrings file.
#
# Copyright 2013-2021, John McNamara, jmcnamara@cpan.org
#

# Standard packages.
import re
import sys

# Package imports.
from . import xmlwriter
from .utility import preserve_whitespace

# Compile performance critical regular expressions.
re_control_chars_1 = re.compile('(_x[0-9a-fA-F]{4}_)')
re_control_chars_2 = re.compile(r'([\x00-\x08\x0b-\x1f])')


class SharedStrings(xmlwriter.XMLwriter):
    """
    A class for writing the Excel XLSX sharedStrings file.

    """

    ###########################################################################
    #
    # Public API.
    #
    ###########################################################################

    def __init__(self):
        """
        Constructor.

        """

        super(SharedStrings, self).__init__()

        self.string_table = None

    ###########################################################################
    #
    # Private API.
    #
    ###########################################################################

    def _assemble_xml_file(self):
        # Assemble and write the XML file.

        # Write the XML declaration.
        self._xml_declaration()

        # Write the sst element.
        self._write_sst()

        # Write the sst strings.
        self._write_sst_strings()

        # Close the sst tag.
        self._xml_end_tag('sst')

        # Close the file.
        self._xml_close()

    ###########################################################################
    #
    # XML methods.
    #
    ###########################################################################

    def _write_sst(self):
        # Write the <sst> element.
        xmlns = 'http://schemas.openxmlformats.org/spreadsheetml/2006/main'

        attributes = [
            ('xmlns', xmlns),
            ('count', self.string_table.count),
            ('uniqueCount', self.string_table.unique_count),
        ]

        self._xml_start_tag('sst', attributes)

    def _write_sst_strings(self):
        # Write the sst string elements.

        for string in (self.string_table._get_strings()):
            self._write_si(string)

    def _write_si(self, string):
        # Write the <si> element.
        attributes = []

        # Excel escapes control characters with _xHHHH_ and also escapes any
        # literal strings of that type by encoding the leading underscore.
        # So "\0" -> _x0000_ and "_x0000_" -> _x005F_x0000_.
        # The following substitutions deal with those cases.

        # Escape the escape.
        string = re_control_chars_1.sub(r'_x005F\1', string)

        # Convert control character to the _xHHHH_ escape.
        string = re_control_chars_2.sub(lambda match: "_x%04X_" %
                                        ord(match.group(1)), string)

        # Escapes non characters in strings.
        if sys.version_info[0] == 2:
            string = string.replace(unichr(0xFFFE), '_xFFFE_')
            string = string.replace(unichr(0xFFFF), '_xFFFF_')
        else:
            string = string.replace('\uFFFE', '_xFFFE_')
            string = string.replace('\uFFFF', '_xFFFF_')

        # Add attribute to preserve leading or trailing whitespace.
        if preserve_whitespace(string):
            attributes.append(('xml:space', 'preserve'))

        # Write any rich strings without further tags.
        if string.startswith('<r>') and string.endswith('</r>'):
            self._xml_rich_si_element(string)
        else:
            self._xml_si_element(string, attributes)


# A metadata class to store Excel strings between worksheets.
class SharedStringTable(object):
    """
    A class to track Excel shared strings between worksheets.

    """

    def __init__(self):
        self.count = 0
        self.unique_count = 0
        self.string_table = {}
        self.string_array = []

    def _get_shared_string_index(self, string):
        """" Get the index of the string in the Shared String table. """
        if string not in self.string_table:
            # String isn't already stored in the table so add it.
            index = self.unique_count
            self.string_table[string] = index
            self.count += 1
            self.unique_count += 1
            return index
        else:
            # String exists in the table.
            index = self.string_table[string]
            self.count += 1
            return index

    def _get_shared_string(self, index):
        """" Get a shared string from the index. """
        return self.string_array[index]

    def _sort_string_data(self):
        """" Sort the shared string data and convert from dict to list. """
        self.string_array = sorted(self.string_table,
                                   key=self.string_table.__getitem__)
        self.string_table = {}

    def _get_strings(self):
        """" Return the sorted string list. """
        return self.string_array

```

---

### File: `tmp\xlsxwriter_old\XlsxWriter-1.4.5\xlsxwriter\styles.py`

```python
###############################################################################
#
# Styles - A class for writing the Excel XLSX Worksheet file.
#
# Copyright 2013-2021, John McNamara, jmcnamara@cpan.org
#

# Package imports.
from . import xmlwriter


class Styles(xmlwriter.XMLwriter):
    """
    A class for writing the Excel XLSX Styles file.


    """

    ###########################################################################
    #
    # Public API.
    #
    ###########################################################################

    def __init__(self):
        """
        Constructor.

        """

        super(Styles, self).__init__()

        self.xf_formats = []
        self.palette = []
        self.font_count = 0
        self.num_format_count = 0
        self.border_count = 0
        self.fill_count = 0
        self.custom_colors = []
        self.dxf_formats = []
        self.has_hyperlink = False
        self.hyperlink_font_id = 0
        self.has_comments = False

    ###########################################################################
    #
    # Private API.
    #
    ###########################################################################

    def _assemble_xml_file(self):
        # Assemble and write the XML file.

        # Write the XML declaration.
        self._xml_declaration()

        # Add the style sheet.
        self._write_style_sheet()

        # Write the number formats.
        self._write_num_fmts()

        # Write the fonts.
        self._write_fonts()

        # Write the fills.
        self._write_fills()

        # Write the borders element.
        self._write_borders()

        # Write the cellStyleXfs element.
        self._write_cell_style_xfs()

        # Write the cellXfs element.
        self._write_cell_xfs()

        # Write the cellStyles element.
        self._write_cell_styles()

        # Write the dxfs element.
        self._write_dxfs()

        # Write the tableStyles element.
        self._write_table_styles()

        # Write the colors element.
        self._write_colors()

        # Close the style sheet tag.
        self._xml_end_tag('styleSheet')

        # Close the file.
        self._xml_close()

    def _set_style_properties(self, properties):
        # Pass in the Format objects and other properties used in the styles.

        self.xf_formats = properties[0]
        self.palette = properties[1]
        self.font_count = properties[2]
        self.num_format_count = properties[3]
        self.border_count = properties[4]
        self.fill_count = properties[5]
        self.custom_colors = properties[6]
        self.dxf_formats = properties[7]
        self.has_comments = properties[8]

    def _get_palette_color(self, color):
        # Convert the RGB color.
        if color[0] == '#':
            color = color[1:]

        return "FF" + color.upper()

    ###########################################################################
    #
    # XML methods.
    #
    ###########################################################################

    def _write_style_sheet(self):
        # Write the <styleSheet> element.
        xmlns = 'http://schemas.openxmlformats.org/spreadsheetml/2006/main'

        attributes = [('xmlns', xmlns)]
        self._xml_start_tag('styleSheet', attributes)

    def _write_num_fmts(self):
        # Write the <numFmts> element.
        if not self.num_format_count:
            return

        attributes = [('count', self.num_format_count)]
        self._xml_start_tag('numFmts', attributes)

        # Write the numFmts elements.
        for xf_format in self.xf_formats:
            # Ignore built-in number formats, i.e., < 164.
            if xf_format.num_format_index >= 164:
                self._write_num_fmt(xf_format.num_format_index,
                                    xf_format.num_format)

        self._xml_end_tag('numFmts')

    def _write_num_fmt(self, num_fmt_id, format_code):
        # Write the <numFmt> element.
        format_codes = {
            0: 'General',
            1: '0',
            2: '0.00',
            3: '#,##0',
            4: '#,##0.00',
            5: '($#,##0_);($#,##0)',
            6: '($#,##0_);[Red]($#,##0)',
            7: '($#,##0.00_);($#,##0.00)',
            8: '($#,##0.00_);[Red]($#,##0.00)',
            9: '0%',
            10: '0.00%',
            11: '0.00E+00',
            12: '# ?/?',
            13: '# ??/??',
            14: 'm/d/yy',
            15: 'd-mmm-yy',
            16: 'd-mmm',
            17: 'mmm-yy',
            18: 'h:mm AM/PM',
            19: 'h:mm:ss AM/PM',
            20: 'h:mm',
            21: 'h:mm:ss',
            22: 'm/d/yy h:mm',
            37: '(#,##0_);(#,##0)',
            38: '(#,##0_);[Red](#,##0)',
            39: '(#,##0.00_);(#,##0.00)',
            40: '(#,##0.00_);[Red](#,##0.00)',
            41: '_(* #,##0_);_(* (#,##0);_(* "-"_);_(_)',
            42: '_($* #,##0_);_($* (#,##0);_($* "-"_);_(_)',
            43: '_(* #,##0.00_);_(* (#,##0.00);_(* "-"??_);_(_)',
            44: '_($* #,##0.00_);_($* (#,##0.00);_($* "-"??_);_(_)',
            45: 'mm:ss',
            46: '[h]:mm:ss',
            47: 'mm:ss.0',
            48: '##0.0E+0',
            49: '@'}

        # Set the format code for built-in number formats.
        if num_fmt_id < 164:
            if num_fmt_id in format_codes:
                format_code = format_codes[num_fmt_id]
            else:
                format_code = 'General'

        attributes = [
            ('numFmtId', num_fmt_id),
            ('formatCode', format_code),
        ]

        self._xml_empty_tag('numFmt', attributes)

    def _write_fonts(self):
        # Write the <fonts> element.
        if self.has_comments:
            # Add extra font for comments.
            attributes = [('count', self.font_count + 1)]
        else:
            attributes = [('count', self.font_count)]

        self._xml_start_tag('fonts', attributes)

        # Write the font elements for xf_format objects that have them.
        for xf_format in self.xf_formats:
            if xf_format.has_font:
                self._write_font(xf_format)

        if self.has_comments:
            self._write_comment_font()

        self._xml_end_tag('fonts')

    def _write_font(self, xf_format, is_dxf_format=False):
        # Write the <font> element.
        self._xml_start_tag('font')

        # The condense and extend elements are mainly used in dxf formats.
        if xf_format.font_condense:
            self._write_condense()

        if xf_format.font_extend:
            self._write_extend()

        if xf_format.bold:
            self._xml_empty_tag('b')

        if xf_format.italic:
            self._xml_empty_tag('i')

        if xf_format.font_strikeout:
            self._xml_empty_tag('strike')

        if xf_format.font_outline:
            self._xml_empty_tag('outline')

        if xf_format.font_shadow:
            self._xml_empty_tag('shadow')

        # Handle the underline variants.
        if xf_format.underline:
            self._write_underline(xf_format.underline)

        if xf_format.font_script == 1:
            self._write_vert_align('superscript')

        if xf_format.font_script == 2:
            self._write_vert_align('subscript')

        if not is_dxf_format:
            self._xml_empty_tag('sz', [('val', xf_format.font_size)])

        if xf_format.theme == -1:
            # Ignore for excel2003_style.
            pass
        elif xf_format.theme:
            self._write_color('theme', xf_format.theme)
        elif xf_format.color_indexed:
            self._write_color('indexed', xf_format.color_indexed)
        elif xf_format.font_color:
            color = self._get_palette_color(xf_format.font_color)
            self._write_color('rgb', color)
        elif not is_dxf_format:
            self._write_color('theme', 1)

        if not is_dxf_format:
            self._xml_empty_tag('name', [('val', xf_format.font_name)])

            if xf_format.font_family:
                self._xml_empty_tag('family', [('val', xf_format.font_family)])

            if xf_format.font_charset:
                self._xml_empty_tag('charset',
                                    [('val', xf_format.font_charset)])

            if xf_format.font_name == 'Calibri' and not xf_format.hyperlink:
                self._xml_empty_tag(
                    'scheme',
                    [('val', xf_format.font_scheme)])

            if xf_format.hyperlink:
                self.has_hyperlink = True
                if self.hyperlink_font_id == 0:
                    self.hyperlink_font_id = xf_format.font_index

        self._xml_end_tag('font')

    def _write_comment_font(self):
        # Write the <font> element for comments.
        self._xml_start_tag('font')

        self._xml_empty_tag('sz', [('val', 8)])
        self._write_color('indexed', 81)
        self._xml_empty_tag('name', [('val', 'Tahoma')])
        self._xml_empty_tag('family', [('val', 2)])

        self._xml_end_tag('font')

    def _write_underline(self, underline):
        # Write the underline font element.

        if underline == 2:
            attributes = [('val', 'double')]
        elif underline == 33:
            attributes = [('val', 'singleAccounting')]
        elif underline == 34:
            attributes = [('val', 'doubleAccounting')]
        else:
            # Default to single underline.
            attributes = []

        self._xml_empty_tag('u', attributes)

    def _write_vert_align(self, val):
        # Write the <vertAlign> font sub-element.
        attributes = [('val', val)]

        self._xml_empty_tag('vertAlign', attributes)

    def _write_color(self, name, value):
        # Write the <color> element.
        attributes = [(name, value)]

        self._xml_empty_tag('color', attributes)

    def _write_fills(self):
        # Write the <fills> element.
        attributes = [('count', self.fill_count)]

        self._xml_start_tag('fills', attributes)

        # Write the default fill element.
        self._write_default_fill('none')
        self._write_default_fill('gray125')

        # Write the fill elements for xf_format objects that have them.
        for xf_format in self.xf_formats:
            if xf_format.has_fill:
                self._write_fill(xf_format)

        self._xml_end_tag('fills')

    def _write_default_fill(self, pattern_type):
        # Write the <fill> element for the default fills.
        self._xml_start_tag('fill')
        self._xml_empty_tag('patternFill', [('patternType', pattern_type)])
        self._xml_end_tag('fill')

    def _write_fill(self, xf_format, is_dxf_format=False):
        # Write the <fill> element.
        pattern = xf_format.pattern
        bg_color = xf_format.bg_color
        fg_color = xf_format.fg_color

        # Colors for dxf formats are handled differently from normal formats
        # since the normal xf_format reverses the meaning of BG and FG for
        # solid fills.
        if is_dxf_format:
            bg_color = xf_format.dxf_bg_color
            fg_color = xf_format.dxf_fg_color

        patterns = (
            'none',
            'solid',
            'mediumGray',
            'darkGray',
            'lightGray',
            'darkHorizontal',
            'darkVertical',
            'darkDown',
            'darkUp',
            'darkGrid',
            'darkTrellis',
            'lightHorizontal',
            'lightVertical',
            'lightDown',
            'lightUp',
            'lightGrid',
            'lightTrellis',
            'gray125',
            'gray0625',
        )

        # Special handling for pattern only case.
        if not fg_color and not bg_color and patterns[pattern]:
            self._write_default_fill(patterns[pattern])
            return

        self._xml_start_tag('fill')

        # The "none" pattern is handled differently for dxf formats.
        if is_dxf_format and pattern <= 1:
            self._xml_start_tag('patternFill')
        else:
            self._xml_start_tag(
                'patternFill',
                [('patternType', patterns[pattern])])

        if fg_color:
            fg_color = self._get_palette_color(fg_color)
            self._xml_empty_tag('fgColor', [('rgb', fg_color)])

        if bg_color:
            bg_color = self._get_palette_color(bg_color)
            self._xml_empty_tag('bgColor', [('rgb', bg_color)])
        else:
            if not is_dxf_format and pattern <= 1:
                self._xml_empty_tag('bgColor', [('indexed', 64)])

        self._xml_end_tag('patternFill')
        self._xml_end_tag('fill')

    def _write_borders(self):
        # Write the <borders> element.
        attributes = [('count', self.border_count)]

        self._xml_start_tag('borders', attributes)

        # Write the border elements for xf_format objects that have them.
        for xf_format in self.xf_formats:
            if xf_format.has_border:
                self._write_border(xf_format)

        self._xml_end_tag('borders')

    def _write_border(self, xf_format, is_dxf_format=False):
        # Write the <border> element.
        attributes = []

        # Diagonal borders add attributes to the <border> element.
        if xf_format.diag_type == 1:
            attributes.append(('diagonalUp', 1))
        elif xf_format.diag_type == 2:
            attributes.append(('diagonalDown', 1))
        elif xf_format.diag_type == 3:
            attributes.append(('diagonalUp', 1))
            attributes.append(('diagonalDown', 1))

        # Ensure that a default diag border is set if the diag type is set.
        if xf_format.diag_type and not xf_format.diag_border:
            xf_format.diag_border = 1

        # Write the start border tag.
        self._xml_start_tag('border', attributes)

        # Write the <border> sub elements.
        self._write_sub_border(
            'left',
            xf_format.left,
            xf_format.left_color)

        self._write_sub_border(
            'right',
            xf_format.right,
            xf_format.right_color)

        self._write_sub_border(
            'top',
            xf_format.top,
            xf_format.top_color)

        self._write_sub_border(
            'bottom',
            xf_format.bottom,
            xf_format.bottom_color)

        # Condition DXF formats don't allow diagonal borders.
        if not is_dxf_format:
            self._write_sub_border(
                'diagonal',
                xf_format.diag_border,
                xf_format.diag_color)

        if is_dxf_format:
            self._write_sub_border('vertical', None, None)
            self._write_sub_border('horizontal', None, None)

        self._xml_end_tag('border')

    def _write_sub_border(self, border_type, style, color):
        # Write the <border> sub elements such as <right>, <top>, etc.
        attributes = []

        if not style:
            self._xml_empty_tag(border_type)
            return

        border_styles = (
            'none',
            'thin',
            'medium',
            'dashed',
            'dotted',
            'thick',
            'double',
            'hair',
            'mediumDashed',
            'dashDot',
            'mediumDashDot',
            'dashDotDot',
            'mediumDashDotDot',
            'slantDashDot',
        )

        attributes.append(('style', border_styles[style]))

        self._xml_start_tag(border_type, attributes)

        if color:
            color = self._get_palette_color(color)
            self._xml_empty_tag('color', [('rgb', color)])
        else:
            self._xml_empty_tag('color', [('auto', 1)])

        self._xml_end_tag(border_type)

    def _write_cell_style_xfs(self):
        # Write the <cellStyleXfs> element.
        count = 1

        if self.has_hyperlink:
            count = 2

        attributes = [('count', count)]

        self._xml_start_tag('cellStyleXfs', attributes)
        self._write_style_xf()

        if self.has_hyperlink:
            self._write_style_xf(True, self.hyperlink_font_id)

        self._xml_end_tag('cellStyleXfs')

    def _write_cell_xfs(self):
        # Write the <cellXfs> element.
        formats = self.xf_formats

        # Workaround for when the last xf_format is used for the comment font
        # and shouldn't be used for cellXfs.
        last_format = formats[-1]
        if last_format.font_only:
            formats.pop()

        attributes = [('count', len(formats))]
        self._xml_start_tag('cellXfs', attributes)

        # Write the xf elements.
        for xf_format in formats:
            self._write_xf(xf_format)

        self._xml_end_tag('cellXfs')

    def _write_style_xf(self, has_hyperlink=False, font_id=0):
        # Write the style <xf> element.
        num_fmt_id = 0
        fill_id = 0
        border_id = 0

        attributes = [
            ('numFmtId', num_fmt_id),
            ('fontId', font_id),
            ('fillId', fill_id),
            ('borderId', border_id),
        ]

        if has_hyperlink:
            attributes.append(('applyNumberFormat', 0))
            attributes.append(('applyFill', 0))
            attributes.append(('applyBorder', 0))
            attributes.append(('applyAlignment', 0))
            attributes.append(('applyProtection', 0))

            self._xml_start_tag('xf', attributes)
            self._xml_empty_tag('alignment', [('vertical', 'top')])
            self._xml_empty_tag('protection', [('locked', 0)])
            self._xml_end_tag('xf')

        else:
            self._xml_empty_tag('xf', attributes)

    def _write_xf(self, xf_format):
        # Write the <xf> element.
        num_fmt_id = xf_format.num_format_index
        font_id = xf_format.font_index
        fill_id = xf_format.fill_index
        border_id = xf_format.border_index
        xf_id = xf_format.xf_id
        has_align = 0
        has_protect = 0

        attributes = [
            ('numFmtId', num_fmt_id),
            ('fontId', font_id),
            ('fillId', fill_id),
            ('borderId', border_id),
            ('xfId', xf_id),
        ]

        if xf_format.num_format_index > 0:
            attributes.append(('applyNumberFormat', 1))

        # Add applyFont attribute if XF format uses a font element.
        if xf_format.font_index > 0 and not xf_format.hyperlink:
            attributes.append(('applyFont', 1))

        # Add applyFill attribute if XF format uses a fill element.
        if xf_format.fill_index > 0:
            attributes.append(('applyFill', 1))

        # Add applyBorder attribute if XF format uses a border element.
        if xf_format.border_index > 0:
            attributes.append(('applyBorder', 1))

        # Check if XF format has alignment properties set.
        (apply_align, align) = xf_format._get_align_properties()

        # Check if an alignment sub-element should be written.
        if apply_align and align:
            has_align = 1

        # We can also have applyAlignment without a sub-element.
        if apply_align or xf_format.hyperlink:
            attributes.append(('applyAlignment', 1))

        # Check for cell protection properties.
        protection = xf_format._get_protection_properties()

        if protection or xf_format.hyperlink:
            attributes.append(('applyProtection', 1))

            if not xf_format.hyperlink:
                has_protect = 1

        # Write XF with sub-elements if required.
        if has_align or has_protect:
            self._xml_start_tag('xf', attributes)
            if has_align:
                self._xml_empty_tag('alignment', align)
            if has_protect:
                self._xml_empty_tag('protection', protection)
            self._xml_end_tag('xf')
        else:
            self._xml_empty_tag('xf', attributes)

    def _write_cell_styles(self):
        # Write the <cellStyles> element.
        count = 1

        if self.has_hyperlink:
            count = 2

        attributes = [('count', count)]

        self._xml_start_tag('cellStyles', attributes)

        if self.has_hyperlink:
            self._write_cell_style('Hyperlink', 1, 8)

        self._write_cell_style()

        self._xml_end_tag('cellStyles')

    def _write_cell_style(self, name='Normal', xf_id=0, builtin_id=0):
        # Write the <cellStyle> element.
        attributes = [
            ('name', name),
            ('xfId', xf_id),
            ('builtinId', builtin_id),
        ]

        self._xml_empty_tag('cellStyle', attributes)

    def _write_dxfs(self):
        # Write the <dxfs> element.
        formats = self.dxf_formats
        count = len(formats)

        attributes = [('count', len(formats))]

        if count:
            self._xml_start_tag('dxfs', attributes)

            # Write the font elements for xf_format objects that have them.
            for xf_format in self.dxf_formats:
                self._xml_start_tag('dxf')
                if xf_format.has_dxf_font:
                    self._write_font(xf_format, True)

                if xf_format.num_format_index:
                    self._write_num_fmt(xf_format.num_format_index,
                                        xf_format.num_format)

                if xf_format.has_dxf_fill:
                    self._write_fill(xf_format, True)
                if xf_format.has_dxf_border:
                    self._write_border(xf_format, True)
                self._xml_end_tag('dxf')

            self._xml_end_tag('dxfs')
        else:
            self._xml_empty_tag('dxfs', attributes)

    def _write_table_styles(self):
        # Write the <tableStyles> element.
        count = 0
        default_table_style = 'TableStyleMedium9'
        default_pivot_style = 'PivotStyleLight16'

        attributes = [
            ('count', count),
            ('defaultTableStyle', default_table_style),
            ('defaultPivotStyle', default_pivot_style),
        ]

        self._xml_empty_tag('tableStyles', attributes)

    def _write_colors(self):
        # Write the <colors> element.
        custom_colors = self.custom_colors

        if not custom_colors:
            return

        self._xml_start_tag('colors')
        self._write_mru_colors(custom_colors)
        self._xml_end_tag('colors')

    def _write_mru_colors(self, custom_colors):
        # Write the <mruColors> element for the most recently used colors.

        # Write the custom custom_colors in reverse order.
        custom_colors.reverse()

        # Limit the mruColors to the last 10.
        if len(custom_colors) > 10:
            custom_colors = custom_colors[0:10]

        self._xml_start_tag('mruColors')

        # Write the custom custom_colors in reverse order.
        for color in custom_colors:
            self._write_color('rgb', color)

        self._xml_end_tag('mruColors')

    def _write_condense(self):
        # Write the <condense> element.
        attributes = [('val', 0)]

        self._xml_empty_tag('condense', attributes)

    def _write_extend(self):
        # Write the <extend> element.
        attributes = [('val', 0)]

        self._xml_empty_tag('extend', attributes)

```

---

### File: `tmp\xlsxwriter_old\XlsxWriter-1.4.5\xlsxwriter\table.py`

```python
###############################################################################
#
# Table - A class for writing the Excel XLSX Worksheet file.
#
# Copyright 2013-2021, John McNamara, jmcnamara@cpan.org
#

from . import xmlwriter


class Table(xmlwriter.XMLwriter):
    """
    A class for writing the Excel XLSX Table file.


    """

    ###########################################################################
    #
    # Public API.
    #
    ###########################################################################

    def __init__(self):
        """
        Constructor.

        """

        super(Table, self).__init__()

        self.properties = {}

    ###########################################################################
    #
    # Private API.
    #
    ###########################################################################

    def _assemble_xml_file(self):
        # Assemble and write the XML file.

        # Write the XML declaration.
        self._xml_declaration()

        # Write the table element.
        self._write_table()

        # Write the autoFilter element.
        self._write_auto_filter()

        # Write the tableColumns element.
        self._write_table_columns()

        # Write the tableStyleInfo element.
        self._write_table_style_info()

        # Close the table tag.
        self._xml_end_tag('table')

        # Close the file.
        self._xml_close()

    def _set_properties(self, properties):
        # Set the document properties.
        self.properties = properties

    ###########################################################################
    #
    # XML methods.
    #
    ###########################################################################

    def _write_table(self):
        # Write the <table> element.
        schema = 'http://schemas.openxmlformats.org/'
        xmlns = schema + 'spreadsheetml/2006/main'
        table_id = self.properties['id']
        name = self.properties['name']
        display_name = self.properties['name']
        ref = self.properties['range']
        totals_row_shown = self.properties['totals_row_shown']
        header_row_count = self.properties['header_row_count']

        attributes = [
            ('xmlns', xmlns),
            ('id', table_id),
            ('name', name),
            ('displayName', display_name),
            ('ref', ref),
        ]

        if not header_row_count:
            attributes.append(('headerRowCount', 0))

        if totals_row_shown:
            attributes.append(('totalsRowCount', 1))
        else:
            attributes.append(('totalsRowShown', 0))

        self._xml_start_tag('table', attributes)

    def _write_auto_filter(self):
        # Write the <autoFilter> element.
        autofilter = self.properties.get('autofilter', 0)

        if not autofilter:
            return

        attributes = [('ref', autofilter,)]

        self._xml_empty_tag('autoFilter', attributes)

    def _write_table_columns(self):
        # Write the <tableColumns> element.
        columns = self.properties['columns']

        count = len(columns)

        attributes = [('count', count)]

        self._xml_start_tag('tableColumns', attributes)

        for col_data in columns:
            # Write the tableColumn element.
            self._write_table_column(col_data)

        self._xml_end_tag('tableColumns')

    def _write_table_column(self, col_data):
        # Write the <tableColumn> element.
        attributes = [
            ('id', col_data['id']),
            ('name', col_data['name']),
        ]

        if col_data.get('total_string'):
            attributes.append(('totalsRowLabel', col_data['total_string']))
        elif col_data.get('total_function'):
            attributes.append(('totalsRowFunction',
                               col_data['total_function']))

        if 'format' in col_data and col_data['format'] is not None:
            attributes.append(('dataDxfId', col_data['format']))

        if col_data.get('formula'):
            self._xml_start_tag('tableColumn', attributes)

            # Write the calculatedColumnFormula element.
            self._write_calculated_column_formula(col_data['formula'])

            self._xml_end_tag('tableColumn')
        else:
            self._xml_empty_tag('tableColumn', attributes)

    def _write_table_style_info(self):
        # Write the <tableStyleInfo> element.
        props = self.properties
        attributes = []

        name = props['style']
        show_first_column = 0 + props['show_first_col']
        show_last_column = 0 + props['show_last_col']
        show_row_stripes = 0 + props['show_row_stripes']
        show_column_stripes = 0 + props['show_col_stripes']

        if name is not None and name != '' and name != 'None':
            attributes.append(('name', name))

        attributes.append(('showFirstColumn', show_first_column))
        attributes.append(('showLastColumn', show_last_column))
        attributes.append(('showRowStripes', show_row_stripes))
        attributes.append(('showColumnStripes', show_column_stripes))

        self._xml_empty_tag('tableStyleInfo', attributes)

    def _write_calculated_column_formula(self, formula):
        # Write the <calculatedColumnFormula> element.
        self._xml_data_element('calculatedColumnFormula', formula)

```

---

### File: `tmp\xlsxwriter_old\XlsxWriter-1.4.5\xlsxwriter\theme.py`

```python
###############################################################################
#
# Theme - A class for writing the Excel XLSX Worksheet file.
#
# Copyright 2013-2021, John McNamara, jmcnamara@cpan.org
#

# Standard packages.
import codecs
import sys

# Standard packages in Python 2/3 compatibility mode.
from .compatibility import StringIO


class Theme(object):
    """
    A class for writing the Excel XLSX Theme file.


    """

    ###########################################################################
    #
    # Public API.
    #
    ###########################################################################

    def __init__(self):
        """
        Constructor.

        """
        super(Theme, self).__init__()
        self.fh = None
        self.internal_fh = False

    ###########################################################################
    #
    # Private API.
    #
    ###########################################################################

    def _assemble_xml_file(self):
        # Assemble and write the XML file.
        self._write_theme_file()
        if self.internal_fh:
            self.fh.close()

    def _set_xml_writer(self, filename):
        # Set the XML writer filehandle for the object.
        if isinstance(filename, StringIO):
            self.internal_fh = False
            self.fh = filename
        else:
            self.internal_fh = True
            self.fh = codecs.open(filename, 'w', 'utf-8')

    ###########################################################################
    #
    # XML methods.
    #
    ###########################################################################

    def _write_theme_file(self):
        # Write a default theme.xml file.

        default_theme = """<?xml version="1.0" encoding="UTF-8" standalone="yes"?>\n<a:theme xmlns:a="http://schemas.openxmlformats.org/drawingml/2006/main" name="Office Theme"><a:themeElements><a:clrScheme name="Office"><a:dk1><a:sysClr val="windowText" lastClr="000000"/></a:dk1><a:lt1><a:sysClr val="window" lastClr="FFFFFF"/></a:lt1><a:dk2><a:srgbClr val="1F497D"/></a:dk2><a:lt2><a:srgbClr val="EEECE1"/></a:lt2><a:accent1><a:srgbClr val="4F81BD"/></a:accent1><a:accent2><a:srgbClr val="C0504D"/></a:accent2><a:accent3><a:srgbClr val="9BBB59"/></a:accent3><a:accent4><a:srgbClr val="8064A2"/></a:accent4><a:accent5><a:srgbClr val="4BACC6"/></a:accent5><a:accent6><a:srgbClr val="F79646"/></a:accent6><a:hlink><a:srgbClr val="0000FF"/></a:hlink><a:folHlink><a:srgbClr val="800080"/></a:folHlink></a:clrScheme><a:fontScheme name="Office"><a:majorFont><a:latin typeface="Cambria"/><a:ea typeface=""/><a:cs typeface=""/><a:font script="Jpan" typeface="\uff2d\uff33 \uff30\u30b4\u30b7\u30c3\u30af"/><a:font script="Hang" typeface="\ub9d1\uc740 \uace0\ub515"/><a:font script="Hans" typeface="\u5b8b\u4f53"/><a:font script="Hant" typeface="\u65b0\u7d30\u660e\u9ad4"/><a:font script="Arab" typeface="Times New Roman"/><a:font script="Hebr" typeface="Times New Roman"/><a:font script="Thai" typeface="Tahoma"/><a:font script="Ethi" typeface="Nyala"/><a:font script="Beng" typeface="Vrinda"/><a:font script="Gujr" typeface="Shruti"/><a:font script="Khmr" typeface="MoolBoran"/><a:font script="Knda" typeface="Tunga"/><a:font script="Guru" typeface="Raavi"/><a:font script="Cans" typeface="Euphemia"/><a:font script="Cher" typeface="Plantagenet Cherokee"/><a:font script="Yiii" typeface="Microsoft Yi Baiti"/><a:font script="Tibt" typeface="Microsoft Himalaya"/><a:font script="Thaa" typeface="MV Boli"/><a:font script="Deva" typeface="Mangal"/><a:font script="Telu" typeface="Gautami"/><a:font script="Taml" typeface="Latha"/><a:font script="Syrc" typeface="Estrangelo Edessa"/><a:font script="Orya" typeface="Kalinga"/><a:font script="Mlym" typeface="Kartika"/><a:font script="Laoo" typeface="DokChampa"/><a:font script="Sinh" typeface="Iskoola Pota"/><a:font script="Mong" typeface="Mongolian Baiti"/><a:font script="Viet" typeface="Times New Roman"/><a:font script="Uigh" typeface="Microsoft Uighur"/></a:majorFont><a:minorFont><a:latin typeface="Calibri"/><a:ea typeface=""/><a:cs typeface=""/><a:font script="Jpan" typeface="\uff2d\uff33 \uff30\u30b4\u30b7\u30c3\u30af"/><a:font script="Hang" typeface="\ub9d1\uc740 \uace0\ub515"/><a:font script="Hans" typeface="\u5b8b\u4f53"/><a:font script="Hant" typeface="\u65b0\u7d30\u660e\u9ad4"/><a:font script="Arab" typeface="Arial"/><a:font script="Hebr" typeface="Arial"/><a:font script="Thai" typeface="Tahoma"/><a:font script="Ethi" typeface="Nyala"/><a:font script="Beng" typeface="Vrinda"/><a:font script="Gujr" typeface="Shruti"/><a:font script="Khmr" typeface="DaunPenh"/><a:font script="Knda" typeface="Tunga"/><a:font script="Guru" typeface="Raavi"/><a:font script="Cans" typeface="Euphemia"/><a:font script="Cher" typeface="Plantagenet Cherokee"/><a:font script="Yiii" typeface="Microsoft Yi Baiti"/><a:font script="Tibt" typeface="Microsoft Himalaya"/><a:font script="Thaa" typeface="MV Boli"/><a:font script="Deva" typeface="Mangal"/><a:font script="Telu" typeface="Gautami"/><a:font script="Taml" typeface="Latha"/><a:font script="Syrc" typeface="Estrangelo Edessa"/><a:font script="Orya" typeface="Kalinga"/><a:font script="Mlym" typeface="Kartika"/><a:font script="Laoo" typeface="DokChampa"/><a:font script="Sinh" typeface="Iskoola Pota"/><a:font script="Mong" typeface="Mongolian Baiti"/><a:font script="Viet" typeface="Arial"/><a:font script="Uigh" typeface="Microsoft Uighur"/></a:minorFont></a:fontScheme><a:fmtScheme name="Office"><a:fillStyleLst><a:solidFill><a:schemeClr val="phClr"/></a:solidFill><a:gradFill rotWithShape="1"><a:gsLst><a:gs pos="0"><a:schemeClr val="phClr"><a:tint val="50000"/><a:satMod val="300000"/></a:schemeClr></a:gs><a:gs pos="35000"><a:schemeClr val="phClr"><a:tint val="37000"/><a:satMod val="300000"/></a:schemeClr></a:gs><a:gs pos="100000"><a:schemeClr val="phClr"><a:tint val="15000"/><a:satMod val="350000"/></a:schemeClr></a:gs></a:gsLst><a:lin ang="16200000" scaled="1"/></a:gradFill><a:gradFill rotWithShape="1"><a:gsLst><a:gs pos="0"><a:schemeClr val="phClr"><a:shade val="51000"/><a:satMod val="130000"/></a:schemeClr></a:gs><a:gs pos="80000"><a:schemeClr val="phClr"><a:shade val="93000"/><a:satMod val="130000"/></a:schemeClr></a:gs><a:gs pos="100000"><a:schemeClr val="phClr"><a:shade val="94000"/><a:satMod val="135000"/></a:schemeClr></a:gs></a:gsLst><a:lin ang="16200000" scaled="0"/></a:gradFill></a:fillStyleLst><a:lnStyleLst><a:ln w="9525" cap="flat" cmpd="sng" algn="ctr"><a:solidFill><a:schemeClr val="phClr"><a:shade val="95000"/><a:satMod val="105000"/></a:schemeClr></a:solidFill><a:prstDash val="solid"/></a:ln><a:ln w="25400" cap="flat" cmpd="sng" algn="ctr"><a:solidFill><a:schemeClr val="phClr"/></a:solidFill><a:prstDash val="solid"/></a:ln><a:ln w="38100" cap="flat" cmpd="sng" algn="ctr"><a:solidFill><a:schemeClr val="phClr"/></a:solidFill><a:prstDash val="solid"/></a:ln></a:lnStyleLst><a:effectStyleLst><a:effectStyle><a:effectLst><a:outerShdw blurRad="40000" dist="20000" dir="5400000" rotWithShape="0"><a:srgbClr val="000000"><a:alpha val="38000"/></a:srgbClr></a:outerShdw></a:effectLst></a:effectStyle><a:effectStyle><a:effectLst><a:outerShdw blurRad="40000" dist="23000" dir="5400000" rotWithShape="0"><a:srgbClr val="000000"><a:alpha val="35000"/></a:srgbClr></a:outerShdw></a:effectLst></a:effectStyle><a:effectStyle><a:effectLst><a:outerShdw blurRad="40000" dist="23000" dir="5400000" rotWithShape="0"><a:srgbClr val="000000"><a:alpha val="35000"/></a:srgbClr></a:outerShdw></a:effectLst><a:scene3d><a:camera prst="orthographicFront"><a:rot lat="0" lon="0" rev="0"/></a:camera><a:lightRig rig="threePt" dir="t"><a:rot lat="0" lon="0" rev="1200000"/></a:lightRig></a:scene3d><a:sp3d><a:bevelT w="63500" h="25400"/></a:sp3d></a:effectStyle></a:effectStyleLst><a:bgFillStyleLst><a:solidFill><a:schemeClr val="phClr"/></a:solidFill><a:gradFill rotWithShape="1"><a:gsLst><a:gs pos="0"><a:schemeClr val="phClr"><a:tint val="40000"/><a:satMod val="350000"/></a:schemeClr></a:gs><a:gs pos="40000"><a:schemeClr val="phClr"><a:tint val="45000"/><a:shade val="99000"/><a:satMod val="350000"/></a:schemeClr></a:gs><a:gs pos="100000"><a:schemeClr val="phClr"><a:shade val="20000"/><a:satMod val="255000"/></a:schemeClr></a:gs></a:gsLst><a:path path="circle"><a:fillToRect l="50000" t="-80000" r="50000" b="180000"/></a:path></a:gradFill><a:gradFill rotWithShape="1"><a:gsLst><a:gs pos="0"><a:schemeClr val="phClr"><a:tint val="80000"/><a:satMod val="300000"/></a:schemeClr></a:gs><a:gs pos="100000"><a:schemeClr val="phClr"><a:shade val="30000"/><a:satMod val="200000"/></a:schemeClr></a:gs></a:gsLst><a:path path="circle"><a:fillToRect l="50000" t="50000" r="50000" b="50000"/></a:path></a:gradFill></a:bgFillStyleLst></a:fmtScheme></a:themeElements><a:objectDefaults/><a:extraClrSchemeLst/></a:theme>"""

        if sys.version_info < (3, 0, 0):
            default_theme = default_theme.decode('unicode-escape')

        self.fh.write(default_theme)

```

---

### File: `tmp\xlsxwriter_old\XlsxWriter-1.4.5\xlsxwriter\utility.py`

```python
###############################################################################
#
# Worksheet - A class for writing Excel Worksheets.
#
# Copyright 2013-2021, John McNamara, jmcnamara@cpan.org
#
import re
import datetime
from warnings import warn

COL_NAMES = {}

# Compile performance critical regular expressions.
re_leading = re.compile(r'^\s')
re_trailing = re.compile(r'\s$')
re_range_parts = re.compile(r'(\$?)([A-Z]{1,3})(\$?)(\d+)')


def xl_rowcol_to_cell(row, col, row_abs=False, col_abs=False):
    """
    Convert a zero indexed row and column cell reference to a A1 style string.

    Args:
       row:     The cell row.    Int.
       col:     The cell column. Int.
       row_abs: Optional flag to make the row absolute.    Bool.
       col_abs: Optional flag to make the column absolute. Bool.

    Returns:
        A1 style string.

    """
    if row < 0:
        warn("Row number %d must be >= 0" % row)
        return None

    if col < 0:
        warn("Col number %d must be >= 0" % col)
        return None

    row += 1  # Change to 1-index.
    row_abs = '$' if row_abs else ''

    col_str = xl_col_to_name(col, col_abs)

    return col_str + row_abs + str(row)


def xl_rowcol_to_cell_fast(row, col):
    """
    Optimized version of the xl_rowcol_to_cell function. Only used internally.

    Args:
       row: The cell row.    Int.
       col: The cell column. Int.

    Returns:
        A1 style string.

    """
    if col in COL_NAMES:
        col_str = COL_NAMES[col]
    else:
        col_str = xl_col_to_name(col)
        COL_NAMES[col] = col_str

    return col_str + str(row + 1)


def xl_col_to_name(col, col_abs=False):
    """
    Convert a zero indexed column cell reference to a string.

    Args:
       col:     The cell column. Int.
       col_abs: Optional flag to make the column absolute. Bool.

    Returns:
        Column style string.

    """
    col_num = col
    if col_num < 0:
        warn("Col number %d must be >= 0" % col_num)
        return None

    col_num += 1  # Change to 1-index.
    col_str = ''
    col_abs = '$' if col_abs else ''

    while col_num:
        # Set remainder from 1 .. 26
        remainder = col_num % 26

        if remainder == 0:
            remainder = 26

        # Convert the remainder to a character.
        col_letter = chr(ord('A') + remainder - 1)

        # Accumulate the column letters, right to left.
        col_str = col_letter + col_str

        # Get the next order of magnitude.
        col_num = int((col_num - 1) / 26)

    return col_abs + col_str


def xl_cell_to_rowcol(cell_str):
    """
    Convert a cell reference in A1 notation to a zero indexed row and column.

    Args:
       cell_str:  A1 style string.

    Returns:
        row, col: Zero indexed cell row and column indices.

    """
    if not cell_str:
        return 0, 0

    match = re_range_parts.match(cell_str)
    col_str = match.group(2)
    row_str = match.group(4)

    # Convert base26 column string to number.
    expn = 0
    col = 0
    for char in reversed(col_str):
        col += (ord(char) - ord('A') + 1) * (26 ** expn)
        expn += 1

    # Convert 1-index to zero-index
    row = int(row_str) - 1
    col -= 1

    return row, col


def xl_cell_to_rowcol_abs(cell_str):
    """
    Convert an absolute cell reference in A1 notation to a zero indexed
    row and column, with True/False values for absolute rows or columns.

    Args:
       cell_str: A1 style string.

    Returns:
        row, col, row_abs, col_abs:  Zero indexed cell row and column indices.

    """
    if not cell_str:
        return 0, 0, False, False

    match = re_range_parts.match(cell_str)

    col_abs = match.group(1)
    col_str = match.group(2)
    row_abs = match.group(3)
    row_str = match.group(4)

    if col_abs:
        col_abs = True
    else:
        col_abs = False

    if row_abs:
        row_abs = True
    else:
        row_abs = False

    # Convert base26 column string to number.
    expn = 0
    col = 0
    for char in reversed(col_str):
        col += (ord(char) - ord('A') + 1) * (26 ** expn)
        expn += 1

    # Convert 1-index to zero-index
    row = int(row_str) - 1
    col -= 1

    return row, col, row_abs, col_abs


def xl_range(first_row, first_col, last_row, last_col):
    """
    Convert zero indexed row and col cell references to a A1:B1 range string.

    Args:
       first_row: The first cell row.    Int.
       first_col: The first cell column. Int.
       last_row:  The last cell row.     Int.
       last_col:  The last cell column.  Int.

    Returns:
        A1:B1 style range string.

    """
    range1 = xl_rowcol_to_cell(first_row, first_col)
    range2 = xl_rowcol_to_cell(last_row, last_col)

    if range1 is None or range2 is None:
        warn("Row and column numbers must be >= 0")
        return None

    if range1 == range2:
        return range1
    else:
        return range1 + ':' + range2


def xl_range_abs(first_row, first_col, last_row, last_col):
    """
    Convert zero indexed row and col cell references to a $A$1:$B$1 absolute
    range string.

    Args:
       first_row: The first cell row.    Int.
       first_col: The first cell column. Int.
       last_row:  The last cell row.     Int.
       last_col:  The last cell column.  Int.

    Returns:
        $A$1:$B$1 style range string.

    """
    range1 = xl_rowcol_to_cell(first_row, first_col, True, True)
    range2 = xl_rowcol_to_cell(last_row, last_col, True, True)

    if range1 is None or range2 is None:
        warn("Row and column numbers must be >= 0")
        return None

    if range1 == range2:
        return range1
    else:
        return range1 + ':' + range2


def xl_range_formula(sheetname, first_row, first_col, last_row, last_col):
    """
    Convert worksheet name and zero indexed row and col cell references to
    a Sheet1!A1:B1 range formula string.

    Args:
       sheetname: The worksheet name.    String.
       first_row: The first cell row.    Int.
       first_col: The first cell column. Int.
       last_row:  The last cell row.     Int.
       last_col:  The last cell column.  Int.

    Returns:
        A1:B1 style range string.

    """
    cell_range = xl_range_abs(first_row, first_col, last_row, last_col)
    sheetname = quote_sheetname(sheetname)

    return sheetname + '!' + cell_range


def quote_sheetname(sheetname):
    """
    Convert a worksheet name to a quoted  name if it contains spaces or
    special characters.

    Args:
       sheetname: The worksheet name. String.

    Returns:
        A quoted worksheet string.

    """

    # TODO. Possibly extend this to quote sheetnames that look like ranges.
    if not sheetname.isalnum() and not sheetname.startswith("'"):
        # Double quote any single quotes.
        sheetname = sheetname.replace("'", "''")

        # Singe quote the sheet name.
        sheetname = "'%s'" % sheetname

    return sheetname


def xl_color(color):
    # Used in conjunction with the XlsxWriter *color() methods to convert
    # a color name into an RGB formatted string. These colors are for
    # backward compatibility with older versions of Excel.
    named_colors = {
        'black': '#000000',
        'blue': '#0000FF',
        'brown': '#800000',
        'cyan': '#00FFFF',
        'gray': '#808080',
        'green': '#008000',
        'lime': '#00FF00',
        'magenta': '#FF00FF',
        'navy': '#000080',
        'orange': '#FF6600',
        'pink': '#FF00FF',
        'purple': '#800080',
        'red': '#FF0000',
        'silver': '#C0C0C0',
        'white': '#FFFFFF',
        'yellow': '#FFFF00',
    }

    if color in named_colors:
        color = named_colors[color]

    if not re.match('#[0-9a-fA-F]{6}', color):
        warn("Color '%s' isn't a valid Excel color" % color)

    # Convert the RGB color to the Excel ARGB format.
    return "FF" + color.lstrip('#').upper()


def get_rgb_color(color):
    # Convert the user specified color to an RGB color.
    rgb_color = xl_color(color)

    # Remove leading FF from RGB color for charts.
    rgb_color = re.sub(r'^FF', '', rgb_color)

    return rgb_color


def get_sparkline_style(style_id):
    styles = [
        {'series':   {'theme': "4", 'tint': "-0.499984740745262"},
         'negative': {'theme': "5"},
         'markers':  {'theme': "4", 'tint': "-0.499984740745262"},
         'first':    {'theme': "4", 'tint': "0.39997558519241921"},
         'last':     {'theme': "4", 'tint': "0.39997558519241921"},
         'high':     {'theme': "4"},
         'low':      {'theme': "4"},
         },  # 0
        {'series':   {'theme': "4", 'tint': "-0.499984740745262"},
         'negative': {'theme': "5"},
         'markers':  {'theme': "4", 'tint': "-0.499984740745262"},
         'first':    {'theme': "4", 'tint': "0.39997558519241921"},
         'last':     {'theme': "4", 'tint': "0.39997558519241921"},
         'high':     {'theme': "4"},
         'low':      {'theme': "4"},
         },  # 1
        {'series':   {'theme': "5", 'tint': "-0.499984740745262"},
         'negative': {'theme': "6"},
         'markers':  {'theme': "5", 'tint': "-0.499984740745262"},
         'first':    {'theme': "5", 'tint': "0.39997558519241921"},
         'last':     {'theme': "5", 'tint': "0.39997558519241921"},
         'high':     {'theme': "5"},
         'low':      {'theme': "5"},
         },  # 2
        {'series':   {'theme': "6", 'tint': "-0.499984740745262"},
         'negative': {'theme': "7"},
         'markers':  {'theme': "6", 'tint': "-0.499984740745262"},
         'first':    {'theme': "6", 'tint': "0.39997558519241921"},
         'last':     {'theme': "6", 'tint': "0.39997558519241921"},
         'high':     {'theme': "6"},
         'low':      {'theme': "6"},
         },  # 3
        {'series':   {'theme': "7", 'tint': "-0.499984740745262"},
         'negative': {'theme': "8"},
         'markers':  {'theme': "7", 'tint': "-0.499984740745262"},
         'first':    {'theme': "7", 'tint': "0.39997558519241921"},
         'last':     {'theme': "7", 'tint': "0.39997558519241921"},
         'high':     {'theme': "7"},
         'low':      {'theme': "7"},
         },  # 4
        {'series':   {'theme': "8", 'tint': "-0.499984740745262"},
         'negative': {'theme': "9"},
         'markers':  {'theme': "8", 'tint': "-0.499984740745262"},
         'first':    {'theme': "8", 'tint': "0.39997558519241921"},
         'last':     {'theme': "8", 'tint': "0.39997558519241921"},
         'high':     {'theme': "8"},
         'low':      {'theme': "8"},
         },  # 5
        {'series':   {'theme': "9", 'tint': "-0.499984740745262"},
         'negative': {'theme': "4"},
         'markers':  {'theme': "9", 'tint': "-0.499984740745262"},
         'first':    {'theme': "9", 'tint': "0.39997558519241921"},
         'last':     {'theme': "9", 'tint': "0.39997558519241921"},
         'high':     {'theme': "9"},
         'low':      {'theme': "9"},
         },  # 6
        {'series':   {'theme': "4", 'tint': "-0.249977111117893"},
         'negative': {'theme': "5"},
         'markers':  {'theme': "5", 'tint': "-0.249977111117893"},
         'first':    {'theme': "5", 'tint': "-0.249977111117893"},
         'last':     {'theme': "5", 'tint': "-0.249977111117893"},
         'high':     {'theme': "5", 'tint': "-0.249977111117893"},
         'low':      {'theme': "5", 'tint': "-0.249977111117893"},
         },  # 7
        {'series':   {'theme': "5", 'tint': "-0.249977111117893"},
         'negative': {'theme': "6"},
         'markers':  {'theme': "6", 'tint': "-0.249977111117893"},
         'first':    {'theme': "6", 'tint': "-0.249977111117893"},
         'last':     {'theme': "6", 'tint': "-0.249977111117893"},
         'high':     {'theme': "6", 'tint': "-0.249977111117893"},
         'low':      {'theme': "6", 'tint': "-0.249977111117893"},
         },  # 8
        {'series':   {'theme': "6", 'tint': "-0.249977111117893"},
         'negative': {'theme': "7"},
         'markers':  {'theme': "7", 'tint': "-0.249977111117893"},
         'first':    {'theme': "7", 'tint': "-0.249977111117893"},
         'last':     {'theme': "7", 'tint': "-0.249977111117893"},
         'high':     {'theme': "7", 'tint': "-0.249977111117893"},
         'low':      {'theme': "7", 'tint': "-0.249977111117893"},
         },  # 9
        {'series':   {'theme': "7", 'tint': "-0.249977111117893"},
         'negative': {'theme': "8"},
         'markers':  {'theme': "8", 'tint': "-0.249977111117893"},
         'first':    {'theme': "8", 'tint': "-0.249977111117893"},
         'last':     {'theme': "8", 'tint': "-0.249977111117893"},
         'high':     {'theme': "8", 'tint': "-0.249977111117893"},
         'low':      {'theme': "8", 'tint': "-0.249977111117893"},
         },  # 10
        {'series':   {'theme': "8", 'tint': "-0.249977111117893"},
         'negative': {'theme': "9"},
         'markers':  {'theme': "9", 'tint': "-0.249977111117893"},
         'first':    {'theme': "9", 'tint': "-0.249977111117893"},
         'last':     {'theme': "9", 'tint': "-0.249977111117893"},
         'high':     {'theme': "9", 'tint': "-0.249977111117893"},
         'low':      {'theme': "9", 'tint': "-0.249977111117893"},
         },  # 11
        {'series':   {'theme': "9", 'tint': "-0.249977111117893"},
         'negative': {'theme': "4"},
         'markers':  {'theme': "4", 'tint': "-0.249977111117893"},
         'first':    {'theme': "4", 'tint': "-0.249977111117893"},
         'last':     {'theme': "4", 'tint': "-0.249977111117893"},
         'high':     {'theme': "4", 'tint': "-0.249977111117893"},
         'low':      {'theme': "4", 'tint': "-0.249977111117893"},
         },  # 12
        {'series':   {'theme': "4"},
         'negative': {'theme': "5"},
         'markers':  {'theme': "4", 'tint': "-0.249977111117893"},
         'first':    {'theme': "4", 'tint': "-0.249977111117893"},
         'last':     {'theme': "4", 'tint': "-0.249977111117893"},
         'high':     {'theme': "4", 'tint': "-0.249977111117893"},
         'low':      {'theme': "4", 'tint': "-0.249977111117893"},
         },  # 13
        {'series':   {'theme': "5"},
         'negative': {'theme': "6"},
         'markers':  {'theme': "5", 'tint': "-0.249977111117893"},
         'first':    {'theme': "5", 'tint': "-0.249977111117893"},
         'last':     {'theme': "5", 'tint': "-0.249977111117893"},
         'high':     {'theme': "5", 'tint': "-0.249977111117893"},
         'low':      {'theme': "5", 'tint': "-0.249977111117893"},
         },  # 14
        {'series':   {'theme': "6"},
         'negative': {'theme': "7"},
         'markers':  {'theme': "6", 'tint': "-0.249977111117893"},
         'first':    {'theme': "6", 'tint': "-0.249977111117893"},
         'last':     {'theme': "6", 'tint': "-0.249977111117893"},
         'high':     {'theme': "6", 'tint': "-0.249977111117893"},
         'low':      {'theme': "6", 'tint': "-0.249977111117893"},
         },  # 15
        {'series':   {'theme': "7"},
         'negative': {'theme': "8"},
         'markers':  {'theme': "7", 'tint': "-0.249977111117893"},
         'first':    {'theme': "7", 'tint': "-0.249977111117893"},
         'last':     {'theme': "7", 'tint': "-0.249977111117893"},
         'high':     {'theme': "7", 'tint': "-0.249977111117893"},
         'low':      {'theme': "7", 'tint': "-0.249977111117893"},
         },  # 16
        {'series':   {'theme': "8"},
         'negative': {'theme': "9"},
         'markers':  {'theme': "8", 'tint': "-0.249977111117893"},
         'first':    {'theme': "8", 'tint': "-0.249977111117893"},
         'last':     {'theme': "8", 'tint': "-0.249977111117893"},
         'high':     {'theme': "8", 'tint': "-0.249977111117893"},
         'low':      {'theme': "8", 'tint': "-0.249977111117893"},
         },  # 17
        {'series':   {'theme': "9"},
         'negative': {'theme': "4"},
         'markers':  {'theme': "9", 'tint': "-0.249977111117893"},
         'first':    {'theme': "9", 'tint': "-0.249977111117893"},
         'last':     {'theme': "9", 'tint': "-0.249977111117893"},
         'high':     {'theme': "9", 'tint': "-0.249977111117893"},
         'low':      {'theme': "9", 'tint': "-0.249977111117893"},
         },  # 18
        {'series':   {'theme': "4", 'tint': "0.39997558519241921"},
         'negative': {'theme': "0", 'tint': "-0.499984740745262"},
         'markers':  {'theme': "4", 'tint': "0.79998168889431442"},
         'first':    {'theme': "4", 'tint': "-0.249977111117893"},
         'last':     {'theme': "4", 'tint': "-0.249977111117893"},
         'high':     {'theme': "4", 'tint': "-0.499984740745262"},
         'low':      {'theme': "4", 'tint': "-0.499984740745262"},
         },  # 19
        {'series':   {'theme': "5", 'tint': "0.39997558519241921"},
         'negative': {'theme': "0", 'tint': "-0.499984740745262"},
         'markers':  {'theme': "5", 'tint': "0.79998168889431442"},
         'first':    {'theme': "5", 'tint': "-0.249977111117893"},
         'last':     {'theme': "5", 'tint': "-0.249977111117893"},
         'high':     {'theme': "5", 'tint': "-0.499984740745262"},
         'low':      {'theme': "5", 'tint': "-0.499984740745262"},
         },  # 20
        {'series':   {'theme': "6", 'tint': "0.39997558519241921"},
         'negative': {'theme': "0", 'tint': "-0.499984740745262"},
         'markers':  {'theme': "6", 'tint': "0.79998168889431442"},
         'first':    {'theme': "6", 'tint': "-0.249977111117893"},
         'last':     {'theme': "6", 'tint': "-0.249977111117893"},
         'high':     {'theme': "6", 'tint': "-0.499984740745262"},
         'low':      {'theme': "6", 'tint': "-0.499984740745262"},
         },  # 21
        {'series':   {'theme': "7", 'tint': "0.39997558519241921"},
         'negative': {'theme': "0", 'tint': "-0.499984740745262"},
         'markers':  {'theme': "7", 'tint': "0.79998168889431442"},
         'first':    {'theme': "7", 'tint': "-0.249977111117893"},
         'last':     {'theme': "7", 'tint': "-0.249977111117893"},
         'high':     {'theme': "7", 'tint': "-0.499984740745262"},
         'low':      {'theme': "7", 'tint': "-0.499984740745262"},
         },  # 22
        {'series':   {'theme': "8", 'tint': "0.39997558519241921"},
         'negative': {'theme': "0", 'tint': "-0.499984740745262"},
         'markers':  {'theme': "8", 'tint': "0.79998168889431442"},
         'first':    {'theme': "8", 'tint': "-0.249977111117893"},
         'last':     {'theme': "8", 'tint': "-0.249977111117893"},
         'high':     {'theme': "8", 'tint': "-0.499984740745262"},
         'low':      {'theme': "8", 'tint': "-0.499984740745262"},
         },  # 23
        {'series':   {'theme': "9", 'tint': "0.39997558519241921"},
         'negative': {'theme': "0", 'tint': "-0.499984740745262"},
         'markers':  {'theme': "9", 'tint': "0.79998168889431442"},
         'first':    {'theme': "9", 'tint': "-0.249977111117893"},
         'last':     {'theme': "9", 'tint': "-0.249977111117893"},
         'high':     {'theme': "9", 'tint': "-0.499984740745262"},
         'low':      {'theme': "9", 'tint': "-0.499984740745262"},
         },  # 24
        {'series':   {'theme': "1", 'tint': "0.499984740745262"},
         'negative': {'theme': "1", 'tint': "0.249977111117893"},
         'markers':  {'theme': "1", 'tint': "0.249977111117893"},
         'first':    {'theme': "1", 'tint': "0.249977111117893"},
         'last':     {'theme': "1", 'tint': "0.249977111117893"},
         'high':     {'theme': "1", 'tint': "0.249977111117893"},
         'low':      {'theme': "1", 'tint': "0.249977111117893"},
         },  # 25
        {'series':   {'theme': "1", 'tint': "0.34998626667073579"},
         'negative': {'theme': "0", 'tint': "-0.249977111117893"},
         'markers':  {'theme': "0", 'tint': "-0.249977111117893"},
         'first':    {'theme': "0", 'tint': "-0.249977111117893"},
         'last':     {'theme': "0", 'tint': "-0.249977111117893"},
         'high':     {'theme': "0", 'tint': "-0.249977111117893"},
         'low':      {'theme': "0", 'tint': "-0.249977111117893"},
         },  # 26
        {'series':   {'rgb': "FF323232"},
         'negative': {'rgb': "FFD00000"},
         'markers':  {'rgb': "FFD00000"},
         'first':    {'rgb': "FFD00000"},
         'last':     {'rgb': "FFD00000"},
         'high':     {'rgb': "FFD00000"},
         'low':      {'rgb': "FFD00000"},
         },  # 27
        {'series':   {'rgb': "FF000000"},
         'negative': {'rgb': "FF0070C0"},
         'markers':  {'rgb': "FF0070C0"},
         'first':    {'rgb': "FF0070C0"},
         'last':     {'rgb': "FF0070C0"},
         'high':     {'rgb': "FF0070C0"},
         'low':      {'rgb': "FF0070C0"},
         },  # 28
        {'series':   {'rgb': "FF376092"},
         'negative': {'rgb': "FFD00000"},
         'markers':  {'rgb': "FFD00000"},
         'first':    {'rgb': "FFD00000"},
         'last':     {'rgb': "FFD00000"},
         'high':     {'rgb': "FFD00000"},
         'low':      {'rgb': "FFD00000"},
         },  # 29
        {'series':   {'rgb': "FF0070C0"},
         'negative': {'rgb': "FF000000"},
         'markers':  {'rgb': "FF000000"},
         'first':    {'rgb': "FF000000"},
         'last':     {'rgb': "FF000000"},
         'high':     {'rgb': "FF000000"},
         'low':      {'rgb': "FF000000"},
         },  # 30
        {'series':   {'rgb': "FF5F5F5F"},
         'negative': {'rgb': "FFFFB620"},
         'markers':  {'rgb': "FFD70077"},
         'first':    {'rgb': "FF5687C2"},
         'last':     {'rgb': "FF359CEB"},
         'high':     {'rgb': "FF56BE79"},
         'low':      {'rgb': "FFFF5055"},
         },  # 31
        {'series':   {'rgb': "FF5687C2"},
         'negative': {'rgb': "FFFFB620"},
         'markers':  {'rgb': "FFD70077"},
         'first':    {'rgb': "FF777777"},
         'last':     {'rgb': "FF359CEB"},
         'high':     {'rgb': "FF56BE79"},
         'low':      {'rgb': "FFFF5055"},
         },  # 32
        {'series':   {'rgb': "FFC6EFCE"},
         'negative': {'rgb': "FFFFC7CE"},
         'markers':  {'rgb': "FF8CADD6"},
         'first':    {'rgb': "FFFFDC47"},
         'last':     {'rgb': "FFFFEB9C"},
         'high':     {'rgb': "FF60D276"},
         'low':      {'rgb': "FFFF5367"},
         },  # 33
        {'series':   {'rgb': "FF00B050"},
         'negative': {'rgb': "FFFF0000"},
         'markers':  {'rgb': "FF0070C0"},
         'first':    {'rgb': "FFFFC000"},
         'last':     {'rgb': "FFFFC000"},
         'high':     {'rgb': "FF00B050"},
         'low':      {'rgb': "FFFF0000"},
         },  # 34
        {'series':   {'theme': "3"},
         'negative': {'theme': "9"},
         'markers':  {'theme': "8"},
         'first':    {'theme': "4"},
         'last':     {'theme': "5"},
         'high':     {'theme': "6"},
         'low':      {'theme': "7"},
         },  # 35
        {'series':   {'theme': "1"},
         'negative': {'theme': "9"},
         'markers':  {'theme': "8"},
         'first':    {'theme': "4"},
         'last':     {'theme': "5"},
         'high':     {'theme': "6"},
         'low':      {'theme': "7"},
         },  # 36
    ]

    return styles[style_id]


def supported_datetime(dt):
    # Determine is an argument is a supported datetime object.
    return(isinstance(dt, (datetime.datetime,
                           datetime.date,
                           datetime.time,
                           datetime.timedelta)))


def remove_datetime_timezone(dt_obj, remove_timezone):
    # Excel doesn't support timezones in datetimes/times so we remove the
    # tzinfo from the object if the user has specified that option in the
    # constructor.
    if remove_timezone:
        dt_obj = dt_obj.replace(tzinfo=None)
    else:
        if dt_obj.tzinfo:
            raise TypeError(
                "Excel doesn't support timezones in datetimes. "
                "Set the tzinfo in the datetime/time object to None or "
                "use the 'remove_timezone' Workbook() option")

    return dt_obj


def datetime_to_excel_datetime(dt_obj, date_1904, remove_timezone):
    # Convert a datetime object to an Excel serial date and time. The integer
    # part of the number stores the number of days since the epoch and the
    # fractional part stores the percentage of the day.
    date_type = dt_obj
    is_timedelta = False

    if date_1904:
        # Excel for Mac date epoch.
        epoch = datetime.datetime(1904, 1, 1)
    else:
        # Default Excel epoch.
        epoch = datetime.datetime(1899, 12, 31)

    # We handle datetime .datetime, .date and .time objects but convert
    # them to datetime.datetime objects and process them in the same way.
    if isinstance(dt_obj, datetime.datetime):
        dt_obj = remove_datetime_timezone(dt_obj, remove_timezone)
        delta = dt_obj - epoch
    elif isinstance(dt_obj, datetime.date):
        dt_obj = datetime.datetime.fromordinal(dt_obj.toordinal())
        delta = dt_obj - epoch
    elif isinstance(dt_obj, datetime.time):
        dt_obj = datetime.datetime.combine(epoch, dt_obj)
        dt_obj = remove_datetime_timezone(dt_obj, remove_timezone)
        delta = dt_obj - epoch
    elif isinstance(dt_obj, datetime.timedelta):
        is_timedelta = True
        delta = dt_obj
    else:
        raise TypeError("Unknown or unsupported datetime type")

    # Convert a Python datetime.datetime value to an Excel date number.
    excel_time = (delta.days
                  + (float(delta.seconds)
                     + float(delta.microseconds) / 1E6)
                  / (60 * 60 * 24))

    # The following is a workaround for the fact that in Excel a time only
    # value is represented as 1899-12-31+time whereas in datetime.datetime()
    # it is 1900-1-1+time so we need to subtract the 1 day difference.
    if (isinstance(date_type, datetime.datetime)
            and dt_obj.isocalendar() == (1900, 1, 1)):
        excel_time -= 1

    # Account for Excel erroneously treating 1900 as a leap year.
    if not date_1904 and not is_timedelta and excel_time > 59:
        excel_time += 1

    return excel_time


def preserve_whitespace(string):
    # Check if a string has leading or trailing whitespace that requires a
    # "preserve" attribute.
    if (re_leading.search(string) or re_trailing.search(string)):
        return True
    else:
        return False

```

---

### File: `tmp\xlsxwriter_old\XlsxWriter-1.4.5\xlsxwriter\vml.py`

```python
###############################################################################
#
# Vml - A class for writing the Excel XLSX Vml file.
#
# Copyright 2013-2021, John McNamara, jmcnamara@cpan.org
#

# Package imports.
from . import xmlwriter


class Vml(xmlwriter.XMLwriter):
    """
    A class for writing the Excel XLSX Vml file.


    """

    ###########################################################################
    #
    # Public API.
    #
    ###########################################################################

    def __init__(self):
        """
        Constructor.

        """

        super(Vml, self).__init__()

    ###########################################################################
    #
    # Private API.
    #
    ###########################################################################
    def _assemble_xml_file(self, data_id, vml_shape_id, comments_data=None,
                           buttons_data=None, header_images_data=None):
        # Assemble and write the XML file.
        z_index = 1

        self._write_xml_namespace()

        # Write the o:shapelayout element.
        self._write_shapelayout(data_id)

        if buttons_data:
            # Write the v:shapetype element.
            self._write_button_shapetype()

            for button in buttons_data:
                # Write the v:shape element.
                vml_shape_id += 1
                self._write_button_shape(vml_shape_id, z_index, button)
                z_index += 1

        if comments_data:
            # Write the v:shapetype element.
            self._write_comment_shapetype()

            for comment in comments_data:
                # Write the v:shape element.
                vml_shape_id += 1
                self._write_comment_shape(vml_shape_id, z_index, comment)
                z_index += 1

        if header_images_data:

            # Write the v:shapetype element.
            self._write_image_shapetype()

            index = 1
            for image in header_images_data:
                # Write the v:shape element.
                vml_shape_id += 1
                self._write_image_shape(vml_shape_id, index, image)
                index += 1

        self._xml_end_tag('xml')

        # Close the XML writer filehandle.
        self._xml_close()

    def _pixels_to_points(self, vertices):
        # Convert comment vertices from pixels to points.

        left, top, width, height = vertices[8:12]

        # Scale to pixels.
        left *= 0.75
        top *= 0.75
        width *= 0.75
        height *= 0.75

        return left, top, width, height

    ###########################################################################
    #
    # XML methods.
    #
    ###########################################################################
    def _write_xml_namespace(self):
        # Write the <xml> element. This is the root element of VML.
        schema = 'urn:schemas-microsoft-com:'
        xmlns = schema + 'vml'
        xmlns_o = schema + 'office:office'
        xmlns_x = schema + 'office:excel'

        attributes = [
            ('xmlns:v', xmlns),
            ('xmlns:o', xmlns_o),
            ('xmlns:x', xmlns_x),
        ]

        self._xml_start_tag('xml', attributes)

    def _write_shapelayout(self, data_id):
        # Write the <o:shapelayout> element.
        attributes = [('v:ext', 'edit')]

        self._xml_start_tag('o:shapelayout', attributes)

        # Write the o:idmap element.
        self._write_idmap(data_id)

        self._xml_end_tag('o:shapelayout')

    def _write_idmap(self, data_id):
        # Write the <o:idmap> element.
        attributes = [
            ('v:ext', 'edit'),
            ('data', data_id),
        ]

        self._xml_empty_tag('o:idmap', attributes)

    def _write_comment_shapetype(self):
        # Write the <v:shapetype> element.
        shape_id = '_x0000_t202'
        coordsize = '21600,21600'
        spt = 202
        path = 'm,l,21600r21600,l21600,xe'

        attributes = [
            ('id', shape_id),
            ('coordsize', coordsize),
            ('o:spt', spt),
            ('path', path),
        ]

        self._xml_start_tag('v:shapetype', attributes)

        # Write the v:stroke element.
        self._write_stroke()

        # Write the v:path element.
        self._write_comment_path('t', 'rect')

        self._xml_end_tag('v:shapetype')

    def _write_button_shapetype(self):
        # Write the <v:shapetype> element.
        shape_id = '_x0000_t201'
        coordsize = '21600,21600'
        spt = 201
        path = 'm,l,21600r21600,l21600,xe'

        attributes = [
            ('id', shape_id),
            ('coordsize', coordsize),
            ('o:spt', spt),
            ('path', path),
        ]

        self._xml_start_tag('v:shapetype', attributes)

        # Write the v:stroke element.
        self._write_stroke()

        # Write the v:path element.
        self._write_button_path()

        # Write the o:lock element.
        self._write_shapetype_lock()

        self._xml_end_tag('v:shapetype')

    def _write_image_shapetype(self):
        # Write the <v:shapetype> element.
        shape_id = '_x0000_t75'
        coordsize = '21600,21600'
        spt = 75
        o_preferrelative = 't'
        path = 'm@4@5l@4@11@9@11@9@5xe'
        filled = 'f'
        stroked = 'f'

        attributes = [
            ('id', shape_id),
            ('coordsize', coordsize),
            ('o:spt', spt),
            ('o:preferrelative', o_preferrelative),
            ('path', path),
            ('filled', filled),
            ('stroked', stroked),
        ]

        self._xml_start_tag('v:shapetype', attributes)

        # Write the v:stroke element.
        self._write_stroke()

        # Write the v:formulas element.
        self._write_formulas()

        # Write the v:path element.
        self._write_image_path()

        # Write the o:lock element.
        self._write_aspect_ratio_lock()

        self._xml_end_tag('v:shapetype')

    def _write_stroke(self):
        # Write the <v:stroke> element.
        joinstyle = 'miter'

        attributes = [('joinstyle', joinstyle)]

        self._xml_empty_tag('v:stroke', attributes)

    def _write_comment_path(self, gradientshapeok, connecttype):
        # Write the <v:path> element.
        attributes = []

        if gradientshapeok:
            attributes.append(('gradientshapeok', 't'))

        attributes.append(('o:connecttype', connecttype))

        self._xml_empty_tag('v:path', attributes)

    def _write_button_path(self):
        # Write the <v:path> element.
        shadowok = 'f'
        extrusionok = 'f'
        strokeok = 'f'
        fillok = 'f'
        connecttype = 'rect'

        attributes = [
            ('shadowok', shadowok),
            ('o:extrusionok', extrusionok),
            ('strokeok', strokeok),
            ('fillok', fillok),
            ('o:connecttype', connecttype),
        ]

        self._xml_empty_tag('v:path', attributes)

    def _write_image_path(self):
        # Write the <v:path> element.
        extrusionok = 'f'
        gradientshapeok = 't'
        connecttype = 'rect'

        attributes = [
            ('o:extrusionok', extrusionok),
            ('gradientshapeok', gradientshapeok),
            ('o:connecttype', connecttype),
        ]

        self._xml_empty_tag('v:path', attributes)

    def _write_shapetype_lock(self):
        # Write the <o:lock> element.
        ext = 'edit'
        shapetype = 't'

        attributes = [
            ('v:ext', ext),
            ('shapetype', shapetype),
        ]

        self._xml_empty_tag('o:lock', attributes)

    def _write_rotation_lock(self):
        # Write the <o:lock> element.
        ext = 'edit'
        rotation = 't'

        attributes = [
            ('v:ext', ext),
            ('rotation', rotation),
        ]

        self._xml_empty_tag('o:lock', attributes)

    def _write_aspect_ratio_lock(self):
        # Write the <o:lock> element.
        ext = 'edit'
        aspectratio = 't'

        attributes = [
            ('v:ext', ext),
            ('aspectratio', aspectratio),
        ]

        self._xml_empty_tag('o:lock', attributes)

    def _write_comment_shape(self, shape_id, z_index, comment):
        # Write the <v:shape> element.
        shape_type = '#_x0000_t202'
        insetmode = 'auto'
        visibility = 'hidden'

        # Set the shape index.
        shape_id = '_x0000_s' + str(shape_id)

        # Get the comment parameters
        row = comment[0]
        col = comment[1]
        visible = comment[4]
        fillcolor = comment[5]
        vertices = comment[9]

        (left, top, width, height) = self._pixels_to_points(vertices)

        # Set the visibility.
        if visible:
            visibility = 'visible'

        style = (
            'position:absolute;'
            'margin-left:%.15gpt;'
            'margin-top:%.15gpt;'
            'width:%.15gpt;'
            'height:%.15gpt;'
            'z-index:%d;'
            'visibility:%s' % (left, top, width, height, z_index, visibility))

        attributes = [
            ('id', shape_id),
            ('type', shape_type),
            ('style', style),
            ('fillcolor', fillcolor),
            ('o:insetmode', insetmode),
        ]

        self._xml_start_tag('v:shape', attributes)

        # Write the v:fill element.
        self._write_comment_fill()

        # Write the v:shadow element.
        self._write_shadow()

        # Write the v:path element.
        self._write_comment_path(None, 'none')

        # Write the v:textbox element.
        self._write_comment_textbox()

        # Write the x:ClientData element.
        self._write_comment_client_data(row, col, visible, vertices)

        self._xml_end_tag('v:shape')

    def _write_button_shape(self, shape_id, z_index, button):
        # Write the <v:shape> element.
        shape_type = '#_x0000_t201'

        # Set the shape index.
        shape_id = '_x0000_s' + str(shape_id)

        # Get the button parameters.
        # row = button["_row"]
        # col = button["_col"]
        vertices = button["vertices"]

        (left, top, width, height) = self._pixels_to_points(vertices)

        style = (
            'position:absolute;'
            'margin-left:%.15gpt;'
            'margin-top:%.15gpt;'
            'width:%.15gpt;'
            'height:%.15gpt;'
            'z-index:%d;'
            'mso-wrap-style:tight' % (left, top, width, height, z_index))

        attributes = [
            ('id', shape_id),
            ('type', shape_type),
        ]

        if button.get('description'):
            attributes.append(('alt', button['description']))

        attributes.append(('style', style))
        attributes.append(('o:button', 't'))
        attributes.append(('fillcolor', 'buttonFace [67]'))
        attributes.append(('strokecolor', 'windowText [64]'))
        attributes.append(('o:insetmode', 'auto'))

        self._xml_start_tag('v:shape', attributes)

        # Write the v:fill element.
        self._write_button_fill()

        # Write the o:lock element.
        self._write_rotation_lock()

        # Write the v:textbox element.
        self._write_button_textbox(button["font"])

        # Write the x:ClientData element.
        self._write_button_client_data(button)

        self._xml_end_tag('v:shape')

    def _write_image_shape(self, shape_id, z_index, image_data):
        # Write the <v:shape> element.
        shape_type = '#_x0000_t75'

        # Set the shape index.
        shape_id = '_x0000_s' + str(shape_id)

        # Get the image parameters
        width = image_data[0]
        height = image_data[1]
        name = image_data[2]
        position = image_data[3]
        x_dpi = image_data[4]
        y_dpi = image_data[5]
        ref_id = image_data[6]

        # Scale the height/width by the resolution, relative to 72dpi.
        width = width * 72.0 / x_dpi
        height = height * 72.0 / y_dpi

        # Excel uses a rounding based around 72 and 96 dpi.
        width = 72.0 / 96 * int(width * 96.0 / 72 + 0.25)
        height = 72.0 / 96 * int(height * 96.0 / 72 + 0.25)

        style = (
            'position:absolute;'
            'margin-left:0;'
            'margin-top:0;'
            'width:%.15gpt;'
            'height:%.15gpt;'
            'z-index:%d' % (width, height, z_index))

        attributes = [
            ('id', position),
            ('o:spid', shape_id),
            ('type', shape_type),
            ('style', style),
        ]

        self._xml_start_tag('v:shape', attributes)

        # Write the v:imagedata element.
        self._write_imagedata(ref_id, name)

        # Write the o:lock element.
        self._write_rotation_lock()

        self._xml_end_tag('v:shape')

    def _write_comment_fill(self):
        # Write the <v:fill> element.
        color_2 = '#ffffe1'

        attributes = [('color2', color_2)]

        self._xml_empty_tag('v:fill', attributes)

    def _write_button_fill(self):
        # Write the <v:fill> element.
        color_2 = 'buttonFace [67]'
        detectmouseclick = 't'

        attributes = [
            ('color2', color_2),
            ('o:detectmouseclick', detectmouseclick),
        ]

        self._xml_empty_tag('v:fill', attributes)

    def _write_shadow(self):
        # Write the <v:shadow> element.
        on = 't'
        color = 'black'
        obscured = 't'

        attributes = [
            ('on', on),
            ('color', color),
            ('obscured', obscured),
        ]

        self._xml_empty_tag('v:shadow', attributes)

    def _write_comment_textbox(self):
        # Write the <v:textbox> element.
        style = 'mso-direction-alt:auto'

        attributes = [('style', style)]

        self._xml_start_tag('v:textbox', attributes)

        # Write the div element.
        self._write_div('left')

        self._xml_end_tag('v:textbox')

    def _write_button_textbox(self, font):
        # Write the <v:textbox> element.
        style = 'mso-direction-alt:auto'

        attributes = [('style', style), ('o:singleclick', 'f')]

        self._xml_start_tag('v:textbox', attributes)

        # Write the div element.
        self._write_div('center', font)

        self._xml_end_tag('v:textbox')

    def _write_div(self, align, font=None):
        # Write the <div> element.

        style = 'text-align:' + align

        attributes = [('style', style)]

        self._xml_start_tag('div', attributes)

        if font:
            # Write the font element.
            self._write_font(font)

        self._xml_end_tag('div')

    def _write_font(self, font):
        # Write the <font> element.
        caption = font["caption"]
        face = 'Calibri'
        size = 220
        color = '#000000'

        attributes = [
            ('face', face),
            ('size', size),
            ('color', color),
        ]

        self._xml_data_element('font', caption, attributes)

    def _write_comment_client_data(self, row, col, visible, vertices):
        # Write the <x:ClientData> element.
        object_type = 'Note'

        attributes = [('ObjectType', object_type)]

        self._xml_start_tag('x:ClientData', attributes)

        # Write the x:MoveWithCells element.
        self._write_move_with_cells()

        # Write the x:SizeWithCells element.
        self._write_size_with_cells()

        # Write the x:Anchor element.
        self._write_anchor(vertices)

        # Write the x:AutoFill element.
        self._write_auto_fill()

        # Write the x:Row element.
        self._write_row(row)

        # Write the x:Column element.
        self._write_column(col)

        # Write the x:Visible element.
        if visible:
            self._write_visible()

        self._xml_end_tag('x:ClientData')

    def _write_button_client_data(self, button):
        # Write the <x:ClientData> element.
        macro = button["macro"]
        vertices = button["vertices"]

        object_type = 'Button'

        attributes = [('ObjectType', object_type)]

        self._xml_start_tag('x:ClientData', attributes)

        # Write the x:Anchor element.
        self._write_anchor(vertices)

        # Write the x:PrintObject element.
        self._write_print_object()

        # Write the x:AutoFill element.
        self._write_auto_fill()

        # Write the x:FmlaMacro element.
        self._write_fmla_macro(macro)

        # Write the x:TextHAlign element.
        self._write_text_halign()

        # Write the x:TextVAlign element.
        self._write_text_valign()

        self._xml_end_tag('x:ClientData')

    def _write_move_with_cells(self):
        # Write the <x:MoveWithCells> element.
        self._xml_empty_tag('x:MoveWithCells')

    def _write_size_with_cells(self):
        # Write the <x:SizeWithCells> element.
        self._xml_empty_tag('x:SizeWithCells')

    def _write_visible(self):
        # Write the <x:Visible> element.
        self._xml_empty_tag('x:Visible')

    def _write_anchor(self, vertices):
        # Write the <x:Anchor> element.
        (col_start, row_start, x1, y1, col_end, row_end, x2, y2) = vertices[:8]

        strings = [col_start, x1, row_start, y1, col_end, x2, row_end, y2]
        strings = [str(i) for i in strings]

        data = ", ".join(strings)

        self._xml_data_element('x:Anchor', data)

    def _write_auto_fill(self):
        # Write the <x:AutoFill> element.
        data = 'False'

        self._xml_data_element('x:AutoFill', data)

    def _write_row(self, data):
        # Write the <x:Row> element.
        self._xml_data_element('x:Row', data)

    def _write_column(self, data):
        # Write the <x:Column> element.
        self._xml_data_element('x:Column', data)

    def _write_print_object(self):
        # Write the <x:PrintObject> element.
        self._xml_data_element('x:PrintObject', 'False')

    def _write_text_halign(self):
        # Write the <x:TextHAlign> element.
        self._xml_data_element('x:TextHAlign', 'Center')

    def _write_text_valign(self):
        # Write the <x:TextVAlign> element.
        self._xml_data_element('x:TextVAlign', 'Center')

    def _write_fmla_macro(self, data):
        # Write the <x:FmlaMacro> element.
        self._xml_data_element('x:FmlaMacro', data)

    def _write_imagedata(self, ref_id, o_title):
        # Write the <v:imagedata> element.
        attributes = [
            ('o:relid', 'rId' + str(ref_id)),
            ('o:title', o_title),
        ]

        self._xml_empty_tag('v:imagedata', attributes)

    def _write_formulas(self):
        # Write the <v:formulas> element.
        self._xml_start_tag('v:formulas')

        # Write the v:f elements.
        self._write_formula('if lineDrawn pixelLineWidth 0')
        self._write_formula('sum @0 1 0')
        self._write_formula('sum 0 0 @1')
        self._write_formula('prod @2 1 2')
        self._write_formula('prod @3 21600 pixelWidth')
        self._write_formula('prod @3 21600 pixelHeight')
        self._write_formula('sum @0 0 1')
        self._write_formula('prod @6 1 2')
        self._write_formula('prod @7 21600 pixelWidth')
        self._write_formula('sum @8 21600 0')
        self._write_formula('prod @7 21600 pixelHeight')
        self._write_formula('sum @10 21600 0')

        self._xml_end_tag('v:formulas')

    def _write_formula(self, eqn):
        # Write the <v:f> element.
        attributes = [('eqn', eqn)]

        self._xml_empty_tag('v:f', attributes)

```

---

### File: `tmp\xlsxwriter_old\XlsxWriter-1.4.5\xlsxwriter\workbook.py`

```python
###############################################################################
#
# Workbook - A class for writing the Excel XLSX Workbook file.
#
# Copyright 2013-2021, John McNamara, jmcnamara@cpan.org
#

# Standard packages.
import hashlib
import re
import os
import operator
import time
from warnings import warn
from datetime import datetime
from zipfile import ZipFile, ZipInfo, ZIP_DEFLATED, LargeZipFile
from struct import unpack

from .compatibility import int_types, num_types, str_types, force_unicode

# Package imports.
from . import xmlwriter
from .worksheet import Worksheet
from .chartsheet import Chartsheet
from .sharedstrings import SharedStringTable
from .format import Format
from .packager import Packager
from .utility import xl_cell_to_rowcol
from .chart_area import ChartArea
from .chart_bar import ChartBar
from .chart_column import ChartColumn
from .chart_doughnut import ChartDoughnut
from .chart_line import ChartLine
from .chart_pie import ChartPie
from .chart_radar import ChartRadar
from .chart_scatter import ChartScatter
from .chart_stock import ChartStock
from .exceptions import InvalidWorksheetName
from .exceptions import DuplicateWorksheetName
from .exceptions import UndefinedImageSize
from .exceptions import UnsupportedImageFormat
from .exceptions import FileCreateError
from .exceptions import FileSizeError


class Workbook(xmlwriter.XMLwriter):
    """
    A class for writing the Excel XLSX Workbook file.


    """

    ###########################################################################
    #
    # Public API.
    #
    ###########################################################################
    chartsheet_class = Chartsheet
    worksheet_class = Worksheet

    def __init__(self, filename=None, options=None):
        """
        Constructor.

        """
        if options is None:
            options = {}

        super(Workbook, self).__init__()

        self.filename = filename

        self.tmpdir = options.get('tmpdir', None)
        self.date_1904 = options.get('date_1904', False)
        self.strings_to_numbers = options.get('strings_to_numbers', False)
        self.strings_to_formulas = options.get('strings_to_formulas', True)
        self.strings_to_urls = options.get('strings_to_urls', True)
        self.nan_inf_to_errors = options.get('nan_inf_to_errors', False)
        self.default_date_format = options.get('default_date_format', None)
        self.constant_memory = options.get('constant_memory', False)
        self.in_memory = options.get('in_memory', False)
        self.excel2003_style = options.get('excel2003_style', False)
        self.remove_timezone = options.get('remove_timezone', False)
        self.use_future_functions = options.get('use_future_functions', False)
        self.default_format_properties = \
            options.get('default_format_properties', {})

        self.max_url_length = options.get('max_url_length', 2079)
        if self.max_url_length < 255:
            self.max_url_length = 2079

        if options.get('use_zip64'):
            self.allow_zip64 = True
        else:
            self.allow_zip64 = False

        self.worksheet_meta = WorksheetMeta()
        self.selected = 0
        self.fileclosed = 0
        self.filehandle = None
        self.internal_fh = 0
        self.sheet_name = 'Sheet'
        self.chart_name = 'Chart'
        self.sheetname_count = 0
        self.chartname_count = 0
        self.worksheets_objs = []
        self.charts = []
        self.drawings = []
        self.sheetnames = {}
        self.formats = []
        self.xf_formats = []
        self.xf_format_indices = {}
        self.dxf_formats = []
        self.dxf_format_indices = {}
        self.palette = []
        self.font_count = 0
        self.num_format_count = 0
        self.defined_names = []
        self.named_ranges = []
        self.custom_colors = []
        self.doc_properties = {}
        self.custom_properties = []
        self.createtime = datetime.utcnow()
        self.num_vml_files = 0
        self.num_comment_files = 0
        self.x_window = 240
        self.y_window = 15
        self.window_width = 16095
        self.window_height = 9660
        self.tab_ratio = 600
        self.str_table = SharedStringTable()
        self.vba_project = None
        self.vba_is_stream = False
        self.vba_codename = None
        self.image_types = {}
        self.images = []
        self.border_count = 0
        self.fill_count = 0
        self.drawing_count = 0
        self.calc_mode = "auto"
        self.calc_on_load = True
        self.calc_id = 124519
        self.has_comments = False
        self.read_only = 0
        self.has_metadata = False

        # We can't do 'constant_memory' mode while doing 'in_memory' mode.
        if self.in_memory:
            self.constant_memory = False

        # Add the default cell format.
        if self.excel2003_style:
            self.add_format({'xf_index': 0, 'font_family': 0})
        else:
            self.add_format({'xf_index': 0})

        # Add a default URL format.
        self.default_url_format = self.add_format({'hyperlink': True})

        # Add the default date format.
        if self.default_date_format is not None:
            self.default_date_format = \
                self.add_format({'num_format': self.default_date_format})

    def __enter__(self):
        """Return self object to use with "with" statement."""
        return self

    def __exit__(self, type, value, traceback):
        """Close workbook when exiting "with" statement."""
        self.close()

    def add_worksheet(self, name=None, worksheet_class=None):
        """
        Add a new worksheet to the Excel workbook.

        Args:
            name: The worksheet name. Defaults to 'Sheet1', etc.

        Returns:
            Reference to a worksheet object.

        """
        if worksheet_class is None:
            worksheet_class = self.worksheet_class

        return self._add_sheet(name, worksheet_class=worksheet_class)

    def add_chartsheet(self, name=None, chartsheet_class=None):
        """
        Add a new chartsheet to the Excel workbook.

        Args:
            name: The chartsheet name. Defaults to 'Sheet1', etc.

        Returns:
            Reference to a chartsheet object.

        """
        if chartsheet_class is None:
            chartsheet_class = self.chartsheet_class

        return self._add_sheet(name, worksheet_class=chartsheet_class)

    def add_format(self, properties=None):
        """
        Add a new Format to the Excel Workbook.

        Args:
            properties: The format properties.

        Returns:
            Reference to a Format object.

        """
        format_properties = self.default_format_properties.copy()

        if self.excel2003_style:
            format_properties = {'font_name': 'Arial', 'font_size': 10,
                                 'theme': 1 * -1}

        if properties:
            format_properties.update(properties)

        xf_format = Format(format_properties,
                           self.xf_format_indices,
                           self.dxf_format_indices)

        # Store the format reference.
        self.formats.append(xf_format)

        return xf_format

    def add_chart(self, options):
        """
        Create a chart object.

        Args:
            options: The chart type and subtype options.

        Returns:
            Reference to a Chart object.

        """

        # Type must be specified so we can create the required chart instance.
        chart_type = options.get('type')
        if chart_type is None:
            warn("Chart type must be defined in add_chart()")
            return

        if chart_type == 'area':
            chart = ChartArea(options)
        elif chart_type == 'bar':
            chart = ChartBar(options)
        elif chart_type == 'column':
            chart = ChartColumn(options)
        elif chart_type == 'doughnut':
            chart = ChartDoughnut(options)
        elif chart_type == 'line':
            chart = ChartLine(options)
        elif chart_type == 'pie':
            chart = ChartPie(options)
        elif chart_type == 'radar':
            chart = ChartRadar(options)
        elif chart_type == 'scatter':
            chart = ChartScatter(options)
        elif chart_type == 'stock':
            chart = ChartStock(options)
        else:
            warn("Unknown chart type '%s' in add_chart()" % chart_type)
            return

        # Set the embedded chart name if present.
        if 'name' in options:
            chart.chart_name = options['name']

        chart.embedded = True
        chart.date_1904 = self.date_1904
        chart.remove_timezone = self.remove_timezone

        self.charts.append(chart)

        return chart

    def add_vba_project(self, vba_project, is_stream=False):
        """
        Add a vbaProject binary to the Excel workbook.

        Args:
            vba_project: The vbaProject binary file name.
            is_stream:   vba_project is an in memory byte stream.

        Returns:
            Nothing.

        """
        if not is_stream and not os.path.exists(vba_project):
            warn("VBA project binary file '%s' not found."
                 % force_unicode(vba_project))
            return -1

        if self.vba_codename is None:
            self.vba_codename = 'ThisWorkbook'

        self.vba_project = vba_project
        self.vba_is_stream = is_stream

    def close(self):
        """
        Call finalization code and close file.

        Args:
            None.

        Returns:
            Nothing.

        """
        if not self.fileclosed:

            try:
                self._store_workbook()
            except IOError as e:
                raise FileCreateError(e)
            except LargeZipFile as e:
                raise FileSizeError("Filesize would require ZIP64 extensions. "
                                    "Use workbook.use_zip64().")

            self.fileclosed = True

            # Ensure all constant_memory temp files are closed.
            if self.constant_memory:
                for worksheet in self.worksheets():
                    worksheet._opt_close()

        else:
            warn("Calling close() on already closed file.")

    def set_size(self, width, height):
        """
        Set the size of a workbook window.

        Args:
            width:  Width  of the window in pixels.
            height: Height of the window in pixels.

        Returns:
            Nothing.

        """
        # Convert the width/height to twips at 96 dpi.
        if width:
            self.window_width = int(width * 1440 / 96)
        else:
            self.window_width = 16095

        if height:
            self.window_height = int(height * 1440 / 96)
        else:
            self.window_height = 9660

    def set_tab_ratio(self, tab_ratio=None):
        """
        Set the ratio between worksheet tabs and the horizontal slider.

        Args:
            tab_ratio: The tab ratio, 0 <= tab_ratio <= 100

        Returns:
            Nothing.

        """
        if tab_ratio is None:
            return

        if tab_ratio < 0 or tab_ratio > 100:
            warn("Tab ratio '%d' outside: 0 <= tab_ratio <= 100" % tab_ratio)
        else:
            self.tab_ratio = int(tab_ratio * 10)

    def set_properties(self, properties):
        """
        Set the document properties such as Title, Author etc.

        Args:
            properties: Dictionary of document properties.

        Returns:
            Nothing.

        """
        self.doc_properties = properties

    def set_custom_property(self, name, value, property_type=None):
        """
        Set a custom document property.

        Args:
            name:          The name of the custom property.
            value:         The value of the custom property.
            property_type: The type of the custom property. Optional.

        Returns:
            Nothing.

        """
        if name is None or value is None:
            warn("The name and value parameters must be non-None in "
                 "set_custom_property()")
            return -1

        if property_type is None:
            # Determine the property type from the Python type.
            if isinstance(value, bool):
                property_type = 'bool'
            elif isinstance(value, datetime):
                property_type = 'date'
            elif isinstance(value, int_types):
                property_type = 'number_int'
            elif isinstance(value, num_types):
                property_type = 'number'
            else:
                property_type = 'text'

        if property_type == 'date':
            value = value.strftime("%Y-%m-%dT%H:%M:%SZ")

        if property_type == 'text' and len(value) > 255:
            warn("Length of 'value' parameter exceeds Excel's limit of 255 "
                 "characters in set_custom_property(): '%s'" %
                 force_unicode(value))

        if len(name) > 255:
            warn("Length of 'name' parameter exceeds Excel's limit of 255 "
                 "characters in set_custom_property(): '%s'" %
                 force_unicode(name))

        self.custom_properties.append((name, value, property_type))

    def set_calc_mode(self, mode, calc_id=None):
        """
        Set the Excel calculation mode for the workbook.

        Args:
            mode: String containing one of:
                * manual
                * auto_except_tables
                * auto

        Returns:
            Nothing.

        """
        self.calc_mode = mode

        if mode == 'manual':
            self.calc_on_load = False
        elif mode == 'auto_except_tables':
            self.calc_mode = 'autoNoTable'

        # Leave undocumented for now. Rarely required.
        if calc_id:
            self.calc_id = calc_id

    def define_name(self, name, formula):
        # Create a defined name in Excel. We handle global/workbook level
        # names and local/worksheet names.
        """
        Create a defined name in the workbook.

        Args:
            name:    The defined name.
            formula: The cell or range that the defined name refers to.

        Returns:
            Nothing.

        """
        sheet_index = None
        sheetname = ''

        # Remove the = sign from the formula if it exists.
        if formula.startswith('='):
            formula = formula.lstrip('=')

        # Local defined names are formatted like "Sheet1!name".
        sheet_parts = re.compile(r'^(.*)!(.*)$')
        match = sheet_parts.match(name)

        if match:
            sheetname = match.group(1)
            name = match.group(2)
            sheet_index = self._get_sheet_index(sheetname)

            # Warn if the sheet index wasn't found.
            if sheet_index is None:
                warn("Unknown sheet name '%s' in defined_name()"
                     % force_unicode(sheetname))
                return -1
        else:
            # Use -1 to indicate global names.
            sheet_index = -1

        # Warn if the defined name contains invalid chars as defined by Excel.
        if (not re.match(r'^[\w\\][\w\\.]*$', name, re.UNICODE)
                or re.match(r'^\d', name)):
            warn("Invalid Excel characters in defined_name(): '%s'"
                 % force_unicode(name))
            return -1

        # Warn if the defined name looks like a cell name.
        if re.match(r'^[a-zA-Z][a-zA-Z]?[a-dA-D]?[0-9]+$', name):
            warn("Name looks like a cell name in defined_name(): '%s'"
                 % force_unicode(name))
            return -1

        # Warn if the name looks like a R1C1 cell reference.
        if (re.match(r'^[rcRC]$', name)
                or re.match(r'^[rcRC]\d+[rcRC]\d+$', name)):
            warn("Invalid name '%s' like a RC cell ref in defined_name()"
                 % force_unicode(name))
            return -1

        self.defined_names.append([name, sheet_index, formula, False])

    def worksheets(self):
        """
        Return a list of the worksheet objects in the workbook.

        Args:
            None.

        Returns:
            A list of worksheet objects.

        """
        return self.worksheets_objs

    def get_worksheet_by_name(self, name):
        """
        Return a worksheet object in the workbook using the sheetname.

        Args:
            name: The name of the worksheet.

        Returns:
            A worksheet object or None.

        """
        return self.sheetnames.get(name)

    def get_default_url_format(self):
        """
        Get the default url format used when a user defined format isn't
        specified with write_url(). The format is the hyperlink style defined
        by Excel for the default theme.

        Args:
            None.

        Returns:
            A format object.

        """
        return self.default_url_format

    def use_zip64(self):
        """
        Allow ZIP64 extensions when writing xlsx file zip container.

        Args:
            None.

        Returns:
            Nothing.

        """
        self.allow_zip64 = True

    def set_vba_name(self, name=None):
        """
        Set the VBA name for the workbook. By default the workbook is referred
        to as ThisWorkbook in VBA.

        Args:
            name: The VBA name for the workbook.

        Returns:
            Nothing.

        """
        if name is not None:
            self.vba_codename = name
        else:
            self.vba_codename = 'ThisWorkbook'

    def read_only_recommended(self):
        """
        Set the Excel "Read-only recommended" option when saving a file.

        Args:
            None.

        Returns:
            Nothing.

        """
        self.read_only = 2

    ###########################################################################
    #
    # Private API.
    #
    ###########################################################################

    def _assemble_xml_file(self):
        # Assemble and write the XML file.

        # Prepare format object for passing to Style.pm.
        self._prepare_format_properties()

        # Write the XML declaration.
        self._xml_declaration()

        # Write the workbook element.
        self._write_workbook()

        # Write the fileVersion element.
        self._write_file_version()

        # Write the fileSharing element.
        self._write_file_sharing()

        # Write the workbookPr element.
        self._write_workbook_pr()

        # Write the bookViews element.
        self._write_book_views()

        # Write the sheets element.
        self._write_sheets()

        # Write the workbook defined names.
        self._write_defined_names()

        # Write the calcPr element.
        self._write_calc_pr()

        # Close the workbook tag.
        self._xml_end_tag('workbook')

        # Close the file.
        self._xml_close()

    def _store_workbook(self):

        # Create the xlsx/zip file.
        try:
            xlsx_file = ZipFile(self.filename, "w", compression=ZIP_DEFLATED,
                                allowZip64=self.allow_zip64)
        except IOError as e:
            raise e

        # Assemble worksheets into a workbook.
        packager = self._get_packager()

        # Add a default worksheet if non have been added.
        if not self.worksheets():
            self.add_worksheet()

        # Ensure that at least one worksheet has been selected.
        if self.worksheet_meta.activesheet == 0:
            self.worksheets_objs[0].selected = 1
            self.worksheets_objs[0].hidden = 0

        # Set the active sheet.
        for sheet in self.worksheets():
            if sheet.index == self.worksheet_meta.activesheet:
                sheet.active = 1

        # Set the sheet vba_codename the workbook has a vbaProject binary.
        if self.vba_project:
            for sheet in self.worksheets():
                if sheet.vba_codename is None:
                    sheet.set_vba_name()

        # Convert the SST strings data structure.
        self._prepare_sst_string_data()

        # Prepare the worksheet VML elements such as comments and buttons.
        self._prepare_vml()

        # Set the defined names for the worksheets such as Print Titles.
        self._prepare_defined_names()

        # Prepare the drawings, charts and images.
        self._prepare_drawings()

        # Add cached data to charts.
        self._add_chart_data()

        # Prepare the worksheet tables.
        self._prepare_tables()

        # Prepare the metadata file links.
        self._prepare_metadata()

        # Package the workbook.
        packager._add_workbook(self)
        packager._set_tmpdir(self.tmpdir)
        packager._set_in_memory(self.in_memory)
        xml_files = packager._create_package()

        # Free up the Packager object.
        packager = None

        # Add XML sub-files to the Zip file with their Excel filename.
        for file_id, file_data in enumerate(xml_files):
            os_filename, xml_filename, is_binary = file_data

            if self.in_memory:

                # Set sub-file timestamp to Excel's timestamp of 1/1/1980.
                zipinfo = ZipInfo(xml_filename, (1980, 1, 1, 0, 0, 0))

                # Copy compression type from parent ZipFile.
                zipinfo.compress_type = xlsx_file.compression

                if is_binary:
                    xlsx_file.writestr(zipinfo, os_filename.getvalue())
                else:
                    xlsx_file.writestr(zipinfo,
                                       os_filename.getvalue().encode('utf-8'))
            else:
                # The sub-files are tempfiles on disk, i.e, not in memory.

                # Set sub-file timestamp to 31/1/1980 due to portability
                # issues setting it to Excel's timestamp of 1/1/1980.
                timestamp = time.mktime((1980, 1, 31, 0, 0, 0, 0, 0, -1))
                os.utime(os_filename, (timestamp, timestamp))

                try:
                    xlsx_file.write(os_filename, xml_filename)
                    os.remove(os_filename)
                except LargeZipFile as e:
                    # Close open temp files on zipfile.LargeZipFile exception.
                    for i in range(file_id, len(xml_files)-1):
                        os.remove(xml_files[i][0])
                    raise e

        xlsx_file.close()

    def _add_sheet(self, name, worksheet_class=None):
        # Utility for shared code in add_worksheet() and add_chartsheet().

        if worksheet_class:
            worksheet = worksheet_class()
        else:
            worksheet = self.worksheet_class()

        sheet_index = len(self.worksheets_objs)
        name = self._check_sheetname(name, isinstance(worksheet, Chartsheet))

        # Initialization data to pass to the worksheet.
        init_data = {
            'name': name,
            'index': sheet_index,
            'str_table': self.str_table,
            'worksheet_meta': self.worksheet_meta,
            'constant_memory': self.constant_memory,
            'tmpdir': self.tmpdir,
            'date_1904': self.date_1904,
            'strings_to_numbers': self.strings_to_numbers,
            'strings_to_formulas': self.strings_to_formulas,
            'strings_to_urls': self.strings_to_urls,
            'nan_inf_to_errors': self.nan_inf_to_errors,
            'default_date_format': self.default_date_format,
            'default_url_format': self.default_url_format,
            'excel2003_style': self.excel2003_style,
            'remove_timezone': self.remove_timezone,
            'max_url_length': self.max_url_length,
            'use_future_functions': self.use_future_functions,
        }

        worksheet._initialize(init_data)

        self.worksheets_objs.append(worksheet)
        self.sheetnames[name] = worksheet

        return worksheet

    def _check_sheetname(self, sheetname, is_chartsheet=False):
        # Check for valid worksheet names. We check the length, if it contains
        # any invalid chars and if the sheetname is unique in the workbook.
        invalid_char = re.compile(r'[\[\]:*?/\\]')

        # Increment the Sheet/Chart number used for default sheet names below.
        if is_chartsheet:
            self.chartname_count += 1
        else:
            self.sheetname_count += 1

        # Supply default Sheet/Chart sheetname if none has been defined.
        if sheetname is None or sheetname == '':
            if is_chartsheet:
                sheetname = self.chart_name + str(self.chartname_count)
            else:
                sheetname = self.sheet_name + str(self.sheetname_count)

        # Check that sheet sheetname is <= 31. Excel limit.
        if len(sheetname) > 31:
            raise InvalidWorksheetName(
                "Excel worksheet name '%s' must be <= 31 chars." %
                sheetname)

        # Check that sheetname doesn't contain any invalid characters.
        if invalid_char.search(sheetname):
            raise InvalidWorksheetName(
                "Invalid Excel character '[]:*?/\\' in sheetname '%s'." %
                sheetname)

        # Check that sheetname doesn't start or end with an apostrophe.
        if sheetname.startswith("'") or sheetname.endswith("'"):
            raise InvalidWorksheetName(
                "Sheet name cannot start or end with an apostrophe \"%s\"." %
                sheetname)

        # Check that the worksheet name doesn't already exist since this is a
        # fatal Excel error. The check must be case insensitive like Excel.
        for worksheet in self.worksheets():
            if sheetname.lower() == worksheet.name.lower():
                raise DuplicateWorksheetName(
                    "Sheetname '%s', with case ignored, is already in use." %
                    sheetname)

        return sheetname

    def _prepare_format_properties(self):
        # Prepare all Format properties prior to passing them to styles.py.

        # Separate format objects into XF and DXF formats.
        self._prepare_formats()

        # Set the font index for the format objects.
        self._prepare_fonts()

        # Set the number format index for the format objects.
        self._prepare_num_formats()

        # Set the border index for the format objects.
        self._prepare_borders()

        # Set the fill index for the format objects.
        self._prepare_fills()

    def _prepare_formats(self):
        # Iterate through the XF Format objects and separate them into
        # XF and DXF formats. The XF and DF formats then need to be sorted
        # back into index order rather than creation order.
        xf_formats = []
        dxf_formats = []

        # Sort into XF and DXF formats.
        for xf_format in self.formats:
            if xf_format.xf_index is not None:
                xf_formats.append(xf_format)

            if xf_format.dxf_index is not None:
                dxf_formats.append(xf_format)

        # Pre-extend the format lists.
        self.xf_formats = [None] * len(xf_formats)
        self.dxf_formats = [None] * len(dxf_formats)

        # Rearrange formats into index order.
        for xf_format in xf_formats:
            index = xf_format.xf_index
            self.xf_formats[index] = xf_format

        for dxf_format in dxf_formats:
            index = dxf_format.dxf_index
            self.dxf_formats[index] = dxf_format

    def _set_default_xf_indices(self):
        # Set the default index for each format. Only used for testing.

        formats = list(self.formats)

        # Delete the default url format.
        del formats[1]

        # Skip the default date format if set.
        if self.default_date_format is not None:
            del formats[1]

        # Set the remaining formats.
        for xf_format in formats:
            xf_format._get_xf_index()

    def _prepare_fonts(self):
        # Iterate through the XF Format objects and give them an index to
        # non-default font elements.
        fonts = {}
        index = 0

        for xf_format in self.xf_formats:
            key = xf_format._get_font_key()
            if key in fonts:
                # Font has already been used.
                xf_format.font_index = fonts[key]
                xf_format.has_font = 0
            else:
                # This is a new font.
                fonts[key] = index
                xf_format.font_index = index
                xf_format.has_font = 1
                index += 1

        self.font_count = index

        # For DXF formats we only need to check if the properties have changed.
        for xf_format in self.dxf_formats:
            # The only font properties that can change for a DXF format are:
            # color, bold, italic, underline and strikethrough.
            if (xf_format.font_color or xf_format.bold or xf_format.italic
                    or xf_format.underline or xf_format.font_strikeout):
                xf_format.has_dxf_font = 1

    def _prepare_num_formats(self):
        # User defined records in Excel start from index 0xA4.
        num_formats = {}
        index = 164
        num_format_count = 0

        for xf_format in (self.xf_formats + self.dxf_formats):
            num_format = xf_format.num_format

            # Check if num_format is an index to a built-in number format.
            if not isinstance(num_format, str_types):
                num_format = int(num_format)

                # Number format '0' is indexed as 1 in Excel.
                if num_format == 0:
                    num_format = 1

                xf_format.num_format_index = num_format
                continue
            elif num_format == '0':
                # Number format '0' is indexed as 1 in Excel.
                xf_format.num_format_index = 1
                continue
            elif num_format == 'General':
                # The 'General' format has an number format index of 0.
                xf_format.num_format_index = 0
                continue

            if num_format in num_formats:
                # Number xf_format has already been used.
                xf_format.num_format_index = num_formats[num_format]
            else:
                # Add a new number xf_format.
                num_formats[num_format] = index
                xf_format.num_format_index = index
                index += 1

                # Only increase font count for XF formats (not DXF formats).
                if xf_format.xf_index:
                    num_format_count += 1

        self.num_format_count = num_format_count

    def _prepare_borders(self):
        # Iterate through the XF Format objects and give them an index to
        # non-default border elements.
        borders = {}
        index = 0

        for xf_format in self.xf_formats:
            key = xf_format._get_border_key()

            if key in borders:
                # Border has already been used.
                xf_format.border_index = borders[key]
                xf_format.has_border = 0
            else:
                # This is a new border.
                borders[key] = index
                xf_format.border_index = index
                xf_format.has_border = 1
                index += 1

        self.border_count = index

        # For DXF formats we only need to check if the properties have changed.
        has_border = re.compile(r'[^0:]')

        for xf_format in self.dxf_formats:
            key = xf_format._get_border_key()

            if has_border.search(key):
                xf_format.has_dxf_border = 1

    def _prepare_fills(self):
        # Iterate through the XF Format objects and give them an index to
        # non-default fill elements.
        # The user defined fill properties start from 2 since there are 2
        # default fills: patternType="none" and patternType="gray125".
        fills = {}
        index = 2  # Start from 2. See above.

        # Add the default fills.
        fills['0:0:0'] = 0
        fills['17:0:0'] = 1

        # Store the DXF colors separately since them may be reversed below.
        for xf_format in self.dxf_formats:
            if xf_format.pattern or xf_format.bg_color or xf_format.fg_color:
                xf_format.has_dxf_fill = 1
                xf_format.dxf_bg_color = xf_format.bg_color
                xf_format.dxf_fg_color = xf_format.fg_color

        for xf_format in self.xf_formats:
            # The following logical statements jointly take care of special
            # cases in relation to cell colors and patterns:
            # 1. For a solid fill (_pattern == 1) Excel reverses the role of
            # foreground and background colors, and
            # 2. If the user specifies a foreground or background color
            # without a pattern they probably wanted a solid fill, so we fill
            # in the defaults.
            if (xf_format.pattern == 1 and xf_format.bg_color != 0
                    and xf_format.fg_color != 0):
                tmp = xf_format.fg_color
                xf_format.fg_color = xf_format.bg_color
                xf_format.bg_color = tmp

            if (xf_format.pattern <= 1 and xf_format.bg_color != 0
                    and xf_format.fg_color == 0):
                xf_format.fg_color = xf_format.bg_color
                xf_format.bg_color = 0
                xf_format.pattern = 1

            if (xf_format.pattern <= 1 and xf_format.bg_color == 0
                    and xf_format.fg_color != 0):
                xf_format.bg_color = 0
                xf_format.pattern = 1

            key = xf_format._get_fill_key()

            if key in fills:
                # Fill has already been used.
                xf_format.fill_index = fills[key]
                xf_format.has_fill = 0
            else:
                # This is a new fill.
                fills[key] = index
                xf_format.fill_index = index
                xf_format.has_fill = 1
                index += 1

        self.fill_count = index

    def _prepare_defined_names(self):
        # Iterate through the worksheets and store any defined names in
        # addition to any user defined names. Stores the defined names
        # for the Workbook.xml and the named ranges for App.xml.
        defined_names = self.defined_names

        for sheet in self.worksheets():
            # Check for Print Area settings.
            if sheet.autofilter_area:
                hidden = 1
                sheet_range = sheet.autofilter_area
                # Store the defined names.
                defined_names.append(['_xlnm._FilterDatabase',
                                      sheet.index, sheet_range, hidden])

            # Check for Print Area settings.
            if sheet.print_area_range:
                hidden = 0
                sheet_range = sheet.print_area_range
                # Store the defined names.
                defined_names.append(['_xlnm.Print_Area',
                                      sheet.index, sheet_range, hidden])

            # Check for repeat rows/cols referred to as Print Titles.
            if sheet.repeat_col_range or sheet.repeat_row_range:
                hidden = 0
                sheet_range = ''
                if sheet.repeat_col_range and sheet.repeat_row_range:
                    sheet_range = (sheet.repeat_col_range + ',' +
                                   sheet.repeat_row_range)
                else:
                    sheet_range = (sheet.repeat_col_range +
                                   sheet.repeat_row_range)
                # Store the defined names.
                defined_names.append(['_xlnm.Print_Titles',
                                      sheet.index, sheet_range, hidden])

        defined_names = self._sort_defined_names(defined_names)
        self.defined_names = defined_names
        self.named_ranges = self._extract_named_ranges(defined_names)

    def _sort_defined_names(self, names):
        # Sort the list of list of internal and user defined names in
        # the same order as used by Excel.

        # Add a normalize name string to each list for sorting.
        for name_list in names:
            (defined_name, _, sheet_name, _) = name_list

            # Normalize the defined name by removing any leading '_xmln.'
            # from internal names and lowercasing the string.
            defined_name = defined_name.replace('_xlnm.', '').lower()

            # Normalize the sheetname by removing the leading quote and
            # lowercasing the string.
            sheet_name = sheet_name.lstrip("'").lower()

            name_list.append(defined_name + "::" + sheet_name)

        # Sort based on the normalized key.
        names.sort(key=operator.itemgetter(4))

        # Remove the extra key used for sorting.
        for name_list in names:
            name_list.pop()

        return names

    def _prepare_drawings(self):
        # Iterate through the worksheets and set up chart and image drawings.
        chart_ref_id = 0
        image_ref_id = 0
        ref_id = 0
        drawing_id = 0
        image_ids = {}
        header_image_ids = {}
        background_ids = {}

        for sheet in self.worksheets():
            chart_count = len(sheet.charts)
            image_count = len(sheet.images)
            shape_count = len(sheet.shapes)

            header_image_count = len(sheet.header_images)
            footer_image_count = len(sheet.footer_images)
            has_background = sheet.background_image
            has_drawing = False

            if not (chart_count or image_count or shape_count
                    or header_image_count or footer_image_count
                    or has_background):
                continue

            # Don't increase the drawing_id header/footer images.
            if chart_count or image_count or shape_count:
                drawing_id += 1
                has_drawing = True

            # Prepare the background images.
            if sheet.background_image:
                if sheet.background_bytes:
                    filename = ''
                    image_data = sheet.background_image
                else:
                    filename = sheet.background_image
                    image_data = None

                (image_type, width, height, name, x_dpi, y_dpi, digest) = \
                    self._get_image_properties(filename, image_data)

                if digest in background_ids:
                    ref_id = background_ids[digest]
                else:
                    image_ref_id += 1
                    ref_id = image_ref_id
                    background_ids[digest] = image_ref_id
                    self.images.append([filename, image_type, image_data])

                sheet._prepare_background(ref_id, image_type)

            # Prepare the worksheet images.
            for index in range(image_count):
                filename = sheet.images[index][2]
                image_data = sheet.images[index][10]
                (image_type, width, height, name, x_dpi, y_dpi, digest) = \
                    self._get_image_properties(filename, image_data)

                if digest in image_ids:
                    ref_id = image_ids[digest]
                else:
                    image_ref_id += 1
                    ref_id = image_ref_id
                    image_ids[digest] = image_ref_id
                    self.images.append([filename, image_type, image_data])

                sheet._prepare_image(index, ref_id, drawing_id, width, height,
                                     name, image_type, x_dpi, y_dpi, digest)

            # Prepare the worksheet charts.
            for index in range(chart_count):
                chart_ref_id += 1
                sheet._prepare_chart(index, chart_ref_id, drawing_id)

            # Prepare the worksheet shapes.
            for index in range(shape_count):
                sheet._prepare_shape(index, drawing_id)

            # Prepare the header images.
            for index in range(header_image_count):

                filename = sheet.header_images[index][0]
                image_data = sheet.header_images[index][1]
                position = sheet.header_images[index][2]

                (image_type, width, height, name, x_dpi, y_dpi, digest) = \
                    self._get_image_properties(filename, image_data)

                if digest in header_image_ids:
                    ref_id = header_image_ids[digest]
                else:
                    image_ref_id += 1
                    ref_id = image_ref_id
                    header_image_ids[digest] = image_ref_id
                    self.images.append([filename, image_type, image_data])

                sheet._prepare_header_image(ref_id, width, height,
                                            name, image_type, position,
                                            x_dpi, y_dpi, digest)

            # Prepare the footer images.
            for index in range(footer_image_count):

                filename = sheet.footer_images[index][0]
                image_data = sheet.footer_images[index][1]
                position = sheet.footer_images[index][2]

                (image_type, width, height, name, x_dpi, y_dpi, digest) = \
                    self._get_image_properties(filename, image_data)

                if digest in header_image_ids:
                    ref_id = header_image_ids[digest]
                else:
                    image_ref_id += 1
                    ref_id = image_ref_id
                    header_image_ids[digest] = image_ref_id
                    self.images.append([filename, image_type, image_data])

                sheet._prepare_header_image(image_ref_id, width, height,
                                            name, image_type, position,
                                            x_dpi, y_dpi, digest)

            if has_drawing:
                drawing = sheet.drawing
                self.drawings.append(drawing)

        # Remove charts that were created but not inserted into worksheets.
        for chart in self.charts[:]:
            if chart.id == -1:
                self.charts.remove(chart)

        # Sort the workbook charts references into the order that the were
        # written to the worksheets above.
        self.charts = sorted(self.charts, key=lambda chart: chart.id)

        self.drawing_count = drawing_id

    def _get_image_properties(self, filename, image_data):
        # Extract dimension information from the image file.
        height = 0
        width = 0
        x_dpi = 96
        y_dpi = 96

        if not image_data:
            # Open the image file and read in the data.
            fh = open(filename, "rb")
            data = fh.read()
        else:
            # Read the image data from the user supplied byte stream.
            data = image_data.getvalue()

        digest = hashlib.sha256(data).hexdigest()

        # Get the image filename without the path.
        image_name = os.path.basename(filename)

        # Look for some common image file markers.
        marker1 = unpack('3s', data[1:4])[0]
        marker2 = unpack('>H', data[:2])[0]
        marker3 = unpack('2s', data[:2])[0]
        marker4 = unpack('<L', data[:4])[0]
        marker5 = (unpack('4s', data[40:44]))[0]
        marker6 = unpack('4s', data[:4])[0]

        png_marker = b'PNG'
        bmp_marker = b'BM'
        emf_marker = b' EMF'
        gif_marker = b'GIF8'

        if marker1 == png_marker:
            self.image_types['png'] = True
            (image_type, width, height, x_dpi, y_dpi) = self._process_png(data)

        elif marker2 == 0xFFD8:
            self.image_types['jpeg'] = True
            (image_type, width, height, x_dpi, y_dpi) = self._process_jpg(data)

        elif marker3 == bmp_marker:
            self.image_types['bmp'] = True
            (image_type, width, height) = self._process_bmp(data)

        elif marker4 == 0x9AC6CDD7:
            self.image_types['wmf'] = True
            (image_type, width, height, x_dpi, y_dpi) = self._process_wmf(data)

        elif marker4 == 1 and marker5 == emf_marker:
            self.image_types['emf'] = True
            (image_type, width, height, x_dpi, y_dpi) = self._process_emf(data)

        elif marker6 == gif_marker:
            self.image_types['gif'] = True
            (image_type, width, height, x_dpi, y_dpi) = self._process_gif(data)

        else:
            raise UnsupportedImageFormat(
                "%s: Unknown or unsupported image file format." % filename)

        # Check that we found the required data.
        if not height or not width:
            raise UndefinedImageSize(
                "%s: no size data found in image file." % filename)

        if not image_data:
            fh.close()

        # Set a default dpi for images with 0 dpi.
        if x_dpi == 0:
            x_dpi = 96
        if y_dpi == 0:
            y_dpi = 96

        return image_type, width, height, image_name, x_dpi, y_dpi, digest

    def _process_png(self, data):
        # Extract width and height information from a PNG file.
        offset = 8
        data_length = len(data)
        end_marker = False
        width = 0
        height = 0
        x_dpi = 96
        y_dpi = 96

        # Look for numbers rather than strings for Python 2.6/3 compatibility.
        marker_ihdr = 0x49484452  # IHDR
        marker_phys = 0x70485973  # pHYs
        marker_iend = 0x49454E44  # IEND

        # Search through the image data to read the height and width in the
        # IHDR element. Also read the DPI in the pHYs element.
        while not end_marker and offset < data_length:

            length = unpack('>I', data[offset + 0:offset + 4])[0]
            marker = unpack('>I', data[offset + 4:offset + 8])[0]

            # Read the image dimensions.
            if marker == marker_ihdr:
                width = unpack('>I', data[offset + 8:offset + 12])[0]
                height = unpack('>I', data[offset + 12:offset + 16])[0]

            # Read the image DPI.
            if marker == marker_phys:
                x_density = unpack('>I', data[offset + 8:offset + 12])[0]
                y_density = unpack('>I', data[offset + 12:offset + 16])[0]
                units = unpack('b', data[offset + 16:offset + 17])[0]

                if units == 1:
                    x_dpi = x_density * 0.0254
                    y_dpi = y_density * 0.0254

            if marker == marker_iend:
                end_marker = True
                continue

            offset = offset + length + 12

        return 'png', width, height, x_dpi, y_dpi

    def _process_jpg(self, data):
        # Extract width and height information from a JPEG file.
        offset = 2
        data_length = len(data)
        end_marker = False
        width = 0
        height = 0
        x_dpi = 96
        y_dpi = 96

        # Search through the image data to read the JPEG markers.
        while not end_marker and offset < data_length:

            marker = unpack('>H', data[offset + 0:offset + 2])[0]
            length = unpack('>H', data[offset + 2:offset + 4])[0]

            # Read the height and width in the 0xFFCn elements (except C4, C8
            # and CC which aren't SOF markers).
            if ((marker & 0xFFF0) == 0xFFC0
                    and marker != 0xFFC4
                    and marker != 0xFFC8
                    and marker != 0xFFCC):
                height = unpack('>H', data[offset + 5:offset + 7])[0]
                width = unpack('>H', data[offset + 7:offset + 9])[0]

            # Read the DPI in the 0xFFE0 element.
            if marker == 0xFFE0:
                units = unpack('b', data[offset + 11:offset + 12])[0]
                x_density = unpack('>H', data[offset + 12:offset + 14])[0]
                y_density = unpack('>H', data[offset + 14:offset + 16])[0]

                if units == 1:
                    x_dpi = x_density
                    y_dpi = y_density

                if units == 2:
                    x_dpi = x_density * 2.54
                    y_dpi = y_density * 2.54

                # Workaround for incorrect dpi.
                if x_dpi == 1:
                    x_dpi = 96
                if y_dpi == 1:
                    y_dpi = 96

            if marker == 0xFFDA:
                end_marker = True
                continue

            offset = offset + length + 2

        return 'jpeg', width, height, x_dpi, y_dpi

    def _process_gif(self, data):
        # Extract width and height information from a GIF file.
        x_dpi = 96
        y_dpi = 96

        width = unpack('<h', data[6:8])[0]
        height = unpack('<h', data[8:10])[0]

        return 'gif', width, height, x_dpi, y_dpi

    def _process_bmp(self, data):
        # Extract width and height information from a BMP file.
        width = unpack('<L', data[18:22])[0]
        height = unpack('<L', data[22:26])[0]
        return 'bmp', width, height

    def _process_wmf(self, data):
        # Extract width and height information from a WMF file.
        x_dpi = 96
        y_dpi = 96

        # Read the bounding box, measured in logical units.
        x1 = unpack("<h", data[6:8])[0]
        y1 = unpack("<h", data[8:10])[0]
        x2 = unpack("<h", data[10:12])[0]
        y2 = unpack("<h", data[12:14])[0]

        # Read the number of logical units per inch. Used to scale the image.
        inch = unpack("<H", data[14:16])[0]

        # Convert to rendered height and width.
        width = float((x2 - x1) * x_dpi) / inch
        height = float((y2 - y1) * y_dpi) / inch

        return 'wmf', width, height, x_dpi, y_dpi

    def _process_emf(self, data):
        # Extract width and height information from a EMF file.

        # Read the bounding box, measured in logical units.
        bound_x1 = unpack("<l", data[8:12])[0]
        bound_y1 = unpack("<l", data[12:16])[0]
        bound_x2 = unpack("<l", data[16:20])[0]
        bound_y2 = unpack("<l", data[20:24])[0]

        # Convert the bounds to width and height.
        width = bound_x2 - bound_x1
        height = bound_y2 - bound_y1

        # Read the rectangular frame in units of 0.01mm.
        frame_x1 = unpack("<l", data[24:28])[0]
        frame_y1 = unpack("<l", data[28:32])[0]
        frame_x2 = unpack("<l", data[32:36])[0]
        frame_y2 = unpack("<l", data[36:40])[0]

        # Convert the frame bounds to mm width and height.
        width_mm = 0.01 * (frame_x2 - frame_x1)
        height_mm = 0.01 * (frame_y2 - frame_y1)

        # Get the dpi based on the logical size.
        x_dpi = width * 25.4 / width_mm
        y_dpi = height * 25.4 / height_mm

        # This is to match Excel's calculation. It is probably to account for
        # the fact that the bounding box is inclusive-inclusive. Or a bug.
        width += 1
        height += 1

        return 'emf', width, height, x_dpi, y_dpi

    def _extract_named_ranges(self, defined_names):
        # Extract the named ranges from the sorted list of defined names.
        # These are used in the App.xml file.
        named_ranges = []

        for defined_name in defined_names:

            name = defined_name[0]
            index = defined_name[1]
            sheet_range = defined_name[2]

            # Skip autoFilter ranges.
            if name == '_xlnm._FilterDatabase':
                continue

            # We are only interested in defined names with ranges.
            if '!' in sheet_range:
                sheet_name, _ = sheet_range.split('!', 1)

                # Match Print_Area and Print_Titles xlnm types.
                if name.startswith('_xlnm.'):
                    xlnm_type = name.replace('_xlnm.', '')
                    name = sheet_name + '!' + xlnm_type
                elif index != -1:
                    name = sheet_name + '!' + name

                named_ranges.append(name)

        return named_ranges

    def _get_sheet_index(self, sheetname):
        # Convert a sheet name to its index. Return None otherwise.
        sheetname = sheetname.strip("'")

        if sheetname in self.sheetnames:
            return self.sheetnames[sheetname].index
        else:
            return None

    def _prepare_vml(self):
        # Iterate through the worksheets and set up the VML objects.
        comment_id = 0
        vml_drawing_id = 0
        vml_data_id = 1
        vml_header_id = 0
        vml_shape_id = 1024
        vml_files = 0
        comment_files = 0

        for sheet in self.worksheets():
            if not sheet.has_vml and not sheet.has_header_vml:
                continue

            vml_files += 1

            if sheet.has_vml:
                if sheet.has_comments:
                    comment_files += 1
                    comment_id += 1
                    self.has_comments = True

                vml_drawing_id += 1

                count = sheet._prepare_vml_objects(vml_data_id,
                                                   vml_shape_id,
                                                   vml_drawing_id,
                                                   comment_id)

                # Each VML should start with a shape id incremented by 1024.
                vml_data_id += 1 * int((1024 + count) / 1024)
                vml_shape_id += 1024 * int((1024 + count) / 1024)

            if sheet.has_header_vml:
                vml_header_id += 1
                vml_drawing_id += 1
                sheet._prepare_header_vml_objects(vml_header_id,
                                                  vml_drawing_id)

            self.num_vml_files = vml_files
            self.num_comment_files = comment_files

    def _prepare_tables(self):
        # Set the table ids for the worksheet tables.
        table_id = 0
        seen = {}

        for sheet in self.worksheets():
            table_count = len(sheet.tables)

            if not table_count:
                continue

            sheet._prepare_tables(table_id + 1, seen)
            table_id += table_count

    def _prepare_metadata(self):
        # Set the metadata rel link.
        for sheet in self.worksheets():
            if sheet.has_dynamic_arrays:
                self.has_metadata = True

    def _add_chart_data(self):
        # Add "cached" data to charts to provide the numCache and strCache
        # data for series and title/axis ranges.
        worksheets = {}
        seen_ranges = {}
        charts = []

        # Map worksheet names to worksheet objects.
        for worksheet in self.worksheets():
            worksheets[worksheet.name] = worksheet

        # Build a list of the worksheet charts including any combined charts.
        for chart in self.charts:
            charts.append(chart)
            if chart.combined:
                charts.append(chart.combined)

        for chart in charts:

            for c_range in chart.formula_ids.keys():
                r_id = chart.formula_ids[c_range]

                # Skip if the series has user defined data.
                if chart.formula_data[r_id] is not None:
                    if (c_range not in seen_ranges
                            or seen_ranges[c_range] is None):
                        data = chart.formula_data[r_id]
                        seen_ranges[c_range] = data
                    continue

                # Check to see if the data is already cached locally.
                if c_range in seen_ranges:
                    chart.formula_data[r_id] = seen_ranges[c_range]
                    continue

                # Convert the range formula to a sheet name and cell range.
                (sheetname, cells) = self._get_chart_range(c_range)

                # Skip if we couldn't parse the formula.
                if sheetname is None:
                    continue

                # Handle non-contiguous ranges like:
                #     (Sheet1!$A$1:$A$2,Sheet1!$A$4:$A$5).
                # We don't try to parse them. We just return an empty list.
                if sheetname.startswith('('):
                    chart.formula_data[r_id] = []
                    seen_ranges[c_range] = []
                    continue

                # Warn if the name is unknown since it indicates a user error
                # in a chart series formula.
                if sheetname not in worksheets:
                    warn("Unknown worksheet reference '%s' in range "
                         "'%s' passed to add_series()"
                         % (force_unicode(sheetname), force_unicode(c_range)))
                    chart.formula_data[r_id] = []
                    seen_ranges[c_range] = []
                    continue

                # Find the worksheet object based on the sheet name.
                worksheet = worksheets[sheetname]

                # Get the data from the worksheet table.
                data = worksheet._get_range_data(*cells)

                # TODO. Handle SST string ids if required.

                # Add the data to the chart.
                chart.formula_data[r_id] = data

                # Store range data locally to avoid lookup if seen again.
                seen_ranges[c_range] = data

    def _get_chart_range(self, c_range):
        # Convert a range formula such as Sheet1!$B$1:$B$5 into a sheet name
        # and cell range such as ( 'Sheet1', 0, 1, 4, 1 ).

        # Split the range formula into sheetname and cells at the last '!'.
        pos = c_range.rfind('!')
        if pos > 0:
            sheetname = c_range[:pos]
            cells = c_range[pos + 1:]
        else:
            return None, None

        # Split the cell range into 2 cells or else use single cell for both.
        if cells.find(':') > 0:
            (cell_1, cell_2) = cells.split(':', 1)
        else:
            (cell_1, cell_2) = (cells, cells)

        # Remove leading/trailing quotes and convert escaped quotes to single.
        sheetname = sheetname.strip("'")
        sheetname = sheetname.replace("''", "'")

        try:
            # Get the row, col values from the Excel ranges. We do this in a
            # try block for ranges that can't be parsed such as defined names.
            (row_start, col_start) = xl_cell_to_rowcol(cell_1)
            (row_end, col_end) = xl_cell_to_rowcol(cell_2)
        except AttributeError:
            return None, None

        # We only handle 1D ranges.
        if row_start != row_end and col_start != col_end:
            return None, None

        return sheetname, [row_start, col_start, row_end, col_end]

    def _prepare_sst_string_data(self):
        # Convert the SST string data from a dict to a list.
        self.str_table._sort_string_data()

    def _get_packager(self):
        # Get and instance of the Packager class to create the xlsx package.
        # This allows the default packager to be over-ridden.
        return Packager()

    ###########################################################################
    #
    # XML methods.
    #
    ###########################################################################

    def _write_workbook(self):
        # Write <workbook> element.

        schema = 'http://schemas.openxmlformats.org'
        xmlns = schema + '/spreadsheetml/2006/main'
        xmlns_r = schema + '/officeDocument/2006/relationships'

        attributes = [
            ('xmlns', xmlns),
            ('xmlns:r', xmlns_r),
        ]

        self._xml_start_tag('workbook', attributes)

    def _write_file_version(self):
        # Write the <fileVersion> element.

        app_name = 'xl'
        last_edited = 4
        lowest_edited = 4
        rup_build = 4505

        attributes = [
            ('appName', app_name),
            ('lastEdited', last_edited),
            ('lowestEdited', lowest_edited),
            ('rupBuild', rup_build),
        ]

        if self.vba_project:
            attributes.append(
                ('codeName', '{37E998C4-C9E5-D4B9-71C8-EB1FF731991C}'))

        self._xml_empty_tag('fileVersion', attributes)

    def _write_file_sharing(self):
        # Write the <fileSharing> element.
        if self.read_only == 0:
            return

        attributes = [('readOnlyRecommended', 1)]

        self._xml_empty_tag('fileSharing', attributes)

    def _write_workbook_pr(self):
        # Write <workbookPr> element.
        default_theme_version = 124226
        attributes = []

        if self.vba_codename:
            attributes.append(('codeName', self.vba_codename))
        if self.date_1904:
            attributes.append(('date1904', 1))

        attributes.append(('defaultThemeVersion', default_theme_version))

        self._xml_empty_tag('workbookPr', attributes)

    def _write_book_views(self):
        # Write <bookViews> element.
        self._xml_start_tag('bookViews')
        self._write_workbook_view()
        self._xml_end_tag('bookViews')

    def _write_workbook_view(self):
        # Write <workbookView> element.
        attributes = [
            ('xWindow', self.x_window),
            ('yWindow', self.y_window),
            ('windowWidth', self.window_width),
            ('windowHeight', self.window_height),
        ]

        # Store the tabRatio attribute when it isn't the default.
        if self.tab_ratio != 600:
            attributes.append(('tabRatio', self.tab_ratio))

        # Store the firstSheet attribute when it isn't the default.
        if self.worksheet_meta.firstsheet > 0:
            firstsheet = self.worksheet_meta.firstsheet + 1
            attributes.append(('firstSheet', firstsheet))

        # Store the activeTab attribute when it isn't the first sheet.
        if self.worksheet_meta.activesheet > 0:
            attributes.append(('activeTab', self.worksheet_meta.activesheet))

        self._xml_empty_tag('workbookView', attributes)

    def _write_sheets(self):
        # Write <sheets> element.
        self._xml_start_tag('sheets')

        id_num = 1
        for worksheet in self.worksheets():
            self._write_sheet(worksheet.name, id_num, worksheet.hidden)
            id_num += 1

        self._xml_end_tag('sheets')

    def _write_sheet(self, name, sheet_id, hidden):
        # Write <sheet> element.
        attributes = [
            ('name', name),
            ('sheetId', sheet_id),
        ]

        if hidden:
            attributes.append(('state', 'hidden'))

        attributes.append(('r:id', 'rId' + str(sheet_id)))

        self._xml_empty_tag('sheet', attributes)

    def _write_calc_pr(self):
        # Write the <calcPr> element.
        attributes = [('calcId', self.calc_id)]

        if self.calc_mode == 'manual':
            attributes.append(('calcMode', self.calc_mode))
            attributes.append(('calcOnSave', "0"))
        elif self.calc_mode == 'autoNoTable':
            attributes.append(('calcMode', self.calc_mode))

        if self.calc_on_load:
            attributes.append(('fullCalcOnLoad', '1'))

        self._xml_empty_tag('calcPr', attributes)

    def _write_defined_names(self):
        # Write the <definedNames> element.
        if not self.defined_names:
            return

        self._xml_start_tag('definedNames')

        for defined_name in self.defined_names:
            self._write_defined_name(defined_name)

        self._xml_end_tag('definedNames')

    def _write_defined_name(self, defined_name):
        # Write the <definedName> element.
        name = defined_name[0]
        sheet_id = defined_name[1]
        sheet_range = defined_name[2]
        hidden = defined_name[3]

        attributes = [('name', name)]

        if sheet_id != -1:
            attributes.append(('localSheetId', sheet_id))
        if hidden:
            attributes.append(('hidden', 1))

        self._xml_data_element('definedName', sheet_range, attributes)


# A metadata class to share data between worksheets.
class WorksheetMeta(object):
    """
    A class to track worksheets data such as the active sheet and the
    first sheet.

    """

    def __init__(self):
        self.activesheet = 0
        self.firstsheet = 0

```

---

### File: `tmp\xlsxwriter_old\XlsxWriter-1.4.5\xlsxwriter\worksheet.py`

```python
###############################################################################
#
# Worksheet - A class for writing the Excel XLSX Worksheet file.
#
# Copyright 2013-2021, John McNamara, jmcnamara@cpan.org
#

# Standard packages.
import codecs
import datetime
import os
import re
import sys
import tempfile

from collections import defaultdict
from collections import namedtuple
from math import isnan
from math import isinf
from warnings import warn

# Standard packages in Python 2/3 compatibility mode.
from .compatibility import StringIO
from .compatibility import force_unicode
from .compatibility import num_types, str_types

# Package imports.
from . import xmlwriter
from .format import Format
from .drawing import Drawing
from .shape import Shape
from .xmlwriter import XMLwriter
from .utility import xl_rowcol_to_cell
from .utility import xl_rowcol_to_cell_fast
from .utility import xl_cell_to_rowcol
from .utility import xl_col_to_name
from .utility import xl_range
from .utility import xl_color
from .utility import get_sparkline_style
from .utility import supported_datetime
from .utility import datetime_to_excel_datetime
from .utility import preserve_whitespace
from .utility import quote_sheetname
from .exceptions import DuplicateTableName

# Compile performance critical regular expressions.
re_control_chars_1 = re.compile('(_x[0-9a-fA-F]{4}_)')
re_control_chars_2 = re.compile(r'([\x00-\x08\x0b-\x1f])')

re_dynamic_function = re.compile(r"""
    \bSORT\(       |
    \bLET\(        |
    \bLAMBDA\(     |
    \bSINGLE\(     |
    \bSORTBY\(     |
    \bUNIQUE\(     |
    \bXMATCH\(     |
    \bFILTER\(     |
    \bXLOOKUP\(    |
    \bSEQUENCE\(   |
    \bRANDARRAY\(  |
    \bANCHORARRAY\(""", re.VERBOSE)


###############################################################################
#
# Decorator functions.
#
###############################################################################
def convert_cell_args(method):
    """
    Decorator function to convert A1 notation in cell method calls
    to the default row/col notation.

    """
    def cell_wrapper(self, *args, **kwargs):

        try:
            # First arg is an int, default to row/col notation.
            if len(args):
                first_arg = args[0]
                int(first_arg)
        except ValueError:
            # First arg isn't an int, convert to A1 notation.
            new_args = xl_cell_to_rowcol(first_arg)
            args = new_args + args[1:]

        return method(self, *args, **kwargs)

    return cell_wrapper


def convert_range_args(method):
    """
    Decorator function to convert A1 notation in range method calls
    to the default row/col notation.

    """
    def cell_wrapper(self, *args, **kwargs):

        try:
            # First arg is an int, default to row/col notation.
            if len(args):
                int(args[0])
        except ValueError:
            # First arg isn't an int, convert to A1 notation.
            if ':' in args[0]:
                cell_1, cell_2 = args[0].split(':')
                row_1, col_1 = xl_cell_to_rowcol(cell_1)
                row_2, col_2 = xl_cell_to_rowcol(cell_2)
            else:
                row_1, col_1 = xl_cell_to_rowcol(args[0])
                row_2, col_2 = row_1, col_1

            new_args = [row_1, col_1, row_2, col_2]
            new_args.extend(args[1:])
            args = new_args

        return method(self, *args, **kwargs)

    return cell_wrapper


def convert_column_args(method):
    """
    Decorator function to convert A1 notation in columns method calls
    to the default row/col notation.

    """
    def column_wrapper(self, *args, **kwargs):

        try:
            # First arg is an int, default to row/col notation.
            if len(args):
                int(args[0])
        except ValueError:
            # First arg isn't an int, convert to A1 notation.
            cell_1, cell_2 = [col + '1' for col in args[0].split(':')]
            _, col_1 = xl_cell_to_rowcol(cell_1)
            _, col_2 = xl_cell_to_rowcol(cell_2)
            new_args = [col_1, col_2]
            new_args.extend(args[1:])
            args = new_args

        return method(self, *args, **kwargs)

    return column_wrapper


###############################################################################
#
# Named tuples used for cell types.
#
###############################################################################
cell_string_tuple = namedtuple('String', 'string, format')
cell_number_tuple = namedtuple('Number', 'number, format')
cell_blank_tuple = namedtuple('Blank', 'format')
cell_boolean_tuple = namedtuple('Boolean', 'boolean, format')
cell_formula_tuple = namedtuple('Formula', 'formula, format, value')
cell_arformula_tuple = namedtuple('ArrayFormula',
                                  'formula, format, value, range, atype')


###############################################################################
#
# Worksheet Class definition.
#
###############################################################################
class Worksheet(xmlwriter.XMLwriter):
    """
    A class for writing the Excel XLSX Worksheet file.

    """

    ###########################################################################
    #
    # Public API.
    #
    ###########################################################################

    def __init__(self):
        """
        Constructor.

        """

        super(Worksheet, self).__init__()

        self.name = None
        self.index = None
        self.str_table = None
        self.palette = None
        self.constant_memory = 0
        self.tmpdir = None
        self.is_chartsheet = False

        self.ext_sheets = []
        self.fileclosed = 0
        self.excel_version = 2007
        self.excel2003_style = False

        self.xls_rowmax = 1048576
        self.xls_colmax = 16384
        self.xls_strmax = 32767
        self.dim_rowmin = None
        self.dim_rowmax = None
        self.dim_colmin = None
        self.dim_colmax = None

        self.colinfo = {}
        self.selections = []
        self.hidden = 0
        self.active = 0
        self.tab_color = 0

        self.panes = []
        self.active_pane = 3
        self.selected = 0

        self.page_setup_changed = False
        self.paper_size = 0
        self.orientation = 1

        self.print_options_changed = False
        self.hcenter = False
        self.vcenter = False
        self.print_gridlines = False
        self.screen_gridlines = True
        self.print_headers = False
        self.row_col_headers = False

        self.header_footer_changed = False
        self.header = ''
        self.footer = ''
        self.header_footer_aligns = True
        self.header_footer_scales = True
        self.header_images = []
        self.footer_images = []
        self.header_images_list = []

        self.margin_left = 0.7
        self.margin_right = 0.7
        self.margin_top = 0.75
        self.margin_bottom = 0.75
        self.margin_header = 0.3
        self.margin_footer = 0.3

        self.repeat_row_range = ''
        self.repeat_col_range = ''
        self.print_area_range = ''

        self.page_order = 0
        self.black_white = 0
        self.draft_quality = 0
        self.print_comments = 0
        self.page_start = 0

        self.fit_page = 0
        self.fit_width = 0
        self.fit_height = 0

        self.hbreaks = []
        self.vbreaks = []

        self.protect_options = {}
        self.protected_ranges = []
        self.num_protected_ranges = 0
        self.set_cols = {}
        self.set_rows = defaultdict(dict)

        self.zoom = 100
        self.zoom_scale_normal = 1
        self.print_scale = 100
        self.is_right_to_left = 0
        self.show_zeros = 1
        self.leading_zeros = 0

        self.outline_row_level = 0
        self.outline_col_level = 0
        self.outline_style = 0
        self.outline_below = 1
        self.outline_right = 1
        self.outline_on = 1
        self.outline_changed = False

        self.original_row_height = 15
        self.default_row_height = 15
        self.default_row_pixels = 20
        self.default_col_width = 8.43
        self.default_col_pixels = 64
        self.default_row_zeroed = 0

        self.names = {}
        self.write_match = []
        self.table = defaultdict(dict)
        self.merge = []
        self.row_spans = {}

        self.has_vml = False
        self.has_header_vml = False
        self.has_comments = False
        self.comments = defaultdict(dict)
        self.comments_list = []
        self.comments_author = ''
        self.comments_visible = 0
        self.vml_shape_id = 1024
        self.buttons_list = []
        self.vml_header_id = 0

        self.autofilter_area = ''
        self.autofilter_ref = None
        self.filter_range = []
        self.filter_on = 0
        self.filter_cols = {}
        self.filter_type = {}

        self.col_sizes = {}
        self.row_sizes = {}
        self.col_formats = {}
        self.col_size_changed = False
        self.row_size_changed = False

        self.last_shape_id = 1
        self.rel_count = 0
        self.hlink_count = 0
        self.hlink_refs = []
        self.external_hyper_links = []
        self.external_drawing_links = []
        self.external_comment_links = []
        self.external_vml_links = []
        self.external_table_links = []
        self.external_background_links = []
        self.drawing_links = []
        self.vml_drawing_links = []
        self.charts = []
        self.images = []
        self.tables = []
        self.sparklines = []
        self.shapes = []
        self.shape_hash = {}
        self.drawing = 0
        self.drawing_rels = {}
        self.drawing_rels_id = 0
        self.vml_drawing_rels = {}
        self.vml_drawing_rels_id = 0
        self.background_image = None
        self.background_bytes = False

        self.rstring = ''
        self.previous_row = 0

        self.validations = []
        self.cond_formats = {}
        self.data_bars_2010 = []
        self.use_data_bars_2010 = False
        self.dxf_priority = 1
        self.page_view = 0

        self.vba_codename = None

        self.date_1904 = False
        self.hyperlinks = defaultdict(dict)

        self.strings_to_numbers = False
        self.strings_to_urls = True
        self.nan_inf_to_errors = False
        self.strings_to_formulas = True

        self.default_date_format = None
        self.default_url_format = None
        self.remove_timezone = False
        self.max_url_length = 2079

        self.row_data_filename = None
        self.row_data_fh = None
        self.worksheet_meta = None
        self.vml_data_id = None
        self.vml_shape_id = None

        self.row_data_filename = None
        self.row_data_fh = None
        self.row_data_fh_closed = False

        self.vertical_dpi = 0
        self.horizontal_dpi = 0

        self.write_handlers = {}

        self.ignored_errors = None

        self.has_dynamic_arrays = False
        self.use_future_functions = False

    # Utility function for writing different types of strings.
    def _write_token_as_string(self, token, row, col, *args):
        # Map the data to the appropriate write_*() method.
        if token == '':
            return self._write_blank(row, col, *args)

        if self.strings_to_formulas and token.startswith('='):
            return self._write_formula(row, col, *args)

        if token.startswith('{=') and token.endswith('}'):
            return self._write_formula(row, col, *args)

        if ':' in token:
            if self.strings_to_urls and re.match('(ftp|http)s?://', token):
                return self._write_url(row, col, *args)
            elif self.strings_to_urls and re.match('mailto:', token):
                return self._write_url(row, col, *args)
            elif self.strings_to_urls and re.match('(in|ex)ternal:', token):
                return self._write_url(row, col, *args)

        if self.strings_to_numbers:
            try:
                f = float(token)
                if (self.nan_inf_to_errors or
                        (not isnan(f) and not isinf(f))):
                    return self._write_number(row, col, f, *args[1:])
            except ValueError:
                # Not a number, write as a string.
                pass

            return self._write_string(row, col, *args)

        else:
            # We have a plain string.
            return self._write_string(row, col, *args)

    @convert_cell_args
    def write(self, row, col, *args):
        """
        Write data to a worksheet cell by calling the appropriate write_*()
        method based on the type of data being passed.

        Args:
            row:   The cell row (zero indexed).
            col:   The cell column (zero indexed).
            *args: Args to pass to sub functions.

        Returns:
             0:    Success.
            -1:    Row or column is out of worksheet bounds.
            other: Return value of called method.

        """
        return self._write(row, col, *args)

    # Undecorated version of write().
    def _write(self, row, col, *args):
        # Check the number of args passed.
        if not len(args):
            raise TypeError("write() takes at least 4 arguments (3 given)")

        # The first arg should be the token for all write calls.
        token = args[0]

        # Avoid isinstance() for better performance.
        token_type = type(token)

        # Check for any user defined type handlers with callback functions.
        if token_type in self.write_handlers:
            write_handler = self.write_handlers[token_type]
            function_return = write_handler(self, row, col, *args)

            # If the return value is None then the callback has returned
            # control to this function and we should continue as
            # normal. Otherwise we return the value to the caller and exit.
            if function_return is None:
                pass
            else:
                return function_return

        # Write None as a blank cell.
        if token is None:
            return self._write_blank(row, col, *args)

        # Check for standard Python types.
        if token_type is bool:
            return self._write_boolean(row, col, *args)

        if token_type in num_types:
            return self._write_number(row, col, *args)

        if token_type is str:
            return self._write_token_as_string(token, row, col, *args)

        if token_type in (datetime.datetime,
                          datetime.date,
                          datetime.time,
                          datetime.timedelta):
            return self._write_datetime(row, col, *args)

        if sys.version_info < (3, 0, 0):
            if token_type is unicode:
                try:
                    return self._write_token_as_string(str(token),
                                                       row, col, *args)
                except (UnicodeEncodeError, NameError):
                    pass

        # Resort to isinstance() for subclassed primitives.

        # Write number types.
        if isinstance(token, num_types):
            return self._write_number(row, col, *args)

        # Write string types.
        if isinstance(token, str_types):
            return self._write_token_as_string(token, row, col, *args)

        # Write boolean types.
        if isinstance(token, bool):
            return self._write_boolean(row, col, *args)

        # Write datetime objects.
        if supported_datetime(token):
            return self._write_datetime(row, col, *args)

        # We haven't matched a supported type. Try float.
        try:
            f = float(token)
            return self._write_number(row, col, f, *args[1:])
        except ValueError:
            pass
        except TypeError:
            raise TypeError("Unsupported type %s in write()" % type(token))

        # Finally try string.
        try:
            str(token)
            return self._write_string(row, col, *args)
        except ValueError:
            raise TypeError("Unsupported type %s in write()" % type(token))

    @convert_cell_args
    def write_string(self, row, col, string, cell_format=None):
        """
        Write a string to a worksheet cell.

        Args:
            row:    The cell row (zero indexed).
            col:    The cell column (zero indexed).
            string: Cell data. Str.
            format: An optional cell Format object.

        Returns:
            0:  Success.
            -1: Row or column is out of worksheet bounds.
            -2: String truncated to 32k characters.

        """
        return self._write_string(row, col, string, cell_format)

    # Undecorated version of write_string().
    def _write_string(self, row, col, string, cell_format=None):

        str_error = 0

        # Check that row and col are valid and store max and min values.
        if self._check_dimensions(row, col):
            return -1

        # Check that the string is < 32767 chars.
        if len(string) > self.xls_strmax:
            string = string[:self.xls_strmax]
            str_error = -2

        # Write a shared string or an in-line string in constant_memory mode.
        if not self.constant_memory:
            string_index = self.str_table._get_shared_string_index(string)
        else:
            string_index = string

        # Write previous row if in in-line string constant_memory mode.
        if self.constant_memory and row > self.previous_row:
            self._write_single_row(row)

        # Store the cell data in the worksheet data table.
        self.table[row][col] = cell_string_tuple(string_index, cell_format)

        return str_error

    @convert_cell_args
    def write_number(self, row, col, number, cell_format=None):
        """
        Write a number to a worksheet cell.

        Args:
            row:         The cell row (zero indexed).
            col:         The cell column (zero indexed).
            number:      Cell data. Int or float.
            cell_format: An optional cell Format object.

        Returns:
            0:  Success.
            -1: Row or column is out of worksheet bounds.

        """
        return self._write_number(row, col, number, cell_format)

    # Undecorated version of write_number().
    def _write_number(self, row, col, number, cell_format=None):

        if isnan(number) or isinf(number):
            if self.nan_inf_to_errors:
                if isnan(number):
                    return self._write_formula(row, col, '#NUM!', cell_format,
                                               '#NUM!')
                elif isinf(number):
                    return self._write_formula(row, col, '1/0', cell_format,
                                               '#DIV/0!')
            else:
                raise TypeError(
                    "NAN/INF not supported in write_number() "
                    "without 'nan_inf_to_errors' Workbook() option")

        # Check that row and col are valid and store max and min values.
        if self._check_dimensions(row, col):
            return -1

        # Write previous row if in in-line string constant_memory mode.
        if self.constant_memory and row > self.previous_row:
            self._write_single_row(row)

        # Store the cell data in the worksheet data table.
        self.table[row][col] = cell_number_tuple(number, cell_format)

        return 0

    @convert_cell_args
    def write_blank(self, row, col, blank, cell_format=None):
        """
        Write a blank cell with formatting to a worksheet cell. The blank
        token is ignored and the format only is written to the cell.

        Args:
            row:         The cell row (zero indexed).
            col:         The cell column (zero indexed).
            blank:       Any value. It is ignored.
            cell_format: An optional cell Format object.

        Returns:
            0:  Success.
            -1: Row or column is out of worksheet bounds.

        """
        return self._write_blank(row, col, blank, cell_format)

    # Undecorated version of write_blank().
    def _write_blank(self, row, col, blank, cell_format=None):
        # Don't write a blank cell unless it has a format.
        if cell_format is None:
            return 0

        # Check that row and col are valid and store max and min values.
        if self._check_dimensions(row, col):
            return -1

        # Write previous row if in in-line string constant_memory mode.
        if self.constant_memory and row > self.previous_row:
            self._write_single_row(row)

        # Store the cell data in the worksheet data table.
        self.table[row][col] = cell_blank_tuple(cell_format)

        return 0

    @convert_cell_args
    def write_formula(self, row, col, formula, cell_format=None, value=0):
        """
        Write a formula to a worksheet cell.

        Args:
            row:         The cell row (zero indexed).
            col:         The cell column (zero indexed).
            formula:     Cell formula.
            cell_format: An optional cell Format object.
            value:       An optional value for the formula. Default is 0.

        Returns:
            0:  Success.
            -1: Row or column is out of worksheet bounds.
            -2: Formula can't be None or empty.

        """
        # Check that row and col are valid and store max and min values.
        return self._write_formula(row, col, formula, cell_format, value)

    # Undecorated version of write_formula().
    def _write_formula(self, row, col, formula, cell_format=None, value=0):
        if self._check_dimensions(row, col):
            return -1

        if formula is None or formula == '':
            warn("Formula can't be None or empty")
            return -1

        # Check for dynamic array functions.
        if (re_dynamic_function.search(formula)):
            return self.write_dynamic_array_formula(row, col, row, col,
                                                    formula, cell_format,
                                                    value)

        # Hand off array formulas.
        if formula.startswith('{') and formula.endswith('}'):
            return self._write_array_formula(row, col, row, col, formula,
                                             cell_format, value)

        # Modify the formula string, as needed.
        formula = self._prepare_formula(formula)

        # Write previous row if in in-line string constant_memory mode.
        if self.constant_memory and row > self.previous_row:
            self._write_single_row(row)

        # Store the cell data in the worksheet data table.
        self.table[row][col] = cell_formula_tuple(formula, cell_format, value)

        return 0

    @convert_range_args
    def write_array_formula(self, first_row, first_col, last_row, last_col,
                            formula, cell_format=None, value=0):
        """
        Write a formula to a worksheet cell/range.

        Args:
            first_row:    The first row of the cell range. (zero indexed).
            first_col:    The first column of the cell range.
            last_row:     The last row of the cell range. (zero indexed).
            last_col:     The last column of the cell range.
            formula:      Cell formula.
            cell_format:  An optional cell Format object.
            value:        An optional value for the formula. Default is 0.

        Returns:
            0:  Success.
            -1: Row or column is out of worksheet bounds.

        """
        # Check for dynamic array functions.
        if (re_dynamic_function.search(formula)):
            return self.write_dynamic_array_formula(first_row, first_col,
                                                    last_row, last_col,
                                                    formula, cell_format,
                                                    value)

        return self._write_array_formula(first_row, first_col, last_row,
                                         last_col, formula, cell_format,
                                         value, 'static')

    @convert_range_args
    def write_dynamic_array_formula(self, first_row, first_col,
                                    last_row, last_col,
                                    formula, cell_format=None, value=0):
        """
        Write a dynamic array formula to a worksheet cell/range.

        Args:
            first_row:    The first row of the cell range. (zero indexed).
            first_col:    The first column of the cell range.
            last_row:     The last row of the cell range. (zero indexed).
            last_col:     The last column of the cell range.
            formula:      Cell formula.
            cell_format:  An optional cell Format object.
            value:        An optional value for the formula. Default is 0.

        Returns:
            0:  Success.
            -1: Row or column is out of worksheet bounds.

        """
        error = self._write_array_formula(first_row, first_col, last_row,
                                          last_col, formula, cell_format,
                                          value, 'dynamic')

        if error == 0:
            self.has_dynamic_arrays = True

        return error

    # Utility method to strip equal sign and array braces from a formula and
    # also expand out future and dynamic array formulas.
    def _prepare_formula(self, formula):

        # Remove array formula braces and the leading =.
        if formula.startswith('{'):
            formula = formula[1:]
        if formula.startswith('='):
            formula = formula[1:]
        if formula.endswith('}'):
            formula = formula[:-1]

        # Check if formula is already expanded by the user.
        if '_xlfn.' in formula:
            return formula

        # Expand dynamic formulas.
        formula = re.sub(r'\bLET\(', '_xlfn.LET(', formula)
        formula = re.sub(r'\bLAMBDA\(', '_xlfn.LAMBDA(', formula)
        formula = re.sub(r'\bSINGLE\(', '_xlfn.SINGLE(', formula)
        formula = re.sub(r'\bSORTBY\(', '_xlfn.SORTBY(', formula)
        formula = re.sub(r'\bUNIQUE\(', '_xlfn.UNIQUE(', formula)
        formula = re.sub(r'\bXMATCH\(', '_xlfn.XMATCH(', formula)
        formula = re.sub(r'\bSORT\(', '_xlfn._xlws.SORT(', formula)
        formula = re.sub(r'\bXLOOKUP\(', '_xlfn.XLOOKUP(', formula)
        formula = re.sub(r'\bSEQUENCE\(', '_xlfn.SEQUENCE(', formula)
        formula = re.sub(r'\bFILTER\(', '_xlfn._xlws.FILTER(', formula)
        formula = re.sub(r'\bRANDARRAY\(', '_xlfn.RANDARRAY(', formula)
        formula = re.sub(r'\bANCHORARRAY\(', '_xlfn.ANCHORARRAY(', formula)

        if not self.use_future_functions:
            return formula

        formula = re.sub(r'\bCOT\(', '_xlfn.COT(', formula)
        formula = re.sub(r'\bCSC\(', '_xlfn.CSC(', formula)
        formula = re.sub(r'\bIFS\(', '_xlfn.IFS(', formula)
        formula = re.sub(r'\bPHI\(', '_xlfn.PHI(', formula)
        formula = re.sub(r'\bRRI\(', '_xlfn.RRI(', formula)
        formula = re.sub(r'\bSEC\(', '_xlfn.SEC(', formula)
        formula = re.sub(r'\bXOR\(', '_xlfn.XOR(', formula)
        formula = re.sub(r'\bACOT\(', '_xlfn.ACOT(', formula)
        formula = re.sub(r'\bBASE\(', '_xlfn.BASE(', formula)
        formula = re.sub(r'\bCOTH\(', '_xlfn.COTH(', formula)
        formula = re.sub(r'\bCSCH\(', '_xlfn.CSCH(', formula)
        formula = re.sub(r'\bDAYS\(', '_xlfn.DAYS(', formula)
        formula = re.sub(r'\bIFNA\(', '_xlfn.IFNA(', formula)
        formula = re.sub(r'\bSECH\(', '_xlfn.SECH(', formula)
        formula = re.sub(r'\bACOTH\(', '_xlfn.ACOTH(', formula)
        formula = re.sub(r'\bBITOR\(', '_xlfn.BITOR(', formula)
        formula = re.sub(r'\bF.INV\(', '_xlfn.F.INV(', formula)
        formula = re.sub(r'\bGAMMA\(', '_xlfn.GAMMA(', formula)
        formula = re.sub(r'\bGAUSS\(', '_xlfn.GAUSS(', formula)
        formula = re.sub(r'\bIMCOT\(', '_xlfn.IMCOT(', formula)
        formula = re.sub(r'\bIMCSC\(', '_xlfn.IMCSC(', formula)
        formula = re.sub(r'\bIMSEC\(', '_xlfn.IMSEC(', formula)
        formula = re.sub(r'\bIMTAN\(', '_xlfn.IMTAN(', formula)
        formula = re.sub(r'\bMUNIT\(', '_xlfn.MUNIT(', formula)
        formula = re.sub(r'\bSHEET\(', '_xlfn.SHEET(', formula)
        formula = re.sub(r'\bT.INV\(', '_xlfn.T.INV(', formula)
        formula = re.sub(r'\bVAR.P\(', '_xlfn.VAR.P(', formula)
        formula = re.sub(r'\bVAR.S\(', '_xlfn.VAR.S(', formula)
        formula = re.sub(r'\bARABIC\(', '_xlfn.ARABIC(', formula)
        formula = re.sub(r'\bBITAND\(', '_xlfn.BITAND(', formula)
        formula = re.sub(r'\bBITXOR\(', '_xlfn.BITXOR(', formula)
        formula = re.sub(r'\bCONCAT\(', '_xlfn.CONCAT(', formula)
        formula = re.sub(r'\bF.DIST\(', '_xlfn.F.DIST(', formula)
        formula = re.sub(r'\bF.TEST\(', '_xlfn.F.TEST(', formula)
        formula = re.sub(r'\bIMCOSH\(', '_xlfn.IMCOSH(', formula)
        formula = re.sub(r'\bIMCSCH\(', '_xlfn.IMCSCH(', formula)
        formula = re.sub(r'\bIMSECH\(', '_xlfn.IMSECH(', formula)
        formula = re.sub(r'\bIMSINH\(', '_xlfn.IMSINH(', formula)
        formula = re.sub(r'\bMAXIFS\(', '_xlfn.MAXIFS(', formula)
        formula = re.sub(r'\bMINIFS\(', '_xlfn.MINIFS(', formula)
        formula = re.sub(r'\bSHEETS\(', '_xlfn.SHEETS(', formula)
        formula = re.sub(r'\bSKEW.P\(', '_xlfn.SKEW.P(', formula)
        formula = re.sub(r'\bSWITCH\(', '_xlfn.SWITCH(', formula)
        formula = re.sub(r'\bT.DIST\(', '_xlfn.T.DIST(', formula)
        formula = re.sub(r'\bT.TEST\(', '_xlfn.T.TEST(', formula)
        formula = re.sub(r'\bZ.TEST\(', '_xlfn.Z.TEST(', formula)
        formula = re.sub(r'\bCOMBINA\(', '_xlfn.COMBINA(', formula)
        formula = re.sub(r'\bDECIMAL\(', '_xlfn.DECIMAL(', formula)
        formula = re.sub(r'\bRANK.EQ\(', '_xlfn.RANK.EQ(', formula)
        formula = re.sub(r'\bSTDEV.P\(', '_xlfn.STDEV.P(', formula)
        formula = re.sub(r'\bSTDEV.S\(', '_xlfn.STDEV.S(', formula)
        formula = re.sub(r'\bUNICHAR\(', '_xlfn.UNICHAR(', formula)
        formula = re.sub(r'\bUNICODE\(', '_xlfn.UNICODE(', formula)
        formula = re.sub(r'\bBETA.INV\(', '_xlfn.BETA.INV(', formula)
        formula = re.sub(r'\bF.INV.RT\(', '_xlfn.F.INV.RT(', formula)
        formula = re.sub(r'\bNORM.INV\(', '_xlfn.NORM.INV(', formula)
        formula = re.sub(r'\bRANK.AVG\(', '_xlfn.RANK.AVG(', formula)
        formula = re.sub(r'\bT.INV.2T\(', '_xlfn.T.INV.2T(', formula)
        formula = re.sub(r'\bTEXTJOIN\(', '_xlfn.TEXTJOIN(', formula)
        formula = re.sub(r'\bAGGREGATE\(', '_xlfn.AGGREGATE(', formula)
        formula = re.sub(r'\bBETA.DIST\(', '_xlfn.BETA.DIST(', formula)
        formula = re.sub(r'\bBINOM.INV\(', '_xlfn.BINOM.INV(', formula)
        formula = re.sub(r'\bBITLSHIFT\(', '_xlfn.BITLSHIFT(', formula)
        formula = re.sub(r'\bBITRSHIFT\(', '_xlfn.BITRSHIFT(', formula)
        formula = re.sub(r'\bCHISQ.INV\(', '_xlfn.CHISQ.INV(', formula)
        formula = re.sub(r'\bF.DIST.RT\(', '_xlfn.F.DIST.RT(', formula)
        formula = re.sub(r'\bFILTERXML\(', '_xlfn.FILTERXML(', formula)
        formula = re.sub(r'\bGAMMA.INV\(', '_xlfn.GAMMA.INV(', formula)
        formula = re.sub(r'\bISFORMULA\(', '_xlfn.ISFORMULA(', formula)
        formula = re.sub(r'\bMODE.MULT\(', '_xlfn.MODE.MULT(', formula)
        formula = re.sub(r'\bMODE.SNGL\(', '_xlfn.MODE.SNGL(', formula)
        formula = re.sub(r'\bNORM.DIST\(', '_xlfn.NORM.DIST(', formula)
        formula = re.sub(r'\bPDURATION\(', '_xlfn.PDURATION(', formula)
        formula = re.sub(r'\bT.DIST.2T\(', '_xlfn.T.DIST.2T(', formula)
        formula = re.sub(r'\bT.DIST.RT\(', '_xlfn.T.DIST.RT(', formula)
        formula = re.sub(r'\bBINOM.DIST\(', '_xlfn.BINOM.DIST(', formula)
        formula = re.sub(r'\bCHISQ.DIST\(', '_xlfn.CHISQ.DIST(', formula)
        formula = re.sub(r'\bCHISQ.TEST\(', '_xlfn.CHISQ.TEST(', formula)
        formula = re.sub(r'\bEXPON.DIST\(', '_xlfn.EXPON.DIST(', formula)
        formula = re.sub(r'\bFLOOR.MATH\(', '_xlfn.FLOOR.MATH(', formula)
        formula = re.sub(r'\bGAMMA.DIST\(', '_xlfn.GAMMA.DIST(', formula)
        formula = re.sub(r'\bISOWEEKNUM\(', '_xlfn.ISOWEEKNUM(', formula)
        formula = re.sub(r'\bNORM.S.INV\(', '_xlfn.NORM.S.INV(', formula)
        formula = re.sub(r'\bWEBSERVICE\(', '_xlfn.WEBSERVICE(', formula)
        formula = re.sub(r'\bERF.PRECISE\(', '_xlfn.ERF.PRECISE(', formula)
        formula = re.sub(r'\bFORMULATEXT\(', '_xlfn.FORMULATEXT(', formula)
        formula = re.sub(r'\bLOGNORM.INV\(', '_xlfn.LOGNORM.INV(', formula)
        formula = re.sub(r'\bNORM.S.DIST\(', '_xlfn.NORM.S.DIST(', formula)
        formula = re.sub(r'\bNUMBERVALUE\(', '_xlfn.NUMBERVALUE(', formula)
        formula = re.sub(r'\bQUERYSTRING\(', '_xlfn.QUERYSTRING(', formula)
        formula = re.sub(r'\bCEILING.MATH\(', '_xlfn.CEILING.MATH(', formula)
        formula = re.sub(r'\bCHISQ.INV.RT\(', '_xlfn.CHISQ.INV.RT(', formula)
        formula = re.sub(r'\bCONFIDENCE.T\(', '_xlfn.CONFIDENCE.T(', formula)
        formula = re.sub(r'\bCOVARIANCE.P\(', '_xlfn.COVARIANCE.P(', formula)
        formula = re.sub(r'\bCOVARIANCE.S\(', '_xlfn.COVARIANCE.S(', formula)
        formula = re.sub(r'\bERFC.PRECISE\(', '_xlfn.ERFC.PRECISE(', formula)
        formula = re.sub(r'\bFORECAST.ETS\(', '_xlfn.FORECAST.ETS(', formula)
        formula = re.sub(r'\bHYPGEOM.DIST\(', '_xlfn.HYPGEOM.DIST(', formula)
        formula = re.sub(r'\bLOGNORM.DIST\(', '_xlfn.LOGNORM.DIST(', formula)
        formula = re.sub(r'\bPERMUTATIONA\(', '_xlfn.PERMUTATIONA(', formula)
        formula = re.sub(r'\bPOISSON.DIST\(', '_xlfn.POISSON.DIST(', formula)
        formula = re.sub(r'\bQUARTILE.EXC\(', '_xlfn.QUARTILE.EXC(', formula)
        formula = re.sub(r'\bQUARTILE.INC\(', '_xlfn.QUARTILE.INC(', formula)
        formula = re.sub(r'\bWEIBULL.DIST\(', '_xlfn.WEIBULL.DIST(', formula)
        formula = re.sub(r'\bCHISQ.DIST.RT\(', '_xlfn.CHISQ.DIST.RT(', formula)
        formula = re.sub(r'\bFLOOR.PRECISE\(', '_xlfn.FLOOR.PRECISE(', formula)
        formula = re.sub(r'\bNEGBINOM.DIST\(', '_xlfn.NEGBINOM.DIST(', formula)

        formula = re.sub(r'\bPERCENTILE.EXC\(',
                         '_xlfn.PERCENTILE.EXC(', formula)
        formula = re.sub(r'\bPERCENTILE.INC\(',
                         '_xlfn.PERCENTILE.INC(', formula)
        formula = re.sub(r'\bCEILING.PRECISE\(',
                         '_xlfn.CEILING.PRECISE(', formula)
        formula = re.sub(r'\bCONFIDENCE.NORM\(',
                         '_xlfn.CONFIDENCE.NORM(', formula)
        formula = re.sub(r'\bFORECAST.LINEAR\(',
                         '_xlfn.FORECAST.LINEAR(', formula)
        formula = re.sub(r'\bGAMMALN.PRECISE\(',
                         '_xlfn.GAMMALN.PRECISE(', formula)
        formula = re.sub(r'\bPERCENTRANK.EXC\(',
                         '_xlfn.PERCENTRANK.EXC(', formula)
        formula = re.sub(r'\bPERCENTRANK.INC\(',
                         '_xlfn.PERCENTRANK.INC(', formula)
        formula = re.sub(r'\bBINOM.DIST.RANGE\(',
                         '_xlfn.BINOM.DIST.RANGE(', formula)
        formula = re.sub(r'\bFORECAST.ETS.STAT\(',
                         '_xlfn.FORECAST.ETS.STAT(', formula)
        formula = re.sub(r'\bFORECAST.ETS.CONFINT\(',
                         '_xlfn.FORECAST.ETS.CONFINT(', formula)
        formula = re.sub(r'\bFORECAST.ETS.SEASONALITY\(',
                         '_xlfn.FORECAST.ETS.SEASONALITY(', formula)

        return formula

    # Undecorated version of write_array_formula() and
    # write_dynamic_array_formula().
    def _write_array_formula(self, first_row, first_col, last_row, last_col,
                             formula, cell_format=None, value=0,
                             atype='static'):

        # Swap last row/col with first row/col as necessary.
        if first_row > last_row:
            first_row, last_row = last_row, first_row
        if first_col > last_col:
            first_col, last_col = last_col, first_col

        # Check that row and col are valid and store max and min values.
        if self._check_dimensions(first_row, first_col):
            return -1
        if self._check_dimensions(last_row, last_col):
            return -1

        # Define array range
        if first_row == last_row and first_col == last_col:
            cell_range = xl_rowcol_to_cell(first_row, first_col)
        else:
            cell_range = (xl_rowcol_to_cell(first_row, first_col) + ':'
                          + xl_rowcol_to_cell(last_row, last_col))

        # Modify the formula string, as needed.
        formula = self._prepare_formula(formula)

        # Write previous row if in in-line string constant_memory mode.
        if self.constant_memory and first_row > self.previous_row:
            self._write_single_row(first_row)

        # Store the cell data in the worksheet data table.
        self.table[first_row][first_col] = cell_arformula_tuple(formula,
                                                                cell_format,
                                                                value,
                                                                cell_range,
                                                                atype)

        # Pad out the rest of the area with formatted zeroes.
        if not self.constant_memory:
            for row in range(first_row, last_row + 1):
                for col in range(first_col, last_col + 1):
                    if row != first_row or col != first_col:
                        self._write_number(row, col, 0, cell_format)

        return 0

    @convert_cell_args
    def write_datetime(self, row, col, date, cell_format=None):
        """
        Write a date or time to a worksheet cell.

        Args:
            row:         The cell row (zero indexed).
            col:         The cell column (zero indexed).
            date:        Date and/or time as a datetime object.
            cell_format: A cell Format object.

        Returns:
            0:  Success.
            -1: Row or column is out of worksheet bounds.

        """
        return self._write_datetime(row, col, date, cell_format)

    # Undecorated version of write_datetime().
    def _write_datetime(self, row, col, date, cell_format=None):

        # Check that row and col are valid and store max and min values.
        if self._check_dimensions(row, col):
            return -1

        # Write previous row if in in-line string constant_memory mode.
        if self.constant_memory and row > self.previous_row:
            self._write_single_row(row)

        # Convert datetime to an Excel date.
        number = self._convert_date_time(date)

        # Add the default date format.
        if cell_format is None:
            cell_format = self.default_date_format

        # Store the cell data in the worksheet data table.
        self.table[row][col] = cell_number_tuple(number, cell_format)

        return 0

    @convert_cell_args
    def write_boolean(self, row, col, boolean, cell_format=None):
        """
        Write a boolean value to a worksheet cell.

        Args:
            row:         The cell row (zero indexed).
            col:         The cell column (zero indexed).
            boolean:     Cell data. bool type.
            cell_format: An optional cell Format object.

        Returns:
            0:  Success.
            -1: Row or column is out of worksheet bounds.

        """
        return self._write_boolean(row, col, boolean, cell_format)

    # Undecorated version of write_boolean().
    def _write_boolean(self, row, col, boolean, cell_format=None):

        # Check that row and col are valid and store max and min values.
        if self._check_dimensions(row, col):
            return -1

        # Write previous row if in in-line string constant_memory mode.
        if self.constant_memory and row > self.previous_row:
            self._write_single_row(row)

        if boolean:
            value = 1
        else:
            value = 0

        # Store the cell data in the worksheet data table.
        self.table[row][col] = cell_boolean_tuple(value, cell_format)

        return 0

    # Write a hyperlink. This is comprised of two elements: the displayed
    # string and the non-displayed link. The displayed string is the same as
    # the link unless an alternative string is specified. The display string
    # is written using the write_string() method. Therefore the max characters
    # string limit applies.
    #
    # The hyperlink can be to a http, ftp, mail, internal sheet, or external
    # directory urls.
    @convert_cell_args
    def write_url(self, row, col, url, cell_format=None,
                  string=None, tip=None):
        """
        Write a hyperlink to a worksheet cell.

        Args:
            row:    The cell row (zero indexed).
            col:    The cell column (zero indexed).
            url:    Hyperlink url.
            format: An optional cell Format object.
            string: An optional display string for the hyperlink.
            tip:    An optional tooltip.
        Returns:
            0:  Success.
            -1: Row or column is out of worksheet bounds.
            -2: String longer than 32767 characters.
            -3: URL longer than Excel limit of 255 characters.
            -4: Exceeds Excel limit of 65,530 urls per worksheet.
        """
        return self._write_url(row, col, url, cell_format, string, tip)

    # Undecorated version of write_url().
    def _write_url(self, row, col, url, cell_format=None,
                   string=None, tip=None):

        # Check that row and col are valid and store max and min values
        if self._check_dimensions(row, col):
            return -1

        # Set the displayed string to the URL unless defined by the user.
        if string is None:
            string = url

        # Default to external link type such as 'http://' or 'external:'.
        link_type = 1

        # Remove the URI scheme from internal links.
        if url.startswith('internal:'):
            url = url.replace('internal:', '')
            string = string.replace('internal:', '')
            link_type = 2

        # Remove the URI scheme from external links and change the directory
        # separator from Unix to Dos.
        external = False
        if url.startswith('external:'):
            url = url.replace('external:', '')
            url = url.replace('/', '\\')
            string = string.replace('external:', '')
            string = string.replace('/', '\\')
            external = True

        # Strip the mailto header.
        string = string.replace('mailto:', '')

        # Check that the string is < 32767 chars
        str_error = 0
        if len(string) > self.xls_strmax:
            warn("Ignoring URL since it exceeds Excel's string limit of "
                 "32767 characters")
            return -2

        # Copy string for use in hyperlink elements.
        url_str = string

        # External links to URLs and to other Excel workbooks have slightly
        # different characteristics that we have to account for.
        if link_type == 1:

            # Split url into the link and optional anchor/location.
            if '#' in url:
                url, url_str = url.split('#', 1)
            else:
                url_str = None

            url = self._escape_url(url)

            if url_str is not None and not external:
                url_str = self._escape_url(url_str)

            # Add the file:/// URI to the url for Windows style "C:/" link and
            # Network shares.
            if re.match(r'\w:', url) or re.match(r'\\', url):
                url = 'file:///' + url

            # Convert a .\dir\file.xlsx link to dir\file.xlsx.
            url = re.sub(r'^\.\\', '', url)

        # Excel limits the escaped URL and location/anchor to 255 characters.
        tmp_url_str = url_str or ''
        max_url = self.max_url_length
        if len(url) > max_url or len(tmp_url_str) > max_url:
            warn("Ignoring URL '%s' with link or location/anchor > %d "
                 "characters since it exceeds Excel's limit for URLS" %
                 (force_unicode(url), max_url))
            return -3

        # Check the limit of URLS per worksheet.
        self.hlink_count += 1

        if self.hlink_count > 65530:
            warn("Ignoring URL '%s' since it exceeds Excel's limit of "
                 "65,530 URLS per worksheet." % force_unicode(url))
            return -4

        # Write previous row if in in-line string constant_memory mode.
        if self.constant_memory and row > self.previous_row:
            self._write_single_row(row)

        # Add the default URL format.
        if cell_format is None:
            cell_format = self.default_url_format

        # Write the hyperlink string.
        self._write_string(row, col, string, cell_format)

        # Store the hyperlink data in a separate structure.
        self.hyperlinks[row][col] = {
            'link_type': link_type,
            'url': url,
            'str': url_str,
            'tip': tip}

        return str_error

    @convert_cell_args
    def write_rich_string(self, row, col, *args):
        """
        Write a "rich" string with multiple formats to a worksheet cell.

        Args:
            row:          The cell row (zero indexed).
            col:          The cell column (zero indexed).
            string_parts: String and format pairs.
            cell_format:  Optional Format object.

        Returns:
            0:  Success.
            -1: Row or column is out of worksheet bounds.
            -2: String truncated to 32k characters.
            -3: 2 consecutive formats used.
            -4: Empty string used.
            -5: Insufficient parameters.

        """

        return self._write_rich_string(row, col, *args)

    # Undecorated version of write_rich_string().
    def _write_rich_string(self, row, col, *args):

        tokens = list(args)
        cell_format = None
        str_length = 0
        string_index = 0

        # Check that row and col are valid and store max and min values
        if self._check_dimensions(row, col):
            return -1

        # If the last arg is a format we use it as the cell format.
        if isinstance(tokens[-1], Format):
            cell_format = tokens.pop()

        # Create a temp XMLWriter object and use it to write the rich string
        # XML to a string.
        fh = StringIO()
        self.rstring = XMLwriter()
        self.rstring._set_filehandle(fh)

        # Create a temp format with the default font for unformatted fragments.
        default = Format()

        # Convert list of format, string tokens to pairs of (format, string)
        # except for the first string fragment which doesn't require a default
        # formatting run. Use the default for strings without a leading format.
        fragments = []
        previous = 'format'
        pos = 0

        if len(tokens) <= 2:
            warn("You must specify more than 2 format/fragments for rich "
                 "strings. Ignoring input in write_rich_string().")
            return -5

        for token in tokens:
            if not isinstance(token, Format):
                # Token is a string.
                if previous != 'format':
                    # If previous token wasn't a format add one before string.
                    fragments.append(default)
                    fragments.append(token)
                else:
                    # If previous token was a format just add the string.
                    fragments.append(token)

                if token == '':
                    warn("Excel doesn't allow empty strings in rich strings. "
                         "Ignoring input in write_rich_string().")
                    return -4

                # Keep track of actual string str_length.
                str_length += len(token)
                previous = 'string'
            else:
                # Can't allow 2 formats in a row.
                if previous == 'format' and pos > 0:
                    warn("Excel doesn't allow 2 consecutive formats in rich "
                         "strings. Ignoring input in write_rich_string().")
                    return -3

                # Token is a format object. Add it to the fragment list.
                fragments.append(token)
                previous = 'format'

            pos += 1

        # If the first token is a string start the <r> element.
        if not isinstance(fragments[0], Format):
            self.rstring._xml_start_tag('r')

        # Write the XML elements for the $format $string fragments.
        for token in fragments:
            if isinstance(token, Format):
                # Write the font run.
                self.rstring._xml_start_tag('r')
                self._write_font(token)
            else:
                # Write the string fragment part, with whitespace handling.
                attributes = []

                if preserve_whitespace(token):
                    attributes.append(('xml:space', 'preserve'))

                self.rstring._xml_data_element('t', token, attributes)
                self.rstring._xml_end_tag('r')

        # Read the in-memory string.
        string = self.rstring.fh.getvalue()

        # Check that the string is < 32767 chars.
        if str_length > self.xls_strmax:
            warn("String length must be less than or equal to Excel's limit "
                 "of 32,767 characters in write_rich_string().")
            return -2

        # Write a shared string or an in-line string in constant_memory mode.
        if not self.constant_memory:
            string_index = self.str_table._get_shared_string_index(string)
        else:
            string_index = string

        # Write previous row if in in-line string constant_memory mode.
        if self.constant_memory and row > self.previous_row:
            self._write_single_row(row)

        # Store the cell data in the worksheet data table.
        self.table[row][col] = cell_string_tuple(string_index, cell_format)

        return 0

    def add_write_handler(self, user_type, user_function):
        """
        Add a callback function to the write() method to handle user defined
        types.

        Args:
            user_type:      The user type() to match on.
            user_function:  The user defined function to write the type data.
        Returns:
            Nothing.

        """

        self.write_handlers[user_type] = user_function

    @convert_cell_args
    def write_row(self, row, col, data, cell_format=None):
        """
        Write a row of data starting from (row, col).

        Args:
            row:    The cell row (zero indexed).
            col:    The cell column (zero indexed).
            data:   A list of tokens to be written with write().
            format: An optional cell Format object.
        Returns:
            0:  Success.
            other: Return value of write() method.

        """
        for token in data:
            error = self._write(row, col, token, cell_format)
            if error:
                return error
            col += 1

        return 0

    @convert_cell_args
    def write_column(self, row, col, data, cell_format=None):
        """
        Write a column of data starting from (row, col).

        Args:
            row:    The cell row (zero indexed).
            col:    The cell column (zero indexed).
            data:   A list of tokens to be written with write().
            format: An optional cell Format object.
        Returns:
            0:  Success.
            other: Return value of write() method.

        """
        for token in data:
            error = self._write(row, col, token, cell_format)
            if error:
                return error
            row += 1

        return 0

    @convert_cell_args
    def insert_image(self, row, col, filename, options=None):
        """
        Insert an image with its top-left corner in a worksheet cell.

        Args:
            row:      The cell row (zero indexed).
            col:      The cell column (zero indexed).
            filename: Path and filename for in supported formats.
            options:  Position, scale, url and data stream of the image.

        Returns:
            0:  Success.
            -1: Row or column is out of worksheet bounds.

        """
        # Check insert (row, col) without storing.
        if self._check_dimensions(row, col, True, True):
            warn('Cannot insert image at (%d, %d).' % (row, col))
            return -1

        if options is None:
            options = {}

        x_offset = options.get('x_offset', 0)
        y_offset = options.get('y_offset', 0)
        x_scale = options.get('x_scale', 1)
        y_scale = options.get('y_scale', 1)
        url = options.get('url', None)
        tip = options.get('tip', None)
        anchor = options.get('object_position', 2)
        image_data = options.get('image_data', None)
        description = options.get('description', None)
        decorative = options.get('decorative', False)

        # For backward compatibility with older parameter name.
        anchor = options.get('positioning', anchor)

        if not image_data and not os.path.exists(filename):
            warn("Image file '%s' not found." % force_unicode(filename))
            return -1

        self.images.append([row, col, filename, x_offset, y_offset,
                            x_scale, y_scale, url, tip, anchor, image_data,
                            description, decorative])
        return 0

    @convert_cell_args
    def insert_textbox(self, row, col, text, options=None):
        """
        Insert an textbox with its top-left corner in a worksheet cell.

        Args:
            row:      The cell row (zero indexed).
            col:      The cell column (zero indexed).
            text:     The text for the textbox.
            options:  Textbox options.

        Returns:
            0:  Success.
            -1: Row or column is out of worksheet bounds.

        """
        # Check insert (row, col) without storing.
        if self._check_dimensions(row, col, True, True):
            warn('Cannot insert textbox at (%d, %d).' % (row, col))
            return -1

        if text is None:
            text = ''

        if options is None:
            options = {}

        x_offset = options.get('x_offset', 0)
        y_offset = options.get('y_offset', 0)
        x_scale = options.get('x_scale', 1)
        y_scale = options.get('y_scale', 1)
        anchor = options.get('object_position', 1)
        description = options.get('description', None)
        decorative = options.get('decorative', False)

        self.shapes.append([row, col, x_offset, y_offset,
                            x_scale, y_scale, text, anchor, options,
                            description, decorative])
        return 0

    @convert_cell_args
    def insert_chart(self, row, col, chart, options=None):
        """
        Insert an chart with its top-left corner in a worksheet cell.

        Args:
            row:     The cell row (zero indexed).
            col:     The cell column (zero indexed).
            chart:   Chart object.
            options: Position and scale of the chart.

        Returns:
            0:  Success.
            -1: Row or column is out of worksheet bounds.

        """
        # Check insert (row, col) without storing.
        if self._check_dimensions(row, col, True, True):
            warn('Cannot insert chart at (%d, %d).' % (row, col))
            return -1

        if options is None:
            options = {}

        # Ensure a chart isn't inserted more than once.
        if (chart.already_inserted or chart.combined
                and chart.combined.already_inserted):

            warn('Chart cannot be inserted in a worksheet more than once.')
            return
        else:
            chart.already_inserted = True

            if chart.combined:
                chart.combined.already_inserted = True

        x_offset = options.get('x_offset', 0)
        y_offset = options.get('y_offset', 0)
        x_scale = options.get('x_scale', 1)
        y_scale = options.get('y_scale', 1)
        anchor = options.get('object_position', 1)
        description = options.get('description', None)
        decorative = options.get('decorative', False)

        # Allow Chart to override the scale and offset.
        if chart.x_scale != 1:
            x_scale = chart.x_scale

        if chart.y_scale != 1:
            y_scale = chart.y_scale

        if chart.x_offset:
            x_offset = chart.x_offset

        if chart.y_offset:
            y_offset = chart.y_offset

        self.charts.append([row, col, chart,
                            x_offset, y_offset,
                            x_scale, y_scale,
                            anchor,
                            description, decorative])
        return 0

    @convert_cell_args
    def write_comment(self, row, col, comment, options=None):
        """
        Write a comment to a worksheet cell.

        Args:
            row:     The cell row (zero indexed).
            col:     The cell column (zero indexed).
            comment: Cell comment. Str.
            options: Comment formatting options.

        Returns:
            0:  Success.
            -1: Row or column is out of worksheet bounds.
            -2: String longer than 32k characters.

        """
        if options is None:
            options = {}

        # Check that row and col are valid and store max and min values
        if self._check_dimensions(row, col):
            return -1

        # Check that the comment string is < 32767 chars.
        if len(comment) > self.xls_strmax:
            return -2

        self.has_vml = 1
        self.has_comments = 1

        # Store the options of the cell comment, to process on file close.
        self.comments[row][col] = [row, col, comment, options]

        return 0

    def show_comments(self):
        """
        Make any comments in the worksheet visible.

        Args:
            None.

        Returns:
            Nothing.

        """
        self.comments_visible = 1

    def set_background(self, filename, is_byte_stream=False):
        """
        Set a background image for a worksheet.

        Args:
            filename:       Path and filename for in supported formats.
            is_byte_stream: File is a stream of bytes.
        Returns:
            Nothing.

        """

        if not is_byte_stream and not os.path.exists(filename):
            warn("Image file '%s' not found." % force_unicode(filename))
            return -1

        self.background_bytes = is_byte_stream
        self.background_image = filename

    def set_comments_author(self, author):
        """
        Set the default author of the cell comments.

        Args:
            author: Comment author name. String.

        Returns:
            Nothing.

        """
        self.comments_author = author

    def get_name(self):
        """
        Retrieve the worksheet name.

        Args:
            None.

        Returns:
            Nothing.

        """
        # There is no set_name() method. Name must be set in add_worksheet().
        return self.name

    def activate(self):
        """
        Set this worksheet as the active worksheet, i.e. the worksheet that is
        displayed when the workbook is opened. Also set it as selected.

        Note: An active worksheet cannot be hidden.

        Args:
            None.

        Returns:
            Nothing.

        """
        self.hidden = 0
        self.selected = 1
        self.worksheet_meta.activesheet = self.index

    def select(self):
        """
        Set current worksheet as a selected worksheet, i.e. the worksheet
        has its tab highlighted.

        Note: A selected worksheet cannot be hidden.

        Args:
            None.

        Returns:
            Nothing.

        """
        self.selected = 1
        self.hidden = 0

    def hide(self):
        """
        Hide the current worksheet.

        Args:
            None.

        Returns:
            Nothing.

        """
        self.hidden = 1

        # A hidden worksheet shouldn't be active or selected.
        self.selected = 0

        # TODO. Should add a check to see if the sheet is the global
        # activesheet or firstsheet and reset them.

    def set_first_sheet(self):
        """
        Set current worksheet as the first visible sheet. This is necessary
        when there are a large number of worksheets and the activated
        worksheet is not visible on the screen.

        Note: A selected worksheet cannot be hidden.

        Args:
            None.

        Returns:
            Nothing.

        """
        self.hidden = 0  # Active worksheet can't be hidden.
        self.worksheet_meta.firstsheet = self.index

    @convert_column_args
    def set_column(self, first_col, last_col, width=None, cell_format=None,
                   options=None):
        """
        Set the width, and other properties of a single column or a
        range of columns.

        Args:
            first_col:   First column (zero-indexed).
            last_col:    Last column (zero-indexed). Can be same as first_col.
            width:       Column width. (optional).
            cell_format: Column cell_format. (optional).
            options:     Dict of options such as hidden and level.

        Returns:
            0:  Success.
            -1: Column number is out of worksheet bounds.

        """
        if options is None:
            options = {}

        # Ensure 2nd col is larger than first.
        if first_col > last_col:
            (first_col, last_col) = (last_col, first_col)

        # Don't modify the row dimensions when checking the columns.
        ignore_row = True

        # Set optional column values.
        hidden = options.get('hidden', False)
        collapsed = options.get('collapsed', False)
        level = options.get('level', 0)

        # Store the column dimension only in some conditions.
        if cell_format or (width and hidden):
            ignore_col = False
        else:
            ignore_col = True

        # Check that each column is valid and store the max and min values.
        if self._check_dimensions(0, last_col, ignore_row, ignore_col):
            return -1
        if self._check_dimensions(0, first_col, ignore_row, ignore_col):
            return -1

        # Set the limits for the outline levels (0 <= x <= 7).
        if level < 0:
            level = 0
        if level > 7:
            level = 7

        if level > self.outline_col_level:
            self.outline_col_level = level

        # Store the column data. Padded for sorting.
        self.colinfo["%05d" % first_col] = [first_col, last_col, width,
                                            cell_format, hidden, level,
                                            collapsed]

        # Store the column change to allow optimizations.
        self.col_size_changed = True

        if width is None:
            width = self.default_col_width

        # Store the col sizes for use when calculating image vertices taking
        # hidden columns into account. Also store the column formats.
        for col in range(first_col, last_col + 1):
            self.col_sizes[col] = [width, hidden]
            if cell_format:
                self.col_formats[col] = cell_format

        return 0

    @convert_column_args
    def set_column_pixels(self, first_col, last_col, width=None,
                          cell_format=None, options=None):
        """
        Set the width, and other properties of a single column or a
        range of columns, where column width is in pixels.

        Args:
            first_col:   First column (zero-indexed).
            last_col:    Last column (zero-indexed). Can be same as first_col.
            width:       Column width in pixels. (optional).
            cell_format: Column cell_format. (optional).
            options:     Dict of options such as hidden and level.

        Returns:
            0:  Success.
            -1: Column number is out of worksheet bounds.

        """
        if width is not None:
            width = self._pixels_to_width(width)

        return self.set_column(first_col, last_col, width,
                               cell_format, options)

    def set_row(self, row, height=None, cell_format=None, options=None):
        """
        Set the width, and other properties of a row.

        Args:
            row:         Row number (zero-indexed).
            height:      Row height. (optional).
            cell_format: Row cell_format. (optional).
            options:     Dict of options such as hidden, level and collapsed.

        Returns:
            0:  Success.
            -1: Row number is out of worksheet bounds.

        """
        if options is None:
            options = {}

        # Use minimum col in _check_dimensions().
        if self.dim_colmin is not None:
            min_col = self.dim_colmin
        else:
            min_col = 0

        # Check that row is valid.
        if self._check_dimensions(row, min_col):
            return -1

        if height is None:
            height = self.default_row_height

        # Set optional row values.
        hidden = options.get('hidden', False)
        collapsed = options.get('collapsed', False)
        level = options.get('level', 0)

        # If the height is 0 the row is hidden and the height is the default.
        if height == 0:
            hidden = 1
            height = self.default_row_height

        # Set the limits for the outline levels (0 <= x <= 7).
        if level < 0:
            level = 0
        if level > 7:
            level = 7

        if level > self.outline_row_level:
            self.outline_row_level = level

        # Store the row properties.
        self.set_rows[row] = [height, cell_format, hidden, level, collapsed]

        # Store the row change to allow optimizations.
        self.row_size_changed = True

        # Store the row sizes for use when calculating image vertices.
        self.row_sizes[row] = [height, hidden]

        return 0

    def set_row_pixels(self, row, height=None, cell_format=None, options=None):
        """
        Set the width (in pixels), and other properties of a row.

        Args:
            row:         Row number (zero-indexed).
            height:      Row height in pixels. (optional).
            cell_format: Row cell_format. (optional).
            options:     Dict of options such as hidden, level and collapsed.

        Returns:
            0:  Success.
            -1: Row number is out of worksheet bounds.

        """
        if height is not None:
            height = self._pixels_to_height(height)

        return self.set_row(row, height, cell_format, options)

    def set_default_row(self, height=None, hide_unused_rows=False):
        """
        Set the default row properties.

        Args:
            height:           Default height. Optional, defaults to 15.
            hide_unused_rows: Hide unused rows. Optional, defaults to False.

        Returns:
            Nothing.

        """
        if height is None:
            height = self.default_row_height

        if height != self.original_row_height:
            # Store the row change to allow optimizations.
            self.row_size_changed = True
            self.default_row_height = height

        if hide_unused_rows:
            self.default_row_zeroed = 1

    @convert_range_args
    def merge_range(self, first_row, first_col, last_row, last_col,
                    data, cell_format=None):
        """
        Merge a range of cells.

        Args:
            first_row:    The first row of the cell range. (zero indexed).
            first_col:    The first column of the cell range.
            last_row:     The last row of the cell range. (zero indexed).
            last_col:     The last column of the cell range.
            data:         Cell data.
            cell_format:  Cell Format object.

        Returns:
             0:    Success.
            -1:    Row or column is out of worksheet bounds.
            other: Return value of write().

        """
        # Merge a range of cells. The first cell should contain the data and
        # the others should be blank. All cells should have the same format.

        # Excel doesn't allow a single cell to be merged
        if first_row == last_row and first_col == last_col:
            warn("Can't merge single cell")
            return

        # Swap last row/col with first row/col as necessary
        if first_row > last_row:
            (first_row, last_row) = (last_row, first_row)
        if first_col > last_col:
            (first_col, last_col) = (last_col, first_col)

        # Check that row and col are valid and store max and min values.
        if self._check_dimensions(first_row, first_col):
            return -1
        if self._check_dimensions(last_row, last_col):
            return -1

        # Store the merge range.
        self.merge.append([first_row, first_col, last_row, last_col])

        # Write the first cell
        self._write(first_row, first_col, data, cell_format)

        # Pad out the rest of the area with formatted blank cells.
        for row in range(first_row, last_row + 1):
            for col in range(first_col, last_col + 1):
                if row == first_row and col == first_col:
                    continue
                self._write_blank(row, col, '', cell_format)

        return 0

    @convert_range_args
    def autofilter(self, first_row, first_col, last_row, last_col):
        """
        Set the autofilter area in the worksheet.

        Args:
            first_row:    The first row of the cell range. (zero indexed).
            first_col:    The first column of the cell range.
            last_row:     The last row of the cell range. (zero indexed).
            last_col:     The last column of the cell range.

        Returns:
             Nothing.

        """
        # Reverse max and min values if necessary.
        if last_row < first_row:
            (first_row, last_row) = (last_row, first_row)
        if last_col < first_col:
            (first_col, last_col) = (last_col, first_col)

        # Build up the print area range "Sheet1!$A$1:$C$13".
        area = self._convert_name_area(first_row, first_col,
                                       last_row, last_col)
        ref = xl_range(first_row, first_col, last_row, last_col)

        self.autofilter_area = area
        self.autofilter_ref = ref
        self.filter_range = [first_col, last_col]

    def filter_column(self, col, criteria):
        """
        Set the column filter criteria.

        Args:
            col:       Filter column (zero-indexed).
            criteria:  Filter criteria.

        Returns:
             Nothing.

        """
        if not self.autofilter_area:
            warn("Must call autofilter() before filter_column()")
            return

        # Check for a column reference in A1 notation and substitute.
        try:
            int(col)
        except ValueError:
            # Convert col ref to a cell ref and then to a col number.
            col_letter = col
            (_, col) = xl_cell_to_rowcol(col + '1')

            if col >= self.xls_colmax:
                warn("Invalid column '%s'" % col_letter)
                return

        (col_first, col_last) = self.filter_range

        # Reject column if it is outside filter range.
        if col < col_first or col > col_last:
            warn("Column '%d' outside autofilter() column range (%d, %d)"
                 % (col, col_first, col_last))
            return

        tokens = self._extract_filter_tokens(criteria)

        if not (len(tokens) == 3 or len(tokens) == 7):
            warn("Incorrect number of tokens in criteria '%s'" % criteria)

        tokens = self._parse_filter_expression(criteria, tokens)

        # Excel handles single or double custom filters as default filters.
        #  We need to check for them and handle them accordingly.
        if len(tokens) == 2 and tokens[0] == 2:
            # Single equality.
            self.filter_column_list(col, [tokens[1]])
        elif (len(tokens) == 5 and tokens[0] == 2 and tokens[2] == 1
              and tokens[3] == 2):
            # Double equality with "or" operator.
            self.filter_column_list(col, [tokens[1], tokens[4]])
        else:
            # Non default custom filter.
            self.filter_cols[col] = tokens
            self.filter_type[col] = 0

        self.filter_on = 1

    def filter_column_list(self, col, filters):
        """
        Set the column filter criteria in Excel 2007 list style.

        Args:
            col:      Filter column (zero-indexed).
            filters:  List of filter criteria to match.

        Returns:
             Nothing.

        """
        if not self.autofilter_area:
            warn("Must call autofilter() before filter_column()")
            return

        # Check for a column reference in A1 notation and substitute.
        try:
            int(col)
        except ValueError:
            # Convert col ref to a cell ref and then to a col number.
            col_letter = col
            (_, col) = xl_cell_to_rowcol(col + '1')

            if col >= self.xls_colmax:
                warn("Invalid column '%s'" % col_letter)
                return

        (col_first, col_last) = self.filter_range

        # Reject column if it is outside filter range.
        if col < col_first or col > col_last:
            warn("Column '%d' outside autofilter() column range "
                 "(%d,%d)" % (col, col_first, col_last))
            return

        self.filter_cols[col] = filters
        self.filter_type[col] = 1
        self.filter_on = 1

    @convert_range_args
    def data_validation(self, first_row, first_col, last_row, last_col,
                        options=None):
        """
        Add a data validation to a worksheet.

        Args:
            first_row:    The first row of the cell range. (zero indexed).
            first_col:    The first column of the cell range.
            last_row:     The last row of the cell range. (zero indexed).
            last_col:     The last column of the cell range.
            options:      Data validation options.

        Returns:
            0:  Success.
            -1: Row or column is out of worksheet bounds.
            -2: Incorrect parameter or option.
        """
        # Check that row and col are valid without storing the values.
        if self._check_dimensions(first_row, first_col, True, True):
            return -1
        if self._check_dimensions(last_row, last_col, True, True):
            return -1

        if options is None:
            options = {}
        else:
            # Copy the user defined options so they aren't modified.
            options = options.copy()

        # Valid input parameters.
        valid_parameters = {
            'validate': True,
            'criteria': True,
            'value': True,
            'source': True,
            'minimum': True,
            'maximum': True,
            'ignore_blank': True,
            'dropdown': True,
            'show_input': True,
            'input_title': True,
            'input_message': True,
            'show_error': True,
            'error_title': True,
            'error_message': True,
            'error_type': True,
            'other_cells': True,
        }

        # Check for valid input parameters.
        for param_key in options.keys():
            if param_key not in valid_parameters:
                warn("Unknown parameter '%s' in data_validation()" % param_key)
                return -2

        # Map alternative parameter names 'source' or 'minimum' to 'value'.
        if 'source' in options:
            options['value'] = options['source']
        if 'minimum' in options:
            options['value'] = options['minimum']

        # 'validate' is a required parameter.
        if 'validate' not in options:
            warn("Parameter 'validate' is required in data_validation()")
            return -2

        # List of  valid validation types.
        valid_types = {
            'any': 'none',
            'any value': 'none',
            'whole number': 'whole',
            'whole': 'whole',
            'integer': 'whole',
            'decimal': 'decimal',
            'list': 'list',
            'date': 'date',
            'time': 'time',
            'text length': 'textLength',
            'length': 'textLength',
            'custom': 'custom',
        }

        # Check for valid validation types.
        if not options['validate'] in valid_types:
            warn("Unknown validation type '%s' for parameter "
                 "'validate' in data_validation()" % options['validate'])
            return -2
        else:
            options['validate'] = valid_types[options['validate']]

        # No action is required for validation type 'any' if there are no
        # input messages to display.
        if (options['validate'] == 'none'
                and options.get('input_title') is None
                and options.get('input_message') is None):
            return -2

        # The any, list and custom validations don't have a criteria so we use
        # a default of 'between'.
        if (options['validate'] == 'none'
                or options['validate'] == 'list'
                or options['validate'] == 'custom'):
            options['criteria'] = 'between'
            options['maximum'] = None

        # 'criteria' is a required parameter.
        if 'criteria' not in options:
            warn("Parameter 'criteria' is required in data_validation()")
            return -2

        # Valid criteria types.
        criteria_types = {
            'between': 'between',
            'not between': 'notBetween',
            'equal to': 'equal',
            '=': 'equal',
            '==': 'equal',
            'not equal to': 'notEqual',
            '!=': 'notEqual',
            '<>': 'notEqual',
            'greater than': 'greaterThan',
            '>': 'greaterThan',
            'less than': 'lessThan',
            '<': 'lessThan',
            'greater than or equal to': 'greaterThanOrEqual',
            '>=': 'greaterThanOrEqual',
            'less than or equal to': 'lessThanOrEqual',
            '<=': 'lessThanOrEqual',
        }

        # Check for valid criteria types.
        if not options['criteria'] in criteria_types:
            warn("Unknown criteria type '%s' for parameter "
                 "'criteria' in data_validation()" % options['criteria'])
            return -2
        else:
            options['criteria'] = criteria_types[options['criteria']]

        # 'Between' and 'Not between' criteria require 2 values.
        if (options['criteria'] == 'between' or
                options['criteria'] == 'notBetween'):
            if 'maximum' not in options:
                warn("Parameter 'maximum' is required in data_validation() "
                     "when using 'between' or 'not between' criteria")
                return -2
        else:
            options['maximum'] = None

        # Valid error dialog types.
        error_types = {
            'stop': 0,
            'warning': 1,
            'information': 2,
        }

        # Check for valid error dialog types.
        if 'error_type' not in options:
            options['error_type'] = 0
        elif not options['error_type'] in error_types:
            warn("Unknown criteria type '%s' for parameter 'error_type' "
                 "in data_validation()" % options['error_type'])
            return -2
        else:
            options['error_type'] = error_types[options['error_type']]

        # Convert date/times value if required.
        if options['validate'] == 'date' or options['validate'] == 'time':

            if options['value']:
                if supported_datetime(options['value']):
                    date_time = self._convert_date_time(options['value'])
                    # Format date number to the same precision as Excel.
                    options['value'] = "%.16g" % date_time

            if options['maximum']:
                if supported_datetime(options['maximum']):
                    date_time = self._convert_date_time(options['maximum'])
                    options['maximum'] = "%.16g" % date_time

        # Check that the input title doesn't exceed the maximum length.
        if options.get('input_title') and len(options['input_title']) > 32:
            warn("Length of input title '%s' exceeds Excel's limit of 32"
                 % force_unicode(options['input_title']))
            return -2

        # Check that the error title doesn't exceed the maximum length.
        if options.get('error_title') and len(options['error_title']) > 32:
            warn("Length of error title '%s' exceeds Excel's limit of 32"
                 % force_unicode(options['error_title']))
            return -2

        # Check that the input message doesn't exceed the maximum length.
        if (options.get('input_message')
                and len(options['input_message']) > 255):
            warn("Length of input message '%s' exceeds Excel's limit of 255"
                 % force_unicode(options['input_message']))
            return -2

        # Check that the error message doesn't exceed the maximum length.
        if (options.get('error_message')
                and len(options['error_message']) > 255):
            warn("Length of error message '%s' exceeds Excel's limit of 255"
                 % force_unicode(options['error_message']))
            return -2

        # Check that the input list doesn't exceed the maximum length.
        if options['validate'] == 'list' and type(options['value']) is list:
            formula = self._csv_join(*options['value'])
            if len(formula) > 255:
                warn("Length of list items '%s' exceeds Excel's limit of "
                     "255, use a formula range instead"
                     % force_unicode(formula))
                return -2

        # Set some defaults if they haven't been defined by the user.
        if 'ignore_blank' not in options:
            options['ignore_blank'] = 1
        if 'dropdown' not in options:
            options['dropdown'] = 1
        if 'show_input' not in options:
            options['show_input'] = 1
        if 'show_error' not in options:
            options['show_error'] = 1

        # These are the cells to which the validation is applied.
        options['cells'] = [[first_row, first_col, last_row, last_col]]

        # A (for now) undocumented parameter to pass additional cell ranges.
        if 'other_cells' in options:
            options['cells'].extend(options['other_cells'])

        # Store the validation information until we close the worksheet.
        self.validations.append(options)

        return 0

    @convert_range_args
    def conditional_format(self, first_row, first_col, last_row, last_col,
                           options=None):
        """
        Add a conditional format to a worksheet.

        Args:
            first_row:    The first row of the cell range. (zero indexed).
            first_col:    The first column of the cell range.
            last_row:     The last row of the cell range. (zero indexed).
            last_col:     The last column of the cell range.
            options:      Conditional format options.

        Returns:
            0:  Success.
            -1: Row or column is out of worksheet bounds.
            -2: Incorrect parameter or option.
        """
        # Check that row and col are valid without storing the values.
        if self._check_dimensions(first_row, first_col, True, True):
            return -1
        if self._check_dimensions(last_row, last_col, True, True):
            return -1

        if options is None:
            options = {}
        else:
            # Copy the user defined options so they aren't modified.
            options = options.copy()

        # Valid input parameters.
        valid_parameter = {
            'type': True,
            'format': True,
            'criteria': True,
            'value': True,
            'minimum': True,
            'maximum': True,
            'stop_if_true': True,
            'min_type': True,
            'mid_type': True,
            'max_type': True,
            'min_value': True,
            'mid_value': True,
            'max_value': True,
            'min_color': True,
            'mid_color': True,
            'max_color': True,
            'min_length': True,
            'max_length': True,
            'multi_range': True,
            'bar_color': True,
            'bar_negative_color': True,
            'bar_negative_color_same': True,
            'bar_solid': True,
            'bar_border_color': True,
            'bar_negative_border_color': True,
            'bar_negative_border_color_same': True,
            'bar_no_border': True,
            'bar_direction': True,
            'bar_axis_position': True,
            'bar_axis_color': True,
            'bar_only': True,
            'data_bar_2010': True,
            'icon_style': True,
            'reverse_icons': True,
            'icons_only': True,
            'icons': True}

        # Check for valid input parameters.
        for param_key in options.keys():
            if param_key not in valid_parameter:
                warn("Unknown parameter '%s' in conditional_format()" %
                     param_key)
                return -2

        # 'type' is a required parameter.
        if 'type' not in options:
            warn("Parameter 'type' is required in conditional_format()")
            return -2

        # Valid types.
        valid_type = {
            'cell': 'cellIs',
            'date': 'date',
            'time': 'time',
            'average': 'aboveAverage',
            'duplicate': 'duplicateValues',
            'unique': 'uniqueValues',
            'top': 'top10',
            'bottom': 'top10',
            'text': 'text',
            'time_period': 'timePeriod',
            'blanks': 'containsBlanks',
            'no_blanks': 'notContainsBlanks',
            'errors': 'containsErrors',
            'no_errors': 'notContainsErrors',
            '2_color_scale': '2_color_scale',
            '3_color_scale': '3_color_scale',
            'data_bar': 'dataBar',
            'formula': 'expression',
            'icon_set': 'iconSet'}

        # Check for valid types.
        if options['type'] not in valid_type:
            warn("Unknown value '%s' for parameter 'type' "
                 "in conditional_format()" % options['type'])
            return -2
        else:
            if options['type'] == 'bottom':
                options['direction'] = 'bottom'
            options['type'] = valid_type[options['type']]

        # Valid criteria types.
        criteria_type = {
            'between': 'between',
            'not between': 'notBetween',
            'equal to': 'equal',
            '=': 'equal',
            '==': 'equal',
            'not equal to': 'notEqual',
            '!=': 'notEqual',
            '<>': 'notEqual',
            'greater than': 'greaterThan',
            '>': 'greaterThan',
            'less than': 'lessThan',
            '<': 'lessThan',
            'greater than or equal to': 'greaterThanOrEqual',
            '>=': 'greaterThanOrEqual',
            'less than or equal to': 'lessThanOrEqual',
            '<=': 'lessThanOrEqual',
            'containing': 'containsText',
            'not containing': 'notContains',
            'begins with': 'beginsWith',
            'ends with': 'endsWith',
            'yesterday': 'yesterday',
            'today': 'today',
            'last 7 days': 'last7Days',
            'last week': 'lastWeek',
            'this week': 'thisWeek',
            'next week': 'nextWeek',
            'last month': 'lastMonth',
            'this month': 'thisMonth',
            'next month': 'nextMonth',
            # For legacy, but incorrect, support.
            'continue week': 'nextWeek',
            'continue month': 'nextMonth'}

        # Check for valid criteria types.
        if 'criteria' in options and options['criteria'] in criteria_type:
            options['criteria'] = criteria_type[options['criteria']]

        # Convert date/times value if required.
        if options['type'] == 'date' or options['type'] == 'time':
            options['type'] = 'cellIs'

            if 'value' in options:
                if not supported_datetime(options['value']):
                    warn("Conditional format 'value' must be a "
                         "datetime object.")
                    return -2
                else:
                    date_time = self._convert_date_time(options['value'])
                    # Format date number to the same precision as Excel.
                    options['value'] = "%.16g" % date_time

            if 'minimum' in options:
                if not supported_datetime(options['minimum']):
                    warn("Conditional format 'minimum' must be a "
                         "datetime object.")
                    return -2
                else:
                    date_time = self._convert_date_time(options['minimum'])
                    options['minimum'] = "%.16g" % date_time

            if 'maximum' in options:
                if not supported_datetime(options['maximum']):
                    warn("Conditional format 'maximum' must be a "
                         "datetime object.")
                    return -2
                else:
                    date_time = self._convert_date_time(options['maximum'])
                    options['maximum'] = "%.16g" % date_time

        # Valid icon styles.
        valid_icons = {
            "3_arrows": "3Arrows",                          # 1
            "3_flags": "3Flags",                            # 2
            "3_traffic_lights_rimmed": "3TrafficLights2",   # 3
            "3_symbols_circled": "3Symbols",                # 4
            "4_arrows": "4Arrows",                          # 5
            "4_red_to_black": "4RedToBlack",                # 6
            "4_traffic_lights": "4TrafficLights",           # 7
            "5_arrows_gray": "5ArrowsGray",                 # 8
            "5_quarters": "5Quarters",                      # 9
            "3_arrows_gray": "3ArrowsGray",                 # 10
            "3_traffic_lights": "3TrafficLights",           # 11
            "3_signs": "3Signs",                            # 12
            "3_symbols": "3Symbols2",                       # 13
            "4_arrows_gray": "4ArrowsGray",                 # 14
            "4_ratings": "4Rating",                         # 15
            "5_arrows": "5Arrows",                          # 16
            "5_ratings": "5Rating"}                         # 17

        # Set the icon set properties.
        if options['type'] == 'iconSet':

            # An icon_set must have an icon style.
            if not options.get('icon_style'):
                warn("The 'icon_style' parameter must be specified when "
                     "'type' == 'icon_set' in conditional_format()")
                return -3

            # Check for valid icon styles.
            if options['icon_style'] not in valid_icons:
                warn("Unknown icon_style '%s' in conditional_format()" %
                     options['icon_style'])
                return -2
            else:
                options['icon_style'] = valid_icons[options['icon_style']]

            # Set the number of icons for the icon style.
            options['total_icons'] = 3
            if options['icon_style'].startswith('4'):
                options['total_icons'] = 4
            elif options['icon_style'].startswith('5'):
                options['total_icons'] = 5

            options['icons'] = self._set_icon_props(options.get('total_icons'),
                                                    options.get('icons'))

        # Swap last row/col for first row/col as necessary
        if first_row > last_row:
            first_row, last_row = last_row, first_row

        if first_col > last_col:
            first_col, last_col = last_col, first_col

        # Set the formatting range.
        cell_range = xl_range(first_row, first_col, last_row, last_col)
        start_cell = xl_rowcol_to_cell(first_row, first_col)

        # Override with user defined multiple range if provided.
        if 'multi_range' in options:
            cell_range = options['multi_range']
            cell_range = cell_range.replace('$', '')

        # Get the dxf format index.
        if 'format' in options and options['format']:
            options['format'] = options['format']._get_dxf_index()

        # Set the priority based on the order of adding.
        options['priority'] = self.dxf_priority
        self.dxf_priority += 1

        # Check for 2010 style data_bar parameters.
        if (self.use_data_bars_2010 or
                options.get('data_bar_2010') or
                options.get('bar_solid') or
                options.get('bar_border_color') or
                options.get('bar_negative_color') or
                options.get('bar_negative_color_same') or
                options.get('bar_negative_border_color') or
                options.get('bar_negative_border_color_same') or
                options.get('bar_no_border') or
                options.get('bar_axis_position') or
                options.get('bar_axis_color') or
                options.get('bar_direction')):
            options['is_data_bar_2010'] = True

        # Special handling of text criteria.
        if options['type'] == 'text':

            if options['criteria'] == 'containsText':
                options['type'] = 'containsText'
                options['formula'] = ('NOT(ISERROR(SEARCH("%s",%s)))'
                                      % (options['value'], start_cell))
            elif options['criteria'] == 'notContains':
                options['type'] = 'notContainsText'
                options['formula'] = ('ISERROR(SEARCH("%s",%s))'
                                      % (options['value'], start_cell))
            elif options['criteria'] == 'beginsWith':
                options['type'] = 'beginsWith'
                options['formula'] = ('LEFT(%s,%d)="%s"'
                                      % (start_cell,
                                         len(options['value']),
                                         options['value']))
            elif options['criteria'] == 'endsWith':
                options['type'] = 'endsWith'
                options['formula'] = ('RIGHT(%s,%d)="%s"'
                                      % (start_cell,
                                         len(options['value']),
                                         options['value']))
            else:
                warn("Invalid text criteria '%s' "
                     "in conditional_format()" % options['criteria'])

        # Special handling of time time_period criteria.
        if options['type'] == 'timePeriod':

            if options['criteria'] == 'yesterday':
                options['formula'] = 'FLOOR(%s,1)=TODAY()-1' % start_cell

            elif options['criteria'] == 'today':
                options['formula'] = 'FLOOR(%s,1)=TODAY()' % start_cell

            elif options['criteria'] == 'tomorrow':
                options['formula'] = 'FLOOR(%s,1)=TODAY()+1' % start_cell

            elif options['criteria'] == 'last7Days':
                options['formula'] = \
                    ('AND(TODAY()-FLOOR(%s,1)<=6,FLOOR(%s,1)<=TODAY())' %
                     (start_cell, start_cell))

            elif options['criteria'] == 'lastWeek':
                options['formula'] = \
                    ('AND(TODAY()-ROUNDDOWN(%s,0)>=(WEEKDAY(TODAY())),'
                     'TODAY()-ROUNDDOWN(%s,0)<(WEEKDAY(TODAY())+7))' %
                     (start_cell, start_cell))

            elif options['criteria'] == 'thisWeek':
                options['formula'] = \
                    ('AND(TODAY()-ROUNDDOWN(%s,0)<=WEEKDAY(TODAY())-1,'
                     'ROUNDDOWN(%s,0)-TODAY()<=7-WEEKDAY(TODAY()))' %
                     (start_cell, start_cell))

            elif options['criteria'] == 'nextWeek':
                options['formula'] = \
                    ('AND(ROUNDDOWN(%s,0)-TODAY()>(7-WEEKDAY(TODAY())),'
                     'ROUNDDOWN(%s,0)-TODAY()<(15-WEEKDAY(TODAY())))' %
                     (start_cell, start_cell))

            elif options['criteria'] == 'lastMonth':
                options['formula'] = \
                    ('AND(MONTH(%s)=MONTH(TODAY())-1,OR(YEAR(%s)=YEAR('
                     'TODAY()),AND(MONTH(%s)=1,YEAR(A1)=YEAR(TODAY())-1)))' %
                     (start_cell, start_cell, start_cell))

            elif options['criteria'] == 'thisMonth':
                options['formula'] = \
                    ('AND(MONTH(%s)=MONTH(TODAY()),YEAR(%s)=YEAR(TODAY()))' %
                     (start_cell, start_cell))

            elif options['criteria'] == 'nextMonth':
                options['formula'] = \
                    ('AND(MONTH(%s)=MONTH(TODAY())+1,OR(YEAR(%s)=YEAR('
                     'TODAY()),AND(MONTH(%s)=12,YEAR(%s)=YEAR(TODAY())+1)))' %
                     (start_cell, start_cell, start_cell, start_cell))

            else:
                warn("Invalid time_period criteria '%s' "
                     "in conditional_format()" % options['criteria'])

        # Special handling of blanks/error types.
        if options['type'] == 'containsBlanks':
            options['formula'] = 'LEN(TRIM(%s))=0' % start_cell

        if options['type'] == 'notContainsBlanks':
            options['formula'] = 'LEN(TRIM(%s))>0' % start_cell

        if options['type'] == 'containsErrors':
            options['formula'] = 'ISERROR(%s)' % start_cell

        if options['type'] == 'notContainsErrors':
            options['formula'] = 'NOT(ISERROR(%s))' % start_cell

        # Special handling for 2 color scale.
        if options['type'] == '2_color_scale':
            options['type'] = 'colorScale'

            # Color scales don't use any additional formatting.
            options['format'] = None

            # Turn off 3 color parameters.
            options['mid_type'] = None
            options['mid_color'] = None

            options.setdefault('min_type', 'min')
            options.setdefault('max_type', 'max')
            options.setdefault('min_value', 0)
            options.setdefault('max_value', 0)
            options.setdefault('min_color', '#FF7128')
            options.setdefault('max_color', '#FFEF9C')

            options['min_color'] = xl_color(options['min_color'])
            options['max_color'] = xl_color(options['max_color'])

        # Special handling for 3 color scale.
        if options['type'] == '3_color_scale':
            options['type'] = 'colorScale'

            # Color scales don't use any additional formatting.
            options['format'] = None

            options.setdefault('min_type', 'min')
            options.setdefault('mid_type', 'percentile')
            options.setdefault('max_type', 'max')
            options.setdefault('min_value', 0)
            options.setdefault('max_value', 0)
            options.setdefault('min_color', '#F8696B')
            options.setdefault('mid_color', '#FFEB84')
            options.setdefault('max_color', '#63BE7B')

            options['min_color'] = xl_color(options['min_color'])
            options['mid_color'] = xl_color(options['mid_color'])
            options['max_color'] = xl_color(options['max_color'])

            # Set a default mid value.
            if 'mid_value' not in options:
                options['mid_value'] = 50

        # Special handling for data bar.
        if options['type'] == 'dataBar':

            # Color scales don't use any additional formatting.
            options['format'] = None

            if not options.get('min_type'):
                options['min_type'] = 'min'
                options['x14_min_type'] = 'autoMin'
            else:
                options['x14_min_type'] = options['min_type']

            if not options.get('max_type'):
                options['max_type'] = 'max'
                options['x14_max_type'] = 'autoMax'
            else:
                options['x14_max_type'] = options['max_type']

            options.setdefault('min_value', 0)
            options.setdefault('max_value', 0)
            options.setdefault('bar_color', '#638EC6')
            options.setdefault('bar_border_color', options['bar_color'])
            options.setdefault('bar_only', False)
            options.setdefault('bar_no_border', False)
            options.setdefault('bar_solid', False)
            options.setdefault('bar_direction', '')
            options.setdefault('bar_negative_color', '#FF0000')
            options.setdefault('bar_negative_border_color', '#FF0000')
            options.setdefault('bar_negative_color_same', False)
            options.setdefault('bar_negative_border_color_same', False)
            options.setdefault('bar_axis_position', '')
            options.setdefault('bar_axis_color', '#000000')

            options['bar_color'] = xl_color(options['bar_color'])
            options['bar_border_color'] = xl_color(options['bar_border_color'])
            options['bar_axis_color'] = xl_color(options['bar_axis_color'])
            options['bar_negative_color'] = \
                xl_color(options['bar_negative_color'])
            options['bar_negative_border_color'] = \
                xl_color(options['bar_negative_border_color'])

        # Adjust for 2010 style data_bar parameters.
        if options.get('is_data_bar_2010'):
            self.excel_version = 2010

            if options['min_type'] == 'min' and options['min_value'] == 0:
                options['min_value'] = None

            if options['max_type'] == 'max' and options['max_value'] == 0:
                options['max_value'] = None

            options['range'] = cell_range

        # Strip the leading = from formulas.
        try:
            options['min_value'] = options['min_value'].lstrip('=')
        except (KeyError, AttributeError):
            pass
        try:
            options['mid_value'] = options['mid_value'].lstrip('=')
        except (KeyError, AttributeError):
            pass
        try:
            options['max_value'] = options['max_value'].lstrip('=')
        except (KeyError, AttributeError):
            pass

        # Store the conditional format until we close the worksheet.
        if cell_range in self.cond_formats:
            self.cond_formats[cell_range].append(options)
        else:
            self.cond_formats[cell_range] = [options]

        return 0

    @convert_range_args
    def add_table(self, first_row, first_col, last_row, last_col,
                  options=None):
        """
        Add an Excel table to a worksheet.

        Args:
            first_row:    The first row of the cell range. (zero indexed).
            first_col:    The first column of the cell range.
            last_row:     The last row of the cell range. (zero indexed).
            last_col:     The last column of the cell range.
            options:      Table format options. (Optional)

        Returns:
            0:  Success.
            -1: Not supported in constant_memory mode.
            -2: Row or column is out of worksheet bounds.
            -3: Incorrect parameter or option.
        """
        table = {}
        col_formats = {}

        if options is None:
            options = {}
        else:
            # Copy the user defined options so they aren't modified.
            options = options.copy()

        if self.constant_memory:
            warn("add_table() isn't supported in 'constant_memory' mode")
            return -1

        # Check that row and col are valid without storing the values.
        if self._check_dimensions(first_row, first_col, True, True):
            return -2
        if self._check_dimensions(last_row, last_col, True, True):
            return -2

        # Swap last row/col for first row/col as necessary.
        if first_row > last_row:
            (first_row, last_row) = (last_row, first_row)
        if first_col > last_col:
            (first_col, last_col) = (last_col, first_col)

        # Valid input parameters.
        valid_parameter = {
            'autofilter': True,
            'banded_columns': True,
            'banded_rows': True,
            'columns': True,
            'data': True,
            'first_column': True,
            'header_row': True,
            'last_column': True,
            'name': True,
            'style': True,
            'total_row': True,
        }

        # Check for valid input parameters.
        for param_key in options.keys():
            if param_key not in valid_parameter:
                warn("Unknown parameter '%s' in add_table()" % param_key)
                return -3

        # Turn on Excel's defaults.
        options['banded_rows'] = options.get('banded_rows', True)
        options['header_row'] = options.get('header_row', True)
        options['autofilter'] = options.get('autofilter', True)

        # Check that there are enough rows.
        num_rows = last_row - first_row
        if options['header_row']:
            num_rows -= 1

        if num_rows < 0:
            warn("Must have at least one data row in in add_table()")
            return -3

        # Set the table options.
        table['show_first_col'] = options.get('first_column', False)
        table['show_last_col'] = options.get('last_column', False)
        table['show_row_stripes'] = options.get('banded_rows', False)
        table['show_col_stripes'] = options.get('banded_columns', False)
        table['header_row_count'] = options.get('header_row', 0)
        table['totals_row_shown'] = options.get('total_row', False)

        # Set the table name.
        if 'name' in options:
            name = options['name']
            table['name'] = name

            if ' ' in name:
                warn("Name '%s' in add_table() cannot contain spaces"
                     % force_unicode(name))
                return -3

            # Warn if the name contains invalid chars as defined by Excel.
            if (not re.match(r'^[\w\\][\w\\.]*$', name, re.UNICODE)
                    or re.match(r'^\d', name)):
                warn("Invalid Excel characters in add_table(): '%s'"
                     % force_unicode(name))
                return -1

            # Warn if the name looks like a cell name.
            if re.match(r'^[a-zA-Z][a-zA-Z]?[a-dA-D]?[0-9]+$', name):
                warn("Name looks like a cell name in add_table(): '%s'"
                     % force_unicode(name))
                return -1

            # Warn if the name looks like a R1C1 cell reference.
            if (re.match(r'^[rcRC]$', name)
                    or re.match(r'^[rcRC]\d+[rcRC]\d+$', name)):
                warn("Invalid name '%s' like a RC cell ref in add_table()"
                     % force_unicode(name))
                return -1

        # Set the table style.
        if 'style' in options:
            table['style'] = options['style']

            if table['style'] is None:
                table['style'] = ''

            # Remove whitespace from style name.
            table['style'] = table['style'].replace(' ', '')
        else:
            table['style'] = "TableStyleMedium9"

        # Set the data range rows (without the header and footer).
        first_data_row = first_row
        last_data_row = last_row

        if options.get('header_row'):
            first_data_row += 1

        if options.get('total_row'):
            last_data_row -= 1

        # Set the table and autofilter ranges.
        table['range'] = xl_range(first_row, first_col,
                                  last_row, last_col)

        table['a_range'] = xl_range(first_row, first_col,
                                    last_data_row, last_col)

        # If the header row if off the default is to turn autofilter off.
        if not options['header_row']:
            options['autofilter'] = 0

        # Set the autofilter range.
        if options['autofilter']:
            table['autofilter'] = table['a_range']

        # Add the table columns.
        col_id = 1
        table['columns'] = []
        seen_names = {}

        for col_num in range(first_col, last_col + 1):
            # Set up the default column data.
            col_data = {
                'id': col_id,
                'name': 'Column' + str(col_id),
                'total_string': '',
                'total_function': '',
                'total_value': 0,
                'formula': '',
                'format': None,
                'name_format': None,
            }

            # Overwrite the defaults with any user defined values.
            if 'columns' in options:
                # Check if there are user defined values for this column.
                if col_id <= len(options['columns']):
                    user_data = options['columns'][col_id - 1]
                else:
                    user_data = None

                if user_data:
                    # Get the column format.
                    xformat = user_data.get('format', None)

                    # Map user defined values to internal values.
                    if user_data.get('header'):
                        col_data['name'] = user_data['header']

                    # Excel requires unique case insensitive header names.
                    header_name = col_data['name']
                    name = header_name.lower()
                    if name in seen_names:
                        warn("Duplicate header name in add_table(): '%s'"
                             % force_unicode(name))
                        return -1
                    else:
                        seen_names[name] = True

                    col_data['name_format'] = user_data.get('header_format')

                    # Handle the column formula.
                    if 'formula' in user_data and user_data['formula']:
                        formula = user_data['formula']

                        # Remove the formula '=' sign if it exists.
                        if formula.startswith('='):
                            formula = formula.lstrip('=')

                        # Covert Excel 2010 "@" ref to 2007 "#This Row".
                        formula = formula.replace('@', '[#This Row],')

                        col_data['formula'] = formula

                        for row in range(first_data_row, last_data_row + 1):
                            self._write_formula(row, col_num, formula, xformat)

                    # Handle the function for the total row.
                    if user_data.get('total_function'):
                        function = user_data['total_function']

                        # Massage the function name.
                        function = function.lower()
                        function = function.replace('_', '')
                        function = function.replace(' ', '')

                        if function == 'countnums':
                            function = 'countNums'
                        if function == 'stddev':
                            function = 'stdDev'

                        col_data['total_function'] = function

                        formula = \
                            self._table_function_to_formula(function,
                                                            col_data['name'])

                        value = user_data.get('total_value', 0)

                        self._write_formula(last_row, col_num, formula,
                                            xformat, value)

                    elif user_data.get('total_string'):
                        # Total label only (not a function).
                        total_string = user_data['total_string']
                        col_data['total_string'] = total_string

                        self._write_string(last_row, col_num, total_string,
                                           user_data.get('format'))

                    # Get the dxf format index.
                    if xformat is not None:
                        col_data['format'] = xformat._get_dxf_index()

                    # Store the column format for writing the cell data.
                    # It doesn't matter if it is undefined.
                    col_formats[col_id - 1] = xformat

            # Store the column data.
            table['columns'].append(col_data)

            # Write the column headers to the worksheet.
            if options['header_row']:
                self._write_string(first_row, col_num, col_data['name'],
                                   col_data['name_format'])

            col_id += 1

        # Write the cell data if supplied.
        if 'data' in options:
            data = options['data']

            i = 0  # For indexing the row data.
            for row in range(first_data_row, last_data_row + 1):
                j = 0  # For indexing the col data.
                for col in range(first_col, last_col + 1):
                    if i < len(data) and j < len(data[i]):
                        token = data[i][j]
                        if j in col_formats:
                            self._write(row, col, token, col_formats[j])
                        else:
                            self._write(row, col, token, None)
                    j += 1
                i += 1

        # Store the table data.
        self.tables.append(table)

        return 0

    @convert_cell_args
    def add_sparkline(self, row, col, options=None):
        """
        Add sparklines to the worksheet.

        Args:
            row:     The cell row (zero indexed).
            col:     The cell column (zero indexed).
            options: Sparkline formatting options.

        Returns:
            0:  Success.
            -1: Row or column is out of worksheet bounds.
            -2: Incorrect parameter or option.

        """

        # Check that row and col are valid without storing the values.
        if self._check_dimensions(row, col, True, True):
            return -1

        sparkline = {'locations': [xl_rowcol_to_cell(row, col)]}

        if options is None:
            options = {}

        # Valid input parameters.
        valid_parameters = {
            'location': True,
            'range': True,
            'type': True,
            'high_point': True,
            'low_point': True,
            'negative_points': True,
            'first_point': True,
            'last_point': True,
            'markers': True,
            'style': True,
            'series_color': True,
            'negative_color': True,
            'markers_color': True,
            'first_color': True,
            'last_color': True,
            'high_color': True,
            'low_color': True,
            'max': True,
            'min': True,
            'axis': True,
            'reverse': True,
            'empty_cells': True,
            'show_hidden': True,
            'plot_hidden': True,
            'date_axis': True,
            'weight': True,
        }

        # Check for valid input parameters.
        for param_key in options.keys():
            if param_key not in valid_parameters:
                warn("Unknown parameter '%s' in add_sparkline()" % param_key)
                return -1

        # 'range' is a required parameter.
        if 'range' not in options:
            warn("Parameter 'range' is required in add_sparkline()")
            return -2

        # Handle the sparkline type.
        spark_type = options.get('type', 'line')

        if spark_type not in ('line', 'column', 'win_loss'):
            warn("Parameter 'type' must be 'line', 'column' "
                 "or 'win_loss' in add_sparkline()")
            return -2

        if spark_type == 'win_loss':
            spark_type = 'stacked'
        sparkline['type'] = spark_type

        # We handle single location/range values or list of values.
        if 'location' in options:
            if type(options['location']) is list:
                sparkline['locations'] = options['location']
            else:
                sparkline['locations'] = [options['location']]

        if type(options['range']) is list:
            sparkline['ranges'] = options['range']
        else:
            sparkline['ranges'] = [options['range']]

        range_count = len(sparkline['ranges'])
        location_count = len(sparkline['locations'])

        # The ranges and locations must match.
        if range_count != location_count:
            warn("Must have the same number of location and range "
                 "parameters in add_sparkline()")
            return -2

        # Store the count.
        sparkline['count'] = len(sparkline['locations'])

        # Get the worksheet name for the range conversion below.
        sheetname = quote_sheetname(self.name)

        # Cleanup the input ranges.
        new_ranges = []
        for spark_range in sparkline['ranges']:

            # Remove the absolute reference $ symbols.
            spark_range = spark_range.replace('$', '')

            # Remove the = from formula.
            spark_range = spark_range.lstrip('=')

            # Convert a simple range into a full Sheet1!A1:D1 range.
            if '!' not in spark_range:
                spark_range = sheetname + "!" + spark_range

            new_ranges.append(spark_range)

        sparkline['ranges'] = new_ranges

        # Cleanup the input locations.
        new_locations = []
        for location in sparkline['locations']:
            location = location.replace('$', '')
            new_locations.append(location)

        sparkline['locations'] = new_locations

        # Map options.
        sparkline['high'] = options.get('high_point')
        sparkline['low'] = options.get('low_point')
        sparkline['negative'] = options.get('negative_points')
        sparkline['first'] = options.get('first_point')
        sparkline['last'] = options.get('last_point')
        sparkline['markers'] = options.get('markers')
        sparkline['min'] = options.get('min')
        sparkline['max'] = options.get('max')
        sparkline['axis'] = options.get('axis')
        sparkline['reverse'] = options.get('reverse')
        sparkline['hidden'] = options.get('show_hidden')
        sparkline['weight'] = options.get('weight')

        # Map empty cells options.
        empty = options.get('empty_cells', '')

        if empty == 'zero':
            sparkline['empty'] = 0
        elif empty == 'connect':
            sparkline['empty'] = 'span'
        else:
            sparkline['empty'] = 'gap'

        # Map the date axis range.
        date_range = options.get('date_axis')

        if date_range and '!' not in date_range:
            date_range = sheetname + "!" + date_range

        sparkline['date_axis'] = date_range

        # Set the sparkline styles.
        style_id = options.get('style', 0)
        style = get_sparkline_style(style_id)

        sparkline['series_color'] = style['series']
        sparkline['negative_color'] = style['negative']
        sparkline['markers_color'] = style['markers']
        sparkline['first_color'] = style['first']
        sparkline['last_color'] = style['last']
        sparkline['high_color'] = style['high']
        sparkline['low_color'] = style['low']

        # Override the style colors with user defined colors.
        self._set_spark_color(sparkline, options, 'series_color')
        self._set_spark_color(sparkline, options, 'negative_color')
        self._set_spark_color(sparkline, options, 'markers_color')
        self._set_spark_color(sparkline, options, 'first_color')
        self._set_spark_color(sparkline, options, 'last_color')
        self._set_spark_color(sparkline, options, 'high_color')
        self._set_spark_color(sparkline, options, 'low_color')

        self.sparklines.append(sparkline)

        return 0

    @convert_range_args
    def set_selection(self, first_row, first_col, last_row, last_col):
        """
        Set the selected cell or cells in a worksheet

        Args:
            first_row:    The first row of the cell range. (zero indexed).
            first_col:    The first column of the cell range.
            last_row:     The last row of the cell range. (zero indexed).
            last_col:     The last column of the cell range.

        Returns:
            0:  Nothing.
        """
        pane = None

        # Range selection. Do this before swapping max/min to allow the
        # selection direction to be reversed.
        active_cell = xl_rowcol_to_cell(first_row, first_col)

        # Swap last row/col for first row/col if necessary
        if first_row > last_row:
            (first_row, last_row) = (last_row, first_row)

        if first_col > last_col:
            (first_col, last_col) = (last_col, first_col)

        sqref = xl_range(first_row, first_col, last_row, last_col)

        # Selection isn't set for cell A1.
        if sqref == 'A1':
            return

        self.selections = [[pane, active_cell, sqref]]

    def outline_settings(self, visible=1, symbols_below=1, symbols_right=1,
                         auto_style=0):
        """
        Control outline settings.

        Args:
            visible:       Outlines are visible. Optional, defaults to True.
            symbols_below: Show row outline symbols below the outline bar.
                           Optional, defaults to True.
            symbols_right: Show column outline symbols to the right of the
                           outline bar. Optional, defaults to True.
            auto_style:    Use Automatic style. Optional, defaults to False.

        Returns:
            0:  Nothing.
        """
        self.outline_on = visible
        self.outline_below = symbols_below
        self.outline_right = symbols_right
        self.outline_style = auto_style

        self.outline_changed = True

    @convert_cell_args
    def freeze_panes(self, row, col, top_row=None, left_col=None, pane_type=0):
        """
        Create worksheet panes and mark them as frozen.

        Args:
            row:      The cell row (zero indexed).
            col:      The cell column (zero indexed).
            top_row:  Topmost visible row in scrolling region of pane.
            left_col: Leftmost visible row in scrolling region of pane.

        Returns:
            0:  Nothing.

        """
        if top_row is None:
            top_row = row

        if left_col is None:
            left_col = col

        self.panes = [row, col, top_row, left_col, pane_type]

    @convert_cell_args
    def split_panes(self, x, y, top_row=None, left_col=None):
        """
        Create worksheet panes and mark them as split.

        Args:
            x:        The position for the vertical split.
            y:        The position for the horizontal split.
            top_row:  Topmost visible row in scrolling region of pane.
            left_col: Leftmost visible row in scrolling region of pane.

        Returns:
            0:  Nothing.

        """
        # Same as freeze panes with a different pane type.
        self.freeze_panes(x, y, top_row, left_col, 2)

    def set_zoom(self, zoom=100):
        """
        Set the worksheet zoom factor.

        Args:
            zoom: Scale factor: 10 <= zoom <= 400.

        Returns:
            Nothing.

        """
        # Ensure the zoom scale is in Excel's range.
        if zoom < 10 or zoom > 400:
            warn("Zoom factor %d outside range: 10 <= zoom <= 400" % zoom)
            zoom = 100

        self.zoom = int(zoom)

    def right_to_left(self):
        """
        Display the worksheet right to left for some versions of Excel.

        Args:
            None.

        Returns:
            Nothing.

        """
        self.is_right_to_left = 1

    def hide_zero(self):
        """
        Hide zero values in worksheet cells.

        Args:
            None.

        Returns:
            Nothing.

        """
        self.show_zeros = 0

    def set_tab_color(self, color):
        """
        Set the color of the worksheet tab.

        Args:
            color: A #RGB color index.

        Returns:
            Nothing.

        """
        self.tab_color = xl_color(color)

    def protect(self, password='', options=None):
        """
        Set the password and protection options of the worksheet.

        Args:
            password: An optional password string.
            options:  A dictionary of worksheet objects to protect.

        Returns:
            Nothing.

        """
        if password != '':
            password = self._encode_password(password)

        if not options:
            options = {}

        # Default values for objects that can be protected.
        defaults = {
            'sheet': True,
            'content': False,
            'objects': False,
            'scenarios': False,
            'format_cells': False,
            'format_columns': False,
            'format_rows': False,
            'insert_columns': False,
            'insert_rows': False,
            'insert_hyperlinks': False,
            'delete_columns': False,
            'delete_rows': False,
            'select_locked_cells': True,
            'sort': False,
            'autofilter': False,
            'pivot_tables': False,
            'select_unlocked_cells': True}

        # Overwrite the defaults with user specified values.
        for key in (options.keys()):

            if key in defaults:
                defaults[key] = options[key]
            else:
                warn("Unknown protection object: '%s'" % key)

        # Set the password after the user defined values.
        defaults['password'] = password

        self.protect_options = defaults

    def unprotect_range(self, cell_range, range_name=None, password=None):
        """
        Unprotect ranges within a protected worksheet.

        Args:
            cell_range: The cell or cell range to unprotect.
            range_name: An optional name for the range.
            password:   An optional password string. (undocumented)

        Returns:
            Nothing.

        """
        if cell_range is None:
            warn('Cell range must be specified in unprotect_range()')
            return -1

        # Sanitize the cell range.
        cell_range = cell_range.lstrip('=')
        cell_range = cell_range.replace('$', '')

        self.num_protected_ranges += 1

        if range_name is None:
            range_name = 'Range' + str(self.num_protected_ranges)

        if password:
            password = self._encode_password(password)

        self.protected_ranges.append((cell_range, range_name, password))

    @convert_cell_args
    def insert_button(self, row, col, options=None):
        """
        Insert a button form object into the worksheet.

        Args:
            row:     The cell row (zero indexed).
            col:     The cell column (zero indexed).
            options: Button formatting options.

        Returns:
            0:  Success.
            -1: Row or column is out of worksheet bounds.

        """
        # Check insert (row, col) without storing.
        if self._check_dimensions(row, col, True, True):
            warn('Cannot insert button at (%d, %d).' % (row, col))
            return -1

        if options is None:
            options = {}

        button = self._button_params(row, col, options)

        self.buttons_list.append(button)

        self.has_vml = 1

        return 0

    ###########################################################################
    #
    # Public API. Page Setup methods.
    #
    ###########################################################################
    def set_landscape(self):
        """
        Set the page orientation as landscape.

        Args:
            None.

        Returns:
            Nothing.

        """
        self.orientation = 0
        self.page_setup_changed = True

    def set_portrait(self):
        """
        Set the page orientation as portrait.

        Args:
            None.

        Returns:
            Nothing.

        """
        self.orientation = 1
        self.page_setup_changed = True

    def set_page_view(self):
        """
        Set the page view mode.

        Args:
            None.

        Returns:
            Nothing.

        """
        self.page_view = 1

    def set_paper(self, paper_size):
        """
        Set the paper type. US Letter = 1, A4 = 9.

        Args:
            paper_size: Paper index.

        Returns:
            Nothing.

        """
        if paper_size:
            self.paper_size = paper_size
            self.page_setup_changed = True

    def center_horizontally(self):
        """
        Center the page horizontally.

        Args:
            None.

        Returns:
            Nothing.

        """
        self.print_options_changed = True
        self.hcenter = 1

    def center_vertically(self):
        """
        Center the page vertically.

        Args:
            None.

        Returns:
            Nothing.

        """
        self.print_options_changed = True
        self.vcenter = 1

    def set_margins(self, left=0.7, right=0.7, top=0.75, bottom=0.75):
        """
        Set all the page margins in inches.

        Args:
            left:   Left margin.
            right:  Right margin.
            top:    Top margin.
            bottom: Bottom margin.

        Returns:
            Nothing.

        """
        self.margin_left = left
        self.margin_right = right
        self.margin_top = top
        self.margin_bottom = bottom

    def set_header(self, header='', options=None, margin=None):
        """
        Set the page header caption and optional margin.

        Args:
            header:  Header string.
            margin:  Header margin.
            options: Header options, mainly for images.

        Returns:
            Nothing.

        """
        header_orig = header
        header = header.replace('&[Picture]', '&G')

        if len(header) > 255:
            warn("Header string cannot be longer than Excel's "
                 "limit of 255 characters")
            return

        if options is not None:
            # For backward compatibility allow options to be the margin.
            if not isinstance(options, dict):
                options = {'margin': options}
        else:
            options = {}

        # Copy the user defined options so they aren't modified.
        options = options.copy()

        # For backward compatibility.
        if margin is not None:
            options['margin'] = margin

        # Reset the list in case the function is called more than once.
        self.header_images = []

        if options.get('image_left'):
            self.header_images.append([options.get('image_left'),
                                       options.get('image_data_left'),
                                       'LH'])

        if options.get('image_center'):
            self.header_images.append([options.get('image_center'),
                                       options.get('image_data_center'),
                                       'CH'])

        if options.get('image_right'):
            self.header_images.append([options.get('image_right'),
                                       options.get('image_data_right'),
                                       'RH'])

        placeholder_count = header.count('&G')
        image_count = len(self.header_images)

        if placeholder_count != image_count:
            warn("Number of header images (%s) doesn't match placeholder "
                 "count (%s) in string: %s"
                 % (image_count, placeholder_count, header_orig))
            self.header_images = []
            return

        if 'align_with_margins' in options:
            self.header_footer_aligns = options['align_with_margins']

        if 'scale_with_doc' in options:
            self.header_footer_scales = options['scale_with_doc']

        self.header = header
        self.margin_header = options.get('margin', 0.3)
        self.header_footer_changed = True

        if image_count:
            self.has_header_vml = True

    def set_footer(self, footer='', options=None, margin=None):
        """
        Set the page footer caption and optional margin.

        Args:
            footer:  Footer string.
            margin:  Footer margin.
            options: Footer options, mainly for images.

        Returns:
            Nothing.

        """
        footer_orig = footer
        footer = footer.replace('&[Picture]', '&G')

        if len(footer) > 255:
            warn("Footer string cannot be longer than Excel's "
                 "limit of 255 characters")
            return

        if options is not None:
            # For backward compatibility allow options to be the margin.
            if not isinstance(options, dict):
                options = {'margin': options}
        else:
            options = {}

        # Copy the user defined options so they aren't modified.
        options = options.copy()

        # For backward compatibility.
        if margin is not None:
            options['margin'] = margin

        # Reset the list in case the function is called more than once.
        self.footer_images = []

        if options.get('image_left'):
            self.footer_images.append([options.get('image_left'),
                                       options.get('image_data_left'),
                                       'LF'])

        if options.get('image_center'):
            self.footer_images.append([options.get('image_center'),
                                       options.get('image_data_center'),
                                       'CF'])

        if options.get('image_right'):
            self.footer_images.append([options.get('image_right'),
                                       options.get('image_data_right'),
                                       'RF'])

        placeholder_count = footer.count('&G')
        image_count = len(self.footer_images)

        if placeholder_count != image_count:
            warn("Number of footer images (%s) doesn't match placeholder "
                 "count (%s) in string: %s"
                 % (image_count, placeholder_count, footer_orig))
            self.footer_images = []
            return

        if 'align_with_margins' in options:
            self.header_footer_aligns = options['align_with_margins']

        if 'scale_with_doc' in options:
            self.header_footer_scales = options['scale_with_doc']

        self.footer = footer
        self.margin_footer = options.get('margin', 0.3)
        self.header_footer_changed = True

        if image_count:
            self.has_header_vml = True

    def repeat_rows(self, first_row, last_row=None):
        """
        Set the rows to repeat at the top of each printed page.

        Args:
            first_row: Start row for range.
            last_row: End row for range.

        Returns:
            Nothing.

        """
        if last_row is None:
            last_row = first_row

        # Convert rows to 1 based.
        first_row += 1
        last_row += 1

        # Create the row range area like: $1:$2.
        area = '$%d:$%d' % (first_row, last_row)

        # Build up the print titles area "Sheet1!$1:$2"
        sheetname = quote_sheetname(self.name)
        self.repeat_row_range = sheetname + '!' + area

    @convert_column_args
    def repeat_columns(self, first_col, last_col=None):
        """
        Set the columns to repeat at the left hand side of each printed page.

        Args:
            first_col: Start column for range.
            last_col: End column for range.

        Returns:
            Nothing.

        """
        if last_col is None:
            last_col = first_col

        # Convert to A notation.
        first_col = xl_col_to_name(first_col, 1)
        last_col = xl_col_to_name(last_col, 1)

        # Create a column range like $C:$D.
        area = first_col + ':' + last_col

        # Build up the print area range "=Sheet2!$C:$D"
        sheetname = quote_sheetname(self.name)
        self.repeat_col_range = sheetname + "!" + area

    def hide_gridlines(self, option=1):
        """
        Set the option to hide gridlines on the screen and the printed page.

        Args:
            option:    0 : Don't hide gridlines
                       1 : Hide printed gridlines only
                       2 : Hide screen and printed gridlines

        Returns:
            Nothing.

        """
        if option == 0:
            self.print_gridlines = 1
            self.screen_gridlines = 1
            self.print_options_changed = True
        elif option == 1:
            self.print_gridlines = 0
            self.screen_gridlines = 1
        else:
            self.print_gridlines = 0
            self.screen_gridlines = 0

    def print_row_col_headers(self):
        """
        Set the option to print the row and column headers on the printed page.

        Args:
            None.

        Returns:
            Nothing.

        """
        self.print_headers = True
        self.print_options_changed = True

    def hide_row_col_headers(self):
        """
        Set the option to hide the row and column headers on the worksheet.

        Args:
            None.

        Returns:
            Nothing.

        """
        self.row_col_headers = True

    @convert_range_args
    def print_area(self, first_row, first_col, last_row, last_col):
        """
        Set the print area in the current worksheet.

        Args:
            first_row:    The first row of the cell range. (zero indexed).
            first_col:    The first column of the cell range.
            last_row:     The last row of the cell range. (zero indexed).
            last_col:     The last column of the cell range.

        Returns:
            0:  Success.
            -1: Row or column is out of worksheet bounds.

        """
        # Set the print area in the current worksheet.

        # Ignore max print area since it is the same as no  area for Excel.
        if (first_row == 0 and first_col == 0
                and last_row == self.xls_rowmax - 1
                and last_col == self.xls_colmax - 1):
            return

        # Build up the print area range "Sheet1!$A$1:$C$13".
        area = self._convert_name_area(first_row, first_col,
                                       last_row, last_col)
        self.print_area_range = area

        return 0

    def print_across(self):
        """
        Set the order in which pages are printed.

        Args:
            None.

        Returns:
            Nothing.

        """
        self.page_order = 1
        self.page_setup_changed = True

    def fit_to_pages(self, width, height):
        """
        Fit the printed area to a specific number of pages both vertically and
        horizontally.

        Args:
            width:  Number of pages horizontally.
            height: Number of pages vertically.

        Returns:
            Nothing.

        """
        self.fit_page = 1
        self.fit_width = width
        self.fit_height = height
        self.page_setup_changed = True

    def set_start_page(self, start_page):
        """
        Set the start page number when printing.

        Args:
            start_page: Start page number.

        Returns:
            Nothing.

        """
        self.page_start = start_page

    def set_print_scale(self, scale):
        """
        Set the scale factor for the printed page.

        Args:
            scale: Print scale. 10 <= scale <= 400.

        Returns:
            Nothing.

        """
        # Confine the scale to Excel's range.
        if scale < 10 or scale > 400:
            warn("Print scale '%d' outside range: 10 <= scale <= 400" % scale)
            return

        # Turn off "fit to page" option when print scale is on.
        self.fit_page = 0

        self.print_scale = int(scale)
        self.page_setup_changed = True

    def set_h_pagebreaks(self, breaks):
        """
        Set the horizontal page breaks on a worksheet.

        Args:
            breaks: List of rows where the page breaks should be added.

        Returns:
            Nothing.

        """
        self.hbreaks = breaks

    def set_v_pagebreaks(self, breaks):
        """
        Set the horizontal page breaks on a worksheet.

        Args:
            breaks: List of columns where the page breaks should be added.

        Returns:
            Nothing.

        """
        self.vbreaks = breaks

    def set_vba_name(self, name=None):
        """
        Set the VBA name for the worksheet. By default this is the
        same as the sheet name: i.e., Sheet1 etc.

        Args:
            name: The VBA name for the worksheet.

        Returns:
            Nothing.

        """
        if name is not None:
            self.vba_codename = name
        else:
            self.vba_codename = 'Sheet' + str(self.index + 1)

    def ignore_errors(self, options=None):
        """
        Ignore various Excel errors/warnings in a worksheet for user defined
        ranges.

        Args:
            options: A dict of ignore errors keys with cell range values.

        Returns:
            0: Success.
           -1: Incorrect parameter or option.

        """
        if options is None:
            return -1
        else:
            # Copy the user defined options so they aren't modified.
            options = options.copy()

        # Valid input parameters.
        valid_parameters = {
            'number_stored_as_text': True,
            'eval_error': True,
            'formula_differs': True,
            'formula_range': True,
            'formula_unlocked': True,
            'empty_cell_reference': True,
            'list_data_validation': True,
            'calculated_column': True,
            'two_digit_text_year': True,
        }

        # Check for valid input parameters.
        for param_key in options.keys():
            if param_key not in valid_parameters:
                warn("Unknown parameter '%s' in ignore_errors()" % param_key)
                return -1

        self.ignored_errors = options

        return 0

    ###########################################################################
    #
    # Private API.
    #
    ###########################################################################
    def _initialize(self, init_data):
        self.name = init_data['name']
        self.index = init_data['index']
        self.str_table = init_data['str_table']
        self.worksheet_meta = init_data['worksheet_meta']
        self.constant_memory = init_data['constant_memory']
        self.tmpdir = init_data['tmpdir']
        self.date_1904 = init_data['date_1904']
        self.strings_to_numbers = init_data['strings_to_numbers']
        self.strings_to_formulas = init_data['strings_to_formulas']
        self.strings_to_urls = init_data['strings_to_urls']
        self.nan_inf_to_errors = init_data['nan_inf_to_errors']
        self.default_date_format = init_data['default_date_format']
        self.default_url_format = init_data['default_url_format']
        self.excel2003_style = init_data['excel2003_style']
        self.remove_timezone = init_data['remove_timezone']
        self.max_url_length = init_data['max_url_length']
        self.use_future_functions = init_data['use_future_functions']

        if self.excel2003_style:
            self.original_row_height = 12.75
            self.default_row_height = 12.75
            self.default_row_pixels = 17
            self.margin_left = 0.75
            self.margin_right = 0.75
            self.margin_top = 1
            self.margin_bottom = 1
            self.margin_header = 0.5
            self.margin_footer = 0.5
            self.header_footer_aligns = False

        # Open a temp filehandle to store row data in constant_memory mode.
        if self.constant_memory:
            # This is sub-optimal but we need to create a temp file
            # with utf8 encoding in Python < 3.
            (fd, filename) = tempfile.mkstemp(dir=self.tmpdir)
            os.close(fd)
            self.row_data_filename = filename
            self.row_data_fh = codecs.open(filename, 'w+', 'utf-8')

            # Set as the worksheet filehandle until the file is assembled.
            self.fh = self.row_data_fh

    def _assemble_xml_file(self):
        # Assemble and write the XML file.

        # Write the XML declaration.
        self._xml_declaration()

        # Write the root worksheet element.
        self._write_worksheet()

        # Write the worksheet properties.
        self._write_sheet_pr()

        # Write the worksheet dimensions.
        self._write_dimension()

        # Write the sheet view properties.
        self._write_sheet_views()

        # Write the sheet format properties.
        self._write_sheet_format_pr()

        # Write the sheet column info.
        self._write_cols()

        # Write the worksheet data such as rows columns and cells.
        if not self.constant_memory:
            self._write_sheet_data()
        else:
            self._write_optimized_sheet_data()

        # Write the sheetProtection element.
        self._write_sheet_protection()

        # Write the protectedRanges element.
        self._write_protected_ranges()

        # Write the phoneticPr element.
        if self.excel2003_style:
            self._write_phonetic_pr()

        # Write the autoFilter element.
        self._write_auto_filter()

        # Write the mergeCells element.
        self._write_merge_cells()

        # Write the conditional formats.
        self._write_conditional_formats()

        # Write the dataValidations element.
        self._write_data_validations()

        # Write the hyperlink element.
        self._write_hyperlinks()

        # Write the printOptions element.
        self._write_print_options()

        # Write the worksheet page_margins.
        self._write_page_margins()

        # Write the worksheet page setup.
        self._write_page_setup()

        # Write the headerFooter element.
        self._write_header_footer()

        # Write the rowBreaks element.
        self._write_row_breaks()

        # Write the colBreaks element.
        self._write_col_breaks()

        # Write the ignoredErrors element.
        self._write_ignored_errors()

        # Write the drawing element.
        self._write_drawings()

        # Write the legacyDrawing element.
        self._write_legacy_drawing()

        # Write the legacyDrawingHF element.
        self._write_legacy_drawing_hf()

        # Write the picture element, for the background.
        self._write_picture()

        # Write the tableParts element.
        self._write_table_parts()

        # Write the extLst elements.
        self._write_ext_list()

        # Close the worksheet tag.
        self._xml_end_tag('worksheet')

        # Close the file.
        self._xml_close()

    def _check_dimensions(self, row, col, ignore_row=False, ignore_col=False):
        # Check that row and col are valid and store the max and min
        # values for use in other methods/elements. The ignore_row /
        # ignore_col flags is used to indicate that we wish to perform
        # the dimension check without storing the value. The ignore
        # flags are use by set_row() and data_validate.

        # Check that the row/col are within the worksheet bounds.
        if row < 0 or col < 0:
            return -1
        if row >= self.xls_rowmax or col >= self.xls_colmax:
            return -1

        # In constant_memory mode we don't change dimensions for rows
        # that are already written.
        if not ignore_row and not ignore_col and self.constant_memory:
            if row < self.previous_row:
                return -2

        if not ignore_row:
            if self.dim_rowmin is None or row < self.dim_rowmin:
                self.dim_rowmin = row
            if self.dim_rowmax is None or row > self.dim_rowmax:
                self.dim_rowmax = row

        if not ignore_col:
            if self.dim_colmin is None or col < self.dim_colmin:
                self.dim_colmin = col
            if self.dim_colmax is None or col > self.dim_colmax:
                self.dim_colmax = col

        return 0

    def _convert_date_time(self, dt_obj):
        # Convert a datetime object to an Excel serial date and time.
        return datetime_to_excel_datetime(dt_obj,
                                          self.date_1904,
                                          self.remove_timezone)

    def _convert_name_area(self, row_num_1, col_num_1, row_num_2, col_num_2):
        # Convert zero indexed rows and columns to the format required by
        # worksheet named ranges, eg, "Sheet1!$A$1:$C$13".

        range1 = ''
        range2 = ''
        area = ''
        row_col_only = 0

        # Convert to A1 notation.
        col_char_1 = xl_col_to_name(col_num_1, 1)
        col_char_2 = xl_col_to_name(col_num_2, 1)
        row_char_1 = '$' + str(row_num_1 + 1)
        row_char_2 = '$' + str(row_num_2 + 1)

        # We need to handle special cases that refer to rows or columns only.
        if row_num_1 == 0 and row_num_2 == self.xls_rowmax - 1:
            range1 = col_char_1
            range2 = col_char_2
            row_col_only = 1
        elif col_num_1 == 0 and col_num_2 == self.xls_colmax - 1:
            range1 = row_char_1
            range2 = row_char_2
            row_col_only = 1
        else:
            range1 = col_char_1 + row_char_1
            range2 = col_char_2 + row_char_2

        # A repeated range is only written once (if it isn't a special case).
        if range1 == range2 and not row_col_only:
            area = range1
        else:
            area = range1 + ':' + range2

        # Build up the print area range "Sheet1!$A$1:$C$13".
        sheetname = quote_sheetname(self.name)
        area = sheetname + "!" + area

        return area

    def _sort_pagebreaks(self, breaks):
        # This is an internal method used to filter elements of a list of
        # pagebreaks used in the _store_hbreak() and _store_vbreak() methods.
        # It:
        #   1. Removes duplicate entries from the list.
        #   2. Sorts the list.
        #   3. Removes 0 from the list if present.
        if not breaks:
            return

        breaks_set = set(breaks)

        if 0 in breaks_set:
            breaks_set.remove(0)

        breaks_list = list(breaks_set)
        breaks_list.sort()

        # The Excel 2007 specification says that the maximum number of page
        # breaks is 1026. However, in practice it is actually 1023.
        max_num_breaks = 1023
        if len(breaks_list) > max_num_breaks:
            breaks_list = breaks_list[:max_num_breaks]

        return breaks_list

    def _extract_filter_tokens(self, expression):
        # Extract the tokens from the filter expression. The tokens are mainly
        # non-whitespace groups. The only tricky part is to extract string
        # tokens that contain whitespace and/or quoted double quotes (Excel's
        # escaped quotes).
        #
        # Examples: 'x <  2000'
        #           'x >  2000 and x <  5000'
        #           'x = "foo"'
        #           'x = "foo bar"'
        #           'x = "foo "" bar"'
        #
        if not expression:
            return []

        token_re = re.compile(r'"(?:[^"]|"")*"|\S+')
        tokens = token_re.findall(expression)

        new_tokens = []
        # Remove single leading and trailing quotes and un-escape other quotes.
        for token in tokens:
            if token.startswith('"'):
                token = token[1:]

            if token.endswith('"'):
                token = token[:-1]

            token = token.replace('""', '"')

            new_tokens.append(token)

        return new_tokens

    def _parse_filter_expression(self, expression, tokens):
        # Converts the tokens of a possibly conditional expression into 1 or 2
        # sub expressions for further parsing.
        #
        # Examples:
        #          ('x', '==', 2000) -> exp1
        #          ('x', '>',  2000, 'and', 'x', '<', 5000) -> exp1 and exp2

        if len(tokens) == 7:
            # The number of tokens will be either 3 (for 1 expression)
            # or 7 (for 2  expressions).
            conditional = tokens[3]

            if re.match('(and|&&)', conditional):
                conditional = 0
            elif re.match(r'(or|\|\|)', conditional):
                conditional = 1
            else:
                warn("Token '%s' is not a valid conditional "
                     "in filter expression '%s'" % (conditional, expression))

            expression_1 = self._parse_filter_tokens(expression, tokens[0:3])
            expression_2 = self._parse_filter_tokens(expression, tokens[4:7])

            return expression_1 + [conditional] + expression_2
        else:
            return self._parse_filter_tokens(expression, tokens)

    def _parse_filter_tokens(self, expression, tokens):
        # Parse the 3 tokens of a filter expression and return the operator
        # and token. The use of numbers instead of operators is a legacy of
        # Spreadsheet::WriteExcel.
        operators = {
            '==': 2,
            '=': 2,
            '=~': 2,
            'eq': 2,

            '!=': 5,
            '!~': 5,
            'ne': 5,
            '<>': 5,

            '<': 1,
            '<=': 3,
            '>': 4,
            '>=': 6,
        }

        operator = operators.get(tokens[1], None)
        token = tokens[2]

        # Special handling of "Top" filter expressions.
        if re.match('top|bottom', tokens[0].lower()):
            value = int(tokens[1])

            if value < 1 or value > 500:
                warn("The value '%d' in expression '%s' "
                     "must be in the range 1 to 500" % (value, expression))

            token = token.lower()

            if token != 'items' and token != '%':
                warn("The type '%s' in expression '%s' "
                     "must be either 'items' or '%'" % (token, expression))

            if tokens[0].lower() == 'top':
                operator = 30
            else:
                operator = 32

            if tokens[2] == '%':
                operator += 1

            token = str(value)

        if not operator and tokens[0]:
            warn("Token '%s' is not a valid operator "
                 "in filter expression '%s'" % (token[0], expression))

        # Special handling for Blanks/NonBlanks.
        if re.match('blanks|nonblanks', token.lower()):
            # Only allow Equals or NotEqual in this context.
            if operator != 2 and operator != 5:
                warn("The operator '%s' in expression '%s' "
                     "is not valid in relation to Blanks/NonBlanks'"
                     % (tokens[1], expression))

            token = token.lower()

            # The operator should always be 2 (=) to flag a "simple" equality
            # in the binary record. Therefore we convert <> to =.
            if token == 'blanks':
                if operator == 5:
                    token = ' '
            else:
                if operator == 5:
                    operator = 2
                    token = 'blanks'
                else:
                    operator = 5
                    token = ' '

        # if the string token contains an Excel match character then change the
        # operator type to indicate a non "simple" equality.
        if operator == 2 and re.search('[*?]', token):
            operator = 22

        return [operator, token]

    def _encode_password(self, plaintext):
        # Encode the worksheet protection "password" as a simple hash.
        # Based on the algorithm by Daniel Rentz of OpenOffice.
        i = 0
        count = len(plaintext)
        digits = []

        for char in plaintext:
            i += 1
            char = ord(char) << i
            low_15 = char & 0x7fff
            high_15 = char & 0x7fff << 15
            high_15 >>= 15
            char = low_15 | high_15
            digits.append(char)

        password_hash = 0x0000

        for digit in digits:
            password_hash ^= digit

        password_hash ^= count
        password_hash ^= 0xCE4B

        return "%X" % password_hash

    def _prepare_image(self, index, image_id, drawing_id, width, height,
                       name, image_type, x_dpi, y_dpi, digest):

        # Set up images/drawings.
        drawing_type = 2
        (row, col, _, x_offset, y_offset,
            x_scale, y_scale, url, tip, anchor, _,
            description, decorative) = self.images[index]

        width *= x_scale
        height *= y_scale

        # Scale by non 96dpi resolutions.
        width *= 96.0 / x_dpi
        height *= 96.0 / y_dpi

        dimensions = self._position_object_emus(col, row, x_offset, y_offset,
                                                width, height, anchor)
        # Convert from pixels to emus.
        width = int(0.5 + (width * 9525))
        height = int(0.5 + (height * 9525))

        # Create a Drawing obj to use with worksheet unless one already exists.
        if not self.drawing:
            drawing = Drawing()
            drawing.embedded = 1
            self.drawing = drawing

            self.external_drawing_links.append(['/drawing',
                                                '../drawings/drawing'
                                                + str(drawing_id)
                                                + '.xml', None])
        else:
            drawing = self.drawing

        drawing_object = drawing._add_drawing_object()
        drawing_object['type'] = drawing_type
        drawing_object['dimensions'] = dimensions
        drawing_object['width'] = width
        drawing_object['height'] = height
        drawing_object['description'] = name
        drawing_object['shape'] = None
        drawing_object['anchor'] = anchor
        drawing_object['rel_index'] = 0
        drawing_object['url_rel_index'] = 0
        drawing_object['tip'] = tip
        drawing_object['decorative'] = decorative

        if description is not None:
            drawing_object['description'] = description

        if url:
            target = None
            rel_type = '/hyperlink'
            target_mode = 'External'

            if re.match('(ftp|http)s?://', url):
                target = self._escape_url(url)

            if re.match('^mailto:', url):
                target = self._escape_url(url)

            if re.match('external:', url):
                target = url.replace('external:', '')
                target = self._escape_url(target)
                # Additional escape not required in worksheet hyperlinks.
                target = target.replace('#', '%23')

                if re.match(r'\w:', target) or re.match(r'\\', target):
                    target = 'file:///' + target
                else:
                    target = target.replace('\\', '/')

            if re.match('internal:', url):
                target = url.replace('internal:', '#')
                target_mode = None

            if target is not None:
                if len(target) > self.max_url_length:
                    warn("Ignoring URL '%s' with link and/or anchor > %d "
                         "characters since it exceeds Excel's limit for URLS" %
                         (force_unicode(url), self.max_url_length))
                else:
                    if not self.drawing_rels.get(url):
                        self.drawing_links.append([rel_type, target,
                                                   target_mode])

                    drawing_object['url_rel_index'] = \
                        self._get_drawing_rel_index(url)

        if not self.drawing_rels.get(digest):
            self.drawing_links.append(['/image',
                                       '../media/image'
                                       + str(image_id) + '.'
                                       + image_type])

        drawing_object['rel_index'] = self._get_drawing_rel_index(digest)

    def _prepare_shape(self, index, drawing_id):
        # Set up shapes/drawings.
        drawing_type = 3

        (row, col, x_offset, y_offset, x_scale, y_scale, text, anchor, options,
         description, decorative) = self.shapes[index]

        width = options.get('width', self.default_col_pixels * 3)
        height = options.get('height', self.default_row_pixels * 6)

        width *= x_scale
        height *= y_scale

        dimensions = self._position_object_emus(col, row, x_offset, y_offset,
                                                width, height, anchor)

        # Convert from pixels to emus.
        width = int(0.5 + (width * 9525))
        height = int(0.5 + (height * 9525))

        # Create a Drawing obj to use with worksheet unless one already exists.
        if not self.drawing:
            drawing = Drawing()
            drawing.embedded = 1
            self.drawing = drawing

            self.external_drawing_links.append(['/drawing',
                                                '../drawings/drawing'
                                                + str(drawing_id)
                                                + '.xml', None])
        else:
            drawing = self.drawing

        shape = Shape('rect', 'TextBox', options)
        shape.text = text

        drawing_object = drawing._add_drawing_object()
        drawing_object['type'] = drawing_type
        drawing_object['dimensions'] = dimensions
        drawing_object['width'] = width
        drawing_object['height'] = height
        drawing_object['description'] = description
        drawing_object['shape'] = shape
        drawing_object['anchor'] = anchor
        drawing_object['rel_index'] = 0
        drawing_object['url_rel_index'] = 0
        drawing_object['tip'] = options.get('tip')
        drawing_object['decorative'] = decorative

        url = options.get('url', None)
        if url:
            target = None
            rel_type = '/hyperlink'
            target_mode = 'External'

            if re.match('(ftp|http)s?://', url):
                target = self._escape_url(url)

            if re.match('^mailto:', url):
                target = self._escape_url(url)

            if re.match('external:', url):
                target = url.replace('external:', 'file:///')
                target = self._escape_url(target)
                # Additional escape not required in worksheet hyperlinks.
                target = target.replace('#', '%23')

            if re.match('internal:', url):
                target = url.replace('internal:', '#')
                target_mode = None

            if target is not None:
                if len(target) > self.max_url_length:
                    warn("Ignoring URL '%s' with link and/or anchor > %d "
                         "characters since it exceeds Excel's limit for URLS" %
                         (force_unicode(url), self.max_url_length))
                else:
                    if not self.drawing_rels.get(url):
                        self.drawing_links.append([rel_type, target,
                                                   target_mode])

                    drawing_object['url_rel_index'] = \
                        self._get_drawing_rel_index(url)

    def _prepare_header_image(self, image_id, width, height, name, image_type,
                              position, x_dpi, y_dpi, digest):

        # Set up an image without a drawing object for header/footer images.

        # Strip the extension from the filename.
        name = re.sub(r'\..*$', '', name)

        if not self.vml_drawing_rels.get(digest):
            self.vml_drawing_links.append(['/image',
                                           '../media/image'
                                           + str(image_id) + '.'
                                           + image_type])

        ref_id = self._get_vml_drawing_rel_index(digest)

        self.header_images_list.append([width, height, name, position,
                                        x_dpi, y_dpi, ref_id])

    def _prepare_background(self, image_id, image_type):
        # Set up an image without a drawing object for backgrounds.
        self.external_background_links.append(['/image',
                                               '../media/image'
                                               + str(image_id) + '.'
                                               + image_type])

    def _prepare_chart(self, index, chart_id, drawing_id):
        # Set up chart/drawings.
        drawing_type = 1

        (row, col, chart, x_offset, y_offset, x_scale, y_scale, anchor,
         description, decorative) = self.charts[index]

        chart.id = chart_id - 1

        # Use user specified dimensions, if any.
        width = int(0.5 + (chart.width * x_scale))
        height = int(0.5 + (chart.height * y_scale))

        dimensions = self._position_object_emus(col, row, x_offset, y_offset,
                                                width, height, anchor)

        # Set the chart name for the embedded object if it has been specified.
        name = chart.chart_name

        # Create a Drawing obj to use with worksheet unless one already exists.
        if not self.drawing:
            drawing = Drawing()
            drawing.embedded = 1
            self.drawing = drawing

            self.external_drawing_links.append(['/drawing',
                                                '../drawings/drawing'
                                                + str(drawing_id)
                                                + '.xml'])
        else:
            drawing = self.drawing

        drawing_object = drawing._add_drawing_object()
        drawing_object['type'] = drawing_type
        drawing_object['dimensions'] = dimensions
        drawing_object['width'] = width
        drawing_object['height'] = height
        drawing_object['name'] = name
        drawing_object['shape'] = None
        drawing_object['anchor'] = anchor
        drawing_object['rel_index'] = self._get_drawing_rel_index()
        drawing_object['url_rel_index'] = 0
        drawing_object['tip'] = None
        drawing_object['description'] = description
        drawing_object['decorative'] = decorative

        self.drawing_links.append(['/chart',
                                   '../charts/chart'
                                   + str(chart_id)
                                   + '.xml'])

    def _position_object_emus(self, col_start, row_start, x1, y1,
                              width, height, anchor):
        # Calculate the vertices that define the position of a graphical
        # object within the worksheet in EMUs.
        #
        # The vertices are expressed as English Metric Units (EMUs). There are
        # 12,700 EMUs per point. Therefore, 12,700 * 3 /4 = 9,525 EMUs per
        # pixel
        (col_start, row_start, x1, y1,
         col_end, row_end, x2, y2, x_abs, y_abs) = \
            self._position_object_pixels(col_start, row_start, x1, y1,
                                         width, height, anchor)

        # Convert the pixel values to EMUs. See above.
        x1 = int(0.5 + 9525 * x1)
        y1 = int(0.5 + 9525 * y1)
        x2 = int(0.5 + 9525 * x2)
        y2 = int(0.5 + 9525 * y2)
        x_abs = int(0.5 + 9525 * x_abs)
        y_abs = int(0.5 + 9525 * y_abs)

        return (col_start, row_start, x1, y1, col_end, row_end, x2, y2,
                x_abs, y_abs)

    # Calculate the vertices that define the position of a graphical object
    # within the worksheet in pixels.
    #
    #         +------------+------------+
    #         |     A      |      B     |
    #   +-----+------------+------------+
    #   |     |(x1,y1)     |            |
    #   |  1  |(A1)._______|______      |
    #   |     |    |              |     |
    #   |     |    |              |     |
    #   +-----+----|    OBJECT    |-----+
    #   |     |    |              |     |
    #   |  2  |    |______________.     |
    #   |     |            |        (B2)|
    #   |     |            |     (x2,y2)|
    #   +---- +------------+------------+
    #
    # Example of an object that covers some of the area from cell A1 to  B2.
    #
    # Based on the width and height of the object we need to calculate 8 vars:
    #
    #     col_start, row_start, col_end, row_end, x1, y1, x2, y2.
    #
    # We also calculate the absolute x and y position of the top left vertex of
    # the object. This is required for images.
    #
    # The width and height of the cells that the object occupies can be
    # variable and have to be taken into account.
    #
    # The values of col_start and row_start are passed in from the calling
    # function. The values of col_end and row_end are calculated by
    # subtracting the width and height of the object from the width and
    # height of the underlying cells.
    #
    def _position_object_pixels(self, col_start, row_start, x1, y1,
                                width, height, anchor):
        # col_start       # Col containing upper left corner of object.
        # x1              # Distance to left side of object.
        #
        # row_start       # Row containing top left corner of object.
        # y1              # Distance to top of object.
        #
        # col_end         # Col containing lower right corner of object.
        # x2              # Distance to right side of object.
        #
        # row_end         # Row containing bottom right corner of object.
        # y2              # Distance to bottom of object.
        #
        # width           # Width of object frame.
        # height          # Height of object frame.
        #
        # x_abs           # Absolute distance to left side of object.
        # y_abs           # Absolute distance to top side of object.
        x_abs = 0
        y_abs = 0

        # Adjust start column for negative offsets.
        while x1 < 0 and col_start > 0:
            x1 += self._size_col(col_start - 1)
            col_start -= 1

        # Adjust start row for negative offsets.
        while y1 < 0 and row_start > 0:
            y1 += self._size_row(row_start - 1)
            row_start -= 1

        # Ensure that the image isn't shifted off the page at top left.
        if x1 < 0:
            x1 = 0

        if y1 < 0:
            y1 = 0

        # Calculate the absolute x offset of the top-left vertex.
        if self.col_size_changed:
            for col_id in range(col_start):
                x_abs += self._size_col(col_id)
        else:
            # Optimization for when the column widths haven't changed.
            x_abs += self.default_col_pixels * col_start

        x_abs += x1

        # Calculate the absolute y offset of the top-left vertex.
        if self.row_size_changed:
            for row_id in range(row_start):
                y_abs += self._size_row(row_id)
        else:
            # Optimization for when the row heights haven't changed.
            y_abs += self.default_row_pixels * row_start

        y_abs += y1

        # Adjust start column for offsets that are greater than the col width.
        while x1 >= self._size_col(col_start, anchor):
            x1 -= self._size_col(col_start)
            col_start += 1

        # Adjust start row for offsets that are greater than the row height.
        while y1 >= self._size_row(row_start, anchor):
            y1 -= self._size_row(row_start)
            row_start += 1

        # Initialize end cell to the same as the start cell.
        col_end = col_start
        row_end = row_start

        # Don't offset the image in the cell if the row/col is hidden.
        if self._size_col(col_start, anchor) > 0:
            width = width + x1
        if self._size_row(row_start, anchor) > 0:
            height = height + y1

        # Subtract the underlying cell widths to find end cell of the object.
        while width >= self._size_col(col_end, anchor):
            width -= self._size_col(col_end, anchor)
            col_end += 1

        # Subtract the underlying cell heights to find end cell of the object.
        while height >= self._size_row(row_end, anchor):
            height -= self._size_row(row_end, anchor)
            row_end += 1

        # The end vertices are whatever is left from the width and height.
        x2 = width
        y2 = height

        return ([col_start, row_start, x1, y1, col_end, row_end, x2, y2,
                x_abs, y_abs])

    def _size_col(self, col, anchor=0):
        # Convert the width of a cell from character units to pixels. Excel
        # rounds the column width to the nearest pixel. If the width hasn't
        # been set by the user we use the default value. A hidden column is
        # treated as having a width of zero unless it has the special
        # "object_position" of 4 (size with cells).
        max_digit_width = 7  # For Calabri 11.
        padding = 5
        pixels = 0

        # Look up the cell value to see if it has been changed.
        if col in self.col_sizes:
            width = self.col_sizes[col][0]
            hidden = self.col_sizes[col][1]

            # Convert to pixels.
            if hidden and anchor != 4:
                pixels = 0
            elif width < 1:
                pixels = int(width * (max_digit_width + padding) + 0.5)
            else:
                pixels = int(width * max_digit_width + 0.5) + padding
        else:
            pixels = self.default_col_pixels

        return pixels

    def _size_row(self, row, anchor=0):
        # Convert the height of a cell from character units to pixels. If the
        # height hasn't been set by the user we use the default value. A
        # hidden row is treated as having a height of zero unless it has the
        # special "object_position" of 4 (size with cells).
        pixels = 0

        # Look up the cell value to see if it has been changed
        if row in self.row_sizes:
            height = self.row_sizes[row][0]
            hidden = self.row_sizes[row][1]

            if hidden and anchor != 4:
                pixels = 0
            else:
                pixels = int(4.0 / 3.0 * height)
        else:
            pixels = int(4.0 / 3.0 * self.default_row_height)

        return pixels

    def _pixels_to_width(self, pixels):
        # Convert the width of a cell from pixels to character units.
        max_digit_width = 7.0  # For Calabri 11.
        padding = 5.0

        if pixels <= 12:
            width = pixels / (max_digit_width + padding)
        else:
            width = (pixels - padding) / max_digit_width

        return width

    def _pixels_to_height(self, pixels):
        # Convert the height of a cell from pixels to character units.
        return 0.75 * pixels

    def _comment_params(self, row, col, string, options):
        # This method handles the additional optional parameters to
        # write_comment() as well as calculating the comment object
        # position and vertices.
        default_width = 128
        default_height = 74
        anchor = 0

        params = {
            'author': None,
            'color': '#ffffe1',
            'start_cell': None,
            'start_col': None,
            'start_row': None,
            'visible': None,
            'width': default_width,
            'height': default_height,
            'x_offset': None,
            'x_scale': 1,
            'y_offset': None,
            'y_scale': 1,
            'font_name': 'Tahoma',
            'font_size': 8,
            'font_family': 2,
        }

        # Overwrite the defaults with any user supplied values. Incorrect or
        # misspelled parameters are silently ignored.
        for key in options.keys():
            params[key] = options[key]

        # Ensure that a width and height have been set.
        if not params['width']:
            params['width'] = default_width
        if not params['height']:
            params['height'] = default_height

        # Set the comment background color.
        params['color'] = xl_color(params['color']).lower()

        # Convert from Excel XML style color to XML html style color.
        params['color'] = params['color'].replace('ff', '#', 1)

        # Convert a cell reference to a row and column.
        if params['start_cell'] is not None:
            (start_row, start_col) = xl_cell_to_rowcol(params['start_cell'])
            params['start_row'] = start_row
            params['start_col'] = start_col

        # Set the default start cell and offsets for the comment. These are
        # generally fixed in relation to the parent cell. However there are
        # some edge cases for cells at the, er, edges.
        row_max = self.xls_rowmax
        col_max = self.xls_colmax

        if params['start_row'] is None:
            if row == 0:
                params['start_row'] = 0
            elif row == row_max - 3:
                params['start_row'] = row_max - 7
            elif row == row_max - 2:
                params['start_row'] = row_max - 6
            elif row == row_max - 1:
                params['start_row'] = row_max - 5
            else:
                params['start_row'] = row - 1

        if params['y_offset'] is None:
            if row == 0:
                params['y_offset'] = 2
            elif row == row_max - 3:
                params['y_offset'] = 16
            elif row == row_max - 2:
                params['y_offset'] = 16
            elif row == row_max - 1:
                params['y_offset'] = 14
            else:
                params['y_offset'] = 10

        if params['start_col'] is None:
            if col == col_max - 3:
                params['start_col'] = col_max - 6
            elif col == col_max - 2:
                params['start_col'] = col_max - 5
            elif col == col_max - 1:
                params['start_col'] = col_max - 4
            else:
                params['start_col'] = col + 1

        if params['x_offset'] is None:
            if col == col_max - 3:
                params['x_offset'] = 49
            elif col == col_max - 2:
                params['x_offset'] = 49
            elif col == col_max - 1:
                params['x_offset'] = 49
            else:
                params['x_offset'] = 15

        # Scale the size of the comment box if required.
        if params['x_scale']:
            params['width'] = params['width'] * params['x_scale']

        if params['y_scale']:
            params['height'] = params['height'] * params['y_scale']

        # Round the dimensions to the nearest pixel.
        params['width'] = int(0.5 + params['width'])
        params['height'] = int(0.5 + params['height'])

        # Calculate the positions of the comment object.
        vertices = self._position_object_pixels(
            params['start_col'], params['start_row'], params['x_offset'],
            params['y_offset'], params['width'], params['height'], anchor)

        # Add the width and height for VML.
        vertices.append(params['width'])
        vertices.append(params['height'])

        return ([row, col, string, params['author'],
                 params['visible'], params['color'],
                 params['font_name'], params['font_size'],
                 params['font_family']] + [vertices])

    def _button_params(self, row, col, options):
        # This method handles the parameters passed to insert_button() as well
        # as calculating the comment object position and vertices.

        default_height = self.default_row_pixels
        default_width = self.default_col_pixels
        anchor = 0

        button_number = 1 + len(self.buttons_list)
        button = {'row': row, 'col': col, 'font': {}}
        params = {}

        # Overwrite the defaults with any user supplied values. Incorrect or
        # misspelled parameters are silently ignored.
        for key in options.keys():
            params[key] = options[key]

        # Set the button caption.
        caption = params.get('caption')

        # Set a default caption if none was specified by user.
        if caption is None:
            caption = 'Button %d' % button_number

        button['font']['caption'] = caption

        # Set the macro name.
        if params.get('macro'):
            button['macro'] = '[0]!' + params['macro']
        else:
            button['macro'] = '[0]!Button%d_Click' % button_number

        # Set the alt text for the button.
        button['description'] = params.get('description')

        # Ensure that a width and height have been set.
        params['width'] = params.get('width', default_width)
        params['height'] = params.get('height', default_height)

        # Set the x/y offsets.
        params['x_offset'] = params.get('x_offset', 0)
        params['y_offset'] = params.get('y_offset', 0)

        # Scale the size of the button if required.
        params['width'] = params['width'] * params.get('x_scale', 1)
        params['height'] = params['height'] * params.get('y_scale', 1)

        # Round the dimensions to the nearest pixel.
        params['width'] = int(0.5 + params['width'])
        params['height'] = int(0.5 + params['height'])

        params['start_row'] = row
        params['start_col'] = col

        # Calculate the positions of the button object.
        vertices = self._position_object_pixels(
            params['start_col'], params['start_row'], params['x_offset'],
            params['y_offset'], params['width'], params['height'], anchor)

        # Add the width and height for VML.
        vertices.append(params['width'])
        vertices.append(params['height'])

        button['vertices'] = vertices

        return button

    def _prepare_vml_objects(self, vml_data_id, vml_shape_id, vml_drawing_id,
                             comment_id):
        comments = []
        # Sort the comments into row/column order for easier comparison
        # testing and set the external links for comments and buttons.
        row_nums = sorted(self.comments.keys())

        for row in row_nums:
            col_nums = sorted(self.comments[row].keys())

            for col in col_nums:
                user_options = self.comments[row][col]
                params = self._comment_params(*user_options)
                self.comments[row][col] = params

                # Set comment visibility if required and not user defined.
                if self.comments_visible:
                    if self.comments[row][col][4] is None:
                        self.comments[row][col][4] = 1

                # Set comment author if not already user defined.
                if self.comments[row][col][3] is None:
                    self.comments[row][col][3] = self.comments_author

                comments.append(self.comments[row][col])

        self.external_vml_links.append(['/vmlDrawing',
                                        '../drawings/vmlDrawing'
                                        + str(vml_drawing_id)
                                        + '.vml'])

        if self.has_comments:
            self.comments_list = comments

            self.external_comment_links.append(['/comments',
                                                '../comments'
                                                + str(comment_id)
                                                + '.xml'])

        count = len(comments)
        start_data_id = vml_data_id

        # The VML o:idmap data id contains a comma separated range when there
        # is more than one 1024 block of comments, like this: data="1,2".
        for i in range(int(count / 1024)):
            vml_data_id = '%s,%d' % (vml_data_id, start_data_id + i + 1)

        self.vml_data_id = vml_data_id
        self.vml_shape_id = vml_shape_id

        return count

    def _prepare_header_vml_objects(self, vml_header_id, vml_drawing_id):
        # Set up external linkage for VML header/footer images.

        self.vml_header_id = vml_header_id

        self.external_vml_links.append(['/vmlDrawing',
                                        '../drawings/vmlDrawing'
                                        + str(vml_drawing_id) + '.vml'])

    def _prepare_tables(self, table_id, seen):
        # Set the table ids for the worksheet tables.
        for table in self.tables:
            table['id'] = table_id

            if table.get('name') is None:
                # Set a default name.
                table['name'] = 'Table' + str(table_id)

            # Check for duplicate table names.
            name = table['name'].lower()

            if name in seen:
                raise DuplicateTableName(
                    "Duplicate name '%s' used in worksheet.add_table()." %
                    table['name'])
            else:
                seen[name] = True

            # Store the link used for the rels file.
            self.external_table_links.append(['/table',
                                              '../tables/table'
                                              + str(table_id)
                                              + '.xml'])
            table_id += 1

    def _table_function_to_formula(self, function, col_name):
        # Convert a table total function to a worksheet formula.
        formula = ''

        # Escape special characters, as required by Excel.
        col_name = col_name.replace("'", "''")
        col_name = col_name.replace("#", "'#")
        col_name = col_name.replace("]", "']")
        col_name = col_name.replace("[", "'[")

        subtotals = {
            'average': 101,
            'countNums': 102,
            'count': 103,
            'max': 104,
            'min': 105,
            'stdDev': 107,
            'sum': 109,
            'var': 110,
        }

        if function in subtotals:
            func_num = subtotals[function]
            formula = "SUBTOTAL(%s,[%s])" % (func_num, col_name)
        else:
            warn("Unsupported function '%s' in add_table()" % function)

        return formula

    def _set_spark_color(self, sparkline, options, user_color):
        # Set the sparkline color.
        if user_color not in options:
            return

        sparkline[user_color] = {'rgb': xl_color(options[user_color])}

    def _get_range_data(self, row_start, col_start, row_end, col_end):
        # Returns a range of data from the worksheet _table to be used in
        # chart cached data. Strings are returned as SST ids and decoded
        # in the workbook. Return None for data that doesn't exist since
        # Excel can chart series with data missing.

        if self.constant_memory:
            return ()

        data = []

        # Iterate through the table data.
        for row_num in range(row_start, row_end + 1):
            # Store None if row doesn't exist.
            if row_num not in self.table:
                data.append(None)
                continue

            for col_num in range(col_start, col_end + 1):

                if col_num in self.table[row_num]:
                    cell = self.table[row_num][col_num]

                    type_cell_name = type(cell).__name__

                    if type_cell_name == 'Number':
                        # Return a number with Excel's precision.
                        data.append("%.16g" % cell.number)

                    elif type_cell_name == 'String':
                        # Return a string from it's shared string index.
                        index = cell.string
                        string = self.str_table._get_shared_string(index)

                        data.append(string)

                    elif (type_cell_name == 'Formula'
                            or type_cell_name == 'ArrayFormula'):
                        # Return the formula value.
                        value = cell.value

                        if value is None:
                            value = 0

                        data.append(value)

                    elif type_cell_name == 'Blank':
                        # Return a empty cell.
                        data.append('')
                else:

                    # Store None if column doesn't exist.
                    data.append(None)

        return data

    def _csv_join(self, *items):
        # Create a csv string for use with data validation formulas and lists.

        # Convert non string types to string.
        items = [str(item) if not isinstance(item, str_types) else item
                 for item in items]

        return ','.join(items)

    def _escape_url(self, url):
        # Don't escape URL if it looks already escaped.
        if re.search('%[0-9a-fA-F]{2}', url):
            return url

        # Can't use url.quote() here because it doesn't match Excel.
        url = url.replace('%', '%25')
        url = url.replace('"', '%22')
        url = url.replace(' ', '%20')
        url = url.replace('<', '%3c')
        url = url.replace('>', '%3e')
        url = url.replace('[', '%5b')
        url = url.replace(']', '%5d')
        url = url.replace('^', '%5e')
        url = url.replace('`', '%60')
        url = url.replace('{', '%7b')
        url = url.replace('}', '%7d')

        return url

    def _get_drawing_rel_index(self, target=None):
        # Get the index used to address a drawing rel link.
        if target is None:
            self.drawing_rels_id += 1
            return self.drawing_rels_id
        elif self.drawing_rels.get(target):
            return self.drawing_rels[target]
        else:
            self.drawing_rels_id += 1
            self.drawing_rels[target] = self.drawing_rels_id
            return self.drawing_rels_id

    def _get_vml_drawing_rel_index(self, target=None):
        # Get the index used to address a vml drawing rel link.
        if self.vml_drawing_rels.get(target):
            return self.vml_drawing_rels[target]
        else:
            self.vml_drawing_rels_id += 1
            self.vml_drawing_rels[target] = self.vml_drawing_rels_id
            return self.vml_drawing_rels_id

    ###########################################################################
    #
    # The following font methods are, more or less, duplicated from the
    # Styles class. Not the cleanest version of reuse but works for now.
    #
    ###########################################################################
    def _write_font(self, xf_format):
        # Write the <font> element.
        xml_writer = self.rstring

        xml_writer._xml_start_tag('rPr')

        # Handle the main font properties.
        if xf_format.bold:
            xml_writer._xml_empty_tag('b')
        if xf_format.italic:
            xml_writer._xml_empty_tag('i')
        if xf_format.font_strikeout:
            xml_writer._xml_empty_tag('strike')
        if xf_format.font_outline:
            xml_writer._xml_empty_tag('outline')
        if xf_format.font_shadow:
            xml_writer._xml_empty_tag('shadow')

        # Handle the underline variants.
        if xf_format.underline:
            self._write_underline(xf_format.underline)

        # Handle super/subscript.
        if xf_format.font_script == 1:
            self._write_vert_align('superscript')
        if xf_format.font_script == 2:
            self._write_vert_align('subscript')

        # Write the font size
        xml_writer._xml_empty_tag('sz', [('val', xf_format.font_size)])

        # Handle colors.
        if xf_format.theme == -1:
            # Ignore for excel2003_style.
            pass
        elif xf_format.theme:
            self._write_color('theme', xf_format.theme)
        elif xf_format.color_indexed:
            self._write_color('indexed', xf_format.color_indexed)
        elif xf_format.font_color:
            color = self._get_palette_color(xf_format.font_color)
            self._write_rstring_color('rgb', color)
        else:
            self._write_rstring_color('theme', 1)

        # Write some other font properties related to font families.
        xml_writer._xml_empty_tag('rFont', [('val', xf_format.font_name)])
        xml_writer._xml_empty_tag('family', [('val', xf_format.font_family)])

        if xf_format.font_name == 'Calibri' and not xf_format.hyperlink:
            xml_writer._xml_empty_tag('scheme',
                                      [('val', xf_format.font_scheme)])

        xml_writer._xml_end_tag('rPr')

    def _write_underline(self, underline):
        # Write the underline font element.
        attributes = []

        # Handle the underline variants.
        if underline == 2:
            attributes = [('val', 'double')]
        elif underline == 33:
            attributes = [('val', 'singleAccounting')]
        elif underline == 34:
            attributes = [('val', 'doubleAccounting')]

        self.rstring._xml_empty_tag('u', attributes)

    def _write_vert_align(self, val):
        # Write the <vertAlign> font sub-element.
        attributes = [('val', val)]

        self.rstring._xml_empty_tag('vertAlign', attributes)

    def _write_rstring_color(self, name, value):
        # Write the <color> element.
        attributes = [(name, value)]

        self.rstring._xml_empty_tag('color', attributes)

    def _get_palette_color(self, color):
        # Convert the RGB color.
        if color[0] == '#':
            color = color[1:]

        return "FF" + color.upper()

    def _opt_close(self):
        # Close the row data filehandle in constant_memory mode.
        if not self.row_data_fh_closed:
            self.row_data_fh.close()
            self.row_data_fh_closed = True

    def _opt_reopen(self):
        # Reopen the row data filehandle in constant_memory mode.
        if self.row_data_fh_closed:
            filename = self.row_data_filename
            self.row_data_fh = codecs.open(filename, 'a+', 'utf-8')
            self.row_data_fh_closed = False
            self.fh = self.row_data_fh

    def _set_icon_props(self, total_icons, user_props=None):
        # Set the sub-properties for icons.
        props = []

        # Set the defaults.
        for _ in range(total_icons):
            props.append({'criteria': False,
                          'value': 0,
                          'type': 'percent'})

        # Set the default icon values based on the number of icons.
        if total_icons == 3:
            props[0]['value'] = 67
            props[1]['value'] = 33

        if total_icons == 4:
            props[0]['value'] = 75
            props[1]['value'] = 50
            props[2]['value'] = 25

        if total_icons == 5:
            props[0]['value'] = 80
            props[1]['value'] = 60
            props[2]['value'] = 40
            props[3]['value'] = 20

        # Overwrite default properties with user defined properties.
        if user_props:

            # Ensure we don't set user properties for lowest icon.
            max_data = len(user_props)
            if max_data >= total_icons:
                max_data = total_icons - 1

            for i in range(max_data):

                # Set the user defined 'value' property.
                if user_props[i].get('value') is not None:
                    props[i]['value'] = user_props[i]['value']

                    # Remove the formula '=' sign if it exists.
                    tmp = props[i]['value']
                    if isinstance(tmp, str_types) and tmp.startswith('='):
                        props[i]['value'] = tmp.lstrip('=')

                # Set the user defined 'type' property.
                if user_props[i].get('type'):
                    valid_types = ('percent',
                                   'percentile',
                                   'number',
                                   'formula')

                    if user_props[i]['type'] not in valid_types:
                        warn("Unknown icon property type '%s' for sub-"
                             "property 'type' in conditional_format()" %
                             user_props[i]['type'])
                    else:
                        props[i]['type'] = user_props[i]['type']

                        if props[i]['type'] == 'number':
                            props[i]['type'] = 'num'

                # Set the user defined 'criteria' property.
                criteria = user_props[i].get('criteria')
                if criteria and criteria == '>':
                    props[i]['criteria'] = True

        return props

    ###########################################################################
    #
    # XML methods.
    #
    ###########################################################################

    def _write_worksheet(self):
        # Write the <worksheet> element. This is the root element.

        schema = 'http://schemas.openxmlformats.org/'
        xmlns = schema + 'spreadsheetml/2006/main'
        xmlns_r = schema + 'officeDocument/2006/relationships'
        xmlns_mc = schema + 'markup-compatibility/2006'
        ms_schema = 'http://schemas.microsoft.com/'
        xmlns_x14ac = ms_schema + 'office/spreadsheetml/2009/9/ac'

        attributes = [
            ('xmlns', xmlns),
            ('xmlns:r', xmlns_r)]

        # Add some extra attributes for Excel 2010. Mainly for sparklines.
        if self.excel_version == 2010:
            attributes.append(('xmlns:mc', xmlns_mc))
            attributes.append(('xmlns:x14ac', xmlns_x14ac))
            attributes.append(('mc:Ignorable', 'x14ac'))

        self._xml_start_tag('worksheet', attributes)

    def _write_dimension(self):
        # Write the <dimension> element. This specifies the range of
        # cells in the worksheet. As a special case, empty
        # spreadsheets use 'A1' as a range.

        if self.dim_rowmin is None and self.dim_colmin is None:
            # If the min dimensions are not defined then no dimensions
            # have been set and we use the default 'A1'.
            ref = 'A1'

        elif self.dim_rowmin is None and self.dim_colmin is not None:
            # If the row dimensions aren't set but the column
            # dimensions are set then they have been changed via
            # set_column().

            if self.dim_colmin == self.dim_colmax:
                # The dimensions are a single cell and not a range.
                ref = xl_rowcol_to_cell(0, self.dim_colmin)
            else:
                # The dimensions are a cell range.
                cell_1 = xl_rowcol_to_cell(0, self.dim_colmin)
                cell_2 = xl_rowcol_to_cell(0, self.dim_colmax)
                ref = cell_1 + ':' + cell_2

        elif (self.dim_rowmin == self.dim_rowmax and
              self.dim_colmin == self.dim_colmax):
            # The dimensions are a single cell and not a range.
            ref = xl_rowcol_to_cell(self.dim_rowmin, self.dim_colmin)
        else:
            # The dimensions are a cell range.
            cell_1 = xl_rowcol_to_cell(self.dim_rowmin, self.dim_colmin)
            cell_2 = xl_rowcol_to_cell(self.dim_rowmax, self.dim_colmax)
            ref = cell_1 + ':' + cell_2

        self._xml_empty_tag('dimension', [('ref', ref)])

    def _write_sheet_views(self):
        # Write the <sheetViews> element.
        self._xml_start_tag('sheetViews')

        # Write the sheetView element.
        self._write_sheet_view()

        self._xml_end_tag('sheetViews')

    def _write_sheet_view(self):
        # Write the <sheetViews> element.
        attributes = []

        # Hide screen gridlines if required.
        if not self.screen_gridlines:
            attributes.append(('showGridLines', 0))

        # Hide screen row/column headers.
        if self.row_col_headers:
            attributes.append(('showRowColHeaders', 0))

        # Hide zeroes in cells.
        if not self.show_zeros:
            attributes.append(('showZeros', 0))

        # Display worksheet right to left for Hebrew, Arabic and others.
        if self.is_right_to_left:
            attributes.append(('rightToLeft', 1))

        # Show that the sheet tab is selected.
        if self.selected:
            attributes.append(('tabSelected', 1))

        # Turn outlines off. Also required in the outlinePr element.
        if not self.outline_on:
            attributes.append(("showOutlineSymbols", 0))

        # Set the page view/layout mode if required.
        if self.page_view:
            attributes.append(('view', 'pageLayout'))

        # Set the zoom level.
        if self.zoom != 100:
            if not self.page_view:
                attributes.append(('zoomScale', self.zoom))
                if self.zoom_scale_normal:
                    attributes.append(('zoomScaleNormal', self.zoom))

        attributes.append(('workbookViewId', 0))

        if self.panes or len(self.selections):
            self._xml_start_tag('sheetView', attributes)
            self._write_panes()
            self._write_selections()
            self._xml_end_tag('sheetView')
        else:
            self._xml_empty_tag('sheetView', attributes)

    def _write_sheet_format_pr(self):
        # Write the <sheetFormatPr> element.
        default_row_height = self.default_row_height
        row_level = self.outline_row_level
        col_level = self.outline_col_level

        attributes = [('defaultRowHeight', default_row_height)]

        if self.default_row_height != self.original_row_height:
            attributes.append(('customHeight', 1))

        if self.default_row_zeroed:
            attributes.append(('zeroHeight', 1))

        if row_level:
            attributes.append(('outlineLevelRow', row_level))
        if col_level:
            attributes.append(('outlineLevelCol', col_level))

        if self.excel_version == 2010:
            attributes.append(('x14ac:dyDescent', '0.25'))

        self._xml_empty_tag('sheetFormatPr', attributes)

    def _write_cols(self):
        # Write the <cols> element and <col> sub elements.

        # Exit unless some column have been formatted.
        if not self.colinfo:
            return

        self._xml_start_tag('cols')

        for col in sorted(self.colinfo.keys()):
            self._write_col_info(self.colinfo[col])

        self._xml_end_tag('cols')

    def _write_col_info(self, col_info):
        # Write the <col> element.

        (col_min, col_max, width, cell_format,
         hidden, level, collapsed) = col_info

        custom_width = 1
        xf_index = 0

        # Get the cell_format index.
        if cell_format:
            xf_index = cell_format._get_xf_index()

        # Set the Excel default column width.
        if width is None:
            if not hidden:
                width = 8.43
                custom_width = 0
            else:
                width = 0
        elif width == 8.43:
            # Width is defined but same as default.
            custom_width = 0

        # Convert column width from user units to character width.
        if width > 0:
            # For Calabri 11.
            max_digit_width = 7
            padding = 5

            if width < 1:
                width = int((int(width * (max_digit_width + padding) + 0.5))
                            / float(max_digit_width) * 256.0) / 256.0
            else:
                width = int((int(width * max_digit_width + 0.5) + padding)
                            / float(max_digit_width) * 256.0) / 256.0

        attributes = [
            ('min', col_min + 1),
            ('max', col_max + 1),
            ('width', "%.16g" % width)]

        if xf_index:
            attributes.append(('style', xf_index))
        if hidden:
            attributes.append(('hidden', '1'))
        if custom_width:
            attributes.append(('customWidth', '1'))
        if level:
            attributes.append(('outlineLevel', level))
        if collapsed:
            attributes.append(('collapsed', '1'))

        self._xml_empty_tag('col', attributes)

    def _write_sheet_data(self):
        # Write the <sheetData> element.

        if self.dim_rowmin is None:
            # If the dimensions aren't defined there is no data to write.
            self._xml_empty_tag('sheetData')
        else:
            self._xml_start_tag('sheetData')
            self._write_rows()
            self._xml_end_tag('sheetData')

    def _write_optimized_sheet_data(self):
        # Write the <sheetData> element when constant_memory is on. In this
        # case we read the data stored in the temp file and rewrite it to the
        # XML sheet file.
        if self.dim_rowmin is None:
            # If the dimensions aren't defined then there is no data to write.
            self._xml_empty_tag('sheetData')
        else:
            self._xml_start_tag('sheetData')

            # Rewind the filehandle that was used for temp row data.
            buff_size = 65536
            self.row_data_fh.seek(0)
            data = self.row_data_fh.read(buff_size)

            while data:
                self.fh.write(data)
                data = self.row_data_fh.read(buff_size)

            self.row_data_fh.close()
            os.unlink(self.row_data_filename)

            self._xml_end_tag('sheetData')

    def _write_page_margins(self):
        # Write the <pageMargins> element.
        attributes = [
            ('left', self.margin_left),
            ('right', self.margin_right),
            ('top', self.margin_top),
            ('bottom', self.margin_bottom),
            ('header', self.margin_header),
            ('footer', self.margin_footer)]

        self._xml_empty_tag('pageMargins', attributes)

    def _write_page_setup(self):
        # Write the <pageSetup> element.
        #
        # The following is an example taken from Excel.
        #
        # <pageSetup
        #     paperSize="9"
        #     scale="110"
        #     fitToWidth="2"
        #     fitToHeight="2"
        #     pageOrder="overThenDown"
        #     orientation="portrait"
        #     blackAndWhite="1"
        #     draft="1"
        #     horizontalDpi="200"
        #     verticalDpi="200"
        #     r:id="rId1"
        # />
        #
        attributes = []

        # Skip this element if no page setup has changed.
        if not self.page_setup_changed:
            return

        # Set paper size.
        if self.paper_size:
            attributes.append(('paperSize', self.paper_size))

        # Set the print_scale.
        if self.print_scale != 100:
            attributes.append(('scale', self.print_scale))

        # Set the "Fit to page" properties.
        if self.fit_page and self.fit_width != 1:
            attributes.append(('fitToWidth', self.fit_width))

        if self.fit_page and self.fit_height != 1:
            attributes.append(('fitToHeight', self.fit_height))

        # Set the page print direction.
        if self.page_order:
            attributes.append(('pageOrder', "overThenDown"))

        # Set start page for printing.
        if self.page_start > 1:
            attributes.append(('firstPageNumber', self.page_start))

        # Set page orientation.
        if self.orientation:
            attributes.append(('orientation', 'portrait'))
        else:
            attributes.append(('orientation', 'landscape'))

        # Set start page for printing.
        if self.page_start != 0:
            attributes.append(('useFirstPageNumber', '1'))

        # Set the DPI. Mainly only for testing.
        if self.is_chartsheet:
            if self.horizontal_dpi:
                attributes.append(('horizontalDpi', self.horizontal_dpi))

            if self.vertical_dpi:
                attributes.append(('verticalDpi', self.vertical_dpi))
        else:
            if self.vertical_dpi:
                attributes.append(('verticalDpi', self.vertical_dpi))

            if self.horizontal_dpi:
                attributes.append(('horizontalDpi', self.horizontal_dpi))

        self._xml_empty_tag('pageSetup', attributes)

    def _write_print_options(self):
        # Write the <printOptions> element.
        attributes = []

        if not self.print_options_changed:
            return

        # Set horizontal centering.
        if self.hcenter:
            attributes.append(('horizontalCentered', 1))

        # Set vertical centering.
        if self.vcenter:
            attributes.append(('verticalCentered', 1))

        # Enable row and column headers.
        if self.print_headers:
            attributes.append(('headings', 1))

        # Set printed gridlines.
        if self.print_gridlines:
            attributes.append(('gridLines', 1))

        self._xml_empty_tag('printOptions', attributes)

    def _write_header_footer(self):
        # Write the <headerFooter> element.
        attributes = []

        if not self.header_footer_scales:
            attributes.append(('scaleWithDoc', 0))

        if not self.header_footer_aligns:
            attributes.append(('alignWithMargins', 0))

        if self.header_footer_changed:
            self._xml_start_tag('headerFooter', attributes)
            if self.header:
                self._write_odd_header()
            if self.footer:
                self._write_odd_footer()
            self._xml_end_tag('headerFooter')
        elif self.excel2003_style:
            self._xml_empty_tag('headerFooter', attributes)

    def _write_odd_header(self):
        # Write the <headerFooter> element.
        self._xml_data_element('oddHeader', self.header)

    def _write_odd_footer(self):
        # Write the <headerFooter> element.
        self._xml_data_element('oddFooter', self.footer)

    def _write_rows(self):
        # Write out the worksheet data as a series of rows and cells.
        self._calculate_spans()

        for row_num in range(self.dim_rowmin, self.dim_rowmax + 1):

            if (row_num in self.set_rows or row_num in self.comments
                    or self.table[row_num]):
                # Only process rows with formatting, cell data and/or comments.

                span_index = int(row_num / 16)

                if span_index in self.row_spans:
                    span = self.row_spans[span_index]
                else:
                    span = None

                if self.table[row_num]:
                    # Write the cells if the row contains data.
                    if row_num not in self.set_rows:
                        self._write_row(row_num, span)
                    else:
                        self._write_row(row_num, span, self.set_rows[row_num])

                    for col_num in range(self.dim_colmin, self.dim_colmax + 1):
                        if col_num in self.table[row_num]:
                            col_ref = self.table[row_num][col_num]
                            self._write_cell(row_num, col_num, col_ref)

                    self._xml_end_tag('row')

                elif row_num in self.comments:
                    # Row with comments in cells.
                    self._write_empty_row(row_num, span,
                                          self.set_rows[row_num])
                else:
                    # Blank row with attributes only.
                    self._write_empty_row(row_num, span,
                                          self.set_rows[row_num])

    def _write_single_row(self, current_row_num=0):
        # Write out the worksheet data as a single row with cells.
        # This method is used when constant_memory is on. A single
        # row is written and the data table is reset. That way only
        # one row of data is kept in memory at any one time. We don't
        # write span data in the optimized case since it is optional.

        # Set the new previous row as the current row.
        row_num = self.previous_row
        self.previous_row = current_row_num

        if (row_num in self.set_rows or row_num in self.comments
                or self.table[row_num]):
            # Only process rows with formatting, cell data and/or comments.

            # No span data in optimized mode.
            span = None

            if self.table[row_num]:
                # Write the cells if the row contains data.
                if row_num not in self.set_rows:
                    self._write_row(row_num, span)
                else:
                    self._write_row(row_num, span, self.set_rows[row_num])

                for col_num in range(self.dim_colmin, self.dim_colmax + 1):
                    if col_num in self.table[row_num]:
                        col_ref = self.table[row_num][col_num]
                        self._write_cell(row_num, col_num, col_ref)

                self._xml_end_tag('row')
            else:
                # Row attributes or comments only.
                self._write_empty_row(row_num, span, self.set_rows[row_num])

        # Reset table.
        self.table.clear()

    def _calculate_spans(self):
        # Calculate the "spans" attribute of the <row> tag. This is an
        # XLSX optimization and isn't strictly required. However, it
        # makes comparing files easier. The span is the same for each
        # block of 16 rows.
        spans = {}
        span_min = None
        span_max = None

        for row_num in range(self.dim_rowmin, self.dim_rowmax + 1):

            if row_num in self.table:
                # Calculate spans for cell data.
                for col_num in range(self.dim_colmin, self.dim_colmax + 1):
                    if col_num in self.table[row_num]:
                        if span_min is None:
                            span_min = col_num
                            span_max = col_num
                        else:
                            if col_num < span_min:
                                span_min = col_num
                            if col_num > span_max:
                                span_max = col_num

            if row_num in self.comments:
                # Calculate spans for comments.
                for col_num in range(self.dim_colmin, self.dim_colmax + 1):
                    if (row_num in self.comments
                            and col_num in self.comments[row_num]):
                        if span_min is None:
                            span_min = col_num
                            span_max = col_num
                        else:
                            if col_num < span_min:
                                span_min = col_num
                            if col_num > span_max:
                                span_max = col_num

            if ((row_num + 1) % 16 == 0) or row_num == self.dim_rowmax:
                span_index = int(row_num / 16)

                if span_min is not None:
                    span_min += 1
                    span_max += 1
                    spans[span_index] = "%s:%s" % (span_min, span_max)
                    span_min = None

        self.row_spans = spans

    def _write_row(self, row, spans, properties=None, empty_row=False):
        # Write the <row> element.
        xf_index = 0

        if properties:
            height, cell_format, hidden, level, collapsed = properties
        else:
            height, cell_format, hidden, level, collapsed = None, None, 0, 0, 0

        if height is None:
            height = self.default_row_height

        attributes = [('r', row + 1)]

        # Get the cell_format index.
        if cell_format:
            xf_index = cell_format._get_xf_index()

        # Add row attributes where applicable.
        if spans:
            attributes.append(('spans', spans))

        if xf_index:
            attributes.append(('s', xf_index))

        if cell_format:
            attributes.append(('customFormat', 1))

        if height != self.original_row_height:
            attributes.append(('ht', "%g" % height))

        if hidden:
            attributes.append(('hidden', 1))

        if height != self.original_row_height:
            attributes.append(('customHeight', 1))

        if level:
            attributes.append(('outlineLevel', level))

        if collapsed:
            attributes.append(('collapsed', 1))

        if self.excel_version == 2010:
            attributes.append(('x14ac:dyDescent', '0.25'))

        if empty_row:
            self._xml_empty_tag_unencoded('row', attributes)
        else:
            self._xml_start_tag_unencoded('row', attributes)

    def _write_empty_row(self, row, spans, properties=None):
        # Write and empty <row> element.
        self._write_row(row, spans, properties, empty_row=True)

    def _write_cell(self, row, col, cell):
        # Write the <cell> element.
        # Note. This is the innermost loop so efficiency is important.

        cell_range = xl_rowcol_to_cell_fast(row, col)

        attributes = [('r', cell_range)]

        if cell.format:
            # Add the cell format index.
            xf_index = cell.format._get_xf_index()
            attributes.append(('s', xf_index))
        elif row in self.set_rows and self.set_rows[row][1]:
            # Add the row format.
            row_xf = self.set_rows[row][1]
            attributes.append(('s', row_xf._get_xf_index()))
        elif col in self.col_formats:
            # Add the column format.
            col_xf = self.col_formats[col]
            attributes.append(('s', col_xf._get_xf_index()))

        type_cell_name = type(cell).__name__

        # Write the various cell types.
        if type_cell_name == 'Number':
            # Write a number.
            self._xml_number_element(cell.number, attributes)

        elif type_cell_name == 'String':
            # Write a string.
            string = cell.string

            if not self.constant_memory:
                # Write a shared string.
                self._xml_string_element(string, attributes)
            else:
                # Write an optimized in-line string.

                # Escape control characters. See SharedString.pm for details.
                string = re_control_chars_1.sub(r'_x005F\1', string)
                string = re_control_chars_2.sub(lambda match: "_x%04X_" %
                                                ord(match.group(1)), string)

                # Escapes non characters in strings.
                if sys.version_info[0] == 2:
                    string = string.replace(unichr(0xFFFE), '_xFFFE_')
                    string = string.replace(unichr(0xFFFF), '_xFFFF_')
                else:
                    string = string.replace('\uFFFE', '_xFFFE_')
                    string = string.replace('\uFFFF', '_xFFFF_')

                # Write any rich strings without further tags.
                if string.startswith('<r>') and string.endswith('</r>'):
                    self._xml_rich_inline_string(string, attributes)
                else:
                    # Add attribute to preserve leading or trailing whitespace.
                    preserve = preserve_whitespace(string)
                    self._xml_inline_string(string, preserve, attributes)

        elif type_cell_name == 'Formula':
            # Write a formula. First check the formula value type.
            value = cell.value
            if type(cell.value) == bool:
                attributes.append(('t', 'b'))
                if cell.value:
                    value = 1
                else:
                    value = 0

            elif isinstance(cell.value, str_types):
                error_codes = ('#DIV/0!', '#N/A', '#NAME?', '#NULL!',
                               '#NUM!', '#REF!', '#VALUE!')

                if cell.value == '':
                    # Allow blank to force recalc in some third party apps.
                    pass
                elif cell.value in error_codes:
                    attributes.append(('t', 'e'))
                else:
                    attributes.append(('t', 'str'))

            self._xml_formula_element(cell.formula, value, attributes)

        elif type_cell_name == 'ArrayFormula':
            # Write a array formula.

            if cell.atype == 'dynamic':
                attributes.append(('cm', 1))

            # First check if the formula value is a string.
            try:
                float(cell.value)
            except ValueError:
                attributes.append(('t', 'str'))

            # Write an array formula.
            self._xml_start_tag('c', attributes)

            self._write_cell_array_formula(cell.formula, cell.range)
            self._write_cell_value(cell.value)
            self._xml_end_tag('c')

        elif type_cell_name == 'Blank':
            # Write a empty cell.
            self._xml_empty_tag('c', attributes)

        elif type_cell_name == 'Boolean':
            # Write a boolean cell.
            attributes.append(('t', 'b'))
            self._xml_start_tag('c', attributes)
            self._write_cell_value(cell.boolean)
            self._xml_end_tag('c')

    def _write_cell_value(self, value):
        # Write the cell value <v> element.
        if value is None:
            value = ''

        self._xml_data_element('v', value)

    def _write_cell_array_formula(self, formula, cell_range):
        # Write the cell array formula <f> element.
        attributes = [
            ('t', 'array'),
            ('ref', cell_range)
        ]

        self._xml_data_element('f', formula, attributes)

    def _write_sheet_pr(self):
        # Write the <sheetPr> element for Sheet level properties.
        attributes = []

        if (not self.fit_page
                and not self.filter_on
                and not self.tab_color
                and not self.outline_changed
                and not self.vba_codename):
            return

        if self.vba_codename:
            attributes.append(('codeName', self.vba_codename))

        if self.filter_on:
            attributes.append(('filterMode', 1))

        if (self.fit_page
                or self.tab_color
                or self.outline_changed):
            self._xml_start_tag('sheetPr', attributes)
            self._write_tab_color()
            self._write_outline_pr()
            self._write_page_set_up_pr()
            self._xml_end_tag('sheetPr')
        else:
            self._xml_empty_tag('sheetPr', attributes)

    def _write_page_set_up_pr(self):
        # Write the <pageSetUpPr> element.
        if not self.fit_page:
            return

        attributes = [('fitToPage', 1)]
        self._xml_empty_tag('pageSetUpPr', attributes)

    def _write_tab_color(self):
        # Write the <tabColor> element.
        color = self.tab_color

        if not color:
            return

        attributes = [('rgb', color)]

        self._xml_empty_tag('tabColor', attributes)

    def _write_outline_pr(self):
        # Write the <outlinePr> element.
        attributes = []

        if not self.outline_changed:
            return

        if self.outline_style:
            attributes.append(("applyStyles", 1))
        if not self.outline_below:
            attributes.append(("summaryBelow", 0))
        if not self.outline_right:
            attributes.append(("summaryRight", 0))
        if not self.outline_on:
            attributes.append(("showOutlineSymbols", 0))

        self._xml_empty_tag('outlinePr', attributes)

    def _write_row_breaks(self):
        # Write the <rowBreaks> element.
        page_breaks = self._sort_pagebreaks(self.hbreaks)

        if not page_breaks:
            return

        count = len(page_breaks)

        attributes = [
            ('count', count),
            ('manualBreakCount', count),
        ]

        self._xml_start_tag('rowBreaks', attributes)

        for row_num in page_breaks:
            self._write_brk(row_num, 16383)

        self._xml_end_tag('rowBreaks')

    def _write_col_breaks(self):
        # Write the <colBreaks> element.
        page_breaks = self._sort_pagebreaks(self.vbreaks)

        if not page_breaks:
            return

        count = len(page_breaks)

        attributes = [
            ('count', count),
            ('manualBreakCount', count),
        ]

        self._xml_start_tag('colBreaks', attributes)

        for col_num in page_breaks:
            self._write_brk(col_num, 1048575)

        self._xml_end_tag('colBreaks')

    def _write_brk(self, brk_id, brk_max):
        # Write the <brk> element.
        attributes = [
            ('id', brk_id),
            ('max', brk_max),
            ('man', 1)]

        self._xml_empty_tag('brk', attributes)

    def _write_merge_cells(self):
        # Write the <mergeCells> element.
        merged_cells = self.merge
        count = len(merged_cells)

        if not count:
            return

        attributes = [('count', count)]

        self._xml_start_tag('mergeCells', attributes)

        for merged_range in merged_cells:

            # Write the mergeCell element.
            self._write_merge_cell(merged_range)

        self._xml_end_tag('mergeCells')

    def _write_merge_cell(self, merged_range):
        # Write the <mergeCell> element.
        (row_min, col_min, row_max, col_max) = merged_range

        # Convert the merge dimensions to a cell range.
        cell_1 = xl_rowcol_to_cell(row_min, col_min)
        cell_2 = xl_rowcol_to_cell(row_max, col_max)
        ref = cell_1 + ':' + cell_2

        attributes = [('ref', ref)]

        self._xml_empty_tag('mergeCell', attributes)

    def _write_hyperlinks(self):
        # Process any stored hyperlinks in row/col order and write the
        # <hyperlinks> element. The attributes are different for internal
        # and external links.
        hlink_refs = []
        display = None

        # Sort the hyperlinks into row order.
        row_nums = sorted(self.hyperlinks.keys())

        # Exit if there are no hyperlinks to process.
        if not row_nums:
            return

        # Iterate over the rows.
        for row_num in row_nums:
            # Sort the hyperlinks into column order.
            col_nums = sorted(self.hyperlinks[row_num].keys())

            # Iterate over the columns.
            for col_num in col_nums:
                # Get the link data for this cell.
                link = self.hyperlinks[row_num][col_num]
                link_type = link['link_type']

                # If the cell isn't a string then we have to add the url as
                # the string to display.
                if (self.table
                        and self.table[row_num]
                        and self.table[row_num][col_num]):
                    cell = self.table[row_num][col_num]
                    if type(cell).__name__ != 'String':
                        display = link['url']

                if link_type == 1:
                    # External link with rel file relationship.
                    self.rel_count += 1

                    hlink_refs.append([link_type,
                                       row_num,
                                       col_num,
                                       self.rel_count,
                                       link['str'],
                                       display,
                                       link['tip']])

                    # Links for use by the packager.
                    self.external_hyper_links.append(['/hyperlink',
                                                      link['url'], 'External'])
                else:
                    # Internal link with rel file relationship.
                    hlink_refs.append([link_type,
                                       row_num,
                                       col_num,
                                       link['url'],
                                       link['str'],
                                       link['tip']])

        # Write the hyperlink elements.
        self._xml_start_tag('hyperlinks')

        for args in hlink_refs:
            link_type = args.pop(0)

            if link_type == 1:
                self._write_hyperlink_external(*args)
            elif link_type == 2:
                self._write_hyperlink_internal(*args)

        self._xml_end_tag('hyperlinks')

    def _write_hyperlink_external(self, row, col, id_num, location=None,
                                  display=None, tooltip=None):
        # Write the <hyperlink> element for external links.
        ref = xl_rowcol_to_cell(row, col)
        r_id = 'rId' + str(id_num)

        attributes = [
            ('ref', ref),
            ('r:id', r_id)]

        if location is not None:
            attributes.append(('location', location))
        if display is not None:
            attributes.append(('display', display))
        if tooltip is not None:
            attributes.append(('tooltip', tooltip))

        self._xml_empty_tag('hyperlink', attributes)

    def _write_hyperlink_internal(self, row, col, location=None, display=None,
                                  tooltip=None):
        # Write the <hyperlink> element for internal links.
        ref = xl_rowcol_to_cell(row, col)

        attributes = [
            ('ref', ref),
            ('location', location)]

        if tooltip is not None:
            attributes.append(('tooltip', tooltip))
        attributes.append(('display', display))

        self._xml_empty_tag('hyperlink', attributes)

    def _write_auto_filter(self):
        # Write the <autoFilter> element.
        if not self.autofilter_ref:
            return

        attributes = [('ref', self.autofilter_ref)]

        if self.filter_on:
            # Autofilter defined active filters.
            self._xml_start_tag('autoFilter', attributes)
            self._write_autofilters()
            self._xml_end_tag('autoFilter')

        else:
            # Autofilter defined without active filters.
            self._xml_empty_tag('autoFilter', attributes)

    def _write_autofilters(self):
        # Function to iterate through the columns that form part of an
        # autofilter range and write the appropriate filters.
        (col1, col2) = self.filter_range

        for col in range(col1, col2 + 1):
            # Skip if column doesn't have an active filter.
            if col not in self.filter_cols:
                continue

            # Retrieve the filter tokens and write the autofilter records.
            tokens = self.filter_cols[col]
            filter_type = self.filter_type[col]

            # Filters are relative to first column in the autofilter.
            self._write_filter_column(col - col1, filter_type, tokens)

    def _write_filter_column(self, col_id, filter_type, filters):
        # Write the <filterColumn> element.
        attributes = [('colId', col_id)]

        self._xml_start_tag('filterColumn', attributes)

        if filter_type == 1:
            # Type == 1 is the new XLSX style filter.
            self._write_filters(filters)
        else:
            # Type == 0 is the classic "custom" filter.
            self._write_custom_filters(filters)

        self._xml_end_tag('filterColumn')

    def _write_filters(self, filters):
        # Write the <filters> element.
        non_blanks = [filter for filter in filters
                      if str(filter).lower() != 'blanks']
        attributes = []

        if len(filters) != len(non_blanks):
            attributes = [('blank', 1)]

        if len(filters) == 1 and len(non_blanks) == 0:
            # Special case for blank cells only.
            self._xml_empty_tag('filters', attributes)
        else:
            # General case.
            self._xml_start_tag('filters', attributes)

            for autofilter in sorted(non_blanks):
                self._write_filter(autofilter)

            self._xml_end_tag('filters')

    def _write_filter(self, val):
        # Write the <filter> element.
        attributes = [('val', val)]

        self._xml_empty_tag('filter', attributes)

    def _write_custom_filters(self, tokens):
        # Write the <customFilters> element.
        if len(tokens) == 2:
            # One filter expression only.
            self._xml_start_tag('customFilters')
            self._write_custom_filter(*tokens)
            self._xml_end_tag('customFilters')
        else:
            # Two filter expressions.
            attributes = []

            # Check if the "join" operand is "and" or "or".
            if tokens[2] == 0:
                attributes = [('and', 1)]
            else:
                attributes = [('and', 0)]

            # Write the two custom filters.
            self._xml_start_tag('customFilters', attributes)
            self._write_custom_filter(tokens[0], tokens[1])
            self._write_custom_filter(tokens[3], tokens[4])
            self._xml_end_tag('customFilters')

    def _write_custom_filter(self, operator, val):
        # Write the <customFilter> element.
        attributes = []

        operators = {
            1: 'lessThan',
            2: 'equal',
            3: 'lessThanOrEqual',
            4: 'greaterThan',
            5: 'notEqual',
            6: 'greaterThanOrEqual',
            22: 'equal',
        }

        # Convert the operator from a number to a descriptive string.
        if operators[operator] is not None:
            operator = operators[operator]
        else:
            warn("Unknown operator = %s" % operator)

        # The 'equal' operator is the default attribute and isn't stored.
        if not operator == 'equal':
            attributes.append(('operator', operator))
        attributes.append(('val', val))

        self._xml_empty_tag('customFilter', attributes)

    def _write_sheet_protection(self):
        # Write the <sheetProtection> element.
        attributes = []

        if not self.protect_options:
            return

        options = self.protect_options

        if options['password']:
            attributes.append(('password', options['password']))
        if options['sheet']:
            attributes.append(('sheet', 1))
        if options['content']:
            attributes.append(('content', 1))
        if not options['objects']:
            attributes.append(('objects', 1))
        if not options['scenarios']:
            attributes.append(('scenarios', 1))
        if options['format_cells']:
            attributes.append(('formatCells', 0))
        if options['format_columns']:
            attributes.append(('formatColumns', 0))
        if options['format_rows']:
            attributes.append(('formatRows', 0))
        if options['insert_columns']:
            attributes.append(('insertColumns', 0))
        if options['insert_rows']:
            attributes.append(('insertRows', 0))
        if options['insert_hyperlinks']:
            attributes.append(('insertHyperlinks', 0))
        if options['delete_columns']:
            attributes.append(('deleteColumns', 0))
        if options['delete_rows']:
            attributes.append(('deleteRows', 0))
        if not options['select_locked_cells']:
            attributes.append(('selectLockedCells', 1))
        if options['sort']:
            attributes.append(('sort', 0))
        if options['autofilter']:
            attributes.append(('autoFilter', 0))
        if options['pivot_tables']:
            attributes.append(('pivotTables', 0))
        if not options['select_unlocked_cells']:
            attributes.append(('selectUnlockedCells', 1))

        self._xml_empty_tag('sheetProtection', attributes)

    def _write_protected_ranges(self):
        # Write the <protectedRanges> element.
        if self.num_protected_ranges == 0:
            return

        self._xml_start_tag('protectedRanges')

        for (cell_range, range_name, password) in self.protected_ranges:
            self._write_protected_range(cell_range, range_name, password)

        self._xml_end_tag('protectedRanges')

    def _write_protected_range(self, cell_range, range_name, password):
        # Write the <protectedRange> element.
        attributes = []

        if password:
            attributes.append(('password', password))

        attributes.append(('sqref', cell_range))
        attributes.append(('name', range_name))

        self._xml_empty_tag('protectedRange', attributes)

    def _write_drawings(self):
        # Write the <drawing> elements.
        if not self.drawing:
            return

        self.rel_count += 1
        self._write_drawing(self.rel_count)

    def _write_drawing(self, drawing_id):
        # Write the <drawing> element.
        r_id = 'rId' + str(drawing_id)

        attributes = [('r:id', r_id)]

        self._xml_empty_tag('drawing', attributes)

    def _write_legacy_drawing(self):
        # Write the <legacyDrawing> element.
        if not self.has_vml:
            return

        # Increment the relationship id for any drawings or comments.
        self.rel_count += 1
        r_id = 'rId' + str(self.rel_count)

        attributes = [('r:id', r_id)]

        self._xml_empty_tag('legacyDrawing', attributes)

    def _write_legacy_drawing_hf(self):
        # Write the <legacyDrawingHF> element.
        if not self.has_header_vml:
            return

        # Increment the relationship id for any drawings or comments.
        self.rel_count += 1
        r_id = 'rId' + str(self.rel_count)

        attributes = [('r:id', r_id)]

        self._xml_empty_tag('legacyDrawingHF', attributes)

    def _write_picture(self):
        # Write the <picture> element.
        if not self.background_image:
            return

        # Increment the relationship id.
        self.rel_count += 1
        r_id = 'rId' + str(self.rel_count)

        attributes = [('r:id', r_id)]

        self._xml_empty_tag('picture', attributes)

    def _write_data_validations(self):
        # Write the <dataValidations> element.
        validations = self.validations
        count = len(validations)

        if not count:
            return

        attributes = [('count', count)]

        self._xml_start_tag('dataValidations', attributes)

        for validation in validations:

            # Write the dataValidation element.
            self._write_data_validation(validation)

        self._xml_end_tag('dataValidations')

    def _write_data_validation(self, options):
        # Write the <dataValidation> element.
        sqref = ''
        attributes = []

        # Set the cell range(s) for the data validation.
        for cells in options['cells']:

            # Add a space between multiple cell ranges.
            if sqref != '':
                sqref += ' '

            (row_first, col_first, row_last, col_last) = cells

            # Swap last row/col for first row/col as necessary
            if row_first > row_last:
                (row_first, row_last) = (row_last, row_first)

            if col_first > col_last:
                (col_first, col_last) = (col_last, col_first)

            sqref += xl_range(row_first, col_first, row_last, col_last)

        if options['validate'] != 'none':
            attributes.append(('type', options['validate']))

            if options['criteria'] != 'between':
                attributes.append(('operator', options['criteria']))

        if 'error_type' in options:
            if options['error_type'] == 1:
                attributes.append(('errorStyle', 'warning'))
            if options['error_type'] == 2:
                attributes.append(('errorStyle', 'information'))

        if options['ignore_blank']:
            attributes.append(('allowBlank', 1))

        if not options['dropdown']:
            attributes.append(('showDropDown', 1))

        if options['show_input']:
            attributes.append(('showInputMessage', 1))

        if options['show_error']:
            attributes.append(('showErrorMessage', 1))

        if 'error_title' in options:
            attributes.append(('errorTitle', options['error_title']))

        if 'error_message' in options:
            attributes.append(('error', options['error_message']))

        if 'input_title' in options:
            attributes.append(('promptTitle', options['input_title']))

        if 'input_message' in options:
            attributes.append(('prompt', options['input_message']))

        attributes.append(('sqref', sqref))

        if options['validate'] == 'none':
            self._xml_empty_tag('dataValidation', attributes)
        else:
            self._xml_start_tag('dataValidation', attributes)

            # Write the formula1 element.
            self._write_formula_1(options['value'])

            # Write the formula2 element.
            if options['maximum'] is not None:
                self._write_formula_2(options['maximum'])

            self._xml_end_tag('dataValidation')

    def _write_formula_1(self, formula):
        # Write the <formula1> element.

        if type(formula) is list:
            formula = self._csv_join(*formula)
            formula = '"%s"' % formula
        else:
            # Check if the formula is a number.
            try:
                float(formula)
            except ValueError:
                # Not a number. Remove the formula '=' sign if it exists.
                if formula.startswith('='):
                    formula = formula.lstrip('=')

        self._xml_data_element('formula1', formula)

    def _write_formula_2(self, formula):
        # Write the <formula2> element.

        # Check if the formula is a number.
        try:
            float(formula)
        except ValueError:
            # Not a number. Remove the formula '=' sign if it exists.
            if formula.startswith('='):
                formula = formula.lstrip('=')

        self._xml_data_element('formula2', formula)

    def _write_conditional_formats(self):
        # Write the Worksheet conditional formats.
        ranges = sorted(self.cond_formats.keys())

        if not ranges:
            return

        for cond_range in ranges:
            self._write_conditional_formatting(cond_range,
                                               self.cond_formats[cond_range])

    def _write_conditional_formatting(self, cond_range, params):
        # Write the <conditionalFormatting> element.
        attributes = [('sqref', cond_range)]
        self._xml_start_tag('conditionalFormatting', attributes)
        for param in params:
            # Write the cfRule element.
            self._write_cf_rule(param)
        self._xml_end_tag('conditionalFormatting')

    def _write_cf_rule(self, params):
        # Write the <cfRule> element.
        attributes = [('type', params['type'])]

        if 'format' in params and params['format'] is not None:
            attributes.append(('dxfId', params['format']))

        attributes.append(('priority', params['priority']))

        if params.get('stop_if_true'):
            attributes.append(('stopIfTrue', 1))

        if params['type'] == 'cellIs':
            attributes.append(('operator', params['criteria']))

            self._xml_start_tag('cfRule', attributes)

            if 'minimum' in params and 'maximum' in params:
                self._write_formula_element(params['minimum'])
                self._write_formula_element(params['maximum'])
            else:
                self._write_formula_element(params['value'])

            self._xml_end_tag('cfRule')

        elif params['type'] == 'aboveAverage':
            if re.search('below', params['criteria']):
                attributes.append(('aboveAverage', 0))

            if re.search('equal', params['criteria']):
                attributes.append(('equalAverage', 1))

            if re.search('[123] std dev', params['criteria']):
                match = re.search('([123]) std dev', params['criteria'])
                attributes.append(('stdDev', match.group(1)))

            self._xml_empty_tag('cfRule', attributes)

        elif params['type'] == 'top10':
            if 'criteria' in params and params['criteria'] == '%':
                attributes.append(('percent', 1))

            if 'direction' in params:
                attributes.append(('bottom', 1))

            rank = params['value'] or 10
            attributes.append(('rank', rank))

            self._xml_empty_tag('cfRule', attributes)

        elif params['type'] == 'duplicateValues':
            self._xml_empty_tag('cfRule', attributes)

        elif params['type'] == 'uniqueValues':
            self._xml_empty_tag('cfRule', attributes)

        elif (params['type'] == 'containsText'
              or params['type'] == 'notContainsText'
              or params['type'] == 'beginsWith'
              or params['type'] == 'endsWith'):
            attributes.append(('operator', params['criteria']))
            attributes.append(('text', params['value']))
            self._xml_start_tag('cfRule', attributes)
            self._write_formula_element(params['formula'])
            self._xml_end_tag('cfRule')

        elif params['type'] == 'timePeriod':
            attributes.append(('timePeriod', params['criteria']))
            self._xml_start_tag('cfRule', attributes)
            self._write_formula_element(params['formula'])
            self._xml_end_tag('cfRule')

        elif (params['type'] == 'containsBlanks'
              or params['type'] == 'notContainsBlanks'
              or params['type'] == 'containsErrors'
              or params['type'] == 'notContainsErrors'):
            self._xml_start_tag('cfRule', attributes)
            self._write_formula_element(params['formula'])
            self._xml_end_tag('cfRule')

        elif params['type'] == 'colorScale':
            self._xml_start_tag('cfRule', attributes)
            self._write_color_scale(params)
            self._xml_end_tag('cfRule')

        elif params['type'] == 'dataBar':
            self._xml_start_tag('cfRule', attributes)
            self._write_data_bar(params)

            if params.get('is_data_bar_2010'):
                self._write_data_bar_ext(params)

            self._xml_end_tag('cfRule')

        elif params['type'] == 'expression':
            self._xml_start_tag('cfRule', attributes)
            self._write_formula_element(params['criteria'])
            self._xml_end_tag('cfRule')

        elif params['type'] == 'iconSet':
            self._xml_start_tag('cfRule', attributes)
            self._write_icon_set(params)
            self._xml_end_tag('cfRule')

    def _write_formula_element(self, formula):
        # Write the <formula> element.

        # Check if the formula is a number.
        try:
            float(formula)
        except ValueError:
            # Not a number. Remove the formula '=' sign if it exists.
            if formula.startswith('='):
                formula = formula.lstrip('=')

        self._xml_data_element('formula', formula)

    def _write_color_scale(self, param):
        # Write the <colorScale> element.

        self._xml_start_tag('colorScale')

        self._write_cfvo(param['min_type'], param['min_value'])

        if param['mid_type'] is not None:
            self._write_cfvo(param['mid_type'], param['mid_value'])

        self._write_cfvo(param['max_type'], param['max_value'])

        self._write_color('rgb', param['min_color'])

        if param['mid_color'] is not None:
            self._write_color('rgb', param['mid_color'])

        self._write_color('rgb', param['max_color'])

        self._xml_end_tag('colorScale')

    def _write_data_bar(self, param):
        # Write the <dataBar> element.
        attributes = []

        # Min and max bar lengths in in the spec but not supported directly by
        # Excel.
        if param.get('min_length'):
            attributes.append(('minLength', param['min_length']))

        if param.get('max_length'):
            attributes.append(('maxLength', param['max_length']))

        if param.get('bar_only'):
            attributes.append(('showValue', 0))

        self._xml_start_tag('dataBar', attributes)

        self._write_cfvo(param['min_type'], param['min_value'])
        self._write_cfvo(param['max_type'], param['max_value'])
        self._write_color('rgb', param['bar_color'])

        self._xml_end_tag('dataBar')

    def _write_data_bar_ext(self, param):
        # Write the <extLst> dataBar extension element.

        # Create a pseudo GUID for each unique Excel 2010 data bar.
        worksheet_count = self.index + 1
        data_bar_count = len(self.data_bars_2010) + 1
        guid = "{DA7ABA51-AAAA-BBBB-%04X-%012X}" % (worksheet_count,
                                                    data_bar_count)

        # Store the 2010 data bar parameters to write the extLst elements.
        param['guid'] = guid
        self.data_bars_2010.append(param)

        self._xml_start_tag('extLst')
        self._write_ext('{B025F937-C7B1-47D3-B67F-A62EFF666E3E}')
        self._xml_data_element('x14:id', guid)
        self._xml_end_tag('ext')
        self._xml_end_tag('extLst')

    def _write_icon_set(self, param):
        # Write the <iconSet> element.
        attributes = []

        # Don't set attribute for default style.
        if param['icon_style'] != '3TrafficLights':
            attributes = [('iconSet', param['icon_style'])]

        if param.get('icons_only'):
            attributes.append(('showValue', 0))

        if param.get('reverse_icons'):
            attributes.append(('reverse', 1))

        self._xml_start_tag('iconSet', attributes)

        # Write the properties for different icon styles.
        for icon in reversed(param['icons']):
            self._write_cfvo(
                icon['type'],
                icon['value'],
                icon['criteria'])

        self._xml_end_tag('iconSet')

    def _write_cfvo(self, cf_type, val, criteria=None):
        # Write the <cfvo> element.
        attributes = [('type', cf_type)]

        if val is not None:
            attributes.append(('val', val))

        if criteria:
            attributes.append(('gte', 0))

        self._xml_empty_tag('cfvo', attributes)

    def _write_color(self, name, value):
        # Write the <color> element.
        attributes = [(name, value)]

        self._xml_empty_tag('color', attributes)

    def _write_selections(self):
        # Write the <selection> elements.
        for selection in self.selections:
            self._write_selection(*selection)

    def _write_selection(self, pane, active_cell, sqref):
        # Write the <selection> element.
        attributes = []

        if pane:
            attributes.append(('pane', pane))

        if active_cell:
            attributes.append(('activeCell', active_cell))

        if sqref:
            attributes.append(('sqref', sqref))

        self._xml_empty_tag('selection', attributes)

    def _write_panes(self):
        # Write the frozen or split <pane> elements.
        panes = self.panes

        if not len(panes):
            return

        if panes[4] == 2:
            self._write_split_panes(*panes)
        else:
            self._write_freeze_panes(*panes)

    def _write_freeze_panes(self, row, col, top_row, left_col, pane_type):
        # Write the <pane> element for freeze panes.
        attributes = []

        y_split = row
        x_split = col
        top_left_cell = xl_rowcol_to_cell(top_row, left_col)
        active_pane = ''
        state = ''
        active_cell = ''
        sqref = ''

        # Move user cell selection to the panes.
        if self.selections:
            (_, active_cell, sqref) = self.selections[0]
            self.selections = []

        # Set the active pane.
        if row and col:
            active_pane = 'bottomRight'

            row_cell = xl_rowcol_to_cell(row, 0)
            col_cell = xl_rowcol_to_cell(0, col)

            self.selections.append(['topRight', col_cell, col_cell])
            self.selections.append(['bottomLeft', row_cell, row_cell])
            self.selections.append(['bottomRight', active_cell, sqref])

        elif col:
            active_pane = 'topRight'
            self.selections.append(['topRight', active_cell, sqref])

        else:
            active_pane = 'bottomLeft'
            self.selections.append(['bottomLeft', active_cell, sqref])

        # Set the pane type.
        if pane_type == 0:
            state = 'frozen'
        elif pane_type == 1:
            state = 'frozenSplit'
        else:
            state = 'split'

        if x_split:
            attributes.append(('xSplit', x_split))

        if y_split:
            attributes.append(('ySplit', y_split))

        attributes.append(('topLeftCell', top_left_cell))
        attributes.append(('activePane', active_pane))
        attributes.append(('state', state))

        self._xml_empty_tag('pane', attributes)

    def _write_split_panes(self, row, col, top_row, left_col, pane_type):
        # Write the <pane> element for split panes.
        attributes = []
        has_selection = 0
        active_pane = ''
        active_cell = ''
        sqref = ''

        y_split = row
        x_split = col

        # Move user cell selection to the panes.
        if self.selections:
            (_, active_cell, sqref) = self.selections[0]
            self.selections = []
            has_selection = 1

        # Convert the row and col to 1/20 twip units with padding.
        if y_split:
            y_split = int(20 * y_split + 300)

        if x_split:
            x_split = self._calculate_x_split_width(x_split)

        # For non-explicit topLeft definitions, estimate the cell offset based
        # on the pixels dimensions. This is only a workaround and doesn't take
        # adjusted cell dimensions into account.
        if top_row == row and left_col == col:
            top_row = int(0.5 + (y_split - 300) / 20 / 15)
            left_col = int(0.5 + (x_split - 390) / 20 / 3 * 4 / 64)

        top_left_cell = xl_rowcol_to_cell(top_row, left_col)

        # If there is no selection set the active cell to the top left cell.
        if not has_selection:
            active_cell = top_left_cell
            sqref = top_left_cell

        # Set the Cell selections.
        if row and col:
            active_pane = 'bottomRight'

            row_cell = xl_rowcol_to_cell(top_row, 0)
            col_cell = xl_rowcol_to_cell(0, left_col)

            self.selections.append(['topRight', col_cell, col_cell])
            self.selections.append(['bottomLeft', row_cell, row_cell])
            self.selections.append(['bottomRight', active_cell, sqref])

        elif col:
            active_pane = 'topRight'
            self.selections.append(['topRight', active_cell, sqref])

        else:
            active_pane = 'bottomLeft'
            self.selections.append(['bottomLeft', active_cell, sqref])

        # Format splits to the same precision as Excel.
        if x_split:
            attributes.append(('xSplit', "%.16g" % x_split))

        if y_split:
            attributes.append(('ySplit', "%.16g" % y_split))

        attributes.append(('topLeftCell', top_left_cell))

        if has_selection:
            attributes.append(('activePane', active_pane))

        self._xml_empty_tag('pane', attributes)

    def _calculate_x_split_width(self, width):
        # Convert column width from user units to pane split width.

        max_digit_width = 7  # For Calabri 11.
        padding = 5

        # Convert to pixels.
        if width < 1:
            pixels = int(width * (max_digit_width + padding) + 0.5)
        else:
            pixels = int(width * max_digit_width + 0.5) + padding

        # Convert to points.
        points = pixels * 3 / 4

        # Convert to twips (twentieths of a point).
        twips = points * 20

        # Add offset/padding.
        width = twips + 390

        return width

    def _write_table_parts(self):
        # Write the <tableParts> element.
        tables = self.tables
        count = len(tables)

        # Return if worksheet doesn't contain any tables.
        if not count:
            return

        attributes = [('count', count,)]

        self._xml_start_tag('tableParts', attributes)

        for _ in tables:

            # Write the tablePart element.
            self.rel_count += 1
            self._write_table_part(self.rel_count)

        self._xml_end_tag('tableParts')

    def _write_table_part(self, r_id):
        # Write the <tablePart> element.

        r_id = 'rId' + str(r_id)

        attributes = [('r:id', r_id,)]

        self._xml_empty_tag('tablePart', attributes)

    def _write_ext_list(self):
        # Write the <extLst> element for data bars and sparklines.
        has_data_bars = len(self.data_bars_2010)
        has_sparklines = len(self.sparklines)

        if not has_data_bars and not has_sparklines:
            return

        # Write the extLst element.
        self._xml_start_tag('extLst')

        if has_data_bars:
            self._write_ext_list_data_bars()

        if has_sparklines:
            self._write_ext_list_sparklines()

        self._xml_end_tag('extLst')

    def _write_ext_list_data_bars(self):
        # Write the Excel 2010 data_bar subelements.
        self._write_ext('{78C0D931-6437-407d-A8EE-F0AAD7539E65}')

        self._xml_start_tag('x14:conditionalFormattings')

        # Write the Excel 2010 conditional formatting data bar elements.
        for data_bar in self.data_bars_2010:
            # Write the x14:conditionalFormatting element.
            self._write_conditional_formatting_2010(data_bar)

        self._xml_end_tag('x14:conditionalFormattings')
        self._xml_end_tag('ext')

    def _write_conditional_formatting_2010(self, data_bar):
        # Write the <x14:conditionalFormatting> element.
        xmlns_xm = 'http://schemas.microsoft.com/office/excel/2006/main'

        attributes = [('xmlns:xm', xmlns_xm)]

        self._xml_start_tag('x14:conditionalFormatting', attributes)

        # Write the x14:cfRule element.
        self._write_x14_cf_rule(data_bar)

        # Write the x14:dataBar element.
        self._write_x14_data_bar(data_bar)

        # Write the x14 max and min data bars.
        self._write_x14_cfvo(data_bar['x14_min_type'], data_bar['min_value'])
        self._write_x14_cfvo(data_bar['x14_max_type'], data_bar['max_value'])

        if not data_bar['bar_no_border']:
            # Write the x14:borderColor element.
            self._write_x14_border_color(data_bar['bar_border_color'])

        # Write the x14:negativeFillColor element.
        if not data_bar['bar_negative_color_same']:
            self._write_x14_negative_fill_color(
                data_bar['bar_negative_color'])

        # Write the x14:negativeBorderColor element.
        if (not data_bar['bar_no_border'] and
                not data_bar['bar_negative_border_color_same']):
            self._write_x14_negative_border_color(
                data_bar['bar_negative_border_color'])

        # Write the x14:axisColor element.
        if data_bar['bar_axis_position'] != 'none':
            self._write_x14_axis_color(data_bar['bar_axis_color'])

        self._xml_end_tag('x14:dataBar')
        self._xml_end_tag('x14:cfRule')

        # Write the xm:sqref element.
        self._xml_data_element('xm:sqref', data_bar['range'])

        self._xml_end_tag('x14:conditionalFormatting')

    def _write_x14_cf_rule(self, data_bar):
        # Write the <x14:cfRule> element.
        rule_type = 'dataBar'
        guid = data_bar['guid']
        attributes = [('type', rule_type), ('id', guid)]

        self._xml_start_tag('x14:cfRule', attributes)

    def _write_x14_data_bar(self, data_bar):
        # Write the <x14:dataBar> element.
        min_length = 0
        max_length = 100

        attributes = [
            ('minLength', min_length),
            ('maxLength', max_length),
        ]

        if not data_bar['bar_no_border']:
            attributes.append(('border', 1))

        if data_bar['bar_solid']:
            attributes.append(('gradient', 0))

        if data_bar['bar_direction'] == 'left':
            attributes.append(('direction', 'leftToRight'))

        if data_bar['bar_direction'] == 'right':
            attributes.append(('direction', 'rightToLeft'))

        if data_bar['bar_negative_color_same']:
            attributes.append(('negativeBarColorSameAsPositive', 1))

        if (not data_bar['bar_no_border'] and
                not data_bar['bar_negative_border_color_same']):
            attributes.append(('negativeBarBorderColorSameAsPositive', 0))

        if data_bar['bar_axis_position'] == 'middle':
            attributes.append(('axisPosition', 'middle'))

        if data_bar['bar_axis_position'] == 'none':
            attributes.append(('axisPosition', 'none'))

        self._xml_start_tag('x14:dataBar', attributes)

    def _write_x14_cfvo(self, rule_type, value):
        # Write the <x14:cfvo> element.
        attributes = [('type', rule_type)]

        if rule_type in ('min', 'max', 'autoMin', 'autoMax'):
            self._xml_empty_tag('x14:cfvo', attributes)
        else:
            self._xml_start_tag('x14:cfvo', attributes)
            self._xml_data_element('xm:f', value)
            self._xml_end_tag('x14:cfvo')

    def _write_x14_border_color(self, rgb):
        # Write the <x14:borderColor> element.
        attributes = [('rgb', rgb)]
        self._xml_empty_tag('x14:borderColor', attributes)

    def _write_x14_negative_fill_color(self, rgb):
        # Write the <x14:negativeFillColor> element.
        attributes = [('rgb', rgb)]
        self._xml_empty_tag('x14:negativeFillColor', attributes)

    def _write_x14_negative_border_color(self, rgb):
        # Write the <x14:negativeBorderColor> element.
        attributes = [('rgb', rgb)]
        self._xml_empty_tag('x14:negativeBorderColor', attributes)

    def _write_x14_axis_color(self, rgb):
        # Write the <x14:axisColor> element.
        attributes = [('rgb', rgb)]
        self._xml_empty_tag('x14:axisColor', attributes)

    def _write_ext_list_sparklines(self):
        # Write the sparkline extension sub-elements.
        self._write_ext('{05C60535-1F16-4fd2-B633-F4F36F0B64E0}')

        # Write the x14:sparklineGroups element.
        self._write_sparkline_groups()

        # Write the sparkline elements.
        for sparkline in reversed(self.sparklines):

            # Write the x14:sparklineGroup element.
            self._write_sparkline_group(sparkline)

            # Write the x14:colorSeries element.
            self._write_color_series(sparkline['series_color'])

            # Write the x14:colorNegative element.
            self._write_color_negative(sparkline['negative_color'])

            # Write the x14:colorAxis element.
            self._write_color_axis()

            # Write the x14:colorMarkers element.
            self._write_color_markers(sparkline['markers_color'])

            # Write the x14:colorFirst element.
            self._write_color_first(sparkline['first_color'])

            # Write the x14:colorLast element.
            self._write_color_last(sparkline['last_color'])

            # Write the x14:colorHigh element.
            self._write_color_high(sparkline['high_color'])

            # Write the x14:colorLow element.
            self._write_color_low(sparkline['low_color'])

            if sparkline['date_axis']:
                self._xml_data_element('xm:f', sparkline['date_axis'])

            self._write_sparklines(sparkline)

            self._xml_end_tag('x14:sparklineGroup')

        self._xml_end_tag('x14:sparklineGroups')
        self._xml_end_tag('ext')

    def _write_sparklines(self, sparkline):
        # Write the <x14:sparklines> element and <x14:sparkline> sub-elements.

        # Write the sparkline elements.
        self._xml_start_tag('x14:sparklines')

        for i in range(sparkline['count']):
            spark_range = sparkline['ranges'][i]
            location = sparkline['locations'][i]

            self._xml_start_tag('x14:sparkline')
            self._xml_data_element('xm:f', spark_range)
            self._xml_data_element('xm:sqref', location)
            self._xml_end_tag('x14:sparkline')

        self._xml_end_tag('x14:sparklines')

    def _write_ext(self, uri):
        # Write the <ext> element.
        schema = 'http://schemas.microsoft.com/office/'
        xmlns_x14 = schema + 'spreadsheetml/2009/9/main'

        attributes = [
            ('xmlns:x14', xmlns_x14),
            ('uri', uri),
        ]

        self._xml_start_tag('ext', attributes)

    def _write_sparkline_groups(self):
        # Write the <x14:sparklineGroups> element.
        xmlns_xm = 'http://schemas.microsoft.com/office/excel/2006/main'

        attributes = [('xmlns:xm', xmlns_xm)]

        self._xml_start_tag('x14:sparklineGroups', attributes)

    def _write_sparkline_group(self, options):
        # Write the <x14:sparklineGroup> element.
        #
        # Example for order.
        #
        # <x14:sparklineGroup
        #     manualMax="0"
        #     manualMin="0"
        #     lineWeight="2.25"
        #     type="column"
        #     dateAxis="1"
        #     displayEmptyCellsAs="span"
        #     markers="1"
        #     high="1"
        #     low="1"
        #     first="1"
        #     last="1"
        #     negative="1"
        #     displayXAxis="1"
        #     displayHidden="1"
        #     minAxisType="custom"
        #     maxAxisType="custom"
        #     rightToLeft="1">
        #
        empty = options.get('empty')
        attributes = []

        if options.get('max') is not None:
            if options['max'] == 'group':
                options['cust_max'] = 'group'
            else:
                attributes.append(('manualMax', options['max']))
                options['cust_max'] = 'custom'

        if options.get('min') is not None:

            if options['min'] == 'group':
                options['cust_min'] = 'group'
            else:
                attributes.append(('manualMin', options['min']))
                options['cust_min'] = 'custom'

        # Ignore the default type attribute (line).
        if options['type'] != 'line':
            attributes.append(('type', options['type']))

        if options.get('weight'):
            attributes.append(('lineWeight', options['weight']))

        if options.get('date_axis'):
            attributes.append(('dateAxis', 1))

        if empty:
            attributes.append(('displayEmptyCellsAs', empty))

        if options.get('markers'):
            attributes.append(('markers', 1))

        if options.get('high'):
            attributes.append(('high', 1))

        if options.get('low'):
            attributes.append(('low', 1))

        if options.get('first'):
            attributes.append(('first', 1))

        if options.get('last'):
            attributes.append(('last', 1))

        if options.get('negative'):
            attributes.append(('negative', 1))

        if options.get('axis'):
            attributes.append(('displayXAxis', 1))

        if options.get('hidden'):
            attributes.append(('displayHidden', 1))

        if options.get('cust_min'):
            attributes.append(('minAxisType', options['cust_min']))

        if options.get('cust_max'):
            attributes.append(('maxAxisType', options['cust_max']))

        if options.get('reverse'):
            attributes.append(('rightToLeft', 1))

        self._xml_start_tag('x14:sparklineGroup', attributes)

    def _write_spark_color(self, element, color):
        # Helper function for the sparkline color functions below.
        attributes = []

        if color.get('rgb'):
            attributes.append(('rgb', color['rgb']))

        if color.get('theme'):
            attributes.append(('theme', color['theme']))

        if color.get('tint'):
            attributes.append(('tint', color['tint']))

        self._xml_empty_tag(element, attributes)

    def _write_color_series(self, color):
        # Write the <x14:colorSeries> element.
        self._write_spark_color('x14:colorSeries', color)

    def _write_color_negative(self, color):
        # Write the <x14:colorNegative> element.
        self._write_spark_color('x14:colorNegative', color)

    def _write_color_axis(self):
        # Write the <x14:colorAxis> element.
        self._write_spark_color('x14:colorAxis', {'rgb': 'FF000000'})

    def _write_color_markers(self, color):
        # Write the <x14:colorMarkers> element.
        self._write_spark_color('x14:colorMarkers', color)

    def _write_color_first(self, color):
        # Write the <x14:colorFirst> element.
        self._write_spark_color('x14:colorFirst', color)

    def _write_color_last(self, color):
        # Write the <x14:colorLast> element.
        self._write_spark_color('x14:colorLast', color)

    def _write_color_high(self, color):
        # Write the <x14:colorHigh> element.
        self._write_spark_color('x14:colorHigh', color)

    def _write_color_low(self, color):
        # Write the <x14:colorLow> element.
        self._write_spark_color('x14:colorLow', color)

    def _write_phonetic_pr(self):
        # Write the <phoneticPr> element.
        attributes = [
            ('fontId', '0'),
            ('type', 'noConversion'),
        ]

        self._xml_empty_tag('phoneticPr', attributes)

    def _write_ignored_errors(self):
        # Write the <ignoredErrors> element.
        if not self.ignored_errors:
            return

        self._xml_start_tag('ignoredErrors')

        if self.ignored_errors.get('number_stored_as_text'):
            range = self.ignored_errors['number_stored_as_text']
            self._write_ignored_error('numberStoredAsText', range)

        if self.ignored_errors.get('eval_error'):
            range = self.ignored_errors['eval_error']
            self._write_ignored_error('evalError', range)

        if self.ignored_errors.get('formula_differs'):
            range = self.ignored_errors['formula_differs']
            self._write_ignored_error('formula', range)

        if self.ignored_errors.get('formula_range'):
            range = self.ignored_errors['formula_range']
            self._write_ignored_error('formulaRange', range)

        if self.ignored_errors.get('formula_unlocked'):
            range = self.ignored_errors['formula_unlocked']
            self._write_ignored_error('unlockedFormula', range)

        if self.ignored_errors.get('empty_cell_reference'):
            range = self.ignored_errors['empty_cell_reference']
            self._write_ignored_error('emptyCellReference', range)

        if self.ignored_errors.get('list_data_validation'):
            range = self.ignored_errors['list_data_validation']
            self._write_ignored_error('listDataValidation', range)

        if self.ignored_errors.get('calculated_column'):
            range = self.ignored_errors['calculated_column']
            self._write_ignored_error('calculatedColumn', range)

        if self.ignored_errors.get('two_digit_text_year'):
            range = self.ignored_errors['two_digit_text_year']
            self._write_ignored_error('twoDigitTextYear', range)

        self._xml_end_tag('ignoredErrors')

    def _write_ignored_error(self, type, range):
        # Write the <ignoredError> element.
        attributes = [
            ('sqref', range),
            (type, 1),
        ]

        self._xml_empty_tag('ignoredError', attributes)

```

---

### File: `tmp\xlsxwriter_old\XlsxWriter-1.4.5\xlsxwriter\xmlwriter.py`

```python
###############################################################################
#
# XMLwriter - A base class for XlsxWriter classes.
#
# Used in conjunction with XlsxWriter.
#
# Copyright 2013-2021, John McNamara, jmcnamara@cpan.org
#

# Standard packages.
import re
import codecs

# Standard packages in Python 2/3 compatibility mode.
from .compatibility import StringIO


class XMLwriter(object):
    """
    Simple XML writer class.

    """

    def __init__(self):
        self.fh = None
        self.escapes = re.compile('["&<>\n]')
        self.internal_fh = False

    def _set_filehandle(self, filehandle):
        # Set the writer filehandle directly. Mainly for testing.
        self.fh = filehandle
        self.internal_fh = False

    def _set_xml_writer(self, filename):
        # Set the XML writer filehandle for the object.
        if isinstance(filename, StringIO):
            self.internal_fh = False
            self.fh = filename
        else:
            self.internal_fh = True
            self.fh = codecs.open(filename, 'w', 'utf-8')

    def _xml_close(self):
        # Close the XML filehandle if we created it.
        if self.internal_fh:
            self.fh.close()

    def _xml_declaration(self):
        # Write the XML declaration.
        self.fh.write(
            """<?xml version="1.0" encoding="UTF-8" standalone="yes"?>\n""")

    def _xml_start_tag(self, tag, attributes=[]):
        # Write an XML start tag with optional attributes.
        for key, value in attributes:
            value = self._escape_attributes(value)
            tag += ' %s="%s"' % (key, value)

        self.fh.write("<%s>" % tag)

    def _xml_start_tag_unencoded(self, tag, attributes=[]):
        # Write an XML start tag with optional, unencoded, attributes.
        # This is a minor speed optimization for elements that don't
        # need encoding.
        for key, value in attributes:
            tag += ' %s="%s"' % (key, value)

        self.fh.write("<%s>" % tag)

    def _xml_end_tag(self, tag):
        # Write an XML end tag.
        self.fh.write("</%s>" % tag)

    def _xml_empty_tag(self, tag, attributes=[]):
        # Write an empty XML tag with optional attributes.
        for key, value in attributes:
            value = self._escape_attributes(value)
            tag += ' %s="%s"' % (key, value)

        self.fh.write("<%s/>" % tag)

    def _xml_empty_tag_unencoded(self, tag, attributes=[]):
        # Write an empty XML tag with optional, unencoded, attributes.
        # This is a minor speed optimization for elements that don't
        # need encoding.
        for key, value in attributes:
            tag += ' %s="%s"' % (key, value)

        self.fh.write("<%s/>" % tag)

    def _xml_data_element(self, tag, data, attributes=[]):
        # Write an XML element containing data with optional attributes.
        end_tag = tag

        for key, value in attributes:
            value = self._escape_attributes(value)
            tag += ' %s="%s"' % (key, value)

        data = self._escape_data(data)
        self.fh.write("<%s>%s</%s>" % (tag, data, end_tag))

    def _xml_string_element(self, index, attributes=[]):
        # Optimized tag writer for <c> cell string elements in the inner loop.
        attr = ''

        for key, value in attributes:
            value = self._escape_attributes(value)
            attr += ' %s="%s"' % (key, value)

        self.fh.write("""<c%s t="s"><v>%d</v></c>""" % (attr, index))

    def _xml_si_element(self, string, attributes=[]):
        # Optimized tag writer for shared strings <si> elements.
        attr = ''

        for key, value in attributes:
            value = self._escape_attributes(value)
            attr += ' %s="%s"' % (key, value)

        string = self._escape_data(string)

        self.fh.write("""<si><t%s>%s</t></si>""" % (attr, string))

    def _xml_rich_si_element(self, string):
        # Optimized tag writer for shared strings <si> rich string elements.

        self.fh.write("""<si>%s</si>""" % string)

    def _xml_number_element(self, number, attributes=[]):
        # Optimized tag writer for <c> cell number elements in the inner loop.
        attr = ''

        for key, value in attributes:
            value = self._escape_attributes(value)
            attr += ' %s="%s"' % (key, value)

        self.fh.write("""<c%s><v>%.16G</v></c>""" % (attr, number))

    def _xml_formula_element(self, formula, result, attributes=[]):
        # Optimized tag writer for <c> cell formula elements in the inner loop.
        attr = ''

        for key, value in attributes:
            value = self._escape_attributes(value)
            attr += ' %s="%s"' % (key, value)

        self.fh.write("""<c%s><f>%s</f><v>%s</v></c>"""
                      % (attr, self._escape_data(formula),
                         self._escape_data(result)))

    def _xml_inline_string(self, string, preserve, attributes=[]):
        # Optimized tag writer for inlineStr cell elements in the inner loop.
        attr = ''
        t_attr = ''

        # Set the <t> attribute to preserve whitespace.
        if preserve:
            t_attr = ' xml:space="preserve"'

        for key, value in attributes:
            value = self._escape_attributes(value)
            attr += ' %s="%s"' % (key, value)

        string = self._escape_data(string)

        self.fh.write("""<c%s t="inlineStr"><is><t%s>%s</t></is></c>""" %
                      (attr, t_attr, string))

    def _xml_rich_inline_string(self, string, attributes=[]):
        # Optimized tag writer for rich inlineStr in the inner loop.
        attr = ''

        for key, value in attributes:
            value = self._escape_attributes(value)
            attr += ' %s="%s"' % (key, value)

        self.fh.write("""<c%s t="inlineStr"><is>%s</is></c>""" %
                      (attr, string))

    def _escape_attributes(self, attribute):
        # Escape XML characters in attributes.
        try:
            if not self.escapes.search(attribute):
                return attribute
        except TypeError:
            return attribute

        attribute = attribute.replace('&', '&amp;')
        attribute = attribute.replace('"', '&quot;')
        attribute = attribute.replace('<', '&lt;')
        attribute = attribute.replace('>', '&gt;')
        attribute = attribute.replace('\n', '&#xA;')

        return attribute

    def _escape_data(self, data):
        # Escape XML characters in data sections of tags.  Note, this
        # is different from _escape_attributes() in that double quotes
        # are not escaped by Excel.
        try:
            if not self.escapes.search(data):
                return data
        except TypeError:
            return data

        data = data.replace('&', '&amp;')
        data = data.replace('<', '&lt;')
        data = data.replace('>', '&gt;')

        return data

```

---

### File: `tmp\xlsxwriter_sdist\XlsxWriter-3.2.0\examples\array_formula.py`

```python
#######################################################################
#
# Example of how to use Python and the XlsxWriter module to write
# simple array formulas.
#
# SPDX-License-Identifier: BSD-2-Clause
# Copyright 2013-2024, John McNamara, jmcnamara@cpan.org
#
import xlsxwriter

# Create a new workbook and add a worksheet
workbook = xlsxwriter.Workbook("array_formula.xlsx")
worksheet = workbook.add_worksheet()

# Write some test data.
worksheet.write("B1", 500)
worksheet.write("B2", 10)
worksheet.write("B5", 1)
worksheet.write("B6", 2)
worksheet.write("B7", 3)
worksheet.write("C1", 300)
worksheet.write("C2", 15)
worksheet.write("C5", 20234)
worksheet.write("C6", 21003)
worksheet.write("C7", 10000)


# Write an array formula that returns a single value
worksheet.write_formula("A1", "{=SUM(B1:C1*B2:C2)}")

# Same as above but more verbose.
worksheet.write_array_formula("A2:A2", "{=SUM(B1:C1*B2:C2)}")

# Write an array formula that returns a range of values
worksheet.write_array_formula("A5:A7", "{=TREND(C5:C7,B5:B7)}")

workbook.close()

```

---

### File: `tmp\xlsxwriter_sdist\XlsxWriter-3.2.0\examples\autofilter.py`

```python
###############################################################################
#
# An example of how to create autofilters with XlsxWriter.
#
# An autofilter is a way of adding drop down lists to the headers of a 2D
# range of worksheet data. This allows users to filter the data based on
# simple criteria so that some data is shown and some is hidden.
#
# SPDX-License-Identifier: BSD-2-Clause
# Copyright 2013-2024, John McNamara, jmcnamara@cpan.org
#
import xlsxwriter

workbook = xlsxwriter.Workbook("autofilter.xlsx")

# Add a worksheet for each autofilter example.
worksheet1 = workbook.add_worksheet()
worksheet2 = workbook.add_worksheet()
worksheet3 = workbook.add_worksheet()
worksheet4 = workbook.add_worksheet()
worksheet5 = workbook.add_worksheet()
worksheet6 = workbook.add_worksheet()
worksheet7 = workbook.add_worksheet()

# Add a bold format for the headers.
bold = workbook.add_format({"bold": 1})

# Open a text file with autofilter example data.
textfile = open("autofilter_data.txt")

# Read the headers from the first line of the input file.
headers = textfile.readline().strip("\n").split()


# Read the text file and store the field data.
data = []
for line in textfile:
    # Split the input data based on whitespace.
    row_data = line.strip("\n").split()

    # Convert the number data from the text file.
    for i, item in enumerate(row_data):
        try:
            row_data[i] = float(item)
        except ValueError:
            pass

    data.append(row_data)


# Set up several sheets with the same data.
for worksheet in workbook.worksheets():
    # Make the columns wider.
    worksheet.set_column("A:D", 12)
    # Make the header row larger.
    worksheet.set_row(0, 20, bold)
    # Make the headers bold.
    worksheet.write_row("A1", headers)


###############################################################################
#
# Example 1. Autofilter without conditions.
#

# Set the autofilter.
worksheet1.autofilter("A1:D51")

row = 1
for row_data in data:
    worksheet1.write_row(row, 0, row_data)

    # Move on to the next worksheet row.
    row += 1


###############################################################################
#
#
# Example 2. Autofilter with a filter condition in the first column.
#

# Autofilter range using Row-Column notation.
worksheet2.autofilter(0, 0, 50, 3)

# Add filter criteria. The placeholder "Region" in the filter is
# ignored and can be any string that adds clarity to the expression.
worksheet2.filter_column(0, "Region == East")

# Hide the rows that don't match the filter criteria.
row = 1
for row_data in data:
    region = row_data[0]

    # Check for rows that match the filter.
    if region == "East":
        # Row matches the filter, no further action required.
        pass
    else:
        # We need to hide rows that don't match the filter.
        worksheet2.set_row(row, options={"hidden": True})

    worksheet2.write_row(row, 0, row_data)

    # Move on to the next worksheet row.
    row += 1


###############################################################################
#
#
# Example 3. Autofilter with a dual filter condition in one of the columns.
#

# Set the autofilter.
worksheet3.autofilter("A1:D51")

# Add filter criteria.
worksheet3.filter_column("A", "x == East or x == South")

# Hide the rows that don't match the filter criteria.
row = 1
for row_data in data:
    region = row_data[0]

    # Check for rows that match the filter.
    if region == "East" or region == "South":
        # Row matches the filter, no further action required.
        pass
    else:
        # We need to hide rows that don't match the filter.
        worksheet3.set_row(row, options={"hidden": True})

    worksheet3.write_row(row, 0, row_data)

    # Move on to the next worksheet row.
    row += 1


###############################################################################
#
#
# Example 4. Autofilter with filter conditions in two columns.
#

# Set the autofilter.
worksheet4.autofilter("A1:D51")

# Add filter criteria.
worksheet4.filter_column("A", "x == East")
worksheet4.filter_column("C", "x > 3000 and x < 8000")

# Hide the rows that don't match the filter criteria.
row = 1
for row_data in data:
    region = row_data[0]
    volume = int(row_data[2])

    # Check for rows that match the filter.
    if region == "East" and volume > 3000 and volume < 8000:
        # Row matches the filter, no further action required.
        pass
    else:
        # We need to hide rows that don't match the filter.
        worksheet4.set_row(row, options={"hidden": True})

    worksheet4.write_row(row, 0, row_data)

    # Move on to the next worksheet row.
    row += 1


###############################################################################
#
#
# Example 5. Autofilter with a filter list condition in one of the columns.
#

# Set the autofilter.
worksheet5.autofilter("A1:D51")

# Add filter criteria.
worksheet5.filter_column_list("A", ["East", "North", "South"])

# Hide the rows that don't match the filter criteria.
row = 1
for row_data in data:
    region = row_data[0]

    # Check for rows that match the filter.
    if region == "East" or region == "North" or region == "South":
        # Row matches the filter, no further action required.
        pass
    else:
        # We need to hide rows that don't match the filter.
        worksheet5.set_row(row, options={"hidden": True})

    worksheet5.write_row(row, 0, row_data)

    # Move on to the next worksheet row.
    row += 1


###############################################################################
#
#
# Example 6. Autofilter with filter for blanks.
#
# Create a blank cell in our test data.

# Set the autofilter.
worksheet6.autofilter("A1:D51")

# Add filter criteria.
worksheet6.filter_column("A", "x == Blanks")

# Simulate a blank cell in the data.
data[5][0] = ""

# Hide the rows that don't match the filter criteria.
row = 1
for row_data in data:
    region = row_data[0]

    # Check for rows that match the filter.
    if region == "":
        # Row matches the filter, no further action required.
        pass
    else:
        # We need to hide rows that don't match the filter.
        worksheet6.set_row(row, options={"hidden": True})

    worksheet6.write_row(row, 0, row_data)

    # Move on to the next worksheet row.
    row += 1


###############################################################################
#
#
# Example 7. Autofilter with filter for non-blanks.
#

# Set the autofilter.
worksheet7.autofilter("A1:D51")

# Add filter criteria.
worksheet7.filter_column("A", "x == NonBlanks")

# Hide the rows that don't match the filter criteria.
row = 1
for row_data in data:
    region = row_data[0]

    # Check for rows that match the filter.
    if region != "":
        # Row matches the filter, no further action required.
        pass
    else:
        # We need to hide rows that don't match the filter.
        worksheet7.set_row(row, options={"hidden": True})

    worksheet7.write_row(row, 0, row_data)

    # Move on to the next worksheet row.
    row += 1


workbook.close()

```

---

### File: `tmp\xlsxwriter_sdist\XlsxWriter-3.2.0\examples\autofit.py`

```python
#######################################################################
#
# An example of using simulated autofit to automatically adjust the width of
# worksheet columns based on the data in the cells.
#
# SPDX-License-Identifier: BSD-2-Clause
# Copyright 2013-2024, John McNamara, jmcnamara@cpan.org
#
from xlsxwriter.workbook import Workbook

workbook = Workbook("autofit.xlsx")
worksheet = workbook.add_worksheet()

# Write some worksheet data to demonstrate autofitting.
worksheet.write(0, 0, "Foo")
worksheet.write(1, 0, "Food")
worksheet.write(2, 0, "Foody")
worksheet.write(3, 0, "Froody")

worksheet.write(0, 1, 12345)
worksheet.write(1, 1, 12345678)
worksheet.write(2, 1, 12345)

worksheet.write(0, 2, "Some longer text")

worksheet.write(0, 3, "http://ww.google.com")
worksheet.write(1, 3, "https://github.com")

# Autofit the worksheet.
worksheet.autofit()

workbook.close()

```

---

### File: `tmp\xlsxwriter_sdist\XlsxWriter-3.2.0\examples\background.py`

```python
##############################################################################
#
# An example of setting a worksheet background image with the XlsxWriter
# Python module.
#
# SPDX-License-Identifier: BSD-2-Clause
# Copyright 2013-2024, John McNamara, jmcnamara@cpan.org
#
import xlsxwriter


# Create an new Excel file and add a worksheet.
workbook = xlsxwriter.Workbook("background.xlsx")
worksheet = workbook.add_worksheet()

# Set the background image.
worksheet.set_background("logo.png")

workbook.close()

```

---

### File: `tmp\xlsxwriter_sdist\XlsxWriter-3.2.0\examples\cell_indentation.py`

```python
##############################################################################
#
# A simple formatting example using XlsxWriter.
#
# This program demonstrates the indentation cell format.
#
# SPDX-License-Identifier: BSD-2-Clause
# Copyright 2013-2024, John McNamara, jmcnamara@cpan.org
#
import xlsxwriter

workbook = xlsxwriter.Workbook("cell_indentation.xlsx")

worksheet = workbook.add_worksheet()

indent1 = workbook.add_format({"indent": 1})
indent2 = workbook.add_format({"indent": 2})

worksheet.set_column("A:A", 40)

worksheet.write("A1", "This text is indented 1 level", indent1)
worksheet.write("A2", "This text is indented 2 levels", indent2)

workbook.close()

```

---

### File: `tmp\xlsxwriter_sdist\XlsxWriter-3.2.0\examples\chart.py`

```python
#######################################################################
#
# An example of a simple Excel chart with Python and XlsxWriter.
#
# SPDX-License-Identifier: BSD-2-Clause
# Copyright 2013-2024, John McNamara, jmcnamara@cpan.org
#
import xlsxwriter

workbook = xlsxwriter.Workbook("chart.xlsx")
worksheet = workbook.add_worksheet()

# Create a new Chart object.
chart = workbook.add_chart({"type": "column"})

# Write some data to add to plot on the chart.
data = [
    [1, 2, 3, 4, 5],
    [2, 4, 6, 8, 10],
    [3, 6, 9, 12, 15],
]

worksheet.write_column("A1", data[0])
worksheet.write_column("B1", data[1])
worksheet.write_column("C1", data[2])

# Configure the charts. In simplest case we just add some data series.
chart.add_series({"values": "=Sheet1!$A$1:$A$5"})
chart.add_series({"values": "=Sheet1!$B$1:$B$5"})
chart.add_series({"values": "=Sheet1!$C$1:$C$5"})

# Insert the chart into the worksheet.
worksheet.insert_chart("A7", chart)

workbook.close()

```

---

### File: `tmp\xlsxwriter_sdist\XlsxWriter-3.2.0\examples\chart_area.py`

```python
#######################################################################
#
# An example of creating Excel Area charts with Python and XlsxWriter.
#
# SPDX-License-Identifier: BSD-2-Clause
# Copyright 2013-2024, John McNamara, jmcnamara@cpan.org
#
import xlsxwriter

workbook = xlsxwriter.Workbook("chart_area.xlsx")
worksheet = workbook.add_worksheet()
bold = workbook.add_format({"bold": 1})

# Add the worksheet data that the charts will refer to.
headings = ["Number", "Batch 1", "Batch 2"]
data = [
    [2, 3, 4, 5, 6, 7],
    [40, 40, 50, 30, 25, 50],
    [30, 25, 30, 10, 5, 10],
]

worksheet.write_row("A1", headings, bold)
worksheet.write_column("A2", data[0])
worksheet.write_column("B2", data[1])
worksheet.write_column("C2", data[2])

#######################################################################
#
# Create an area chart.
#
chart1 = workbook.add_chart({"type": "area"})

# Configure the first series.
chart1.add_series(
    {
        "name": "=Sheet1!$B$1",
        "categories": "=Sheet1!$A$2:$A$7",
        "values": "=Sheet1!$B$2:$B$7",
    }
)

# Configure a second series. Note use of alternative syntax to define ranges.
chart1.add_series(
    {
        "name": ["Sheet1", 0, 2],
        "categories": ["Sheet1", 1, 0, 6, 0],
        "values": ["Sheet1", 1, 2, 6, 2],
    }
)

# Add a chart title and some axis labels.
chart1.set_title({"name": "Results of sample analysis"})
chart1.set_x_axis({"name": "Test number"})
chart1.set_y_axis({"name": "Sample length (mm)"})

# Set an Excel chart style.
chart1.set_style(11)

# Insert the chart into the worksheet (with an offset).
worksheet.insert_chart("D2", chart1, {"x_offset": 25, "y_offset": 10})

#######################################################################
#
# Create a stacked area chart sub-type.
#
chart2 = workbook.add_chart({"type": "area", "subtype": "stacked"})

# Configure the first series.
chart2.add_series(
    {
        "name": "=Sheet1!$B$1",
        "categories": "=Sheet1!$A$2:$A$7",
        "values": "=Sheet1!$B$2:$B$7",
    }
)

# Configure second series.
chart2.add_series(
    {
        "name": "=Sheet1!$C$1",
        "categories": "=Sheet1!$A$2:$A$7",
        "values": "=Sheet1!$C$2:$C$7",
    }
)

# Add a chart title and some axis labels.
chart2.set_title({"name": "Stacked Chart"})
chart2.set_x_axis({"name": "Test number"})
chart2.set_y_axis({"name": "Sample length (mm)"})

# Set an Excel chart style.
chart2.set_style(12)

# Insert the chart into the worksheet (with an offset).
worksheet.insert_chart("D18", chart2, {"x_offset": 25, "y_offset": 10})

#######################################################################
#
# Create a percent stacked area chart sub-type.
#
chart3 = workbook.add_chart({"type": "area", "subtype": "percent_stacked"})

# Configure the first series.
chart3.add_series(
    {
        "name": "=Sheet1!$B$1",
        "categories": "=Sheet1!$A$2:$A$7",
        "values": "=Sheet1!$B$2:$B$7",
    }
)

# Configure second series.
chart3.add_series(
    {
        "name": "=Sheet1!$C$1",
        "categories": "=Sheet1!$A$2:$A$7",
        "values": "=Sheet1!$C$2:$C$7",
    }
)

# Add a chart title and some axis labels.
chart3.set_title({"name": "Percent Stacked Chart"})
chart3.set_x_axis({"name": "Test number"})
chart3.set_y_axis({"name": "Sample length (mm)"})

# Set an Excel chart style.
chart3.set_style(13)

# Insert the chart into the worksheet (with an offset).
worksheet.insert_chart("D34", chart3, {"x_offset": 25, "y_offset": 10})

workbook.close()

```

---

### File: `tmp\xlsxwriter_sdist\XlsxWriter-3.2.0\examples\chart_bar.py`

```python
#######################################################################
#
# An example of creating Excel Bar charts with Python and XlsxWriter.
#
# SPDX-License-Identifier: BSD-2-Clause
# Copyright 2013-2024, John McNamara, jmcnamara@cpan.org
#
import xlsxwriter

workbook = xlsxwriter.Workbook("chart_bar.xlsx")
worksheet = workbook.add_worksheet()
bold = workbook.add_format({"bold": 1})

# Add the worksheet data that the charts will refer to.
headings = ["Number", "Batch 1", "Batch 2"]
data = [
    [2, 3, 4, 5, 6, 7],
    [10, 40, 50, 20, 10, 50],
    [30, 60, 70, 50, 40, 30],
]

worksheet.write_row("A1", headings, bold)
worksheet.write_column("A2", data[0])
worksheet.write_column("B2", data[1])
worksheet.write_column("C2", data[2])

#######################################################################
#
# Create a new bar chart.
#
chart1 = workbook.add_chart({"type": "bar"})

# Configure the first series.
chart1.add_series(
    {
        "name": "=Sheet1!$B$1",
        "categories": "=Sheet1!$A$2:$A$7",
        "values": "=Sheet1!$B$2:$B$7",
    }
)

# Configure a second series. Note use of alternative syntax to define ranges.
chart1.add_series(
    {
        "name": ["Sheet1", 0, 2],
        "categories": ["Sheet1", 1, 0, 6, 0],
        "values": ["Sheet1", 1, 2, 6, 2],
    }
)

# Add a chart title and some axis labels.
chart1.set_title({"name": "Results of sample analysis"})
chart1.set_x_axis({"name": "Test number"})
chart1.set_y_axis({"name": "Sample length (mm)"})

# Set an Excel chart style.
chart1.set_style(11)

# Insert the chart into the worksheet (with an offset).
worksheet.insert_chart("D2", chart1, {"x_offset": 25, "y_offset": 10})

#######################################################################
#
# Create a stacked chart sub-type.
#
chart2 = workbook.add_chart({"type": "bar", "subtype": "stacked"})

# Configure the first series.
chart2.add_series(
    {
        "name": "=Sheet1!$B$1",
        "categories": "=Sheet1!$A$2:$A$7",
        "values": "=Sheet1!$B$2:$B$7",
    }
)

# Configure second series.
chart2.add_series(
    {
        "name": "=Sheet1!$C$1",
        "categories": "=Sheet1!$A$2:$A$7",
        "values": "=Sheet1!$C$2:$C$7",
    }
)

# Add a chart title and some axis labels.
chart2.set_title({"name": "Stacked Chart"})
chart2.set_x_axis({"name": "Test number"})
chart2.set_y_axis({"name": "Sample length (mm)"})

# Set an Excel chart style.
chart2.set_style(12)

# Insert the chart into the worksheet (with an offset).
worksheet.insert_chart("D18", chart2, {"x_offset": 25, "y_offset": 10})

#######################################################################
#
# Create a percentage stacked chart sub-type.
#
chart3 = workbook.add_chart({"type": "bar", "subtype": "percent_stacked"})

# Configure the first series.
chart3.add_series(
    {
        "name": "=Sheet1!$B$1",
        "categories": "=Sheet1!$A$2:$A$7",
        "values": "=Sheet1!$B$2:$B$7",
    }
)

# Configure second series.
chart3.add_series(
    {
        "name": "=Sheet1!$C$1",
        "categories": "=Sheet1!$A$2:$A$7",
        "values": "=Sheet1!$C$2:$C$7",
    }
)

# Add a chart title and some axis labels.
chart3.set_title({"name": "Percent Stacked Chart"})
chart3.set_x_axis({"name": "Test number"})
chart3.set_y_axis({"name": "Sample length (mm)"})

# Set an Excel chart style.
chart3.set_style(13)

# Insert the chart into the worksheet (with an offset).
worksheet.insert_chart("D34", chart3, {"x_offset": 25, "y_offset": 10})

workbook.close()

```

---

### File: `tmp\xlsxwriter_sdist\XlsxWriter-3.2.0\examples\chart_clustered.py`

```python
#######################################################################
#
# A demo of a clustered category chart in XlsxWriter.
#
# SPDX-License-Identifier: BSD-2-Clause
# Copyright 2013-2024, John McNamara, jmcnamara@cpan.org
#
from xlsxwriter.workbook import Workbook

workbook = Workbook("chart_clustered.xlsx")
worksheet = workbook.add_worksheet()
bold = workbook.add_format({"bold": 1})

# Add the worksheet data that the charts will refer to.
headings = ["Types", "Sub Type", "Value 1", "Value 2", "Value 3"]
data = [
    ["Type 1", "Sub Type A", 5000, 8000, 6000],
    ["", "Sub Type B", 2000, 3000, 4000],
    ["", "Sub Type C", 250, 1000, 2000],
    ["Type 2", "Sub Type D", 6000, 6000, 6500],
    ["", "Sub Type E", 500, 300, 200],
]

worksheet.write_row("A1", headings, bold)

for row_num, row_data in enumerate(data):
    worksheet.write_row(row_num + 1, 0, row_data)

# Create a new chart object. In this case an embedded chart.
chart = workbook.add_chart({"type": "column"})

# Configure the series. Note, that the categories are 2D ranges (from column A
# to column B). This creates the clusters. The series are shown as formula
# strings for clarity but you can also use the list syntax. See the docs.
chart.add_series(
    {
        "categories": "=Sheet1!$A$2:$B$6",
        "values": "=Sheet1!$C$2:$C$6",
    }
)

chart.add_series(
    {
        "categories": "=Sheet1!$A$2:$B$6",
        "values": "=Sheet1!$D$2:$D$6",
    }
)

chart.add_series(
    {
        "categories": "=Sheet1!$A$2:$B$6",
        "values": "=Sheet1!$E$2:$E$6",
    }
)

# Set the Excel chart style.
chart.set_style(37)

# Turn off the legend.
chart.set_legend({"position": "none"})

# Insert the chart into the worksheet.
worksheet.insert_chart("G3", chart)

workbook.close()

```

---

### File: `tmp\xlsxwriter_sdist\XlsxWriter-3.2.0\examples\chart_column.py`

```python
#######################################################################
#
# An example of creating Excel Column charts with Python and XlsxWriter.
#
# SPDX-License-Identifier: BSD-2-Clause
# Copyright 2013-2024, John McNamara, jmcnamara@cpan.org
#
import xlsxwriter

workbook = xlsxwriter.Workbook("chart_column.xlsx")
worksheet = workbook.add_worksheet()
bold = workbook.add_format({"bold": 1})

# Add the worksheet data that the charts will refer to.
headings = ["Number", "Batch 1", "Batch 2"]
data = [
    [2, 3, 4, 5, 6, 7],
    [10, 40, 50, 20, 10, 50],
    [30, 60, 70, 50, 40, 30],
]

worksheet.write_row("A1", headings, bold)
worksheet.write_column("A2", data[0])
worksheet.write_column("B2", data[1])
worksheet.write_column("C2", data[2])

#######################################################################
#
# Create a new column chart.
#
chart1 = workbook.add_chart({"type": "column"})

# Configure the first series.
chart1.add_series(
    {
        "name": "=Sheet1!$B$1",
        "categories": "=Sheet1!$A$2:$A$7",
        "values": "=Sheet1!$B$2:$B$7",
    }
)

# Configure a second series. Note use of alternative syntax to define ranges.
chart1.add_series(
    {
        "name": ["Sheet1", 0, 2],
        "categories": ["Sheet1", 1, 0, 6, 0],
        "values": ["Sheet1", 1, 2, 6, 2],
    }
)

# Add a chart title and some axis labels.
chart1.set_title({"name": "Results of sample analysis"})
chart1.set_x_axis({"name": "Test number"})
chart1.set_y_axis({"name": "Sample length (mm)"})

# Set an Excel chart style.
chart1.set_style(11)

# Insert the chart into the worksheet (with an offset).
worksheet.insert_chart("D2", chart1, {"x_offset": 25, "y_offset": 10})

#######################################################################
#
# Create a stacked chart sub-type.
#
chart2 = workbook.add_chart({"type": "column", "subtype": "stacked"})

# Configure the first series.
chart2.add_series(
    {
        "name": "=Sheet1!$B$1",
        "categories": "=Sheet1!$A$2:$A$7",
        "values": "=Sheet1!$B$2:$B$7",
    }
)

# Configure second series.
chart2.add_series(
    {
        "name": "=Sheet1!$C$1",
        "categories": "=Sheet1!$A$2:$A$7",
        "values": "=Sheet1!$C$2:$C$7",
    }
)

# Add a chart title and some axis labels.
chart2.set_title({"name": "Stacked Chart"})
chart2.set_x_axis({"name": "Test number"})
chart2.set_y_axis({"name": "Sample length (mm)"})

# Set an Excel chart style.
chart2.set_style(12)

# Insert the chart into the worksheet (with an offset).
worksheet.insert_chart("D18", chart2, {"x_offset": 25, "y_offset": 10})

#######################################################################
#
# Create a percentage stacked chart sub-type.
#
chart3 = workbook.add_chart({"type": "column", "subtype": "percent_stacked"})

# Configure the first series.
chart3.add_series(
    {
        "name": "=Sheet1!$B$1",
        "categories": "=Sheet1!$A$2:$A$7",
        "values": "=Sheet1!$B$2:$B$7",
    }
)

# Configure second series.
chart3.add_series(
    {
        "name": "=Sheet1!$C$1",
        "categories": "=Sheet1!$A$2:$A$7",
        "values": "=Sheet1!$C$2:$C$7",
    }
)

# Add a chart title and some axis labels.
chart3.set_title({"name": "Percent Stacked Chart"})
chart3.set_x_axis({"name": "Test number"})
chart3.set_y_axis({"name": "Sample length (mm)"})

# Set an Excel chart style.
chart3.set_style(13)

# Insert the chart into the worksheet (with an offset).
worksheet.insert_chart("D34", chart3, {"x_offset": 25, "y_offset": 10})

workbook.close()

```

---

### File: `tmp\xlsxwriter_sdist\XlsxWriter-3.2.0\examples\chart_combined.py`

```python
#######################################################################
#
# An example of a Combined chart in XlsxWriter.
#
# SPDX-License-Identifier: BSD-2-Clause
# Copyright 2013-2024, John McNamara, jmcnamara@cpan.org
#
from xlsxwriter.workbook import Workbook

workbook = Workbook("chart_combined.xlsx")
worksheet = workbook.add_worksheet()

# Add a format for the headings.
bold = workbook.add_format({"bold": True})

# Add the worksheet data that the charts will refer to.
headings = ["Number", "Batch 1", "Batch 2"]
data = [
    [2, 3, 4, 5, 6, 7],
    [10, 40, 50, 20, 10, 50],
    [30, 60, 70, 50, 40, 30],
]

worksheet.write_row("A1", headings, bold)
worksheet.write_column("A2", data[0])
worksheet.write_column("B2", data[1])
worksheet.write_column("C2", data[2])

#
# In the first example we will create a combined column and line chart.
# They will share the same X and Y axes.
#

# Create a new column chart. This will use this as the primary chart.
column_chart1 = workbook.add_chart({"type": "column"})

# Configure the data series for the primary chart.
column_chart1.add_series(
    {
        "name": "=Sheet1!$B$1",
        "categories": "=Sheet1!$A$2:$A$7",
        "values": "=Sheet1!$B$2:$B$7",
    }
)

# Create a new column chart. This will use this as the secondary chart.
line_chart1 = workbook.add_chart({"type": "line"})

# Configure the data series for the secondary chart.
line_chart1.add_series(
    {
        "name": "=Sheet1!$C$1",
        "categories": "=Sheet1!$A$2:$A$7",
        "values": "=Sheet1!$C$2:$C$7",
    }
)

# Combine the charts.
column_chart1.combine(line_chart1)

# Add a chart title and some axis labels. Note, this is done via the
# primary chart.
column_chart1.set_title({"name": "Combined chart - same Y axis"})
column_chart1.set_x_axis({"name": "Test number"})
column_chart1.set_y_axis({"name": "Sample length (mm)"})

# Insert the chart into the worksheet
worksheet.insert_chart("E2", column_chart1)

#
# In the second example we will create a similar combined column and line
# chart except that the secondary chart will have a secondary Y axis.
#

# Create a new column chart. This will use this as the primary chart.
column_chart2 = workbook.add_chart({"type": "column"})

# Configure the data series for the primary chart.
column_chart2.add_series(
    {
        "name": "=Sheet1!$B$1",
        "categories": "=Sheet1!$A$2:$A$7",
        "values": "=Sheet1!$B$2:$B$7",
    }
)

# Create a new column chart. This will use this as the secondary chart.
line_chart2 = workbook.add_chart({"type": "line"})

# Configure the data series for the secondary chart. We also set a
# secondary Y axis via (y2_axis). This is the only difference between
# this and the first example, apart from the axis label below.
line_chart2.add_series(
    {
        "name": "=Sheet1!$C$1",
        "categories": "=Sheet1!$A$2:$A$7",
        "values": "=Sheet1!$C$2:$C$7",
        "y2_axis": True,
    }
)

# Combine the charts.
column_chart2.combine(line_chart2)

# Add a chart title and some axis labels.
column_chart2.set_title({"name": "Combine chart - secondary Y axis"})
column_chart2.set_x_axis({"name": "Test number"})
column_chart2.set_y_axis({"name": "Sample length (mm)"})

# Note: the y2 properties are on the secondary chart.
line_chart2.set_y2_axis({"name": "Target length (mm)"})

# Insert the chart into the worksheet
worksheet.insert_chart("E18", column_chart2)

workbook.close()

```

---

### File: `tmp\xlsxwriter_sdist\XlsxWriter-3.2.0\examples\chart_data_labels.py`

```python
#######################################################################
#
# A demo of an various Excel chart data label features that are available
# via an XlsxWriter chart.
#
# SPDX-License-Identifier: BSD-2-Clause
# Copyright 2013-2024, John McNamara, jmcnamara@cpan.org
#
import xlsxwriter

workbook = xlsxwriter.Workbook("chart_data_labels.xlsx")
worksheet = workbook.add_worksheet()
bold = workbook.add_format({"bold": 1})

# Add the worksheet data that the charts will refer to.
headings = ["Number", "Data", "Text"]

data = [
    [2, 3, 4, 5, 6, 7],
    [20, 10, 20, 30, 40, 30],
    ["Jan", "Feb", "Mar", "Apr", "May", "Jun"],
]

worksheet.write_row("A1", headings, bold)
worksheet.write_column("A2", data[0])
worksheet.write_column("B2", data[1])
worksheet.write_column("C2", data[2])

#######################################################################
#
# Example with standard data labels.
#

# Create a Column chart.
chart1 = workbook.add_chart({"type": "column"})

# Configure the data series and add the data labels.
chart1.add_series(
    {
        "categories": "=Sheet1!$A$2:$A$7",
        "values": "=Sheet1!$B$2:$B$7",
        "data_labels": {"value": True},
    }
)

# Add a chart title.
chart1.set_title({"name": "Chart with standard data labels"})

# Turn off the chart legend.
chart1.set_legend({"none": True})

# Insert the chart into the worksheet (with an offset).
worksheet.insert_chart("D2", chart1, {"x_offset": 25, "y_offset": 10})

#######################################################################
#
# Example with value and category data labels.
#

# Create a Column chart.
chart2 = workbook.add_chart({"type": "column"})

# Configure the data series and add the data labels.
chart2.add_series(
    {
        "categories": "=Sheet1!$A$2:$A$7",
        "values": "=Sheet1!$B$2:$B$7",
        "data_labels": {"value": True, "category": True},
    }
)

# Add a chart title.
chart2.set_title({"name": "Category and Value data labels"})

# Turn off the chart legend.
chart2.set_legend({"none": True})

# Insert the chart into the worksheet (with an offset).
worksheet.insert_chart("D18", chart2, {"x_offset": 25, "y_offset": 10})

#######################################################################
#
# Example with standard data labels with different font.
#

# Create a Column chart.
chart3 = workbook.add_chart({"type": "column"})

# Configure the data series and add the data labels.
chart3.add_series(
    {
        "categories": "=Sheet1!$A$2:$A$7",
        "values": "=Sheet1!$B$2:$B$7",
        "data_labels": {
            "value": True,
            "font": {"bold": True, "color": "red", "rotation": -30},
        },
    }
)

# Add a chart title.
chart3.set_title({"name": "Data labels with user defined font"})

# Turn off the chart legend.
chart3.set_legend({"none": True})

# Insert the chart into the worksheet (with an offset).
worksheet.insert_chart("D34", chart3, {"x_offset": 25, "y_offset": 10})

#######################################################################
#
# Example with standard data labels and formatting.
#

# Create a Column chart.
chart4 = workbook.add_chart({"type": "column"})

# Configure the data series and add the data labels.
chart4.add_series(
    {
        "categories": "=Sheet1!$A$2:$A$7",
        "values": "=Sheet1!$B$2:$B$7",
        "data_labels": {
            "value": True,
            "border": {"color": "red"},
            "fill": {"color": "yellow"},
        },
    }
)

# Add a chart title.
chart4.set_title({"name": "Data labels with formatting"})

# Turn off the chart legend.
chart4.set_legend({"none": True})

# Insert the chart into the worksheet (with an offset).
worksheet.insert_chart("D50", chart4, {"x_offset": 25, "y_offset": 10})

#######################################################################
#
# Example with custom string data labels.
#

# Create a Column chart.
chart5 = workbook.add_chart({"type": "column"})

# Some custom labels.
custom_labels = [
    {"value": "Amy"},
    {"value": "Bea"},
    {"value": "Eva"},
    {"value": "Fay"},
    {"value": "Liv"},
    {"value": "Una"},
]

# Configure the data series and add the data labels.
chart5.add_series(
    {
        "categories": "=Sheet1!$A$2:$A$7",
        "values": "=Sheet1!$B$2:$B$7",
        "data_labels": {"value": True, "custom": custom_labels},
    }
)

# Add a chart title.
chart5.set_title({"name": "Chart with custom string data labels"})

# Turn off the chart legend.
chart5.set_legend({"none": True})

# Insert the chart into the worksheet (with an offset).
worksheet.insert_chart("D66", chart5, {"x_offset": 25, "y_offset": 10})

#######################################################################
#
# Example with custom data labels from cells.
#

# Create a Column chart.
chart6 = workbook.add_chart({"type": "column"})

# Some custom labels.
custom_labels = [
    {"value": "=Sheet1!$C$2"},
    {"value": "=Sheet1!$C$3"},
    {"value": "=Sheet1!$C$4"},
    {"value": "=Sheet1!$C$5"},
    {"value": "=Sheet1!$C$6"},
    {"value": "=Sheet1!$C$7"},
]

# Configure the data series and add the data labels.
chart6.add_series(
    {
        "categories": "=Sheet1!$A$2:$A$7",
        "values": "=Sheet1!$B$2:$B$7",
        "data_labels": {"value": True, "custom": custom_labels},
    }
)

# Add a chart title.
chart6.set_title({"name": "Chart with custom data labels from cells"})

# Turn off the chart legend.
chart6.set_legend({"none": True})

# Insert the chart into the worksheet (with an offset).
worksheet.insert_chart("D82", chart6, {"x_offset": 25, "y_offset": 10})

#######################################################################
#
# Example with custom and default data labels.
#

# Create a Column chart.
chart7 = workbook.add_chart({"type": "column"})

# The following is used to get a mix of default and custom labels. The 'None'
# items will get the default value. We also set a font for the custom items
# as an extra example.
custom_labels = [
    {"value": "=Sheet1!$C$2", "font": {"color": "red"}},
    None,
    {"value": "=Sheet1!$C$4", "font": {"color": "red"}},
    {"value": "=Sheet1!$C$5", "font": {"color": "red"}},
]

# Configure the data series and add the data labels.
chart7.add_series(
    {
        "categories": "=Sheet1!$A$2:$A$7",
        "values": "=Sheet1!$B$2:$B$7",
        "data_labels": {"value": True, "custom": custom_labels},
    }
)

# Add a chart title.
chart7.set_title({"name": "Mixed custom and default data labels"})

# Turn off the chart legend.
chart7.set_legend({"none": True})

# Insert the chart into the worksheet (with an offset).
worksheet.insert_chart("D98", chart7, {"x_offset": 25, "y_offset": 10})


#######################################################################
#
# Example with deleted custom data labels.
#

# Create a Column chart.
chart8 = workbook.add_chart({"type": "column"})

# Some deleted custom labels and defaults (set with None values). This allows
# us to highlight certain values such as the minimum and maximum.
custom_labels = [
    {"delete": True},
    None,
    {"delete": True},
    {"delete": True},
    None,
    {"delete": True},
]

# Configure the data series and add the data labels.
chart8.add_series(
    {
        "categories": "=Sheet1!$A$2:$A$7",
        "values": "=Sheet1!$B$2:$B$7",
        "data_labels": {"value": True, "custom": custom_labels},
    }
)

# Add a chart title.
chart8.set_title({"name": "Chart with deleted data labels"})

# Turn off the chart legend.
chart8.set_legend({"none": True})

# Insert the chart into the worksheet (with an offset).
worksheet.insert_chart("D114", chart8, {"x_offset": 25, "y_offset": 10})

#######################################################################
#
# Example with custom string data labels and formatting.
#

# Create a Column chart.
chart9 = workbook.add_chart({"type": "column"})

# Some custom labels.
custom_labels = [
    {"value": "Amy", "border": {"color": "blue"}},
    {"value": "Bea"},
    {"value": "Eva"},
    {"value": "Fay"},
    {"value": "Liv"},
    {"value": "Una", "fill": {"color": "green"}},
]

# Configure the data series and add the data labels.
chart9.add_series(
    {
        "categories": "=Sheet1!$A$2:$A$7",
        "values": "=Sheet1!$B$2:$B$7",
        "data_labels": {
            "value": True,
            "custom": custom_labels,
            "border": {"color": "red"},
            "fill": {"color": "yellow"},
        },
    }
)

# Add a chart title.
chart9.set_title({"name": "Chart with custom labels and formatting"})

# Turn off the chart legend.
chart9.set_legend({"none": True})

# Insert the chart into the worksheet (with an offset).
worksheet.insert_chart("D130", chart9, {"x_offset": 25, "y_offset": 10})

workbook.close()

```

---

### File: `tmp\xlsxwriter_sdist\XlsxWriter-3.2.0\examples\chart_data_table.py`

```python
#######################################################################
#
# An example of creating Excel Column charts with data tables using
# Python and XlsxWriter.
#
# SPDX-License-Identifier: BSD-2-Clause
# Copyright 2013-2024, John McNamara, jmcnamara@cpan.org
#
import xlsxwriter

workbook = xlsxwriter.Workbook("chart_data_table.xlsx")
worksheet = workbook.add_worksheet()
bold = workbook.add_format({"bold": 1})

# Add the worksheet data that the charts will refer to.
headings = ["Number", "Batch 1", "Batch 2"]
data = [
    [2, 3, 4, 5, 6, 7],
    [10, 40, 50, 20, 10, 50],
    [30, 60, 70, 50, 40, 30],
]

worksheet.write_row("A1", headings, bold)
worksheet.write_column("A2", data[0])
worksheet.write_column("B2", data[1])
worksheet.write_column("C2", data[2])


#######################################################################
#
# Create a column chart with a data table.
#
chart1 = workbook.add_chart({"type": "column"})

# Configure the first series.
chart1.add_series(
    {
        "name": "=Sheet1!$B$1",
        "categories": "=Sheet1!$A$2:$A$7",
        "values": "=Sheet1!$B$2:$B$7",
    }
)

# Configure second series. Note use of alternative syntax to define ranges.
chart1.add_series(
    {
        "name": ["Sheet1", 0, 2],
        "categories": ["Sheet1", 1, 0, 6, 0],
        "values": ["Sheet1", 1, 2, 6, 2],
    }
)

# Add a chart title and some axis labels.
chart1.set_title({"name": "Chart with Data Table"})
chart1.set_x_axis({"name": "Test number"})
chart1.set_y_axis({"name": "Sample length (mm)"})

# Set a default data table on the X-Axis.
chart1.set_table()

# Insert the chart into the worksheet (with an offset).
worksheet.insert_chart("D2", chart1, {"x_offset": 25, "y_offset": 10})

#######################################################################
#
# Create a column chart with a data table and legend keys.
#
chart2 = workbook.add_chart({"type": "column"})

# Configure the first series.
chart2.add_series(
    {
        "name": "=Sheet1!$B$1",
        "categories": "=Sheet1!$A$2:$A$7",
        "values": "=Sheet1!$B$2:$B$7",
    }
)

# Configure second series.
chart2.add_series(
    {
        "name": "=Sheet1!$C$1",
        "categories": "=Sheet1!$A$2:$A$7",
        "values": "=Sheet1!$C$2:$C$7",
    }
)

# Add a chart title and some axis labels.
chart2.set_title({"name": "Data Table with legend keys"})
chart2.set_x_axis({"name": "Test number"})
chart2.set_y_axis({"name": "Sample length (mm)"})

# Set a data table on the X-Axis with the legend keys shown.
chart2.set_table({"show_keys": True})

# Hide the chart legend since the keys are shown on the data table.
chart2.set_legend({"position": "none"})

# Insert the chart into the worksheet (with an offset).
worksheet.insert_chart("D18", chart2, {"x_offset": 25, "y_offset": 10})

workbook.close()

```

---

### File: `tmp\xlsxwriter_sdist\XlsxWriter-3.2.0\examples\chart_data_tools.py`

```python
#######################################################################
#
# A demo of an various Excel chart data tools that are available via
# an XlsxWriter chart.
#
# These include, Trendlines, Data Labels, Error Bars, Drop Lines,
# High-Low Lines and Up-Down Bars.
#
# SPDX-License-Identifier: BSD-2-Clause
# Copyright 2013-2024, John McNamara, jmcnamara@cpan.org
#
import xlsxwriter

workbook = xlsxwriter.Workbook("chart_data_tools.xlsx")
worksheet = workbook.add_worksheet()
bold = workbook.add_format({"bold": 1})

# Add the worksheet data that the charts will refer to.
headings = ["Number", "Data 1", "Data 2"]
data = [
    [2, 3, 4, 5, 6, 7],
    [10, 40, 50, 20, 10, 50],
    [30, 60, 70, 50, 40, 30],
]

worksheet.write_row("A1", headings, bold)
worksheet.write_column("A2", data[0])
worksheet.write_column("B2", data[1])
worksheet.write_column("C2", data[2])


#######################################################################
#
# Trendline example.
#
# Create a Line chart.
chart1 = workbook.add_chart({"type": "line"})

# Configure the first series with a polynomial trendline.
chart1.add_series(
    {
        "categories": "=Sheet1!$A$2:$A$7",
        "values": "=Sheet1!$B$2:$B$7",
        "trendline": {
            "type": "polynomial",
            "order": 3,
        },
    }
)

# Configure the second series with a moving average trendline.
chart1.add_series(
    {
        "categories": "=Sheet1!$A$2:$A$7",
        "values": "=Sheet1!$C$2:$C$7",
        "trendline": {"type": "linear"},
    }
)

# Add a chart title.
chart1.set_title({"name": "Chart with Trendlines"})

# Insert the chart into the worksheet (with an offset).
worksheet.insert_chart("D2", chart1, {"x_offset": 25, "y_offset": 10})

#######################################################################
#
# Data Labels and Markers example.
#
# Create a Line chart.
chart2 = workbook.add_chart({"type": "line"})

# Configure the first series.
chart2.add_series(
    {
        "categories": "=Sheet1!$A$2:$A$7",
        "values": "=Sheet1!$B$2:$B$7",
        "data_labels": {"value": 1},
        "marker": {"type": "automatic"},
    }
)

# Configure the second series.
chart2.add_series(
    {
        "categories": "=Sheet1!$A$2:$A$7",
        "values": "=Sheet1!$C$2:$C$7",
    }
)

# Add a chart title.
chart2.set_title({"name": "Chart with Data Labels and Markers"})

# Insert the chart into the worksheet (with an offset).
worksheet.insert_chart("D18", chart2, {"x_offset": 25, "y_offset": 10})

#######################################################################
#
# Error Bars example.
#
# Create a Line chart.
chart3 = workbook.add_chart({"type": "line"})

# Configure the first series.
chart3.add_series(
    {
        "categories": "=Sheet1!$A$2:$A$7",
        "values": "=Sheet1!$B$2:$B$7",
        "y_error_bars": {"type": "standard_error"},
    }
)

# Configure the second series.
chart3.add_series(
    {
        "categories": "=Sheet1!$A$2:$A$7",
        "values": "=Sheet1!$C$2:$C$7",
    }
)

# Add a chart title.
chart3.set_title({"name": "Chart with Error Bars"})

# Insert the chart into the worksheet (with an offset).
worksheet.insert_chart("D34", chart3, {"x_offset": 25, "y_offset": 10})

#######################################################################
#
# Up-Down Bars example.
#
# Create a Line chart.
chart4 = workbook.add_chart({"type": "line"})

# Add the Up-Down Bars.
chart4.set_up_down_bars()

# Configure the first series.
chart4.add_series(
    {
        "categories": "=Sheet1!$A$2:$A$7",
        "values": "=Sheet1!$B$2:$B$7",
    }
)

# Configure the second series.
chart4.add_series(
    {
        "categories": "=Sheet1!$A$2:$A$7",
        "values": "=Sheet1!$C$2:$C$7",
    }
)

# Add a chart title.
chart4.set_title({"name": "Chart with Up-Down Bars"})

# Insert the chart into the worksheet (with an offset).
worksheet.insert_chart("D50", chart4, {"x_offset": 25, "y_offset": 10})

#######################################################################
#
# High-Low Lines example.
#
# Create a Line chart.
chart5 = workbook.add_chart({"type": "line"})

# Add the High-Low lines.
chart5.set_high_low_lines()

# Configure the first series.
chart5.add_series(
    {
        "categories": "=Sheet1!$A$2:$A$7",
        "values": "=Sheet1!$B$2:$B$7",
    }
)

# Configure the second series.
chart5.add_series(
    {
        "categories": "=Sheet1!$A$2:$A$7",
        "values": "=Sheet1!$C$2:$C$7",
    }
)

# Add a chart title.
chart5.set_title({"name": "Chart with High-Low Lines"})

# Insert the chart into the worksheet (with an offset).
worksheet.insert_chart("D66", chart5, {"x_offset": 25, "y_offset": 10})

#######################################################################
#
# Drop Lines example.
#
# Create a Line chart.
chart6 = workbook.add_chart({"type": "line"})

# Add Drop Lines.
chart6.set_drop_lines()

# Configure the first series.
chart6.add_series(
    {
        "categories": "=Sheet1!$A$2:$A$7",
        "values": "=Sheet1!$B$2:$B$7",
    }
)

# Configure the second series.
chart6.add_series(
    {
        "categories": "=Sheet1!$A$2:$A$7",
        "values": "=Sheet1!$C$2:$C$7",
    }
)

# Add a chart title.
chart6.set_title({"name": "Chart with Drop Lines"})

# Insert the chart into the worksheet (with an offset).
worksheet.insert_chart("D82", chart6, {"x_offset": 25, "y_offset": 10})

workbook.close()

```

---

### File: `tmp\xlsxwriter_sdist\XlsxWriter-3.2.0\examples\chart_date_axis.py`

```python
#######################################################################
#
# An example of creating an Excel charts with a date axis using
# Python and XlsxWriter.
#
# SPDX-License-Identifier: BSD-2-Clause
# Copyright 2013-2024, John McNamara, jmcnamara@cpan.org
#

from datetime import date
import xlsxwriter

workbook = xlsxwriter.Workbook("chart_date_axis.xlsx")

worksheet = workbook.add_worksheet()
chart = workbook.add_chart({"type": "line"})
date_format = workbook.add_format({"num_format": "dd/mm/yyyy"})

# Widen the first column to display the dates.
worksheet.set_column("A:A", 12)

# Some data to be plotted in the worksheet.
dates = [
    date(2013, 1, 1),
    date(2013, 1, 2),
    date(2013, 1, 3),
    date(2013, 1, 4),
    date(2013, 1, 5),
    date(2013, 1, 6),
    date(2013, 1, 7),
    date(2013, 1, 8),
    date(2013, 1, 9),
    date(2013, 1, 10),
]

values = [10, 30, 20, 40, 20, 60, 50, 40, 30, 30]

# Write the date to the worksheet.
worksheet.write_column("A1", dates, date_format)
worksheet.write_column("B1", values)

# Add a series to the chart.
chart.add_series(
    {
        "categories": "=Sheet1!$A$1:$A$10",
        "values": "=Sheet1!$B$1:$B$10",
    }
)

# Configure the X axis as a Date axis and set the max and min limits.
chart.set_x_axis(
    {
        "date_axis": True,
        "min": date(2013, 1, 2),
        "max": date(2013, 1, 9),
    }
)

# Turn off the legend.
chart.set_legend({"none": True})

# Insert the chart into the worksheet.
worksheet.insert_chart("D2", chart)

workbook.close()

```

---

### File: `tmp\xlsxwriter_sdist\XlsxWriter-3.2.0\examples\chart_doughnut.py`

```python
#######################################################################
#
# An example of creating Excel Doughnut charts with Python and XlsxWriter.
#
# The demo also shows how to set segment colors. It is possible to
# define chart colors for most types of XlsxWriter charts
# via the add_series() method. However, Pie/Doughnut charts are a special
# case since each segment is represented as a point so it is necessary to
# assign formatting to each point in the series.
#
# SPDX-License-Identifier: BSD-2-Clause
# Copyright 2013-2024, John McNamara, jmcnamara@cpan.org
#
import xlsxwriter

workbook = xlsxwriter.Workbook("chart_doughnut.xlsx")

worksheet = workbook.add_worksheet()
bold = workbook.add_format({"bold": 1})

# Add the worksheet data that the charts will refer to.
headings = ["Category", "Values"]
data = [
    ["Glazed", "Chocolate", "Cream"],
    [50, 35, 15],
]

worksheet.write_row("A1", headings, bold)
worksheet.write_column("A2", data[0])
worksheet.write_column("B2", data[1])

#######################################################################
#
# Create a new chart object.
#
chart1 = workbook.add_chart({"type": "doughnut"})

# Configure the series. Note the use of the list syntax to define ranges:
chart1.add_series(
    {
        "name": "Doughnut sales data",
        "categories": ["Sheet1", 1, 0, 3, 0],
        "values": ["Sheet1", 1, 1, 3, 1],
    }
)

# Add a title.
chart1.set_title({"name": "Popular Doughnut Types"})

# Set an Excel chart style. Colors with white outline and shadow.
chart1.set_style(10)

# Insert the chart into the worksheet (with an offset).
worksheet.insert_chart("C2", chart1, {"x_offset": 25, "y_offset": 10})

#######################################################################
#
# Create a Doughnut chart with user defined segment colors.
#

# Create an example Doughnut chart like above.
chart2 = workbook.add_chart({"type": "doughnut"})

# Configure the series and add user defined segment colors.
chart2.add_series(
    {
        "name": "Doughnut sales data",
        "categories": "=Sheet1!$A$2:$A$4",
        "values": "=Sheet1!$B$2:$B$4",
        "points": [
            {"fill": {"color": "#FA58D0"}},
            {"fill": {"color": "#61210B"}},
            {"fill": {"color": "#F5F6CE"}},
        ],
    }
)

# Add a title.
chart2.set_title({"name": "Doughnut Chart with user defined colors"})

# Insert the chart into the worksheet (with an offset).
worksheet.insert_chart("C18", chart2, {"x_offset": 25, "y_offset": 10})

#######################################################################
#
# Create a Doughnut chart with rotation of the segments.
#

# Create an example Doughnut chart like above.
chart3 = workbook.add_chart({"type": "doughnut"})

# Configure the series.
chart3.add_series(
    {
        "name": "Doughnut sales data",
        "categories": "=Sheet1!$A$2:$A$4",
        "values": "=Sheet1!$B$2:$B$4",
    }
)

# Add a title.
chart3.set_title({"name": "Doughnut Chart with segment rotation"})

# Change the angle/rotation of the first segment.
chart3.set_rotation(90)

# Insert the chart into the worksheet (with an offset).
worksheet.insert_chart("C34", chart3, {"x_offset": 25, "y_offset": 10})


#######################################################################
#
# Create a Doughnut chart with user defined hole size and other options.
#

# Create an example Doughnut chart like above.
chart4 = workbook.add_chart({"type": "doughnut"})

# Configure the series.
chart4.add_series(
    {
        "name": "Doughnut sales data",
        "categories": "=Sheet1!$A$2:$A$4",
        "values": "=Sheet1!$B$2:$B$4",
        "points": [
            {"fill": {"color": "#FA58D0"}},
            {"fill": {"color": "#61210B"}},
            {"fill": {"color": "#F5F6CE"}},
        ],
    }
)

# Set a 3D style.
chart4.set_style(26)

# Add a title.
chart4.set_title({"name": "Doughnut Chart with options applied"})

# Change the angle/rotation of the first segment.
chart4.set_rotation(28)

# Change the hole size.
chart4.set_hole_size(33)

# Insert the chart into the worksheet (with an offset).
worksheet.insert_chart("C50", chart4, {"x_offset": 25, "y_offset": 10})


workbook.close()

```

---

### File: `tmp\xlsxwriter_sdist\XlsxWriter-3.2.0\examples\chart_gauge.py`

```python
#######################################################################
#
# An example of creating a Gauge Chart in Excel with Python and XlsxWriter.
#
# A Gauge Chart isn't a native chart type in Excel. It is constructed by
# combining a doughnut chart and a pie chart and by using some non-filled
# elements. This example follows the following online example of how to create
# a Gauge Chart in Excel: https://www.excel-easy.com/examples/gauge-chart.html
#
# SPDX-License-Identifier: BSD-2-Clause
# Copyright 2013-2024, John McNamara, jmcnamara@cpan.org
#
import xlsxwriter

workbook = xlsxwriter.Workbook("chart_gauge.xlsx")
worksheet = workbook.add_worksheet()

chart_doughnut = workbook.add_chart({"type": "doughnut"})
chart_pie = workbook.add_chart({"type": "pie"})

# Add some data for the Doughnut and Pie charts. This is set up so the
# gauge goes from 0-100. It is initially set at 75%.
worksheet.write_column("H2", ["Donut", 25, 50, 25, 100])
worksheet.write_column("I2", ["Pie", 75, 1, "=200-I4-I3"])

# Configure the doughnut chart as the background for the gauge.
chart_doughnut.add_series(
    {
        "name": "=Sheet1!$H$2",
        "values": "=Sheet1!$H$3:$H$6",
        "points": [
            {"fill": {"color": "green"}},
            {"fill": {"color": "yellow"}},
            {"fill": {"color": "red"}},
            {"fill": {"none": True}},
        ],
    }
)

# Rotate chart so the gauge parts are above the horizontal.
chart_doughnut.set_rotation(270)

# Turn off the chart legend.
chart_doughnut.set_legend({"none": True})

# Turn off the chart fill and border.
chart_doughnut.set_chartarea(
    {
        "border": {"none": True},
        "fill": {"none": True},
    }
)

# Configure the pie chart as the needle for the gauge.
chart_pie.add_series(
    {
        "name": "=Sheet1!$I$2",
        "values": "=Sheet1!$I$3:$I$6",
        "points": [
            {"fill": {"none": True}},
            {"fill": {"color": "black"}},
            {"fill": {"none": True}},
        ],
    }
)

# Rotate the pie chart/needle to align with the doughnut/gauge.
chart_pie.set_rotation(270)

# Combine the pie and doughnut charts.
chart_doughnut.combine(chart_pie)

# Insert the chart into the worksheet.
worksheet.insert_chart("A1", chart_doughnut)

workbook.close()

```

---

### File: `tmp\xlsxwriter_sdist\XlsxWriter-3.2.0\examples\chart_gradient.py`

```python
#######################################################################
#
# An example of creating an Excel charts with gradient fills using
# Python and XlsxWriter.
#
# SPDX-License-Identifier: BSD-2-Clause
# Copyright 2013-2024, John McNamara, jmcnamara@cpan.org
#
import xlsxwriter

workbook = xlsxwriter.Workbook("chart_gradient.xlsx")
worksheet = workbook.add_worksheet()
bold = workbook.add_format({"bold": 1})

# Add the worksheet data that the charts will refer to.
headings = ["Number", "Batch 1", "Batch 2"]
data = [
    [2, 3, 4, 5, 6, 7],
    [10, 40, 50, 20, 10, 50],
    [30, 60, 70, 50, 40, 30],
]

worksheet.write_row("A1", headings, bold)
worksheet.write_column("A2", data[0])
worksheet.write_column("B2", data[1])
worksheet.write_column("C2", data[2])


# Create a new column chart.
chart = workbook.add_chart({"type": "column"})

# Configure the first series, including a gradient.
chart.add_series(
    {
        "name": "=Sheet1!$B$1",
        "categories": "=Sheet1!$A$2:$A$7",
        "values": "=Sheet1!$B$2:$B$7",
        "gradient": {"colors": ["#963735", "#F1DCDB"]},
    }
)

# Configure the second series, including a gradient.
chart.add_series(
    {
        "name": "=Sheet1!$C$1",
        "categories": "=Sheet1!$A$2:$A$7",
        "values": "=Sheet1!$C$2:$C$7",
        "gradient": {"colors": ["#E36C0A", "#FCEADA"]},
    }
)

# Set a gradient for the plotarea.
chart.set_plotarea({"gradient": {"colors": ["#FFEFD1", "#F0EBD5", "#B69F66"]}})


# Add some axis labels.
chart.set_x_axis({"name": "Test number"})
chart.set_y_axis({"name": "Sample length (mm)"})

# Turn off the chart legend.
chart.set_legend({"none": True})

# Insert the chart into the worksheet.
worksheet.insert_chart("E2", chart)

workbook.close()

```

---

### File: `tmp\xlsxwriter_sdist\XlsxWriter-3.2.0\examples\chart_line.py`

```python
#######################################################################
#
# An example of creating Excel Line charts with Python and XlsxWriter.
#
# SPDX-License-Identifier: BSD-2-Clause
# Copyright 2013-2024, John McNamara, jmcnamara@cpan.org
#
import xlsxwriter

workbook = xlsxwriter.Workbook("chart_line.xlsx")
worksheet = workbook.add_worksheet()
bold = workbook.add_format({"bold": 1})

# Add the worksheet data that the charts will refer to.
headings = ["Number", "Batch 1", "Batch 2"]
data = [
    [2, 3, 4, 5, 6, 7],
    [10, 40, 50, 20, 10, 50],
    [30, 60, 70, 50, 40, 30],
]

worksheet.write_row("A1", headings, bold)
worksheet.write_column("A2", data[0])
worksheet.write_column("B2", data[1])
worksheet.write_column("C2", data[2])

# Create a new chart object. In this case an embedded chart.
chart1 = workbook.add_chart({"type": "line"})

# Configure the first series.
chart1.add_series(
    {
        "name": "=Sheet1!$B$1",
        "categories": "=Sheet1!$A$2:$A$7",
        "values": "=Sheet1!$B$2:$B$7",
    }
)

# Configure a second series. Note use of alternative syntax to define ranges.
chart1.add_series(
    {
        "name": ["Sheet1", 0, 2],
        "categories": ["Sheet1", 1, 0, 6, 0],
        "values": ["Sheet1", 1, 2, 6, 2],
    }
)

# Add a chart title and some axis labels.
chart1.set_title({"name": "Results of sample analysis"})
chart1.set_x_axis({"name": "Test number"})
chart1.set_y_axis({"name": "Sample length (mm)"})

# Set an Excel chart style. Colors with white outline and shadow.
chart1.set_style(10)

# Insert the chart into the worksheet (with an offset).
worksheet.insert_chart("D2", chart1, {"x_offset": 25, "y_offset": 10})

#######################################################################
#
# Create a stacked line chart sub-type.
#
chart2 = workbook.add_chart({"type": "line", "subtype": "stacked"})

# Configure the first series.
chart2.add_series(
    {
        "name": "=Sheet1!$B$1",
        "categories": "=Sheet1!$A$2:$A$7",
        "values": "=Sheet1!$B$2:$B$7",
    }
)

# Configure second series.
chart2.add_series(
    {
        "name": "=Sheet1!$C$1",
        "categories": "=Sheet1!$A$2:$A$7",
        "values": "=Sheet1!$C$2:$C$7",
    }
)

# Add a chart title and some axis labels.
chart2.set_title({"name": "Stacked Chart"})
chart2.set_x_axis({"name": "Test number"})
chart2.set_y_axis({"name": "Sample length (mm)"})

# Set an Excel chart style.
chart2.set_style(12)

# Insert the chart into the worksheet (with an offset).
worksheet.insert_chart("D18", chart2, {"x_offset": 25, "y_offset": 10})

#######################################################################
#
# Create a percent stacked line chart sub-type.
#
chart3 = workbook.add_chart({"type": "line", "subtype": "percent_stacked"})

# Configure the first series.
chart3.add_series(
    {
        "name": "=Sheet1!$B$1",
        "categories": "=Sheet1!$A$2:$A$7",
        "values": "=Sheet1!$B$2:$B$7",
    }
)

# Configure second series.
chart3.add_series(
    {
        "name": "=Sheet1!$C$1",
        "categories": "=Sheet1!$A$2:$A$7",
        "values": "=Sheet1!$C$2:$C$7",
    }
)

# Add a chart title and some axis labels.
chart3.set_title({"name": "Percent Stacked Chart"})
chart3.set_x_axis({"name": "Test number"})
chart3.set_y_axis({"name": "Sample length (mm)"})

# Set an Excel chart style.
chart3.set_style(13)

# Insert the chart into the worksheet (with an offset).
worksheet.insert_chart("D34", chart3, {"x_offset": 25, "y_offset": 10})

workbook.close()

```

---

### File: `tmp\xlsxwriter_sdist\XlsxWriter-3.2.0\examples\chart_pareto.py`

```python
#######################################################################
#
# An example of creating of a Pareto chart with Python and XlsxWriter.
#
# SPDX-License-Identifier: BSD-2-Clause
# Copyright 2013-2024, John McNamara, jmcnamara@cpan.org
#
import xlsxwriter

workbook = xlsxwriter.Workbook("chart_pareto.xlsx")
worksheet = workbook.add_worksheet()

# Formats used in the workbook.
bold = workbook.add_format({"bold": True})
percent_format = workbook.add_format({"num_format": "0.0%"})

# Widen the columns for visibility.
worksheet.set_column("A:A", 15)
worksheet.set_column("B:C", 10)

# Add the worksheet data that the charts will refer to.
headings = ["Reason", "Number", "Percentage"]

reasons = [
    "Traffic",
    "Child care",
    "Public Transport",
    "Weather",
    "Overslept",
    "Emergency",
]

numbers = [60, 40, 20, 15, 10, 5]
percents = [0.44, 0.667, 0.8, 0.9, 0.967, 1]

worksheet.write_row("A1", headings, bold)
worksheet.write_column("A2", reasons)
worksheet.write_column("B2", numbers)
worksheet.write_column("C2", percents, percent_format)


# Create a new column chart. This will be the primary chart.
column_chart = workbook.add_chart({"type": "column"})

# Add a series.
column_chart.add_series(
    {
        "categories": "=Sheet1!$A$2:$A$7",
        "values": "=Sheet1!$B$2:$B$7",
    }
)

# Add a chart title.
column_chart.set_title({"name": "Reasons for lateness"})

# Turn off the chart legend.
column_chart.set_legend({"position": "none"})

# Set the title and scale of the Y axes. Note, the secondary axis is set from
# the primary chart.
column_chart.set_y_axis({"name": "Respondents (number)", "min": 0, "max": 120})
column_chart.set_y2_axis({"max": 1})

# Create a new line chart. This will be the secondary chart.
line_chart = workbook.add_chart({"type": "line"})

# Add a series, on the secondary axis.
line_chart.add_series(
    {
        "categories": "=Sheet1!$A$2:$A$7",
        "values": "=Sheet1!$C$2:$C$7",
        "marker": {"type": "automatic"},
        "y2_axis": 1,
    }
)

# Combine the charts.
column_chart.combine(line_chart)

# Insert the chart into the worksheet.
worksheet.insert_chart("F2", column_chart)

workbook.close()

```

---

### File: `tmp\xlsxwriter_sdist\XlsxWriter-3.2.0\examples\chart_pattern.py`

```python
#######################################################################
#
# An example of an Excel chart with patterns using Python and XlsxWriter.
#
# SPDX-License-Identifier: BSD-2-Clause
# Copyright 2013-2024, John McNamara, jmcnamara@cpan.org
#
import xlsxwriter

workbook = xlsxwriter.Workbook("chart_pattern.xlsx")
worksheet = workbook.add_worksheet()
bold = workbook.add_format({"bold": 1})

# Add the worksheet data that the charts will refer to.
headings = ["Shingle", "Brick"]
data = [
    [105, 150, 130, 90],
    [50, 120, 100, 110],
]

worksheet.write_row("A1", headings, bold)
worksheet.write_column("A2", data[0])
worksheet.write_column("B2", data[1])

# Create a new Chart object.
chart = workbook.add_chart({"type": "column"})

# Configure the charts. Add two series with patterns. The gap is used to make
# the patterns more visible.
chart.add_series(
    {
        "name": "=Sheet1!$A$1",
        "values": "=Sheet1!$A$2:$A$5",
        "pattern": {"pattern": "shingle", "fg_color": "#804000", "bg_color": "#c68c53"},
        "border": {"color": "#804000"},
        "gap": 70,
    }
)

chart.add_series(
    {
        "name": "=Sheet1!$B$1",
        "values": "=Sheet1!$B$2:$B$5",
        "pattern": {
            "pattern": "horizontal_brick",
            "fg_color": "#b30000",
            "bg_color": "#ff6666",
        },
        "border": {"color": "#b30000"},
    }
)

# Add a chart title and some axis labels.
chart.set_title({"name": "Cladding types"})
chart.set_x_axis({"name": "Region"})
chart.set_y_axis({"name": "Number of houses"})

# Insert the chart into the worksheet.
worksheet.insert_chart("D2", chart)

workbook.close()

```

---

### File: `tmp\xlsxwriter_sdist\XlsxWriter-3.2.0\examples\chart_pie.py`

```python
#######################################################################
#
# An example of creating Excel Pie charts with Python and XlsxWriter.
#
# The demo also shows how to set segment colors. It is possible to
# define chart colors for most types of XlsxWriter charts
# via the add_series() method. However, Pie/Doughnut charts are a special
# case since each segment is represented as a point so it is necessary to
# assign formatting to each point in the series.
#
# SPDX-License-Identifier: BSD-2-Clause
# Copyright 2013-2024, John McNamara, jmcnamara@cpan.org
#
import xlsxwriter

workbook = xlsxwriter.Workbook("chart_pie.xlsx")

worksheet = workbook.add_worksheet()
bold = workbook.add_format({"bold": 1})

# Add the worksheet data that the charts will refer to.
headings = ["Category", "Values"]
data = [
    ["Apple", "Cherry", "Pecan"],
    [60, 30, 10],
]

worksheet.write_row("A1", headings, bold)
worksheet.write_column("A2", data[0])
worksheet.write_column("B2", data[1])

#######################################################################
#
# Create a new chart object.
#
chart1 = workbook.add_chart({"type": "pie"})

# Configure the series. Note the use of the list syntax to define ranges:
chart1.add_series(
    {
        "name": "Pie sales data",
        "categories": ["Sheet1", 1, 0, 3, 0],
        "values": ["Sheet1", 1, 1, 3, 1],
    }
)

# Add a title.
chart1.set_title({"name": "Popular Pie Types"})

# Set an Excel chart style. Colors with white outline and shadow.
chart1.set_style(10)

# Insert the chart into the worksheet (with an offset).
worksheet.insert_chart("C2", chart1, {"x_offset": 25, "y_offset": 10})

#######################################################################
#
# Create a Pie chart with user defined segment colors.
#

# Create an example Pie chart like above.
chart2 = workbook.add_chart({"type": "pie"})

# Configure the series and add user defined segment colors.
chart2.add_series(
    {
        "name": "Pie sales data",
        "categories": "=Sheet1!$A$2:$A$4",
        "values": "=Sheet1!$B$2:$B$4",
        "points": [
            {"fill": {"color": "#5ABA10"}},
            {"fill": {"color": "#FE110E"}},
            {"fill": {"color": "#CA5C05"}},
        ],
    }
)

# Add a title.
chart2.set_title({"name": "Pie Chart with user defined colors"})

# Insert the chart into the worksheet (with an offset).
worksheet.insert_chart("C18", chart2, {"x_offset": 25, "y_offset": 10})

#######################################################################
#
# Create a Pie chart with rotation of the segments.
#

# Create an example Pie chart like above.
chart3 = workbook.add_chart({"type": "pie"})

# Configure the series.
chart3.add_series(
    {
        "name": "Pie sales data",
        "categories": "=Sheet1!$A$2:$A$4",
        "values": "=Sheet1!$B$2:$B$4",
    }
)

# Add a title.
chart3.set_title({"name": "Pie Chart with segment rotation"})

# Change the angle/rotation of the first segment.
chart3.set_rotation(90)

# Insert the chart into the worksheet (with an offset).
worksheet.insert_chart("C34", chart3, {"x_offset": 25, "y_offset": 10})

workbook.close()

```

---

### File: `tmp\xlsxwriter_sdist\XlsxWriter-3.2.0\examples\chart_radar.py`

```python
#######################################################################
#
# An example of creating Excel Radar charts with Python and XlsxWriter.
#
# SPDX-License-Identifier: BSD-2-Clause
# Copyright 2013-2024, John McNamara, jmcnamara@cpan.org
#
import xlsxwriter

workbook = xlsxwriter.Workbook("chart_radar.xlsx")
worksheet = workbook.add_worksheet()
bold = workbook.add_format({"bold": 1})

# Add the worksheet data that the charts will refer to.
headings = ["Number", "Batch 1", "Batch 2"]
data = [
    [2, 3, 4, 5, 6, 7],
    [30, 60, 70, 50, 40, 30],
    [25, 40, 50, 30, 50, 40],
]

worksheet.write_row("A1", headings, bold)
worksheet.write_column("A2", data[0])
worksheet.write_column("B2", data[1])
worksheet.write_column("C2", data[2])

#######################################################################
#
# Create a new radar chart.
#
chart1 = workbook.add_chart({"type": "radar"})

# Configure the first series.
chart1.add_series(
    {
        "name": "=Sheet1!$B$1",
        "categories": "=Sheet1!$A$2:$A$7",
        "values": "=Sheet1!$B$2:$B$7",
    }
)

# Configure second series. Note use of alternative syntax to define ranges.
chart1.add_series(
    {
        "name": ["Sheet1", 0, 2],
        "categories": ["Sheet1", 1, 0, 6, 0],
        "values": ["Sheet1", 1, 2, 6, 2],
    }
)

# Add a chart title.
chart1.set_title({"name": "Results of sample analysis"})

# Set an Excel chart style.
chart1.set_style(11)

# Insert the chart into the worksheet (with an offset).
worksheet.insert_chart("D2", chart1, {"x_offset": 25, "y_offset": 10})

#######################################################################
#
# Create a radar chart with markers chart sub-type.
#
chart2 = workbook.add_chart({"type": "radar", "subtype": "with_markers"})

# Configure the first series.
chart2.add_series(
    {
        "name": "=Sheet1!$B$1",
        "categories": "=Sheet1!$A$2:$A$7",
        "values": "=Sheet1!$B$2:$B$7",
    }
)

# Configure second series.
chart2.add_series(
    {
        "name": "=Sheet1!$C$1",
        "categories": "=Sheet1!$A$2:$A$7",
        "values": "=Sheet1!$C$2:$C$7",
    }
)

# Add a chart title.
chart2.set_title({"name": "Radar Chart With Markers"})

# Set an Excel chart style.
chart2.set_style(12)

# Insert the chart into the worksheet (with an offset).
worksheet.insert_chart("D18", chart2, {"x_offset": 25, "y_offset": 10})

#######################################################################
#
# Create a filled radar chart sub-type.
#
chart3 = workbook.add_chart({"type": "radar", "subtype": "filled"})

# Configure the first series.
chart3.add_series(
    {
        "name": "=Sheet1!$B$1",
        "categories": "=Sheet1!$A$2:$A$7",
        "values": "=Sheet1!$B$2:$B$7",
    }
)

# Configure second series.
chart3.add_series(
    {
        "name": "=Sheet1!$C$1",
        "categories": "=Sheet1!$A$2:$A$7",
        "values": "=Sheet1!$C$2:$C$7",
    }
)

# Add a chart title.
chart3.set_title({"name": "Filled Radar Chart"})

# Set an Excel chart style.
chart3.set_style(13)

# Insert the chart into the worksheet (with an offset).
worksheet.insert_chart("D34", chart3, {"x_offset": 25, "y_offset": 10})

workbook.close()

```

---

### File: `tmp\xlsxwriter_sdist\XlsxWriter-3.2.0\examples\chart_scatter.py`

```python
#######################################################################
#
# An example of creating Excel Scatter charts with Python and XlsxWriter.
#
# SPDX-License-Identifier: BSD-2-Clause
# Copyright 2013-2024, John McNamara, jmcnamara@cpan.org
#
import xlsxwriter

workbook = xlsxwriter.Workbook("chart_scatter.xlsx")
worksheet = workbook.add_worksheet()
bold = workbook.add_format({"bold": 1})

# Add the worksheet data that the charts will refer to.
headings = ["Number", "Batch 1", "Batch 2"]
data = [
    [2, 3, 4, 5, 6, 7],
    [10, 40, 50, 20, 10, 50],
    [30, 60, 70, 50, 40, 30],
]

worksheet.write_row("A1", headings, bold)
worksheet.write_column("A2", data[0])
worksheet.write_column("B2", data[1])
worksheet.write_column("C2", data[2])


#######################################################################
#
# Create a new scatter chart.
#
chart1 = workbook.add_chart({"type": "scatter"})

# Configure the first series.
chart1.add_series(
    {
        "name": "=Sheet1!$B$1",
        "categories": "=Sheet1!$A$2:$A$7",
        "values": "=Sheet1!$B$2:$B$7",
    }
)

# Configure second series. Note use of alternative syntax to define ranges.
chart1.add_series(
    {
        "name": ["Sheet1", 0, 2],
        "categories": ["Sheet1", 1, 0, 6, 0],
        "values": ["Sheet1", 1, 2, 6, 2],
    }
)

# Add a chart title and some axis labels.
chart1.set_title({"name": "Results of sample analysis"})
chart1.set_x_axis({"name": "Test number"})
chart1.set_y_axis({"name": "Sample length (mm)"})

# Set an Excel chart style.
chart1.set_style(11)

# Insert the chart into the worksheet (with an offset).
worksheet.insert_chart("D2", chart1, {"x_offset": 25, "y_offset": 10})

#######################################################################
#
# Create a scatter chart sub-type with straight lines and markers.
#
chart2 = workbook.add_chart({"type": "scatter", "subtype": "straight_with_markers"})

# Configure the first series.
chart2.add_series(
    {
        "name": "=Sheet1!$B$1",
        "categories": "=Sheet1!$A$2:$A$7",
        "values": "=Sheet1!$B$2:$B$7",
    }
)

# Configure second series.
chart2.add_series(
    {
        "name": "=Sheet1!$C$1",
        "categories": "=Sheet1!$A$2:$A$7",
        "values": "=Sheet1!$C$2:$C$7",
    }
)

# Add a chart title and some axis labels.
chart2.set_title({"name": "Straight line with markers"})
chart2.set_x_axis({"name": "Test number"})
chart2.set_y_axis({"name": "Sample length (mm)"})

# Set an Excel chart style.
chart2.set_style(12)

# Insert the chart into the worksheet (with an offset).
worksheet.insert_chart("D18", chart2, {"x_offset": 25, "y_offset": 10})

#######################################################################
#
# Create a scatter chart sub-type with straight lines and no markers.
#
chart3 = workbook.add_chart({"type": "scatter", "subtype": "straight"})

# Configure the first series.
chart3.add_series(
    {
        "name": "=Sheet1!$B$1",
        "categories": "=Sheet1!$A$2:$A$7",
        "values": "=Sheet1!$B$2:$B$7",
    }
)

# Configure second series.
chart3.add_series(
    {
        "name": "=Sheet1!$C$1",
        "categories": "=Sheet1!$A$2:$A$7",
        "values": "=Sheet1!$C$2:$C$7",
    }
)

# Add a chart title and some axis labels.
chart3.set_title({"name": "Straight line"})
chart3.set_x_axis({"name": "Test number"})
chart3.set_y_axis({"name": "Sample length (mm)"})

# Set an Excel chart style.
chart3.set_style(13)

# Insert the chart into the worksheet (with an offset).
worksheet.insert_chart("D34", chart3, {"x_offset": 25, "y_offset": 10})

#######################################################################
#
# Create a scatter chart sub-type with smooth lines and markers.
#
chart4 = workbook.add_chart({"type": "scatter", "subtype": "smooth_with_markers"})

# Configure the first series.
chart4.add_series(
    {
        "name": "=Sheet1!$B$1",
        "categories": "=Sheet1!$A$2:$A$7",
        "values": "=Sheet1!$B$2:$B$7",
    }
)

# Configure second series.
chart4.add_series(
    {
        "name": "=Sheet1!$C$1",
        "categories": "=Sheet1!$A$2:$A$7",
        "values": "=Sheet1!$C$2:$C$7",
    }
)

# Add a chart title and some axis labels.
chart4.set_title({"name": "Smooth line with markers"})
chart4.set_x_axis({"name": "Test number"})
chart4.set_y_axis({"name": "Sample length (mm)"})

# Set an Excel chart style.
chart4.set_style(14)

# Insert the chart into the worksheet (with an offset).
worksheet.insert_chart("D50", chart4, {"x_offset": 25, "y_offset": 10})

#######################################################################
#
# Create a scatter chart sub-type with smooth lines and no markers.
#
chart5 = workbook.add_chart({"type": "scatter", "subtype": "smooth"})

# Configure the first series.
chart5.add_series(
    {
        "name": "=Sheet1!$B$1",
        "categories": "=Sheet1!$A$2:$A$7",
        "values": "=Sheet1!$B$2:$B$7",
    }
)

# Configure second series.
chart5.add_series(
    {
        "name": "=Sheet1!$C$1",
        "categories": "=Sheet1!$A$2:$A$7",
        "values": "=Sheet1!$C$2:$C$7",
    }
)

# Add a chart title and some axis labels.
chart5.set_title({"name": "Smooth line"})
chart5.set_x_axis({"name": "Test number"})
chart5.set_y_axis({"name": "Sample length (mm)"})

# Set an Excel chart style.
chart5.set_style(15)

# Insert the chart into the worksheet (with an offset).
worksheet.insert_chart("D66", chart5, {"x_offset": 25, "y_offset": 10})

workbook.close()

```

---

### File: `tmp\xlsxwriter_sdist\XlsxWriter-3.2.0\examples\chart_secondary_axis.py`

```python
#######################################################################
#
# An example of creating an Excel Line chart with a secondary axis
# using Python and XlsxWriter.
#
# SPDX-License-Identifier: BSD-2-Clause
# Copyright 2013-2024, John McNamara, jmcnamara@cpan.org
#
import xlsxwriter

workbook = xlsxwriter.Workbook("chart_secondary_axis.xlsx")
worksheet = workbook.add_worksheet()
bold = workbook.add_format({"bold": 1})

# Add the worksheet data that the charts will refer to.
headings = ["Aliens", "Humans"]
data = [
    [2, 3, 4, 5, 6, 7],
    [10, 40, 50, 20, 10, 50],
]

worksheet.write_row("A1", headings, bold)
worksheet.write_column("A2", data[0])
worksheet.write_column("B2", data[1])


# Create a new chart object. In this case an embedded chart.
chart = workbook.add_chart({"type": "line"})

# Configure a series with a secondary axis
chart.add_series(
    {
        "name": "=Sheet1!$A$1",
        "values": "=Sheet1!$A$2:$A$7",
        "y2_axis": 1,
    }
)

chart.add_series(
    {
        "name": "=Sheet1!$B$1",
        "values": "=Sheet1!$B$2:$B$7",
    }
)

chart.set_legend({"position": "right"})

# Add a chart title and some axis labels.
chart.set_title({"name": "Survey results"})
chart.set_x_axis(
    {
        "name": "Days",
    }
)
chart.set_y_axis({"name": "Population", "major_gridlines": {"visible": 0}})
chart.set_y2_axis({"name": "Laser wounds"})

# Insert the chart into the worksheet (with an offset).
worksheet.insert_chart("D2", chart, {"x_offset": 25, "y_offset": 10})

workbook.close()

```

---

### File: `tmp\xlsxwriter_sdist\XlsxWriter-3.2.0\examples\chart_stock.py`

```python
#######################################################################
#
# An example of creating Excel Stock charts with Python and XlsxWriter.
#
# SPDX-License-Identifier: BSD-2-Clause
# Copyright 2013-2024, John McNamara, jmcnamara@cpan.org
#
from datetime import datetime
import xlsxwriter

workbook = xlsxwriter.Workbook("chart_stock.xlsx")
worksheet = workbook.add_worksheet()

bold = workbook.add_format({"bold": 1})
date_format = workbook.add_format({"num_format": "dd/mm/yyyy"})

chart = workbook.add_chart({"type": "stock"})

# Add the worksheet data that the charts will refer to.
headings = ["Date", "High", "Low", "Close"]
data = [
    ["2007-01-01", "2007-01-02", "2007-01-03", "2007-01-04", "2007-01-05"],
    [27.2, 25.03, 19.05, 20.34, 18.5],
    [23.49, 19.55, 15.12, 17.84, 16.34],
    [25.45, 23.05, 17.32, 20.45, 17.34],
]

worksheet.write_row("A1", headings, bold)

for row in range(5):
    date = datetime.strptime(data[0][row], "%Y-%m-%d")

    worksheet.write(row + 1, 0, date, date_format)
    worksheet.write(row + 1, 1, data[1][row])
    worksheet.write(row + 1, 2, data[2][row])
    worksheet.write(row + 1, 3, data[3][row])

worksheet.set_column("A:D", 11)

# Add a series for each of the High-Low-Close columns.
chart.add_series(
    {
        "categories": "=Sheet1!$A$2:$A$6",
        "values": "=Sheet1!$B$2:$B$6",
    }
)

chart.add_series(
    {
        "categories": "=Sheet1!$A$2:$A$6",
        "values": "=Sheet1!$C$2:$C$6",
    }
)

chart.add_series(
    {
        "categories": "=Sheet1!$A$2:$A$6",
        "values": "=Sheet1!$D$2:$D$6",
    }
)

# Add a chart title and some axis labels.
chart.set_title({"name": "High-Low-Close"})
chart.set_x_axis({"name": "Date"})
chart.set_y_axis({"name": "Share price"})

worksheet.insert_chart("E9", chart)

workbook.close()

```

---

### File: `tmp\xlsxwriter_sdist\XlsxWriter-3.2.0\examples\chart_styles.py`

```python
#######################################################################
#
# An example showing all 48 default chart styles available in Excel 2007
# using Python and XlsxWriter. Note, these styles are not the same as
# the styles available in Excel 2013.
#
# SPDX-License-Identifier: BSD-2-Clause
# Copyright 2013-2024, John McNamara, jmcnamara@cpan.org
#
import xlsxwriter

workbook = xlsxwriter.Workbook("chart_styles.xlsx")

# Show the styles for all of these chart types.
chart_types = ["column", "area", "line", "pie"]

for chart_type in chart_types:
    # Add a worksheet for each chart type.
    worksheet = workbook.add_worksheet(chart_type.title())
    worksheet.set_zoom(30)
    style_number = 1

    # Create 48 charts, each with a different style.
    for row_num in range(0, 90, 15):
        for col_num in range(0, 64, 8):
            chart = workbook.add_chart({"type": chart_type})
            chart.add_series({"values": "=Data!$A$1:$A$6"})
            chart.set_title({"name": "Style %d" % style_number})
            chart.set_legend({"none": True})
            chart.set_style(style_number)

            worksheet.insert_chart(row_num, col_num, chart)
            style_number += 1

# Create a worksheet with data for the charts.
data_worksheet = workbook.add_worksheet("Data")
data = [10, 40, 50, 20, 10, 50]
data_worksheet.write_column("A1", data)
data_worksheet.hide()

workbook.close()

```

---

### File: `tmp\xlsxwriter_sdist\XlsxWriter-3.2.0\examples\chartsheet.py`

```python
#######################################################################
#
# An example of creating an Excel chart in a chartsheet with Python
# and XlsxWriter.
#
# SPDX-License-Identifier: BSD-2-Clause
# Copyright 2013-2024, John McNamara, jmcnamara@cpan.org
#
import xlsxwriter

workbook = xlsxwriter.Workbook("chartsheet.xlsx")

# Add a worksheet to hold the data.
worksheet = workbook.add_worksheet()

# Add a chartsheet. A worksheet that only holds a chart.
chartsheet = workbook.add_chartsheet()

# Add a format for the headings.
bold = workbook.add_format({"bold": 1})

# Add the worksheet data that the charts will refer to.
headings = ["Number", "Batch 1", "Batch 2"]
data = [
    [2, 3, 4, 5, 6, 7],
    [10, 40, 50, 20, 10, 50],
    [30, 60, 70, 50, 40, 30],
]

worksheet.write_row("A1", headings, bold)
worksheet.write_column("A2", data[0])
worksheet.write_column("B2", data[1])
worksheet.write_column("C2", data[2])


# Create a new bar chart.
chart1 = workbook.add_chart({"type": "bar"})

# Configure the first series.
chart1.add_series(
    {
        "name": "=Sheet1!$B$1",
        "categories": "=Sheet1!$A$2:$A$7",
        "values": "=Sheet1!$B$2:$B$7",
    }
)

# Configure a second series. Note use of alternative syntax to define ranges.
chart1.add_series(
    {
        "name": ["Sheet1", 0, 2],
        "categories": ["Sheet1", 1, 0, 6, 0],
        "values": ["Sheet1", 1, 2, 6, 2],
    }
)

# Add a chart title and some axis labels.
chart1.set_title({"name": "Results of sample analysis"})
chart1.set_x_axis({"name": "Test number"})
chart1.set_y_axis({"name": "Sample length (mm)"})

# Set an Excel chart style.
chart1.set_style(11)

# Add the chart to the chartsheet.
chartsheet.set_chart(chart1)

# Display the chartsheet as the active sheet when the workbook is opened.
chartsheet.activate()

workbook.close()

```

---

### File: `tmp\xlsxwriter_sdist\XlsxWriter-3.2.0\examples\check_close.py`

```python
##############################################################################
#
# A simple program demonstrating a check for exceptions when closing the file.
#
# SPDX-License-Identifier: BSD-2-Clause
# Copyright 2013-2024, John McNamara, jmcnamara@cpan.org
#
import xlsxwriter

workbook = xlsxwriter.Workbook("check_close.xlsx")
worksheet = workbook.add_worksheet()

worksheet.write("A1", "Hello world")

# Try to close() the file in a loop so that if there is an exception, such as
# if the file is open in Excel, we can ask the user to close the file, and
# try again to overwrite it.
while True:
    try:
        workbook.close()
    except xlsxwriter.exceptions.FileCreateError as e:
        decision = input(
            "Exception caught in workbook.close(): %s\n"
            "Please close the file if it is open in Excel.\n"
            "Try to write file again? [Y/n]: " % e
        )
        if decision != "n":
            continue

    break

```

---

### File: `tmp\xlsxwriter_sdist\XlsxWriter-3.2.0\examples\comments1.py`

```python
###############################################################################
#
# An example of writing cell comments to a worksheet using Python and
# XlsxWriter.
#
# For more advanced comment options see comments2.py.
#
# SPDX-License-Identifier: BSD-2-Clause
# Copyright 2013-2024, John McNamara, jmcnamara@cpan.org
#
import xlsxwriter

workbook = xlsxwriter.Workbook("comments1.xlsx")
worksheet = workbook.add_worksheet()

worksheet.write("A1", "Hello")
worksheet.write_comment("A1", "This is a comment")

workbook.close()

```

---

### File: `tmp\xlsxwriter_sdist\XlsxWriter-3.2.0\examples\comments2.py`

```python
###############################################################################
#
# An example of writing cell comments to a worksheet using Python and
# XlsxWriter.
#
# Each of the worksheets demonstrates different features of cell comments.
#
# SPDX-License-Identifier: BSD-2-Clause
# Copyright 2013-2024, John McNamara, jmcnamara@cpan.org
#
import xlsxwriter

workbook = xlsxwriter.Workbook("comments.xlsx")

worksheet1 = workbook.add_worksheet()
worksheet2 = workbook.add_worksheet()
worksheet3 = workbook.add_worksheet()
worksheet4 = workbook.add_worksheet()
worksheet5 = workbook.add_worksheet()
worksheet6 = workbook.add_worksheet()
worksheet7 = workbook.add_worksheet()
worksheet8 = workbook.add_worksheet()

text_wrap = workbook.add_format({"text_wrap": 1, "valign": "top"})


###############################################################################
#
# Example 1. Demonstrates a simple cell comments without formatting.
#

# Set up some formatting.
worksheet1.set_column("C:C", 25)
worksheet1.set_row(2, 50)

# Simple ASCII string.
cell_text = "Hold the mouse over this cell to see the comment."

comment = "This is a comment."

worksheet1.write("C3", cell_text, text_wrap)
worksheet1.write_comment("C3", comment)


###############################################################################
#
# Example 2. Demonstrates visible and hidden comments.
#

# Set up some formatting.
worksheet2.set_column("C:C", 25)
worksheet2.set_row(2, 50)
worksheet2.set_row(5, 50)

cell_text = "This cell comment is visible."
comment = "Hello."

worksheet2.write("C3", cell_text, text_wrap)
worksheet2.write_comment("C3", comment, {"visible": True})

cell_text = "This cell comment isn't visible (the default)."

worksheet2.write("C6", cell_text, text_wrap)
worksheet2.write_comment("C6", comment)


###############################################################################
#
# Example 3. Demonstrates visible and hidden comments set at the worksheet
#            level.
#

# Set up some formatting.
worksheet3.set_column("C:C", 25)
worksheet3.set_row(2, 50)
worksheet3.set_row(5, 50)
worksheet3.set_row(8, 50)

# Make all comments on the worksheet visible.
worksheet3.show_comments()

cell_text = "This cell comment is visible, explicitly."
comment = "Hello."

worksheet3.write("C3", cell_text, text_wrap)
worksheet3.write_comment("C3", comment, {"visible": True})

cell_text = "This cell comment is also visible because of show_comments()."

worksheet3.write("C6", cell_text, text_wrap)
worksheet3.write_comment("C6", comment)

cell_text = "However, we can still override it locally."

worksheet3.write("C9", cell_text, text_wrap)
worksheet3.write_comment("C9", comment, {"visible": False})


###############################################################################
#
# Example 4. Demonstrates changes to the comment box dimensions.
#

# Set up some formatting.
worksheet4.set_column("C:C", 25)
worksheet4.set_row(2, 50)
worksheet4.set_row(5, 50)
worksheet4.set_row(8, 50)
worksheet4.set_row(15, 50)
worksheet4.set_row(18, 50)

worksheet4.show_comments()

cell_text = "This cell comment is default size."
comment = "Hello."

worksheet4.write("C3", cell_text, text_wrap)
worksheet4.write_comment("C3", comment)

cell_text = "This cell comment is twice as wide."

worksheet4.write("C6", cell_text, text_wrap)
worksheet4.write_comment("C6", comment, {"x_scale": 2})

cell_text = "This cell comment is twice as high."

worksheet4.write("C9", cell_text, text_wrap)
worksheet4.write_comment("C9", comment, {"y_scale": 2})

cell_text = "This cell comment is scaled in both directions."

worksheet4.write("C16", cell_text, text_wrap)
worksheet4.write_comment("C16", comment, {"x_scale": 1.2, "y_scale": 0.5})

cell_text = "This cell comment has width and height specified in pixels."

worksheet4.write("C19", cell_text, text_wrap)
worksheet4.write_comment("C19", comment, {"width": 200, "height": 50})


###############################################################################
#
# Example 5. Demonstrates changes to the cell comment position.
#
worksheet5.set_column("C:C", 25)
worksheet5.set_row(2, 50)
worksheet5.set_row(5, 50)
worksheet5.set_row(8, 50)
worksheet5.set_row(11, 50)

worksheet5.show_comments()

cell_text = "This cell comment is in the default position."
comment = "Hello."

worksheet5.write("C3", cell_text, text_wrap)
worksheet5.write_comment("C3", comment)

cell_text = "This cell comment has been moved to another cell."

worksheet5.write("C6", cell_text, text_wrap)
worksheet5.write_comment("C6", comment, {"start_cell": "E4"})

cell_text = "This cell comment has been moved to another cell."

worksheet5.write("C9", cell_text, text_wrap)
worksheet5.write_comment("C9", comment, {"start_row": 8, "start_col": 4})

cell_text = "This cell comment has been shifted within its default cell."

worksheet5.write("C12", cell_text, text_wrap)
worksheet5.write_comment("C12", comment, {"x_offset": 30, "y_offset": 12})


###############################################################################
#
# Example 6. Demonstrates changes to the comment background color.
#
worksheet6.set_column("C:C", 25)
worksheet6.set_row(2, 50)
worksheet6.set_row(5, 50)
worksheet6.set_row(8, 50)

worksheet6.show_comments()

cell_text = "This cell comment has a different color."
comment = "Hello."

worksheet6.write("C3", cell_text, text_wrap)
worksheet6.write_comment("C3", comment, {"color": "green"})

cell_text = "This cell comment has the default color."

worksheet6.write("C6", cell_text, text_wrap)
worksheet6.write_comment("C6", comment)

cell_text = "This cell comment has a different color."

worksheet6.write("C9", cell_text, text_wrap)
worksheet6.write_comment("C9", comment, {"color": "#CCFFCC"})


###############################################################################
#
# Example 7. Demonstrates how to set the cell comment author.
#
worksheet7.set_column("C:C", 30)
worksheet7.set_row(2, 50)
worksheet7.set_row(5, 50)

author = ""
cell = "C3"

cell_text = (
    "Move the mouse over this cell and you will see 'Cell commented "
    "by (blank)' in the status bar at the bottom"
)

comment = "Hello."

worksheet7.write(cell, cell_text, text_wrap)
worksheet7.write_comment(cell, comment)

author = "Python"
cell = "C6"
cell_text = (
    "Move the mouse over this cell and you will see 'Cell commented "
    "by Python' in the status bar at the bottom"
)

worksheet7.write(cell, cell_text, text_wrap)
worksheet7.write_comment(cell, comment, {"author": author})


###############################################################################
#
# Example 8. Demonstrates the need to explicitly set the row height.
#

# Set up some formatting.
worksheet8.set_column("C:C", 25)
worksheet8.set_row(2, 80)

worksheet8.show_comments()

cell_text = (
    "The height of this row has been adjusted explicitly using "
    "set_row(). The size of the comment box is adjusted "
    "accordingly by XlsxWriter."
)

comment = "Hello."

worksheet8.write("C3", cell_text, text_wrap)
worksheet8.write_comment("C3", comment)

cell_text = (
    "The height of this row has been adjusted by Excel due to the "
    "text wrap property being set. Unfortunately this means that "
    "the height of the row is unknown to XlsxWriter at run time "
    "and thus the comment box is stretched as well.\n\n"
    "Use set_row() to specify the row height explicitly to avoid "
    "this problem."
)

worksheet8.write("C6", cell_text, text_wrap)
worksheet8.write_comment("C6", comment)

workbook.close()

```

---

### File: `tmp\xlsxwriter_sdist\XlsxWriter-3.2.0\examples\conditional_format.py`

```python
###############################################################################
#
# Example of how to add conditional formatting to an XlsxWriter file.
#
# Conditional formatting allows you to apply a format to a cell or a
# range of cells based on certain criteria.
#
# SPDX-License-Identifier: BSD-2-Clause
# Copyright 2013-2024, John McNamara, jmcnamara@cpan.org
#
import xlsxwriter

workbook = xlsxwriter.Workbook("conditional_format.xlsx")
worksheet1 = workbook.add_worksheet()
worksheet2 = workbook.add_worksheet()
worksheet3 = workbook.add_worksheet()
worksheet4 = workbook.add_worksheet()
worksheet5 = workbook.add_worksheet()
worksheet6 = workbook.add_worksheet()
worksheet7 = workbook.add_worksheet()
worksheet8 = workbook.add_worksheet()
worksheet9 = workbook.add_worksheet()

# Add a format. Light red fill with dark red text.
format1 = workbook.add_format({"bg_color": "#FFC7CE", "font_color": "#9C0006"})

# Add a format. Green fill with dark green text.
format2 = workbook.add_format({"bg_color": "#C6EFCE", "font_color": "#006100"})

# Some sample data to run the conditional formatting against.
data = [
    [34, 72, 38, 30, 75, 48, 75, 66, 84, 86],
    [6, 24, 1, 84, 54, 62, 60, 3, 26, 59],
    [28, 79, 97, 13, 85, 93, 93, 22, 5, 14],
    [27, 71, 40, 17, 18, 79, 90, 93, 29, 47],
    [88, 25, 33, 23, 67, 1, 59, 79, 47, 36],
    [24, 100, 20, 88, 29, 33, 38, 54, 54, 88],
    [6, 57, 88, 28, 10, 26, 37, 7, 41, 48],
    [52, 78, 1, 96, 26, 45, 47, 33, 96, 36],
    [60, 54, 81, 66, 81, 90, 80, 93, 12, 55],
    [70, 5, 46, 14, 71, 19, 66, 36, 41, 21],
]


###############################################################################
#
# Example 1.
#
caption = "Cells with values >= 50 are in light red. Values < 50 are in light green."

# Write the data.
worksheet1.write("A1", caption)

for row, row_data in enumerate(data):
    worksheet1.write_row(row + 2, 1, row_data)

# Write a conditional format over a range.
worksheet1.conditional_format(
    "B3:K12", {"type": "cell", "criteria": ">=", "value": 50, "format": format1}
)

# Write another conditional format over the same range.
worksheet1.conditional_format(
    "B3:K12", {"type": "cell", "criteria": "<", "value": 50, "format": format2}
)


###############################################################################
#
# Example 2.
#
caption = (
    "Values between 30 and 70 are in light red. "
    "Values outside that range are in light green."
)

worksheet2.write("A1", caption)

for row, row_data in enumerate(data):
    worksheet2.write_row(row + 2, 1, row_data)

worksheet2.conditional_format(
    "B3:K12",
    {
        "type": "cell",
        "criteria": "between",
        "minimum": 30,
        "maximum": 70,
        "format": format1,
    },
)

worksheet2.conditional_format(
    "B3:K12",
    {
        "type": "cell",
        "criteria": "not between",
        "minimum": 30,
        "maximum": 70,
        "format": format2,
    },
)


###############################################################################
#
# Example 3.
#
caption = "Duplicate values are in light red. Unique values are in light green."

worksheet3.write("A1", caption)

for row, row_data in enumerate(data):
    worksheet3.write_row(row + 2, 1, row_data)

worksheet3.conditional_format("B3:K12", {"type": "duplicate", "format": format1})

worksheet3.conditional_format("B3:K12", {"type": "unique", "format": format2})


###############################################################################
#
# Example 4.
#
caption = (
    "Above average values are in light red. Below average values are in light green."
)

worksheet4.write("A1", caption)

for row, row_data in enumerate(data):
    worksheet4.write_row(row + 2, 1, row_data)

worksheet4.conditional_format(
    "B3:K12", {"type": "average", "criteria": "above", "format": format1}
)

worksheet4.conditional_format(
    "B3:K12", {"type": "average", "criteria": "below", "format": format2}
)


###############################################################################
#
# Example 5.
#
caption = "Top 10 values are in light red. Bottom 10 values are in light green."

worksheet5.write("A1", caption)

for row, row_data in enumerate(data):
    worksheet5.write_row(row + 2, 1, row_data)

worksheet5.conditional_format(
    "B3:K12", {"type": "top", "value": "10", "format": format1}
)

worksheet5.conditional_format(
    "B3:K12", {"type": "bottom", "value": "10", "format": format2}
)


###############################################################################
#
# Example 6.
#
caption = (
    "Cells with values >= 50 are in light red. "
    "Values < 50 are in light green. Non-contiguous ranges."
)

# Write the data.
worksheet6.write("A1", caption)

for row, row_data in enumerate(data):
    worksheet6.write_row(row + 2, 1, row_data)

# Write a conditional format over a range.
worksheet6.conditional_format(
    "B3:K6",
    {
        "type": "cell",
        "criteria": ">=",
        "value": 50,
        "format": format1,
        "multi_range": "B3:K6 B9:K12",
    },
)

# Write another conditional format over the same range.
worksheet6.conditional_format(
    "B3:K6",
    {
        "type": "cell",
        "criteria": "<",
        "value": 50,
        "format": format2,
        "multi_range": "B3:K6 B9:K12",
    },
)


###############################################################################
#
# Example 7.
#
caption = "Examples of color scales with default and user colors."

data = range(1, 13)

worksheet7.write("A1", caption)

worksheet7.write("B2", "2 Color Scale")
worksheet7.write("D2", "2 Color Scale + user colors")

worksheet7.write("G2", "3 Color Scale")
worksheet7.write("I2", "3 Color Scale + user colors")

for row, row_data in enumerate(data):
    worksheet7.write(row + 2, 1, row_data)
    worksheet7.write(row + 2, 3, row_data)
    worksheet7.write(row + 2, 6, row_data)
    worksheet7.write(row + 2, 8, row_data)

worksheet7.conditional_format("B3:B14", {"type": "2_color_scale"})

worksheet7.conditional_format(
    "D3:D14", {"type": "2_color_scale", "min_color": "#FF0000", "max_color": "#00FF00"}
)

worksheet7.conditional_format("G3:G14", {"type": "3_color_scale"})

worksheet7.conditional_format(
    "I3:I14",
    {
        "type": "3_color_scale",
        "min_color": "#C5D9F1",
        "mid_color": "#8DB4E3",
        "max_color": "#538ED5",
    },
)


###############################################################################
#
# Example 8.
#
caption = "Examples of data bars."

worksheet8.write("A1", caption)

worksheet8.write("B2", "Default data bars")
worksheet8.write("D2", "Bars only")
worksheet8.write("F2", "With user color")
worksheet8.write("H2", "Solid bars")
worksheet8.write("J2", "Right to left")
worksheet8.write("L2", "Excel 2010 style")
worksheet8.write("N2", "Negative same as positive")

data = range(1, 13)
for row, row_data in enumerate(data):
    worksheet8.write(row + 2, 1, row_data)
    worksheet8.write(row + 2, 3, row_data)
    worksheet8.write(row + 2, 5, row_data)
    worksheet8.write(row + 2, 7, row_data)
    worksheet8.write(row + 2, 9, row_data)

data = [-1, -2, -3, -2, -1, 0, 1, 2, 3, 2, 1, 0]
for row, row_data in enumerate(data):
    worksheet8.write(row + 2, 11, row_data)
    worksheet8.write(row + 2, 13, row_data)

worksheet8.conditional_format("B3:B14", {"type": "data_bar"})

worksheet8.conditional_format("D3:D14", {"type": "data_bar", "bar_only": True})

worksheet8.conditional_format("F3:F14", {"type": "data_bar", "bar_color": "#63C384"})

worksheet8.conditional_format("H3:H14", {"type": "data_bar", "bar_solid": True})

worksheet8.conditional_format("J3:J14", {"type": "data_bar", "bar_direction": "right"})

worksheet8.conditional_format("L3:L14", {"type": "data_bar", "data_bar_2010": True})

worksheet8.conditional_format(
    "N3:N14",
    {
        "type": "data_bar",
        "bar_negative_color_same": True,
        "bar_negative_border_color_same": True,
    },
)


###############################################################################
#
# Example 9.
#
caption = "Examples of conditional formats with icon sets."

data = [
    [1, 2, 3],
    [1, 2, 3],
    [1, 2, 3],
    [1, 2, 3],
    [1, 2, 3, 4],
    [1, 2, 3, 4, 5],
    [1, 2, 3, 4, 5],
]

worksheet9.write("A1", caption)

for row, row_data in enumerate(data):
    worksheet9.write_row(row + 2, 1, row_data)

worksheet9.conditional_format(
    "B3:D3", {"type": "icon_set", "icon_style": "3_traffic_lights"}
)

worksheet9.conditional_format(
    "B4:D4",
    {"type": "icon_set", "icon_style": "3_traffic_lights", "reverse_icons": True},
)

worksheet9.conditional_format(
    "B5:D5", {"type": "icon_set", "icon_style": "3_traffic_lights", "icons_only": True}
)

worksheet9.conditional_format("B6:D6", {"type": "icon_set", "icon_style": "3_arrows"})

worksheet9.conditional_format("B7:E7", {"type": "icon_set", "icon_style": "4_arrows"})

worksheet9.conditional_format("B8:F8", {"type": "icon_set", "icon_style": "5_arrows"})

worksheet9.conditional_format("B9:F9", {"type": "icon_set", "icon_style": "5_ratings"})

workbook.close()

```

---

### File: `tmp\xlsxwriter_sdist\XlsxWriter-3.2.0\examples\context_manager.py`

```python
##############################################################################
#
# A simple example using the XlsxWriter Python module and the "with" context
# manager. This doesn't require an explicit close().
#
# SPDX-License-Identifier: BSD-2-Clause
# Copyright 2013-2024, John McNamara, jmcnamara@cpan.org
#
import xlsxwriter

with xlsxwriter.Workbook("hello_world.xlsx") as workbook:
    worksheet = workbook.add_worksheet()

    worksheet.write("A1", "Hello world")

```

---

### File: `tmp\xlsxwriter_sdist\XlsxWriter-3.2.0\examples\data_validate.py`

```python
###############################################################################
#
# Example of how to add data validation and dropdown lists to an
# XlsxWriter file.
#
# Data validation is a feature of Excel which allows you to restrict
# the data that a user enters in a cell and to display help and
# warning messages. It also allows you to restrict input to values in
# a drop down list.
#
# SPDX-License-Identifier: BSD-2-Clause
# Copyright 2013-2024, John McNamara, jmcnamara@cpan.org
#
from datetime import date, time
import xlsxwriter

workbook = xlsxwriter.Workbook("data_validate.xlsx")
worksheet = workbook.add_worksheet()

# Add a format for the header cells.
header_format = workbook.add_format(
    {
        "border": 1,
        "bg_color": "#C6EFCE",
        "bold": True,
        "text_wrap": True,
        "valign": "vcenter",
        "indent": 1,
    }
)

# Set up layout of the worksheet.
worksheet.set_column("A:A", 68)
worksheet.set_column("B:B", 15)
worksheet.set_column("D:D", 15)
worksheet.set_row(0, 36)

# Write the header cells and some data that will be used in the examples.
heading1 = "Some examples of data validation in XlsxWriter"
heading2 = "Enter values in this column"
heading3 = "Sample Data"

worksheet.write("A1", heading1, header_format)
worksheet.write("B1", heading2, header_format)
worksheet.write("D1", heading3, header_format)

worksheet.write_row("D3", ["Integers", 1, 10])
worksheet.write_row("D4", ["List data", "open", "high", "close"])
worksheet.write_row("D5", ["Formula", "=AND(F5=50,G5=60)", 50, 60])


# Example 1. Limiting input to an integer in a fixed range.
#
txt = "Enter an integer between 1 and 10"

worksheet.write("A3", txt)
worksheet.data_validation(
    "B3", {"validate": "integer", "criteria": "between", "minimum": 1, "maximum": 10}
)


# Example 2. Limiting input to an integer outside a fixed range.
#
txt = "Enter an integer that is not between 1 and 10 (using cell references)"


worksheet.write("A5", txt)
worksheet.data_validation(
    "B5",
    {
        "validate": "integer",
        "criteria": "not between",
        "minimum": "=E3",
        "maximum": "=F3",
    },
)


# Example 3. Limiting input to an integer greater than a fixed value.
#
txt = "Enter an integer greater than 0"

worksheet.write("A7", txt)
worksheet.data_validation("B7", {"validate": "integer", "criteria": ">", "value": 0})


# Example 4. Limiting input to an integer less than a fixed value.
#
txt = "Enter an integer less than 10"

worksheet.write("A9", txt)
worksheet.data_validation("B9", {"validate": "integer", "criteria": "<", "value": 10})


# Example 5. Limiting input to a decimal in a fixed range.
#
txt = "Enter a decimal between 0.1 and 0.5"

worksheet.write("A11", txt)
worksheet.data_validation(
    "B11",
    {"validate": "decimal", "criteria": "between", "minimum": 0.1, "maximum": 0.5},
)


# Example 6. Limiting input to a value in a dropdown list.
#
txt = "Select a value from a drop down list"

worksheet.write("A13", txt)
worksheet.data_validation(
    "B13", {"validate": "list", "source": ["open", "high", "close"]}
)


# Example 7. Limiting input to a value in a dropdown list.
#
txt = "Select a value from a drop down list (using a cell range)"

worksheet.write("A15", txt)
worksheet.data_validation("B15", {"validate": "list", "source": "=$E$4:$G$4"})


# Example 8. Limiting input to a date in a fixed range.
#
txt = "Enter a date between 1/1/2013 and 12/12/2013"

worksheet.write("A17", txt)
worksheet.data_validation(
    "B17",
    {
        "validate": "date",
        "criteria": "between",
        "minimum": date(2013, 1, 1),
        "maximum": date(2013, 12, 12),
    },
)


# Example 9. Limiting input to a time in a fixed range.
#
txt = "Enter a time between 6:00 and 12:00"

worksheet.write("A19", txt)
worksheet.data_validation(
    "B19",
    {
        "validate": "time",
        "criteria": "between",
        "minimum": time(6, 0),
        "maximum": time(12, 0),
    },
)


# Example 10. Limiting input to a string greater than a fixed length.
#
txt = "Enter a string longer than 3 characters"

worksheet.write("A21", txt)
worksheet.data_validation("B21", {"validate": "length", "criteria": ">", "value": 3})


# Example 11. Limiting input based on a formula.
#
txt = 'Enter a value if the following is true "=AND(F5=50,G5=60)"'

worksheet.write("A23", txt)
worksheet.data_validation("B23", {"validate": "custom", "value": "=AND(F5=50,G5=60)"})


# Example 12. Displaying and modifying data validation messages.
#
txt = "Displays a message when you select the cell"

worksheet.write("A25", txt)
worksheet.data_validation(
    "B25",
    {
        "validate": "integer",
        "criteria": "between",
        "minimum": 1,
        "maximum": 100,
        "input_title": "Enter an integer:",
        "input_message": "between 1 and 100",
    },
)


# Example 13. Displaying and modifying data validation messages.
#
txt = "Display a custom error message when integer isn't between 1 and 100"

worksheet.write("A27", txt)
worksheet.data_validation(
    "B27",
    {
        "validate": "integer",
        "criteria": "between",
        "minimum": 1,
        "maximum": 100,
        "input_title": "Enter an integer:",
        "input_message": "between 1 and 100",
        "error_title": "Input value is not valid!",
        "error_message": "It should be an integer between 1 and 100",
    },
)


# Example 14. Displaying and modifying data validation messages.
#
txt = "Display a custom info message when integer isn't between 1 and 100"

worksheet.write("A29", txt)
worksheet.data_validation(
    "B29",
    {
        "validate": "integer",
        "criteria": "between",
        "minimum": 1,
        "maximum": 100,
        "input_title": "Enter an integer:",
        "input_message": "between 1 and 100",
        "error_title": "Input value is not valid!",
        "error_message": "It should be an integer between 1 and 100",
        "error_type": "information",
    },
)

workbook.close()

```

---

### File: `tmp\xlsxwriter_sdist\XlsxWriter-3.2.0\examples\datetimes.py`

```python
##############################################################################
#
# A simple program to write some dates and times to an Excel file
# using the XlsxWriter Python module.
#
# SPDX-License-Identifier: BSD-2-Clause
# Copyright 2013-2024, John McNamara, jmcnamara@cpan.org
#
from datetime import datetime
import xlsxwriter

# Create a workbook and add a worksheet.
workbook = xlsxwriter.Workbook("datetimes.xlsx")
worksheet = workbook.add_worksheet()
bold = workbook.add_format({"bold": True})

# Expand the first columns so that the dates are visible.
worksheet.set_column("A:B", 30)

# Write the column headers.
worksheet.write("A1", "Formatted date", bold)
worksheet.write("B1", "Format", bold)

# Create a datetime object to use in the examples.

date_time = datetime.strptime("2013-01-23 12:30:05.123", "%Y-%m-%d %H:%M:%S.%f")

# Examples date and time formats. In the output file compare how changing
# the format codes change the appearance of the date.
date_formats = (
    "dd/mm/yy",
    "mm/dd/yy",
    "dd m yy",
    "d mm yy",
    "d mmm yy",
    "d mmmm yy",
    "d mmmm yyy",
    "d mmmm yyyy",
    "dd/mm/yy hh:mm",
    "dd/mm/yy hh:mm:ss",
    "dd/mm/yy hh:mm:ss.000",
    "hh:mm",
    "hh:mm:ss",
    "hh:mm:ss.000",
)

# Start from first row after headers.
row = 1

# Write the same date and time using each of the above formats.
for date_format_str in date_formats:
    # Create a format for the date or time.
    date_format = workbook.add_format({"num_format": date_format_str, "align": "left"})

    # Write the same date using different formats.
    worksheet.write_datetime(row, 0, date_time, date_format)

    # Also write the format string for comparison.
    worksheet.write_string(row, 1, date_format_str)

    row += 1

workbook.close()

```

---

### File: `tmp\xlsxwriter_sdist\XlsxWriter-3.2.0\examples\defined_name.py`

```python
##############################################################################
#
# Example of how to create defined names with the XlsxWriter Python module.
#
# This method is used to define a user friendly name to represent a value,
# a single cell or a range of cells in a workbook.
#
# SPDX-License-Identifier: BSD-2-Clause
# Copyright 2013-2024, John McNamara, jmcnamara@cpan.org
#
import xlsxwriter


workbook = xlsxwriter.Workbook("defined_name.xlsx")
worksheet1 = workbook.add_worksheet()
worksheet2 = workbook.add_worksheet()

# Define some global/workbook names.
workbook.define_name("Exchange_rate", "=0.96")
workbook.define_name("Sales", "=Sheet1!$G$1:$H$10")

# Define a local/worksheet name. Over-rides the "Sales" name above.
workbook.define_name("Sheet2!Sales", "=Sheet2!$G$1:$G$10")

# Write some text in the file and one of the defined names in a formula.
for worksheet in workbook.worksheets():
    worksheet.set_column("A:A", 45)
    worksheet.write("A1", "This worksheet contains some defined names.")
    worksheet.write("A2", "See Formulas -> Name Manager above.")
    worksheet.write("A3", "Example formula in cell B3 ->")

    worksheet.write("B3", "=Exchange_rate")

workbook.close()

```

---

### File: `tmp\xlsxwriter_sdist\XlsxWriter-3.2.0\examples\demo.py`

```python
##############################################################################
#
# A simple example of some of the features of the XlsxWriter Python module.
#
# SPDX-License-Identifier: BSD-2-Clause
# Copyright 2013-2024, John McNamara, jmcnamara@cpan.org
#
import xlsxwriter


# Create an new Excel file and add a worksheet.
workbook = xlsxwriter.Workbook("demo.xlsx")
worksheet = workbook.add_worksheet()

# Widen the first column to make the text clearer.
worksheet.set_column("A:A", 20)

# Add a bold format to use to highlight cells.
bold = workbook.add_format({"bold": True})

# Write some simple text.
worksheet.write("A1", "Hello")

# Text with formatting.
worksheet.write("A2", "World", bold)

# Write some numbers, with row/column notation.
worksheet.write(2, 0, 123)
worksheet.write(3, 0, 123.456)

# Insert an image.
worksheet.insert_image("B5", "logo.png")

workbook.close()

```

---

### File: `tmp\xlsxwriter_sdist\XlsxWriter-3.2.0\examples\diagonal_border.py`

```python
##############################################################################
#
# A simple formatting example that demonstrates how to add diagonal cell
# borders with XlsxWriter.
#
# SPDX-License-Identifier: BSD-2-Clause
# Copyright 2013-2024, John McNamara, jmcnamara@cpan.org
#
import xlsxwriter

workbook = xlsxwriter.Workbook("diag_border.xlsx")
worksheet = workbook.add_worksheet()

format1 = workbook.add_format({"diag_type": 1})
format2 = workbook.add_format({"diag_type": 2})
format3 = workbook.add_format({"diag_type": 3})

format4 = workbook.add_format(
    {
        "diag_type": 3,
        "diag_border": 7,
        "diag_color": "red",
    }
)

worksheet.write("B3", "Text", format1)
worksheet.write("B6", "Text", format2)
worksheet.write("B9", "Text", format3)
worksheet.write("B12", "Text", format4)

workbook.close()

```

---

### File: `tmp\xlsxwriter_sdist\XlsxWriter-3.2.0\examples\django_simple.py`

```python
##############################################################################
#
# A simple Django view class to write an Excel file using the XlsxWriter
# module.
#
# SPDX-License-Identifier: BSD-2-Clause
# Copyright 2013-2024, John McNamara, jmcnamara@cpan.org
#
import io
from django.http import HttpResponse
from django.views.generic import View
import xlsxwriter


def get_simple_table_data():
    # Simulate a more complex table read.
    return [[1, 2, 3], [4, 5, 6], [7, 8, 9]]


class MyView(View):
    def get(self, request):
        # Create an in-memory output file for the new workbook.
        output = io.BytesIO()

        # Even though the final file will be in memory the module uses temp
        # files during assembly for efficiency. To avoid this on servers that
        # don't allow temp files, for example the Google APP Engine, set the
        # 'in_memory' Workbook() constructor option as shown in the docs.
        workbook = xlsxwriter.Workbook(output)
        worksheet = workbook.add_worksheet()

        # Get some data to write to the spreadsheet.
        data = get_simple_table_data()

        # Write some test data.
        for row_num, columns in enumerate(data):
            for col_num, cell_data in enumerate(columns):
                worksheet.write(row_num, col_num, cell_data)

        # Close the workbook before sending the data.
        workbook.close()

        # Rewind the buffer.
        output.seek(0)

        # Set up the Http response.
        filename = "django_simple.xlsx"
        response = HttpResponse(
            output,
            content_type="application/vnd.openxmlformats-officedocument.spreadsheetml.sheet",
        )
        response["Content-Disposition"] = "attachment; filename=%s" % filename

        return response

```

---

### File: `tmp\xlsxwriter_sdist\XlsxWriter-3.2.0\examples\doc_properties.py`

```python
##############################################################################
#
# An example of adding document properties to a XlsxWriter file.
#
# SPDX-License-Identifier: BSD-2-Clause
# Copyright 2013-2024, John McNamara, jmcnamara@cpan.org
#
import xlsxwriter

workbook = xlsxwriter.Workbook("doc_properties.xlsx")
worksheet = workbook.add_worksheet()

workbook.set_properties(
    {
        "title": "This is an example spreadsheet",
        "subject": "With document properties",
        "author": "John McNamara",
        "manager": "Dr. Heinz Doofenshmirtz",
        "company": "of Wolves",
        "category": "Example spreadsheets",
        "keywords": "Sample, Example, Properties",
        "comments": "Created with Python and XlsxWriter",
        "status": "Quo",
    }
)

worksheet.set_column("A:A", 70)
worksheet.write("A1", "Select 'Workbook Properties' to see properties.")

workbook.close()

```

---

### File: `tmp\xlsxwriter_sdist\XlsxWriter-3.2.0\examples\dynamic_arrays.py`

```python
#######################################################################
#
# An example of how to use the XlsxWriter module to write formulas and
# functions that create dynamic arrays. These functions are new to Excel
# 365. The examples mirror the examples in the Excel documentation on these
# functions.
#
# SPDX-License-Identifier: BSD-2-Clause
# Copyright 2013-2024, John McNamara, jmcnamara@cpan.org
#
import xlsxwriter


def main():
    # Create a new workbook called simple.xls and add some worksheets.
    workbook = xlsxwriter.Workbook("dynamic_arrays.xlsx")

    worksheet1 = workbook.add_worksheet("Filter")
    worksheet2 = workbook.add_worksheet("Unique")
    worksheet3 = workbook.add_worksheet("Sort")
    worksheet4 = workbook.add_worksheet("Sortby")
    worksheet5 = workbook.add_worksheet("Xlookup")
    worksheet6 = workbook.add_worksheet("Xmatch")
    worksheet7 = workbook.add_worksheet("Randarray")
    worksheet8 = workbook.add_worksheet("Sequence")
    worksheet9 = workbook.add_worksheet("Spill ranges")
    worksheet10 = workbook.add_worksheet("Older functions")

    header1 = workbook.add_format({"fg_color": "#74AC4C", "color": "#FFFFFF"})
    header2 = workbook.add_format({"fg_color": "#528FD3", "color": "#FFFFFF"})

    #
    # Example of using the FILTER() function.
    #
    worksheet1.write("F2", "=FILTER(A1:D17,C1:C17=K2)")

    # Write the data the function will work on.
    worksheet1.write("K1", "Product", header2)
    worksheet1.write("K2", "Apple")
    worksheet1.write("F1", "Region", header2)
    worksheet1.write("G1", "Sales Rep", header2)
    worksheet1.write("H1", "Product", header2)
    worksheet1.write("I1", "Units", header2)

    write_worksheet_data(worksheet1, header1)
    worksheet1.set_column_pixels("E:E", 20)
    worksheet1.set_column_pixels("J:J", 20)

    #
    # Example of using the UNIQUE() function.
    #
    worksheet2.write("F2", "=UNIQUE(B2:B17)")

    # A more complex example combining SORT and UNIQUE.
    worksheet2.write("H2", "=SORT(UNIQUE(B2:B17))")

    # Write the data the function will work on.
    worksheet2.write("F1", "Sales Rep", header2)
    worksheet2.write("H1", "Sales Rep", header2)

    write_worksheet_data(worksheet2, header1)
    worksheet2.set_column_pixels("E:E", 20)
    worksheet2.set_column_pixels("G:G", 20)

    #
    # Example of using the SORT() function.
    #
    worksheet3.write("F2", "=SORT(B2:B17)")

    # A more complex example combining SORT and FILTER.
    worksheet3.write("H2", '=SORT(FILTER(C2:D17,D2:D17>5000,""),2,1)')

    # Write the data the function will work on.
    worksheet3.write("F1", "Sales Rep", header2)
    worksheet3.write("H1", "Product", header2)
    worksheet3.write("I1", "Units", header2)

    write_worksheet_data(worksheet3, header1)
    worksheet3.set_column_pixels("E:E", 20)
    worksheet3.set_column_pixels("G:G", 20)

    #
    # Example of using the SORTBY() function.
    #
    worksheet4.write("D2", "=SORTBY(A2:B9,B2:B9)")

    # Write the data the function will work on.
    worksheet4.write("A1", "Name", header1)
    worksheet4.write("B1", "Age", header1)

    worksheet4.write("A2", "Tom")
    worksheet4.write("A3", "Fred")
    worksheet4.write("A4", "Amy")
    worksheet4.write("A5", "Sal")
    worksheet4.write("A6", "Fritz")
    worksheet4.write("A7", "Srivan")
    worksheet4.write("A8", "Xi")
    worksheet4.write("A9", "Hector")

    worksheet4.write("B2", 52)
    worksheet4.write("B3", 65)
    worksheet4.write("B4", 22)
    worksheet4.write("B5", 73)
    worksheet4.write("B6", 19)
    worksheet4.write("B7", 39)
    worksheet4.write("B8", 19)
    worksheet4.write("B9", 66)

    worksheet4.write("D1", "Name", header2)
    worksheet4.write("E1", "Age", header2)

    worksheet4.set_column_pixels("C:C", 20)

    #
    # Example of using the XLOOKUP() function.
    #
    worksheet5.write("F1", "=XLOOKUP(E1,A2:A9,C2:C9)")

    # Write the data the function will work on.
    worksheet5.write("A1", "Country", header1)
    worksheet5.write("B1", "Abr", header1)
    worksheet5.write("C1", "Prefix", header1)

    worksheet5.write("A2", "China")
    worksheet5.write("A3", "India")
    worksheet5.write("A4", "United States")
    worksheet5.write("A5", "Indonesia")
    worksheet5.write("A6", "Brazil")
    worksheet5.write("A7", "Pakistan")
    worksheet5.write("A8", "Nigeria")
    worksheet5.write("A9", "Bangladesh")

    worksheet5.write("B2", "CN")
    worksheet5.write("B3", "IN")
    worksheet5.write("B4", "US")
    worksheet5.write("B5", "ID")
    worksheet5.write("B6", "BR")
    worksheet5.write("B7", "PK")
    worksheet5.write("B8", "NG")
    worksheet5.write("B9", "BD")

    worksheet5.write("C2", 86)
    worksheet5.write("C3", 91)
    worksheet5.write("C4", 1)
    worksheet5.write("C5", 62)
    worksheet5.write("C6", 55)
    worksheet5.write("C7", 92)
    worksheet5.write("C8", 234)
    worksheet5.write("C9", 880)

    worksheet5.write("E1", "Brazil", header2)

    worksheet5.set_column_pixels("A:A", 100)
    worksheet5.set_column_pixels("D:D", 20)

    #
    # Example of using the XMATCH() function.
    #
    worksheet6.write("D2", "=XMATCH(C2,A2:A6)")

    # Write the data the function will work on.
    worksheet6.write("A1", "Product", header1)

    worksheet6.write("A2", "Apple")
    worksheet6.write("A3", "Grape")
    worksheet6.write("A4", "Pear")
    worksheet6.write("A5", "Banana")
    worksheet6.write("A6", "Cherry")

    worksheet6.write("C1", "Product", header2)
    worksheet6.write("D1", "Position", header2)
    worksheet6.write("C2", "Grape")

    worksheet6.set_column_pixels("B:B", 20)

    #
    # Example of using the RANDARRAY() function.
    #
    worksheet7.write("A1", "=RANDARRAY(5,3,1,100, TRUE)")

    #
    # Example of using the SEQUENCE() function.
    #
    worksheet8.write("A1", "=SEQUENCE(4,5)")

    #
    # Example of using the Spill range operator.
    #
    worksheet9.write("H2", "=ANCHORARRAY(F2)")

    worksheet9.write("J2", "=COUNTA(ANCHORARRAY(F2))")

    # Write the data the to work on.
    worksheet9.write("F2", "=UNIQUE(B2:B17)")
    worksheet9.write("F1", "Unique", header2)
    worksheet9.write("H1", "Spill", header2)
    worksheet9.write("J1", "Spill", header2)

    write_worksheet_data(worksheet9, header1)
    worksheet9.set_column_pixels("E:E", 20)
    worksheet9.set_column_pixels("G:G", 20)
    worksheet9.set_column_pixels("I:I", 20)

    #
    # Example of using dynamic ranges with older Excel functions.
    #
    worksheet10.write_dynamic_array_formula("B1:B3", "=LEN(A1:A3)")

    # Write the data the to work on.
    worksheet10.write("A1", "Foo")
    worksheet10.write("A2", "Food")
    worksheet10.write("A3", "Frood")

    # Close the workbook.
    workbook.close()


# Utility function to write the data some of the functions work on.
def write_worksheet_data(worksheet, header):
    worksheet.write("A1", "Region", header)
    worksheet.write("B1", "Sales Rep", header)
    worksheet.write("C1", "Product", header)
    worksheet.write("D1", "Units", header)

    data = (
        ["East", "Tom", "Apple", 6380],
        ["West", "Fred", "Grape", 5619],
        ["North", "Amy", "Pear", 4565],
        ["South", "Sal", "Banana", 5323],
        ["East", "Fritz", "Apple", 4394],
        ["West", "Sravan", "Grape", 7195],
        ["North", "Xi", "Pear", 5231],
        ["South", "Hector", "Banana", 2427],
        ["East", "Tom", "Banana", 4213],
        ["West", "Fred", "Pear", 3239],
        ["North", "Amy", "Grape", 6520],
        ["South", "Sal", "Apple", 1310],
        ["East", "Fritz", "Banana", 6274],
        ["West", "Sravan", "Pear", 4894],
        ["North", "Xi", "Grape", 7580],
        ["South", "Hector", "Apple", 9814],
    )

    row_num = 1
    for row_data in data:
        worksheet.write_row(row_num, 0, row_data)
        row_num += 1


if __name__ == "__main__":
    main()

```

---

### File: `tmp\xlsxwriter_sdist\XlsxWriter-3.2.0\examples\embedded_images.py`

```python
##############################################################################
#
# An example of embedding images into a worksheet cells using the XlsxWriter
# Python module. This is equivalent to Excel's "Place in cell" image insert.
#
# SPDX-License-Identifier: BSD-2-Clause
# Copyright 2013-2024, John McNamara, jmcnamara@cpan.org
#
import xlsxwriter


# Create an new Excel file and add a worksheet.
workbook = xlsxwriter.Workbook("embedded_images.xlsx")
worksheet = workbook.add_worksheet()

# Widen the first column to make the caption clearer.
worksheet.set_column(0, 0, 30)
worksheet.write(0, 0, "Embed images that scale to cell size")

# Embed an images in cells of different widths/heights.
worksheet.set_column(1, 1, 14)

worksheet.set_row(1, 60)
worksheet.embed_image(1, 1, "python.png")

worksheet.set_row(3, 120)
worksheet.embed_image(3, 1, "python.png")

workbook.close()

```

---

### File: `tmp\xlsxwriter_sdist\XlsxWriter-3.2.0\examples\headers_footers.py`

```python
######################################################################
#
# This program shows several examples of how to set up headers and
# footers with XlsxWriter.
#
# The control characters used in the header/footer strings are:
#
#     Control             Category            Description
#     =======             ========            ===========
#     &L                  Justification       Left
#     &C                                      Center
#     &R                                      Right
#
#     &P                  Information         Page number
#     &N                                      Total number of pages
#     &D                                      Date
#     &T                                      Time
#     &F                                      File name
#     &A                                      Worksheet name
#
#     &fontsize           Font                Font size
#     &"font,style"                           Font name and style
#     &U                                      Single underline
#     &E                                      Double underline
#     &S                                      Strikethrough
#     &X                                      Superscript
#     &Y                                      Subscript
#
#     &[Picture]          Images              Image placeholder
#     &G                                      Same as &[Picture]
#
#     &&                  Miscellaneous       Literal ampersand &
#
# See the main XlsxWriter documentation for more information.
#
# SPDX-License-Identifier: BSD-2-Clause
# Copyright 2013-2024, John McNamara, jmcnamara@cpan.org
#
import xlsxwriter

workbook = xlsxwriter.Workbook("headers_footers.xlsx")
preview = "Select Print Preview to see the header and footer"

######################################################################
#
# A simple example to start
#
worksheet1 = workbook.add_worksheet("Simple")
header1 = "&CHere is some centered text."
footer1 = "&LHere is some left aligned text."

worksheet1.set_header(header1)
worksheet1.set_footer(footer1)

worksheet1.set_column("A:A", 50)
worksheet1.write("A1", preview)


######################################################################
#
# Insert a header image.
#
worksheet2 = workbook.add_worksheet("Image")
header2 = "&L&G"

# Adjust the page top margin to allow space for the header image.
worksheet2.set_margins(top=1.3)

worksheet2.set_header(header2, {"image_left": "python-200x80.png"})

worksheet2.set_column("A:A", 50)
worksheet2.write("A1", preview)


######################################################################
#
# This is an example of some of the header/footer variables.
#
worksheet3 = workbook.add_worksheet("Variables")
header3 = "&LPage &P of &N" + "&CFilename: &F" + "&RSheetname: &A"
footer3 = "&LCurrent date: &D" + "&RCurrent time: &T"

worksheet3.set_header(header3)
worksheet3.set_footer(footer3)

worksheet3.set_column("A:A", 50)
worksheet3.write("A1", preview)
worksheet3.write("A21", "Next sheet")
worksheet3.set_h_pagebreaks([20])

######################################################################
#
# This example shows how to use more than one font
#
worksheet4 = workbook.add_worksheet("Mixed fonts")
header4 = '&C&"Courier New,Bold"Hello &"Arial,Italic"World'
footer4 = '&C&"Symbol"e&"Arial" = mc&X2'

worksheet4.set_header(header4)
worksheet4.set_footer(footer4)

worksheet4.set_column("A:A", 50)
worksheet4.write("A1", preview)

######################################################################
#
# Example of line wrapping
#
worksheet5 = workbook.add_worksheet("Word wrap")
header5 = "&CHeading 1\nHeading 2"

worksheet5.set_header(header5)

worksheet5.set_column("A:A", 50)
worksheet5.write("A1", preview)

######################################################################
#
# Example of inserting a literal ampersand &
#
worksheet6 = workbook.add_worksheet("Ampersand")
header6 = "&CCuriouser && Curiouser - Attorneys at Law"

worksheet6.set_header(header6)

worksheet6.set_column("A:A", 50)
worksheet6.write("A1", preview)

workbook.close()

```

---

### File: `tmp\xlsxwriter_sdist\XlsxWriter-3.2.0\examples\hello_world.py`

```python
##############################################################################
#
# A hello world spreadsheet using the XlsxWriter Python module.
#
# SPDX-License-Identifier: BSD-2-Clause
# Copyright 2013-2024, John McNamara, jmcnamara@cpan.org
#
import xlsxwriter

workbook = xlsxwriter.Workbook("hello_world.xlsx")
worksheet = workbook.add_worksheet()

worksheet.write("A1", "Hello world")

workbook.close()

```

---

### File: `tmp\xlsxwriter_sdist\XlsxWriter-3.2.0\examples\hide_row_col.py`

```python
###############################################################################
#
# Example of how to hide rows and columns in XlsxWriter. In order to
# hide rows without setting each one, (of approximately 1 million rows),
# Excel uses an optimizations to hide all rows that don't have data.
#
# SPDX-License-Identifier: BSD-2-Clause
# Copyright 2013-2024, John McNamara, jmcnamara@cpan.org
#
import xlsxwriter

workbook = xlsxwriter.Workbook("hide_row_col.xlsx")
worksheet = workbook.add_worksheet()

# Write some data.
worksheet.write("D1", "Some hidden columns.")
worksheet.write("A8", "Some hidden rows.")

# Hide all rows without data.
worksheet.set_default_row(hide_unused_rows=True)

# Set the height of empty rows that we do want to display even if it is
# the default height.
for row in range(1, 7):
    worksheet.set_row(row, 15)

# Columns can be hidden explicitly. This doesn't increase the file size..
worksheet.set_column("G:XFD", None, None, {"hidden": True})

workbook.close()

```

---

### File: `tmp\xlsxwriter_sdist\XlsxWriter-3.2.0\examples\hide_sheet.py`

```python
#######################################################################
#
# Example of how to hide a worksheet with XlsxWriter.
#
# SPDX-License-Identifier: BSD-2-Clause
# Copyright 2013-2024, John McNamara, jmcnamara@cpan.org
#
import xlsxwriter

workbook = xlsxwriter.Workbook("hide_sheet.xlsx")
worksheet1 = workbook.add_worksheet()
worksheet2 = workbook.add_worksheet()
worksheet3 = workbook.add_worksheet()

worksheet1.set_column("A:A", 30)
worksheet2.set_column("A:A", 30)
worksheet3.set_column("A:A", 30)

# Hide Sheet2. It won't be visible until it is unhidden in Excel.
worksheet2.hide()

worksheet1.write("A1", "Sheet2 is hidden")
worksheet2.write("A1", "Now it's my turn to find you!")
worksheet3.write("A1", "Sheet2 is hidden")

# Note, you can't hide the "active" worksheet, which generally is the
# first worksheet, since this would cause an Excel error. So, in order to hide
# the first sheet you will need to activate another worksheet:
#
#    worksheet2.activate()
#    worksheet1.hide()

workbook.close()

```

---

### File: `tmp\xlsxwriter_sdist\XlsxWriter-3.2.0\examples\http_server.py`

```python
##############################################################################
#
# Example of using Python and XlsxWriter to create an Excel XLSX file in an in
# memory string suitable for serving via SimpleHTTPRequestHandler or Django or
# with the Google App Engine.
#
# SPDX-License-Identifier: BSD-2-Clause
# Copyright 2013-2024, John McNamara, jmcnamara@cpan.org
#

import http.server
import socketserver
import io

import xlsxwriter


class Handler(http.server.SimpleHTTPRequestHandler):
    def do_GET(self):
        # Create an in-memory output file for the new workbook.
        output = io.BytesIO()

        # Even though the final file will be in memory the module uses temp
        # files during assembly for efficiency. To avoid this on servers that
        # don't allow temp files set the 'in_memory' constructor option to True.
        #
        # Note: The Python 3 Runtime Environment in Google App Engine supports
        # a filesystem with read/write access to /tmp which means that the
        # 'in_memory' option isn't required there and can be omitted. See:
        #
        # https://cloud.google.com/appengine/docs/standard/python3/runtime#filesystem
        #
        workbook = xlsxwriter.Workbook(output, {"in_memory": True})
        worksheet = workbook.add_worksheet()

        # Write some test data.
        worksheet.write(0, 0, "Hello, world!")

        # Close the workbook before streaming the data.
        workbook.close()

        # Rewind the buffer.
        output.seek(0)

        # Construct a server response.
        self.send_response(200)
        self.send_header("Content-Disposition", "attachment; filename=test.xlsx")
        self.send_header(
            "Content-type",
            "application/vnd.openxmlformats-officedocument.spreadsheetml.sheet",
        )
        self.end_headers()
        self.wfile.write(output.read())
        return


print("Server listening on port 8000...")
httpd = socketserver.TCPServer(("", 8000), Handler)
httpd.serve_forever()

```

---

### File: `tmp\xlsxwriter_sdist\XlsxWriter-3.2.0\examples\hyperlink.py`

```python
###############################################################################
#
# Example of how to use the XlsxWriter module to write hyperlinks
#
# SPDX-License-Identifier: BSD-2-Clause
# Copyright 2013-2024, John McNamara, jmcnamara@cpan.org
#
import xlsxwriter

# Create a new workbook and add a worksheet
workbook = xlsxwriter.Workbook("hyperlink.xlsx")
worksheet = workbook.add_worksheet("Hyperlinks")

# Format the first column
worksheet.set_column("A:A", 30)

# Add a sample alternative link format.
red_format = workbook.add_format(
    {
        "font_color": "red",
        "bold": 1,
        "underline": 1,
        "font_size": 12,
    }
)

# Write some hyperlinks
worksheet.write_url("A1", "http://www.python.org/")  # Implicit format.
worksheet.write_url("A3", "http://www.python.org/", string="Python Home")
worksheet.write_url("A5", "http://www.python.org/", tip="Click here")
worksheet.write_url("A7", "http://www.python.org/", red_format)
worksheet.write_url("A9", "mailto:jmcnamara@cpan.org", string="Mail me")

# Write a URL that isn't a hyperlink
worksheet.write_string("A11", "http://www.python.org/")

workbook.close()

```

---

### File: `tmp\xlsxwriter_sdist\XlsxWriter-3.2.0\examples\ignore_errors.py`

```python
##############################################################################
#
# An example of turning off worksheet cells errors/warnings using the
# XlsxWriter Python module.
#
# SPDX-License-Identifier: BSD-2-Clause
# Copyright 2013-2024, John McNamara, jmcnamara@cpan.org
#
import xlsxwriter

workbook = xlsxwriter.Workbook("ignore_errors.xlsx")
worksheet = workbook.add_worksheet()

# Write strings that looks like numbers. This will cause an Excel warning.
worksheet.write_string("C2", "123")
worksheet.write_string("C3", "123")

# Write a divide by zero formula. This will also cause an Excel warning.
worksheet.write_formula("C5", "=1/0")
worksheet.write_formula("C6", "=1/0")

# Turn off some of the warnings:
worksheet.ignore_errors({"number_stored_as_text": "C3", "eval_error": "C6"})

# Write some descriptions for the cells and make the column wider for clarity.
worksheet.set_column("B:B", 16, None)
worksheet.write("B2", "Warning:")
worksheet.write("B3", "Warning turned off:")
worksheet.write("B5", "Warning:")
worksheet.write("B6", "Warning turned off:")

workbook.close()

```

---

### File: `tmp\xlsxwriter_sdist\XlsxWriter-3.2.0\examples\images.py`

```python
##############################################################################
#
# An example of inserting images into a worksheet using the XlsxWriter
# Python module.
#
# SPDX-License-Identifier: BSD-2-Clause
# Copyright 2013-2024, John McNamara, jmcnamara@cpan.org
#
import xlsxwriter


# Create an new Excel file and add a worksheet.
workbook = xlsxwriter.Workbook("images.xlsx")
worksheet = workbook.add_worksheet()

# Widen the first column to make the text clearer.
worksheet.set_column("A:A", 30)

# Insert an image.
worksheet.write("A2", "Insert an image in a cell:")
worksheet.insert_image("B2", "python.png")

# Insert an image offset in the cell.
worksheet.write("A12", "Insert an image with an offset:")
worksheet.insert_image("B12", "python.png", {"x_offset": 15, "y_offset": 10})

# Insert an image with scaling.
worksheet.write("A23", "Insert a scaled image:")
worksheet.insert_image("B23", "python.png", {"x_scale": 0.5, "y_scale": 0.5})

workbook.close()

```

---

### File: `tmp\xlsxwriter_sdist\XlsxWriter-3.2.0\examples\images_bytesio.py`

```python
##############################################################################
#
# An example of inserting images from a Python BytesIO byte stream into a
# worksheet using the XlsxWriter module.
#
# SPDX-License-Identifier: BSD-2-Clause
# Copyright 2013-2024, John McNamara, jmcnamara@cpan.org
#

from io import BytesIO
from urllib.request import urlopen


import xlsxwriter

# Create the workbook and add a worksheet.
workbook = xlsxwriter.Workbook("images_bytesio.xlsx")
worksheet = workbook.add_worksheet()


# Read an image from a remote url.
url = (
    "https://raw.githubusercontent.com/jmcnamara/XlsxWriter/"
    + "master/examples/logo.png"
)

image_data = BytesIO(urlopen(url).read())

# Write the byte stream image to a cell. Note, the filename must be
# specified. In this case it will be read from url string.
worksheet.insert_image("B2", url, {"image_data": image_data})


# Read a local image file into a a byte stream. Note, the insert_image()
# method can do this directly. This is for illustration purposes only.
filename = "python.png"

image_file = open(filename, "rb")
image_data = BytesIO(image_file.read())
image_file.close()


# Write the byte stream image to a cell. The filename must  be specified.
worksheet.insert_image("B8", filename, {"image_data": image_data})


workbook.close()

```

---

### File: `tmp\xlsxwriter_sdist\XlsxWriter-3.2.0\examples\inheritance1.py`

```python
##############################################################################
#
# Example of how to subclass the Workbook and Worksheet objects. We also
# override the default worksheet.write() method to show how that is done.
#
# SPDX-License-Identifier: BSD-2-Clause
# Copyright 2013-2024, John McNamara, jmcnamara@cpan.org
#
from xlsxwriter.workbook import Workbook
from xlsxwriter.worksheet import Worksheet
from xlsxwriter.worksheet import convert_cell_args


class MyWorksheet(Worksheet):
    """
    Subclass of the XlsxWriter Worksheet class to override the default
    write() method.

    """

    @convert_cell_args
    def write(self, row, col, *args):
        data = args[0]

        # Reverse strings to demonstrate the overridden method.
        if isinstance(data, str):
            data = data[::-1]
            return self.write_string(row, col, data)
        else:
            # Call the parent version of write() as usual for other data.
            return super(MyWorksheet, self).write(row, col, *args)


class MyWorkbook(Workbook):
    """
    Subclass of the XlsxWriter Workbook class to override the default
    Worksheet class with our custom class.

    """

    def add_worksheet(self, name=None):
        # Overwrite add_worksheet() to create a MyWorksheet object.
        worksheet = super(MyWorkbook, self).add_worksheet(name, MyWorksheet)

        return worksheet


# Create a new MyWorkbook object.
workbook = MyWorkbook("inheritance1.xlsx")

# The code from now on will be the same as a normal "Workbook" program.
worksheet = workbook.add_worksheet()

# Write some data to test the subclassing.
worksheet.write("A1", "Hello")
worksheet.write("A2", "World")
worksheet.write("A3", 123)
worksheet.write("A4", 345)

workbook.close()

```

---

### File: `tmp\xlsxwriter_sdist\XlsxWriter-3.2.0\examples\inheritance2.py`

```python
##############################################################################
#
# Example of how to subclass the Workbook and Worksheet objects. See also the
# simpler inheritance1.py example.
#
# In this example we see an approach to implementing a simulated autofit in a
# user application. This works by overriding the write_string() method to
# track the maximum width string in each column and then set the column
# widths.
#
# Note: THIS ISN'T A FULLY FUNCTIONAL AUTOFIT EXAMPLE. It is only a proof or
# concept or a framework to try out solutions.
#
# SPDX-License-Identifier: BSD-2-Clause
# Copyright 2013-2024, John McNamara, jmcnamara@cpan.org
#
from xlsxwriter.workbook import Workbook
from xlsxwriter.worksheet import Worksheet
from xlsxwriter.worksheet import convert_cell_args


def excel_string_width(str):
    """
    Calculate the length of the string in Excel character units. This is only
    an example and won't give accurate results. It will need to be replaced
    by something more rigorous.

    """
    string_width = len(str)

    if string_width == 0:
        return 0
    else:
        return string_width * 1.1


class MyWorksheet(Worksheet):
    """
    Subclass of the XlsxWriter Worksheet class to override the default
    write_string() method.

    """

    @convert_cell_args
    def write_string(self, row, col, string, cell_format=None):
        # Overridden write_string() method to store the maximum string width
        # seen in each column.

        # Check that row and col are valid and store max and min values.
        if self._check_dimensions(row, col):
            return -1

        # Set the min width for the cell. In some cases this might be the
        # default width of 8.43. In this case we use 0 and adjust for all
        # string widths.
        min_width = 0

        # Check if it the string is the largest we have seen for this column.
        string_width = excel_string_width(string)
        if string_width > min_width:
            max_width = self.max_column_widths.get(col, min_width)
            if string_width > max_width:
                self.max_column_widths[col] = string_width

        # Now call the parent version of write_string() as usual.
        return super(MyWorksheet, self).write_string(row, col, string, cell_format)


class MyWorkbook(Workbook):
    """
    Subclass of the XlsxWriter Workbook class to override the default
    Worksheet class with our custom class.

    """

    def add_worksheet(self, name=None):
        # Overwrite add_worksheet() to create a MyWorksheet object.
        # Also add an Worksheet attribute to store the column widths.
        worksheet = super(MyWorkbook, self).add_worksheet(name, MyWorksheet)
        worksheet.max_column_widths = {}

        return worksheet

    def close(self):
        # We apply the stored column widths for each worksheet when we close
        # the workbook. This will override any other set_column() values that
        # may have been applied. This could be handled in the application code
        # below, instead.
        for worksheet in self.worksheets():
            for column, width in worksheet.max_column_widths.items():
                worksheet.set_column(column, column, width)

        return super(MyWorkbook, self).close()


# Create a new MyWorkbook object.
workbook = MyWorkbook("inheritance2.xlsx")

# The code from now on will be the same as a normal "Workbook" program.
worksheet = workbook.add_worksheet()

# Write some data to test column fitting.
worksheet.write("A1", "F")

worksheet.write("B3", "Foo")

worksheet.write("C1", "F")
worksheet.write("C2", "Fo")
worksheet.write("C3", "Foo")
worksheet.write("C4", "Food")

worksheet.write("D1", "This is a longer string")

# Write a string in row-col notation.
worksheet.write(0, 4, "Hello World")

# Write a number.
worksheet.write(0, 5, 123456)

workbook.close()

```

---

### File: `tmp\xlsxwriter_sdist\XlsxWriter-3.2.0\examples\lambda.py`

```python
#######################################################################
#
# An example of using the new Excel LAMBDA() function with the XlsxWriter
# module.
#
# SPDX-License-Identifier: BSD-2-Clause
# Copyright 2013-2024, John McNamara, jmcnamara@cpan.org
#
from xlsxwriter.workbook import Workbook

workbook = Workbook("lambda.xlsx")
worksheet = workbook.add_worksheet()


# Write a Lambda function to convert Fahrenheit to Celsius to a cell.
#
# Note that the lambda function parameters must be prefixed with
# "_xlpm.". These prefixes won't show up in Excel.
worksheet.write("A1", "=LAMBDA(_xlpm.temp, (5/9) * (_xlpm.temp-32))(32)")

# Create the same formula (without an argument) as a defined name and use that
# to calculate a value.
#
# Note that the formula name is prefixed with "_xlfn." (this is normally
# converted automatically by write_formula() but isn't for defined names)
# and note that the lambda function parameters are prefixed with
# "_xlpm.". These prefixes won't show up in Excel.
workbook.define_name("ToCelsius", "=_xlfn.LAMBDA(_xlpm.temp, (5/9) * (_xlpm.temp-32))")

# The user defined name needs to be written explicitly as a dynamic array
# formula.
worksheet.write_dynamic_array_formula("A2", "=ToCelsius(212)")

workbook.close()

```

---

### File: `tmp\xlsxwriter_sdist\XlsxWriter-3.2.0\examples\macros.py`

```python
#######################################################################
#
# An example of adding macros to an XlsxWriter file using a VBA project
# file extracted from an existing Excel xlsm file.
#
# The vba_extract.py utility supplied with XlsxWriter can be used to extract
# the vbaProject.bin file.
#
# An embedded macro is connected to a form button on the worksheet.
#
# SPDX-License-Identifier: BSD-2-Clause
# Copyright 2013-2024, John McNamara, jmcnamara@cpan.org
#
import xlsxwriter

# Note the file extension should be .xlsm.
workbook = xlsxwriter.Workbook("macros.xlsm")
worksheet = workbook.add_worksheet()

worksheet.set_column("A:A", 30)

# Add the VBA project binary.
workbook.add_vba_project("./vbaProject.bin")

# Show text for the end user.
worksheet.write("A3", "Press the button to say hello.")

# Add a button tied to a macro in the VBA project.
worksheet.insert_button(
    "B3", {"macro": "say_hello", "caption": "Press Me", "width": 80, "height": 30}
)

workbook.close()

```

---

### File: `tmp\xlsxwriter_sdist\XlsxWriter-3.2.0\examples\merge1.py`

```python
##############################################################################
#
# A simple example of merging cells with the XlsxWriter Python module.
#
# SPDX-License-Identifier: BSD-2-Clause
# Copyright 2013-2024, John McNamara, jmcnamara@cpan.org
#
import xlsxwriter


# Create an new Excel file and add a worksheet.
workbook = xlsxwriter.Workbook("merge1.xlsx")
worksheet = workbook.add_worksheet()

# Increase the cell size of the merged cells to highlight the formatting.
worksheet.set_column("B:D", 12)
worksheet.set_row(3, 30)
worksheet.set_row(6, 30)
worksheet.set_row(7, 30)


# Create a format to use in the merged range.
merge_format = workbook.add_format(
    {
        "bold": 1,
        "border": 1,
        "align": "center",
        "valign": "vcenter",
        "fg_color": "yellow",
    }
)


# Merge 3 cells.
worksheet.merge_range("B4:D4", "Merged Range", merge_format)

# Merge 3 cells over two rows.
worksheet.merge_range("B7:D8", "Merged Range", merge_format)


workbook.close()

```

---

### File: `tmp\xlsxwriter_sdist\XlsxWriter-3.2.0\examples\merge_rich_string.py`

```python
##############################################################################
#
# An  example of merging cells which contain a rich string using the
# XlsxWriter Python module.
#
# SPDX-License-Identifier: BSD-2-Clause
# Copyright 2013-2024, John McNamara, jmcnamara@cpan.org
#
import xlsxwriter


# Create an new Excel file and add a worksheet.
workbook = xlsxwriter.Workbook("merge_rich_string.xlsx")
worksheet = workbook.add_worksheet()

# Set up some formats to use.
red = workbook.add_format({"color": "red"})
blue = workbook.add_format({"color": "blue"})
cell_format = workbook.add_format({"align": "center", "valign": "vcenter", "border": 1})

# We can only write simple types to merged ranges so we write a blank string.
worksheet.merge_range("B2:E5", "", cell_format)

# We then overwrite the first merged cell with a rich string. Note that we
# must also pass the cell format used in the merged cells format at the end.
worksheet.write_rich_string(
    "B2", "This is ", red, "red", " and this is ", blue, "blue", cell_format
)

workbook.close()

```

---

### File: `tmp\xlsxwriter_sdist\XlsxWriter-3.2.0\examples\outline.py`

```python
###############################################################################
#
# Example of how use Python and XlsxWriter to generate Excel outlines and
# grouping.
#
# Excel allows you to group rows or columns so that they can be hidden or
# displayed with a single mouse click. This feature is referred to as outlines.
#
# Outlines can reduce complex data down to a few salient sub-totals or
# summaries.
#
# SPDX-License-Identifier: BSD-2-Clause
# Copyright 2013-2024, John McNamara, jmcnamara@cpan.org
#
import xlsxwriter

# Create a new workbook and add some worksheets
workbook = xlsxwriter.Workbook("outline.xlsx")
worksheet1 = workbook.add_worksheet("Outlined Rows")
worksheet2 = workbook.add_worksheet("Collapsed Rows")
worksheet3 = workbook.add_worksheet("Outline Columns")
worksheet4 = workbook.add_worksheet("Outline levels")

# Add a general format
bold = workbook.add_format({"bold": 1})


###############################################################################
#
# Example 1: A worksheet with outlined rows. It also includes SUBTOTAL()
# functions so that it looks like the type of automatic outlines that are
# generated when you use the Excel Data->SubTotals menu item.
#
# For outlines the important parameters are 'level' and 'hidden'. Rows with
# the same 'level' are grouped together. The group will be collapsed if
# 'hidden' is enabled. The parameters 'height' and 'cell_format' are assigned
# default values if they are None.
#
worksheet1.set_row(1, None, None, {"level": 2})
worksheet1.set_row(2, None, None, {"level": 2})
worksheet1.set_row(3, None, None, {"level": 2})
worksheet1.set_row(4, None, None, {"level": 2})
worksheet1.set_row(5, None, None, {"level": 1})

worksheet1.set_row(6, None, None, {"level": 2})
worksheet1.set_row(7, None, None, {"level": 2})
worksheet1.set_row(8, None, None, {"level": 2})
worksheet1.set_row(9, None, None, {"level": 2})
worksheet1.set_row(10, None, None, {"level": 1})

# Adjust the column width for clarity
worksheet1.set_column("A:A", 20)

# Add the data, labels and formulas
worksheet1.write("A1", "Region", bold)
worksheet1.write("A2", "North")
worksheet1.write("A3", "North")
worksheet1.write("A4", "North")
worksheet1.write("A5", "North")
worksheet1.write("A6", "North Total", bold)

worksheet1.write("B1", "Sales", bold)
worksheet1.write("B2", 1000)
worksheet1.write("B3", 1200)
worksheet1.write("B4", 900)
worksheet1.write("B5", 1200)
worksheet1.write("B6", "=SUBTOTAL(9,B2:B5)", bold)

worksheet1.write("A7", "South")
worksheet1.write("A8", "South")
worksheet1.write("A9", "South")
worksheet1.write("A10", "South")
worksheet1.write("A11", "South Total", bold)

worksheet1.write("B7", 400)
worksheet1.write("B8", 600)
worksheet1.write("B9", 500)
worksheet1.write("B10", 600)
worksheet1.write("B11", "=SUBTOTAL(9,B7:B10)", bold)

worksheet1.write("A12", "Grand Total", bold)
worksheet1.write("B12", "=SUBTOTAL(9,B2:B10)", bold)


###############################################################################
#
# Example 2: A worksheet with outlined rows. This is the same as the
# previous example except that the rows are collapsed.
# Note: We need to indicate the rows that contains the collapsed symbol '+'
# with the optional parameter, 'collapsed'. The group will be then be
# collapsed if 'hidden' is True.
#
worksheet2.set_row(1, None, None, {"level": 2, "hidden": True})
worksheet2.set_row(2, None, None, {"level": 2, "hidden": True})
worksheet2.set_row(3, None, None, {"level": 2, "hidden": True})
worksheet2.set_row(4, None, None, {"level": 2, "hidden": True})
worksheet2.set_row(5, None, None, {"level": 1, "hidden": True})

worksheet2.set_row(6, None, None, {"level": 2, "hidden": True})
worksheet2.set_row(7, None, None, {"level": 2, "hidden": True})
worksheet2.set_row(8, None, None, {"level": 2, "hidden": True})
worksheet2.set_row(9, None, None, {"level": 2, "hidden": True})
worksheet2.set_row(10, None, None, {"level": 1, "hidden": True})
worksheet2.set_row(11, None, None, {"collapsed": True})

# Adjust the column width for clarity
worksheet2.set_column("A:A", 20)

# Add the data, labels and formulas
worksheet2.write("A1", "Region", bold)
worksheet2.write("A2", "North")
worksheet2.write("A3", "North")
worksheet2.write("A4", "North")
worksheet2.write("A5", "North")
worksheet2.write("A6", "North Total", bold)

worksheet2.write("B1", "Sales", bold)
worksheet2.write("B2", 1000)
worksheet2.write("B3", 1200)
worksheet2.write("B4", 900)
worksheet2.write("B5", 1200)
worksheet2.write("B6", "=SUBTOTAL(9,B2:B5)", bold)

worksheet2.write("A7", "South")
worksheet2.write("A8", "South")
worksheet2.write("A9", "South")
worksheet2.write("A10", "South")
worksheet2.write("A11", "South Total", bold)

worksheet2.write("B7", 400)
worksheet2.write("B8", 600)
worksheet2.write("B9", 500)
worksheet2.write("B10", 600)
worksheet2.write("B11", "=SUBTOTAL(9,B7:B10)", bold)

worksheet2.write("A12", "Grand Total", bold)
worksheet2.write("B12", "=SUBTOTAL(9,B2:B10)", bold)


###############################################################################
#
# Example 3: Create a worksheet with outlined columns.
#
data = [
    ["Month", "Jan", "Feb", "Mar", "Apr", "May", "Jun", "Total"],
    ["North", 50, 20, 15, 25, 65, 80, "=SUM(B2:G2)"],
    ["South", 10, 20, 30, 50, 50, 50, "=SUM(B3:G3)"],
    ["East", 45, 75, 50, 15, 75, 100, "=SUM(B4:G4)"],
    ["West", 15, 15, 55, 35, 20, 50, "=SUM(B5:G5)"],
]

# Add bold format to the first row.
worksheet3.set_row(0, None, bold)

# Set column formatting and the outline level.
worksheet3.set_column("A:A", 10, bold)
worksheet3.set_column("B:G", 5, None, {"level": 1})
worksheet3.set_column("H:H", 10)

# Write the data and a formula
for row, data_row in enumerate(data):
    worksheet3.write_row(row, 0, data_row)

worksheet3.write("H6", "=SUM(H2:H5)", bold)


###############################################################################
#
# Example 4: Show all possible outline levels.
#
levels = [
    "Level 1",
    "Level 2",
    "Level 3",
    "Level 4",
    "Level 5",
    "Level 6",
    "Level 7",
    "Level 6",
    "Level 5",
    "Level 4",
    "Level 3",
    "Level 2",
    "Level 1",
]

worksheet4.write_column("A1", levels)

worksheet4.set_row(0, None, None, {"level": 1})
worksheet4.set_row(1, None, None, {"level": 2})
worksheet4.set_row(2, None, None, {"level": 3})
worksheet4.set_row(3, None, None, {"level": 4})
worksheet4.set_row(4, None, None, {"level": 5})
worksheet4.set_row(5, None, None, {"level": 6})
worksheet4.set_row(6, None, None, {"level": 7})
worksheet4.set_row(7, None, None, {"level": 6})
worksheet4.set_row(8, None, None, {"level": 5})
worksheet4.set_row(9, None, None, {"level": 4})
worksheet4.set_row(10, None, None, {"level": 3})
worksheet4.set_row(11, None, None, {"level": 2})
worksheet4.set_row(12, None, None, {"level": 1})

workbook.close()

```

---

### File: `tmp\xlsxwriter_sdist\XlsxWriter-3.2.0\examples\outline_collapsed.py`

```python
###############################################################################
#
# Example of how to use Python and XlsxWriter to generate Excel outlines and
# grouping.
#
# These examples focus mainly on collapsed outlines. See also the
# outlines.py example program for more general examples.
#
# SPDX-License-Identifier: BSD-2-Clause
# Copyright 2013-2024, John McNamara, jmcnamara@cpan.org
#
import xlsxwriter

# Create a new workbook and add some worksheets
workbook = xlsxwriter.Workbook("outline_collapsed.xlsx")
worksheet1 = workbook.add_worksheet("Outlined Rows")
worksheet2 = workbook.add_worksheet("Collapsed Rows 1")
worksheet3 = workbook.add_worksheet("Collapsed Rows 2")
worksheet4 = workbook.add_worksheet("Collapsed Rows 3")
worksheet5 = workbook.add_worksheet("Outline Columns")
worksheet6 = workbook.add_worksheet("Collapsed Columns")

# Add a general format
bold = workbook.add_format({"bold": 1})


# This function will generate the same data and sub-totals on each worksheet.
# Used in the first 4 examples.
#
def create_sub_totals(worksheet):
    # Adjust the column width for clarity.
    worksheet.set_column("A:A", 20)

    # Add the data, labels and formulas.
    worksheet.write("A1", "Region", bold)
    worksheet.write("A2", "North")
    worksheet.write("A3", "North")
    worksheet.write("A4", "North")
    worksheet.write("A5", "North")
    worksheet.write("A6", "North Total", bold)

    worksheet.write("B1", "Sales", bold)
    worksheet.write("B2", 1000)
    worksheet.write("B3", 1200)
    worksheet.write("B4", 900)
    worksheet.write("B5", 1200)
    worksheet.write("B6", "=SUBTOTAL(9,B2:B5)", bold)

    worksheet.write("A7", "South")
    worksheet.write("A8", "South")
    worksheet.write("A9", "South")
    worksheet.write("A10", "South")
    worksheet.write("A11", "South Total", bold)

    worksheet.write("B7", 400)
    worksheet.write("B8", 600)
    worksheet.write("B9", 500)
    worksheet.write("B10", 600)
    worksheet.write("B11", "=SUBTOTAL(9,B7:B10)", bold)

    worksheet.write("A12", "Grand Total", bold)
    worksheet.write("B12", "=SUBTOTAL(9,B2:B10)", bold)


###############################################################################
#
# Example 1: A worksheet with outlined rows. It also includes SUBTOTAL()
# functions so that it looks like the type of automatic outlines that are
# generated when you use the Excel Data->SubTotals menu item.
#
worksheet1.set_row(1, None, None, {"level": 2})
worksheet1.set_row(2, None, None, {"level": 2})
worksheet1.set_row(3, None, None, {"level": 2})
worksheet1.set_row(4, None, None, {"level": 2})
worksheet1.set_row(5, None, None, {"level": 1})

worksheet1.set_row(6, None, None, {"level": 2})
worksheet1.set_row(7, None, None, {"level": 2})
worksheet1.set_row(8, None, None, {"level": 2})
worksheet1.set_row(9, None, None, {"level": 2})
worksheet1.set_row(10, None, None, {"level": 1})

# Write the sub-total data that is common to the row examples.
create_sub_totals(worksheet1)


###############################################################################
#
# Example 2: Create a worksheet with collapsed outlined rows.
# This is the same as the example 1  except that the all rows are collapsed.
# Note: We need to indicate the rows that contains the collapsed symbol '+'
# with the optional parameter, 'collapsed'.
#
worksheet2.set_row(1, None, None, {"level": 2, "hidden": True})
worksheet2.set_row(2, None, None, {"level": 2, "hidden": True})
worksheet2.set_row(3, None, None, {"level": 2, "hidden": True})
worksheet2.set_row(4, None, None, {"level": 2, "hidden": True})
worksheet2.set_row(5, None, None, {"level": 1, "hidden": True})

worksheet2.set_row(6, None, None, {"level": 2, "hidden": True})
worksheet2.set_row(7, None, None, {"level": 2, "hidden": True})
worksheet2.set_row(8, None, None, {"level": 2, "hidden": True})
worksheet2.set_row(9, None, None, {"level": 2, "hidden": True})
worksheet2.set_row(10, None, None, {"level": 1, "hidden": True})

worksheet2.set_row(11, None, None, {"collapsed": True})

# Write the sub-total data that is common to the row examples.
create_sub_totals(worksheet2)


###############################################################################
#
# Example 3: Create a worksheet with collapsed outlined rows.
# Same as the example 1  except that the two sub-totals are collapsed.
#
worksheet3.set_row(1, None, None, {"level": 2, "hidden": True})
worksheet3.set_row(2, None, None, {"level": 2, "hidden": True})
worksheet3.set_row(3, None, None, {"level": 2, "hidden": True})
worksheet3.set_row(4, None, None, {"level": 2, "hidden": True})
worksheet3.set_row(5, None, None, {"level": 1, "collapsed": True})

worksheet3.set_row(6, None, None, {"level": 2, "hidden": True})
worksheet3.set_row(7, None, None, {"level": 2, "hidden": True})
worksheet3.set_row(8, None, None, {"level": 2, "hidden": True})
worksheet3.set_row(9, None, None, {"level": 2, "hidden": True})
worksheet3.set_row(10, None, None, {"level": 1, "collapsed": True})

# Write the sub-total data that is common to the row examples.
create_sub_totals(worksheet3)


###############################################################################
#
# Example 4: Create a worksheet with outlined rows.
# Same as the example 1  except that the two sub-totals are collapsed.
#
worksheet4.set_row(1, None, None, {"level": 2, "hidden": True})
worksheet4.set_row(2, None, None, {"level": 2, "hidden": True})
worksheet4.set_row(3, None, None, {"level": 2, "hidden": True})
worksheet4.set_row(4, None, None, {"level": 2, "hidden": True})
worksheet4.set_row(5, None, None, {"level": 1, "hidden": True, "collapsed": True})

worksheet4.set_row(6, None, None, {"level": 2, "hidden": True})
worksheet4.set_row(7, None, None, {"level": 2, "hidden": True})
worksheet4.set_row(8, None, None, {"level": 2, "hidden": True})
worksheet4.set_row(9, None, None, {"level": 2, "hidden": True})
worksheet4.set_row(10, None, None, {"level": 1, "hidden": True, "collapsed": True})

worksheet4.set_row(11, None, None, {"collapsed": True})


# Write the sub-total data that is common to the row examples.
create_sub_totals(worksheet4)


###############################################################################
#
# Example 5: Create a worksheet with outlined columns.
#
data = [
    ["Month", "Jan", "Feb", "Mar", "Apr", "May", "Jun", "Total"],
    ["North", 50, 20, 15, 25, 65, 80, "=SUM(B2:G2)"],
    ["South", 10, 20, 30, 50, 50, 50, "=SUM(B3:G3)"],
    ["East", 45, 75, 50, 15, 75, 100, "=SUM(B4:G4)"],
    ["West", 15, 15, 55, 35, 20, 50, "=SUM(B5:G5)"],
]

# Add bold format to the first row.
worksheet5.set_row(0, None, bold)

# Set column formatting and the outline level.
worksheet5.set_column("A:A", 10, bold)
worksheet5.set_column("B:G", 5, None, {"level": 1})
worksheet5.set_column("H:H", 10)

# Write the data and a formula.
for row, data_row in enumerate(data):
    worksheet5.write_row(row, 0, data_row)

worksheet5.write("H6", "=SUM(H2:H5)", bold)

###############################################################################
#
# Example 6: Create a worksheet with collapsed outlined columns.
# This is the same as the previous example except with collapsed columns.
#

# Reuse the data from the previous example.

# Add bold format to the first row.
worksheet6.set_row(0, None, bold)

# Set column formatting and the outline level.
worksheet6.set_column("A:A", 10, bold)
worksheet6.set_column("B:G", 5, None, {"level": 1, "hidden": True})
worksheet6.set_column("H:H", 10, None, {"collapsed": True})

# Write the data and a formula.
for row, data_row in enumerate(data):
    worksheet6.write_row(row, 0, data_row)

worksheet6.write("H6", "=SUM(H2:H5)", bold)

workbook.close()

```

---

### File: `tmp\xlsxwriter_sdist\XlsxWriter-3.2.0\examples\pandas_autofilter.py`

```python
##############################################################################
#
# An example of converting a Pandas dataframe to an xlsx file with an
# autofilter and filtered data. See also autofilter.py.
#
# SPDX-License-Identifier: BSD-2-Clause
# Copyright 2013-2024, John McNamara, jmcnamara@cpan.org
#

import pandas as pd

# Create a Pandas dataframe by reading some data from a space-separated file.
df = pd.read_csv("autofilter_data.txt", sep=r"\s+")

# Create a Pandas Excel writer using XlsxWriter as the engine.
writer = pd.ExcelWriter("pandas_autofilter.xlsx", engine="xlsxwriter")

# Convert the dataframe to an XlsxWriter Excel object. We also turn off the
# index column at the left of the output dataframe.
df.to_excel(writer, sheet_name="Sheet1", index=False)

# Get the xlsxwriter workbook and worksheet objects.
workbook = writer.book
worksheet = writer.sheets["Sheet1"]

# Get the dimensions of the dataframe.
(max_row, max_col) = df.shape

# Make the columns wider for clarity.
worksheet.set_column(0, max_col - 1, 12)

# Set the autofilter.
worksheet.autofilter(0, 0, max_row, max_col - 1)

# Add an optional filter criteria. The placeholder "Region" in the filter
# is ignored and can be any string that adds clarity to the expression.
worksheet.filter_column(0, "Region == East")

# It isn't enough to just apply the criteria. The rows that don't match
# must also be hidden. We use Pandas to figure our which rows to hide.
for row_num in df.index[(df["Region"] != "East")].tolist():
    worksheet.set_row(row_num + 1, options={"hidden": True})

# Close the Pandas Excel writer and output the Excel file.
writer.close()

```

---

### File: `tmp\xlsxwriter_sdist\XlsxWriter-3.2.0\examples\pandas_chart.py`

```python
##############################################################################
#
# An example of converting a Pandas dataframe to an xlsx file with a chart
# using Pandas and XlsxWriter.
#
# SPDX-License-Identifier: BSD-2-Clause
# Copyright 2013-2024, John McNamara, jmcnamara@cpan.org
#

import pandas as pd


# Create a Pandas dataframe from some data.
df = pd.DataFrame({"Data": [10, 20, 30, 20, 15, 30, 45]})

# Create a Pandas Excel writer using XlsxWriter as the engine.
writer = pd.ExcelWriter("pandas_chart.xlsx", engine="xlsxwriter")

# Convert the dataframe to an XlsxWriter Excel object.
df.to_excel(writer, sheet_name="Sheet1")

# Get the xlsxwriter workbook and worksheet objects.
workbook = writer.book
worksheet = writer.sheets["Sheet1"]

# Create a chart object.
chart = workbook.add_chart({"type": "column"})

# Get the dimensions of the dataframe.
(max_row, max_col) = df.shape

# Configure the series of the chart from the dataframe data.
chart.add_series({"values": ["Sheet1", 1, 1, max_row, 1]})

# Insert the chart into the worksheet.
worksheet.insert_chart(1, 3, chart)

# Close the Pandas Excel writer and output the Excel file.
writer.close()

```

---

### File: `tmp\xlsxwriter_sdist\XlsxWriter-3.2.0\examples\pandas_chart_columns.py`

```python
##############################################################################
#
# An example of converting a Pandas dataframe to an xlsx file with a grouped
# column chart using Pandas and XlsxWriter.
#
# SPDX-License-Identifier: BSD-2-Clause
# Copyright 2013-2024, John McNamara, jmcnamara@cpan.org
#

import pandas as pd

# Some sample data to plot.
farm_1 = {"Apples": 10, "Berries": 32, "Squash": 21, "Melons": 13, "Corn": 18}
farm_2 = {"Apples": 15, "Berries": 43, "Squash": 17, "Melons": 10, "Corn": 22}
farm_3 = {"Apples": 6, "Berries": 24, "Squash": 22, "Melons": 16, "Corn": 30}
farm_4 = {"Apples": 12, "Berries": 30, "Squash": 15, "Melons": 9, "Corn": 15}

data = [farm_1, farm_2, farm_3, farm_4]
index = ["Farm 1", "Farm 2", "Farm 3", "Farm 4"]

# Create a Pandas dataframe from the data.
df = pd.DataFrame(data, index=index)

# Create a Pandas Excel writer using XlsxWriter as the engine.
sheet_name = "Sheet1"
writer = pd.ExcelWriter("pandas_chart_columns.xlsx", engine="xlsxwriter")
df.to_excel(writer, sheet_name=sheet_name)

# Access the XlsxWriter workbook and worksheet objects from the dataframe.
workbook = writer.book
worksheet = writer.sheets[sheet_name]

# Create a chart object.
chart = workbook.add_chart({"type": "column"})

# Some alternative colors for the chart.
colors = ["#E41A1C", "#377EB8", "#4DAF4A", "#984EA3", "#FF7F00"]

# Configure the series of the chart from the dataframe data.
for col_num in range(1, len(farm_1) + 1):
    chart.add_series(
        {
            "name": ["Sheet1", 0, col_num],
            "categories": ["Sheet1", 1, 0, 4, 0],
            "values": ["Sheet1", 1, col_num, 4, col_num],
            "fill": {"color": colors[col_num - 1]},
            "overlap": -10,
        }
    )

# Configure the chart axes.
chart.set_x_axis({"name": "Total Produce"})
chart.set_y_axis({"name": "Farms", "major_gridlines": {"visible": False}})

# Insert the chart into the worksheet.
worksheet.insert_chart(1, 5, chart)

# Close the Pandas Excel writer and output the Excel file.
writer.close()

```

---

### File: `tmp\xlsxwriter_sdist\XlsxWriter-3.2.0\examples\pandas_chart_line.py`

```python
##############################################################################
#
# An example of converting a Pandas dataframe to an xlsx file with a line
# chart using Pandas and XlsxWriter.
#
# SPDX-License-Identifier: BSD-2-Clause
# Copyright 2013-2024, John McNamara, jmcnamara@cpan.org
#

import pandas as pd
import random

# Create some sample data to plot.
categories = ["Node 1", "Node 2", "Node 3", "Node 4"]
index_1 = range(0, 21, 1)
multi_iter1 = {"index": index_1}

for category in categories:
    multi_iter1[category] = [random.randint(10, 100) for x in index_1]

# Create a Pandas dataframe from the data.
index_2 = multi_iter1.pop("index")
df = pd.DataFrame(multi_iter1, index=index_2)
df = df.reindex(columns=sorted(df.columns))

# Create a Pandas Excel writer using XlsxWriter as the engine.
sheet_name = "Sheet1"
writer = pd.ExcelWriter("pandas_chart_line.xlsx", engine="xlsxwriter")
df.to_excel(writer, sheet_name=sheet_name)

# Access the XlsxWriter workbook and worksheet objects from the dataframe.
workbook = writer.book
worksheet = writer.sheets[sheet_name]

# Get the dimensions of the dataframe.
(max_row, max_col) = df.shape

# Create a chart object.
chart = workbook.add_chart({"type": "line"})

# Configure the series of the chart from the dataframe data.
for i in range(len(categories)):
    col = i + 1
    chart.add_series(
        {
            "name": ["Sheet1", 0, col],
            "categories": ["Sheet1", 1, 0, max_row, 0],
            "values": ["Sheet1", 1, col, max_row, col],
        }
    )

# Configure the chart axes.
chart.set_x_axis({"name": "Index"})
chart.set_y_axis({"name": "Value", "major_gridlines": {"visible": False}})

# Insert the chart into the worksheet.
worksheet.insert_chart(1, 6, chart)

# Close the Pandas Excel writer and output the Excel file.
writer.close()

```

---

### File: `tmp\xlsxwriter_sdist\XlsxWriter-3.2.0\examples\pandas_column_formats.py`

```python
##############################################################################
#
# An example of converting a Pandas dataframe to an xlsx file
# with column formats using Pandas and XlsxWriter.
#
# SPDX-License-Identifier: BSD-2-Clause
# Copyright 2013-2024, John McNamara, jmcnamara@cpan.org
#

import pandas as pd

# Create a Pandas dataframe from some data.
df = pd.DataFrame(
    {
        "Numbers": [1010, 2020, 3030, 2020, 1515, 3030, 4545],
        "Percentage": [0.1, 0.2, 0.33, 0.25, 0.5, 0.75, 0.45],
    }
)

# Create a Pandas Excel writer using XlsxWriter as the engine.
writer = pd.ExcelWriter("pandas_column_formats.xlsx", engine="xlsxwriter")

# Convert the dataframe to an XlsxWriter Excel object.
df.to_excel(writer, sheet_name="Sheet1")

# Get the xlsxwriter workbook and worksheet objects.
workbook = writer.book
worksheet = writer.sheets["Sheet1"]

# Add some cell formats.
format1 = workbook.add_format({"num_format": "#,##0.00"})
format2 = workbook.add_format({"num_format": "0%"})

# Note: It isn't possible to format any cells that already have a format such
# as the index or headers or any cells that contain dates or datetimes.

# Set the column width and format.
worksheet.set_column(1, 1, 18, format1)

# Set the format but not the column width.
worksheet.set_column(2, 2, None, format2)

# Close the Pandas Excel writer and output the Excel file.
writer.close()

```

---

### File: `tmp\xlsxwriter_sdist\XlsxWriter-3.2.0\examples\pandas_conditional_format.py`

```python
##############################################################################
#
# An example of converting a Pandas dataframe to an xlsx file with a
# conditional formatting using Pandas and XlsxWriter.
#
# SPDX-License-Identifier: BSD-2-Clause
# Copyright 2013-2024, John McNamara, jmcnamara@cpan.org
#

import pandas as pd


# Create a Pandas dataframe from some data.
df = pd.DataFrame({"Data": [10, 20, 30, 20, 15, 30, 45]})

# Create a Pandas Excel writer using XlsxWriter as the engine.
writer = pd.ExcelWriter("pandas_conditional.xlsx", engine="xlsxwriter")

# Convert the dataframe to an XlsxWriter Excel object.
df.to_excel(writer, sheet_name="Sheet1")

# Get the xlsxwriter workbook and worksheet objects.
workbook = writer.book
worksheet = writer.sheets["Sheet1"]

# Get the dimensions of the dataframe.
(max_row, max_col) = df.shape

# Apply a conditional format to the required cell range.
worksheet.conditional_format(1, max_col, max_row, max_col, {"type": "3_color_scale"})

# Close the Pandas Excel writer and output the Excel file.
writer.close()

```

---

### File: `tmp\xlsxwriter_sdist\XlsxWriter-3.2.0\examples\pandas_datetime.py`

```python
##############################################################################
#
# An example of converting a Pandas dataframe with datetimes to an xlsx file
# with a default datetime and date format using Pandas and XlsxWriter.
#
# SPDX-License-Identifier: BSD-2-Clause
# Copyright 2013-2024, John McNamara, jmcnamara@cpan.org
#

import pandas as pd
from datetime import datetime, date

# Create a Pandas dataframe from some datetime data.
df = pd.DataFrame(
    {
        "Date and time": [
            datetime(2015, 1, 1, 11, 30, 55),
            datetime(2015, 1, 2, 1, 20, 33),
            datetime(2015, 1, 3, 11, 10),
            datetime(2015, 1, 4, 16, 45, 35),
            datetime(2015, 1, 5, 12, 10, 15),
        ],
        "Dates only": [
            date(2015, 2, 1),
            date(2015, 2, 2),
            date(2015, 2, 3),
            date(2015, 2, 4),
            date(2015, 2, 5),
        ],
    }
)

# Create a Pandas Excel writer using XlsxWriter as the engine.
# Also set the default datetime and date formats.
writer = pd.ExcelWriter(
    "pandas_datetime.xlsx",
    engine="xlsxwriter",
    datetime_format="mmm d yyyy hh:mm:ss",
    date_format="mmmm dd yyyy",
)

# Convert the dataframe to an XlsxWriter Excel object.
df.to_excel(writer, sheet_name="Sheet1")

# Get the xlsxwriter workbook and worksheet objects in order
# to set the column widths and make the dates clearer.
workbook = writer.book
worksheet = writer.sheets["Sheet1"]

# Get the dimensions of the dataframe.
(max_row, max_col) = df.shape

# Set the column widths, to make the dates clearer.
worksheet.set_column(1, max_col, 20)

# Close the Pandas Excel writer and output the Excel file.
writer.close()

```

---

### File: `tmp\xlsxwriter_sdist\XlsxWriter-3.2.0\examples\pandas_header_format.py`

```python
##############################################################################
#
# An example of converting a Pandas dataframe to an xlsx file
# with a user defined header format.
#
# SPDX-License-Identifier: BSD-2-Clause
# Copyright 2013-2024, John McNamara, jmcnamara@cpan.org
#

import pandas as pd

# Create a Pandas dataframe from some data.
data = [10, 20, 30, 40, 50, 60]
df = pd.DataFrame({"Heading": data, "Longer heading that should be wrapped": data})

# Create a Pandas Excel writer using XlsxWriter as the engine.
writer = pd.ExcelWriter("pandas_header_format.xlsx", engine="xlsxwriter")

# Convert the dataframe to an XlsxWriter Excel object. Note that we turn off
# the default header and skip one row to allow us to insert a user defined
# header.
df.to_excel(writer, sheet_name="Sheet1", startrow=1, header=False)

# Get the xlsxwriter workbook and worksheet objects.
workbook = writer.book
worksheet = writer.sheets["Sheet1"]

# Add a header format.
header_format = workbook.add_format(
    {
        "bold": True,
        "text_wrap": True,
        "valign": "top",
        "fg_color": "#D7E4BC",
        "border": 1,
    }
)

# Write the column headers with the defined format.
for col_num, value in enumerate(df.columns.values):
    worksheet.write(0, col_num + 1, value, header_format)

# Close the Pandas Excel writer and output the Excel file.
writer.close()

```

---

### File: `tmp\xlsxwriter_sdist\XlsxWriter-3.2.0\examples\pandas_multiple.py`

```python
##############################################################################
#
# An example of writing multiple dataframes to worksheets using Pandas and
# XlsxWriter.
#
# SPDX-License-Identifier: BSD-2-Clause
# Copyright 2013-2024, John McNamara, jmcnamara@cpan.org
#

import pandas as pd


# Create some Pandas dataframes from some data.
df1 = pd.DataFrame({"Data": [11, 12, 13, 14]})
df2 = pd.DataFrame({"Data": [21, 22, 23, 24]})
df3 = pd.DataFrame({"Data": [31, 32, 33, 34]})

# Create a Pandas Excel writer using XlsxWriter as the engine.
writer = pd.ExcelWriter("pandas_multiple.xlsx", engine="xlsxwriter")

# Write each dataframe to a different worksheet.
df1.to_excel(writer, sheet_name="Sheet1")
df2.to_excel(writer, sheet_name="Sheet2")
df3.to_excel(writer, sheet_name="Sheet3")

# Close the Pandas Excel writer and output the Excel file.
writer.close()

```

---

### File: `tmp\xlsxwriter_sdist\XlsxWriter-3.2.0\examples\pandas_percentage.py`

```python
##############################################################################
#
# An example of converting some string percentage data in a Pandas dataframe
# to percentage numbers in an xlsx file with using XlsxWriter.
#
# SPDX-License-Identifier: BSD-2-Clause
# Copyright 2013-2024, John McNamara, jmcnamara@cpan.org
#

import pandas as pd


# Create a Pandas dataframe from some data.
df = pd.DataFrame({"Names": ["Anna", "Arek", "Arun"], "Grade": ["100%", "70%", "85%"]})

# Convert the percentage strings to percentage numbers.
df["Grade"] = df["Grade"].str.replace("%", "")
df["Grade"] = df["Grade"].astype(float)
df["Grade"] = df["Grade"].div(100)

# Create a Pandas Excel writer using XlsxWriter as the engine.
writer = pd.ExcelWriter("pandas_percent.xlsx", engine="xlsxwriter")

# Convert the dataframe to an XlsxWriter Excel object.
df.to_excel(writer, sheet_name="Sheet1")

# Get the xlsxwriter workbook and worksheet objects.
workbook = writer.book
worksheet = writer.sheets["Sheet1"]

# Add a percent number format.
percent_format = workbook.add_format({"num_format": "0%"})

# Apply the number format to Grade column.
worksheet.set_column(2, 2, None, percent_format)

# Close the Pandas Excel writer and output the Excel file.
writer.close()

```

---

### File: `tmp\xlsxwriter_sdist\XlsxWriter-3.2.0\examples\pandas_positioning.py`

```python
##############################################################################
#
# An example of positioning dataframes in a worksheet using Pandas and
# XlsxWriter.
#
# SPDX-License-Identifier: BSD-2-Clause
# Copyright 2013-2024, John McNamara, jmcnamara@cpan.org
#

import pandas as pd


# Create some Pandas dataframes from some data.
df1 = pd.DataFrame({"Data": [11, 12, 13, 14]})
df2 = pd.DataFrame({"Data": [21, 22, 23, 24]})
df3 = pd.DataFrame({"Data": [31, 32, 33, 34]})
df4 = pd.DataFrame({"Data": [41, 42, 43, 44]})

# Create a Pandas Excel writer using XlsxWriter as the engine.
writer = pd.ExcelWriter("pandas_positioning.xlsx", engine="xlsxwriter")

# Position the dataframes in the worksheet.
df1.to_excel(writer, sheet_name="Sheet1")  # Default position, cell A1.
df2.to_excel(writer, sheet_name="Sheet1", startcol=3)
df3.to_excel(writer, sheet_name="Sheet1", startrow=6)

# It is also possible to write the dataframe without the header and index.
df4.to_excel(
    writer, sheet_name="Sheet1", startrow=7, startcol=4, header=False, index=False
)

# Close the Pandas Excel writer and output the Excel file.
writer.close()

```

---

### File: `tmp\xlsxwriter_sdist\XlsxWriter-3.2.0\examples\pandas_simple.py`

```python
##############################################################################
#
# A simple example of converting a Pandas dataframe to an xlsx file using
# Pandas and XlsxWriter.
#
# SPDX-License-Identifier: BSD-2-Clause
# Copyright 2013-2024, John McNamara, jmcnamara@cpan.org
#

import pandas as pd


# Create a Pandas dataframe from some data.
df = pd.DataFrame({"Data": [10, 20, 30, 20, 15, 30, 45]})

# Create a Pandas Excel writer using XlsxWriter as the engine.
writer = pd.ExcelWriter("pandas_simple.xlsx", engine="xlsxwriter")

# Convert the dataframe to an XlsxWriter Excel object.
df.to_excel(writer, sheet_name="Sheet1")

# Close the Pandas Excel writer and output the Excel file.
writer.close()

```

---

### File: `tmp\xlsxwriter_sdist\XlsxWriter-3.2.0\examples\pandas_table.py`

```python
##############################################################################
#
# An example of adding a dataframe to an worksheet table in an xlsx file
# using Pandas and XlsxWriter.
#
# Tables in Excel are used to group rows and columns of data into a single
# structure that can be referenced in a formula or formatted collectively.
#
# SPDX-License-Identifier: BSD-2-Clause
# Copyright 2013-2024, John McNamara, jmcnamara@cpan.org
#

import pandas as pd

# Create a Pandas dataframe from some data.
df = pd.DataFrame(
    {
        "Country": ["China", "India", "United States", "Indonesia"],
        "Population": [1404338840, 1366938189, 330267887, 269603400],
        "Rank": [1, 2, 3, 4],
    }
)

# Order the columns if necessary.
df = df[["Rank", "Country", "Population"]]

# Create a Pandas Excel writer using XlsxWriter as the engine.
writer = pd.ExcelWriter("pandas_table.xlsx", engine="xlsxwriter")

# Write the dataframe data to XlsxWriter. Turn off the default header and
# index and skip one row to allow us to insert a user defined header.
df.to_excel(writer, sheet_name="Sheet1", startrow=1, header=False, index=False)

# Get the xlsxwriter workbook and worksheet objects.
workbook = writer.book
worksheet = writer.sheets["Sheet1"]

# Get the dimensions of the dataframe.
(max_row, max_col) = df.shape

# Create a list of column headers, to use in add_table().
column_settings = [{"header": column} for column in df.columns]

# Add the Excel table structure. Pandas will add the data.
worksheet.add_table(0, 0, max_row, max_col - 1, {"columns": column_settings})

# Make the columns wider for clarity.
worksheet.set_column(0, max_col - 1, 12)

# Close the Pandas Excel writer and output the Excel file.
writer.close()

```

---

### File: `tmp\xlsxwriter_sdist\XlsxWriter-3.2.0\examples\panes.py`

```python
#######################################################################
#
# Example of using Python and the XlsxWriter module to create
# worksheet panes.
#
# SPDX-License-Identifier: BSD-2-Clause
# Copyright 2013-2024, John McNamara, jmcnamara@cpan.org
#
import xlsxwriter

workbook = xlsxwriter.Workbook("panes.xlsx")

worksheet1 = workbook.add_worksheet("Panes 1")
worksheet2 = workbook.add_worksheet("Panes 2")
worksheet3 = workbook.add_worksheet("Panes 3")
worksheet4 = workbook.add_worksheet("Panes 4")

#######################################################################
#
# Set up some formatting and text to highlight the panes.
#
header_format = workbook.add_format(
    {
        "bold": True,
        "align": "center",
        "valign": "vcenter",
        "fg_color": "#D7E4BC",
        "border": 1,
    }
)

center_format = workbook.add_format({"align": "center"})


#######################################################################
#
# Example 1. Freeze pane on the top row.
#
worksheet1.freeze_panes(1, 0)

# Other sheet formatting.
worksheet1.set_column("A:I", 16)
worksheet1.set_row(0, 20)
worksheet1.set_selection("C3")


# Some text to demonstrate scrolling.
for col in range(0, 9):
    worksheet1.write(0, col, "Scroll down", header_format)

for row in range(1, 100):
    for col in range(0, 9):
        worksheet1.write(row, col, row + 1, center_format)


#######################################################################
#
# Example 2. Freeze pane on the left column.
#
worksheet2.freeze_panes(0, 1)

# Other sheet formatting.
worksheet2.set_column("A:A", 16)
worksheet2.set_selection("C3")

# Some text to demonstrate scrolling.
for row in range(0, 50):
    worksheet2.write(row, 0, "Scroll right", header_format)
    for col in range(1, 26):
        worksheet2.write(row, col, col, center_format)


#######################################################################
#
# Example 3. Freeze pane on the top row and left column.
#
worksheet3.freeze_panes(1, 1)

# Other sheet formatting.
worksheet3.set_column("A:Z", 16)
worksheet3.set_row(0, 20)
worksheet3.set_selection("C3")
worksheet3.write(0, 0, "", header_format)

# Some text to demonstrate scrolling.
for col in range(1, 26):
    worksheet3.write(0, col, "Scroll down", header_format)

for row in range(1, 50):
    worksheet3.write(row, 0, "Scroll right", header_format)
    for col in range(1, 26):
        worksheet3.write(row, col, col, center_format)


#######################################################################
#
# Example 4. Split pane on the top row and left column.
#
# The divisions must be specified in terms of row and column dimensions.
# The default row height is 15 and the default column width is 8.43
#
worksheet4.split_panes(15, 8.43)

# Other sheet formatting.
worksheet4.set_selection("C3")

# Some text to demonstrate scrolling.
for col in range(1, 26):
    worksheet4.write(0, col, "Scroll", center_format)

for row in range(1, 50):
    worksheet4.write(row, 0, "Scroll", center_format)
    for col in range(1, 26):
        worksheet4.write(row, col, col, center_format)

workbook.close()

```

---

### File: `tmp\xlsxwriter_sdist\XlsxWriter-3.2.0\examples\polars_chart.py`

```python
##############################################################################
#
# An example of adding a Polars dataframe to a worksheet created by XlsxWriter
# and then adding a chart of the data.
#
# SPDX-License-Identifier: BSD-2-Clause
# Copyright 2013-2024, John McNamara, jmcnamara@cpan.org
#

import xlsxwriter
import polars as pl

df = pl.DataFrame({"Data": [10, 20, 30, 20, 15, 30, 45]})

with xlsxwriter.Workbook("polars_chart.xlsx") as workbook:
    # Create the worksheet so we can reuse it later.
    worksheet = workbook.add_worksheet()

    # Write the Polars data to the worksheet created above.
    df.write_excel(workbook=workbook, worksheet="Sheet1")

    # Create a chart object.
    chart = workbook.add_chart({"type": "column"})

    # Get the dimensions of the dataframe.
    (max_row, max_col) = df.shape

    # Configure the series of the chart from the dataframe data.
    chart.add_series({"values": ["Sheet1", 1, max_col - 1, max_row, max_col - 1]})

    # Insert the chart into the worksheet.
    worksheet.insert_chart(1, 3, chart)

```

---

### File: `tmp\xlsxwriter_sdist\XlsxWriter-3.2.0\examples\polars_conditional_format.py`

```python
##############################################################################
#
# An example of adding a Polars dataframe to a worksheet with a conditional
# format.
#
# SPDX-License-Identifier: BSD-2-Clause
# Copyright 2013-2024, John McNamara, jmcnamara@cpan.org
#

import polars as pl

df = pl.DataFrame({"Data": [10, 20, 30, 20, 15, 30, 45]})

df.write_excel(
    workbook="pandas_conditional.xlsx",
    conditional_formats={"Data": {"type": "3_color_scale"}},
)

```

---

### File: `tmp\xlsxwriter_sdist\XlsxWriter-3.2.0\examples\polars_format_custom.py`

```python
##############################################################################
#
# A simple example of converting a Polars dataframe to an xlsx file with
# custom formatting of the worksheet table.
#
# SPDX-License-Identifier: BSD-2-Clause
# Copyright 2013-2024, John McNamara, jmcnamara@cpan.org
#

from datetime import date
import polars as pl

# Create a Pandas dataframe with some sample data.
df = pl.DataFrame(
    {
        "Dates": [date(2023, 1, 1), date(2023, 1, 2), date(2023, 1, 3)],
        "Strings": ["Alice", "Bob", "Carol"],
        "Numbers": [0.12345, 100, -99.523],
    }
)

# Write the dataframe to a new Excel file with formatting options.
df.write_excel(
    workbook="polars_format_custom.xlsx",
    # Set an alternative table style.
    table_style="Table Style Medium 4",
    # See the floating point precision for reals.
    float_precision=6,
    # Set an alternative number/date format for Polar Date types.
    dtype_formats={pl.Date: "yyyy mm dd;@"},
    # Add totals to the numeric columns.
    column_totals=True,
    # Autofit the column widths.
    autofit=True,
)

```

---

### File: `tmp\xlsxwriter_sdist\XlsxWriter-3.2.0\examples\polars_format_default.py`

```python
##############################################################################
#
# A simple example of converting a Polars dataframe to an xlsx file with
# default formatting.
#
# SPDX-License-Identifier: BSD-2-Clause
# Copyright 2013-2024, John McNamara, jmcnamara@cpan.org
#

from datetime import date
import polars as pl

# Create a Pandas dataframe with some sample data.
df = pl.DataFrame(
    {
        "Dates": [date(2023, 1, 1), date(2023, 1, 2), date(2023, 1, 3)],
        "Strings": ["Alice", "Bob", "Carol"],
        "Numbers": [0.12345, 100, -99.523],
    }
)

# Write the dataframe to a new Excel file with autofit on.
df.write_excel(workbook="polars_format_default.xlsx", autofit=True)

```

---

### File: `tmp\xlsxwriter_sdist\XlsxWriter-3.2.0\examples\polars_multiple.py`

```python
##############################################################################
#
# An example of writing multiple dataframes to worksheets using Polars and
# XlsxWriter.
#
# SPDX-License-Identifier: BSD-2-Clause
# Copyright 2013-2024, John McNamara, jmcnamara@cpan.org
#

import xlsxwriter
import polars as pl

# Create some Polars dataframes from some data.
df1 = pl.DataFrame({"Data": [11, 12, 13, 14]})
df2 = pl.DataFrame({"Data": [21, 22, 23, 24]})
df3 = pl.DataFrame({"Data": [31, 32, 33, 34]})

with xlsxwriter.Workbook("polars_multiple.xlsx") as workbook:
    df1.write_excel(workbook=workbook)
    df2.write_excel(workbook=workbook)
    df3.write_excel(workbook=workbook)

```

---

### File: `tmp\xlsxwriter_sdist\XlsxWriter-3.2.0\examples\polars_positioning.py`

```python
##############################################################################
#
# An example of positioning dataframes in a worksheet using Polars and
# XlsxWriter.
#
# SPDX-License-Identifier: BSD-2-Clause
# Copyright 2013-2024, John McNamara, jmcnamara@cpan.org
#

import xlsxwriter
import polars as pl

# Create some Polars dataframes from some data.
df1 = pl.DataFrame({"Data": [11, 12, 13, 14]})
df2 = pl.DataFrame({"Data": [21, 22, 23, 24]})
df3 = pl.DataFrame({"Data": [31, 32, 33, 34]})
df4 = pl.DataFrame({"Data": [41, 42, 43, 44]})

with xlsxwriter.Workbook("polars_positioning.xlsx") as workbook:
    # Write the dataframe to the default worksheet and position: Sheet1!A1.
    df1.write_excel(workbook=workbook)

    # Write the dataframe using a cell string position.
    df2.write_excel(workbook=workbook, worksheet="Sheet1", position="C1")

    # Write the dataframe using a (row, col) tuple position.
    df3.write_excel(workbook=workbook, worksheet="Sheet1", position=(6, 0))

    # Write the dataframe without the header.
    df4.write_excel(
        workbook=workbook, worksheet="Sheet1", position="C8", has_header=False
    )

```

---

### File: `tmp\xlsxwriter_sdist\XlsxWriter-3.2.0\examples\polars_simple.py`

```python
##############################################################################
#
# A simple example of converting a Polars dataframe to an xlsx file using
# Polars and XlsxWriter.
#
# SPDX-License-Identifier: BSD-2-Clause
# Copyright 2013-2024, John McNamara, jmcnamara@cpan.org
#

import polars as pl

# Create a Pandas dataframe from some data.
df = pl.DataFrame({"Data": [10, 20, 30, 20, 15, 30, 45]})

# Write the dataframe to a new Excel file.
df.write_excel(workbook="polars_simple.xlsx")

```

---

### File: `tmp\xlsxwriter_sdist\XlsxWriter-3.2.0\examples\polars_sparklines.py`

```python
##############################################################################
#
# An example of writing multiple dataframes to worksheets using Polars and
# XlsxWriter.
#
# SPDX-License-Identifier: BSD-2-Clause
# Copyright 2013-2024, John McNamara, jmcnamara@cpan.org
#

import polars as pl
from polars.datatypes import INTEGER_DTYPES

df = pl.DataFrame(
    {
        "Zone": ["North", "South", "East", "West", "Central"],
        "Q1": [100, 55, -20, 0, 35],
        "Q2": [30, -10, 15, 60, 20],
        "Q3": [-50, 0, 40, 80, 80],
        "Q4": [75, 55, 25, -10, -55],
    }
)

# Write the dataframe with sparklines and some additional formatting.
df.write_excel(
    workbook="polars_sparklines.xlsx",
    # Set an alternative table style.
    table_style="Table Style Light 2",
    # Specify an Excel number format for integer types.
    dtype_formats={INTEGER_DTYPES: "#,##0_);(#,##0)"},
    # Configure sparklines to the dataframe.
    sparklines={
        # We use the default options with just  the source columns.
        "Trend": ["Q1", "Q2", "Q3", "Q4"],
        # We also add a customized sparkline type, with a positioning directive.
        "Change": {
            "columns": ["Q1", "Q2", "Q3", "Q4"],
            "insert_after": "Zone",
            "type": "win_loss",
        },
    },
    column_totals=["Q1", "Q2", "Q3", "Q4"],
    # Hide the default gridlines on the worksheet.
    hide_gridlines=True,
)

```

---

### File: `tmp\xlsxwriter_sdist\XlsxWriter-3.2.0\examples\polars_xlsxwriter.py`

```python
##############################################################################
#
# An example of adding a Polars dataframe to a worksheet created by XlsxWriter.
#
# SPDX-License-Identifier: BSD-2-Clause
# Copyright 2013-2024, John McNamara, jmcnamara@cpan.org
#

import xlsxwriter
import polars as pl

with xlsxwriter.Workbook("polars_xlsxwriter.xlsx") as workbook:
    # Create a new worksheet.
    worksheet = workbook.add_worksheet()

    # Do something with the worksheet.
    worksheet.write("A1", "The data below is added by Polars")

    df = pl.DataFrame({"Data": [10, 20, 30, 20, 15, 30, 45]})

    # Write the Polars data to the worksheet created above, at an offset to
    # avoid overwriting the previous text.
    df.write_excel(workbook=workbook, worksheet="Sheet1", position="A2")

```

---

### File: `tmp\xlsxwriter_sdist\XlsxWriter-3.2.0\examples\rich_strings.py`

```python
#######################################################################
#
# An example of using Python and XlsxWriter to write some "rich strings",
# i.e., strings with multiple formats.
#
# SPDX-License-Identifier: BSD-2-Clause
# Copyright 2013-2024, John McNamara, jmcnamara@cpan.org
#
import xlsxwriter

workbook = xlsxwriter.Workbook("rich_strings.xlsx")
worksheet = workbook.add_worksheet()

worksheet.set_column("A:A", 30)

# Set up some formats to use.
bold = workbook.add_format({"bold": True})
italic = workbook.add_format({"italic": True})
red = workbook.add_format({"color": "red"})
blue = workbook.add_format({"color": "blue"})
center = workbook.add_format({"align": "center"})
superscript = workbook.add_format({"font_script": 1})

# Write some strings with multiple formats.
worksheet.write_rich_string(
    "A1", "This is ", bold, "bold", " and this is ", italic, "italic"
)

worksheet.write_rich_string("A3", "This is ", red, "red", " and this is ", blue, "blue")

worksheet.write_rich_string("A5", "Some ", bold, "bold text", " centered", center)

worksheet.write_rich_string("A7", italic, "j = k", superscript, "(n-1)", center)

# If you have formats and segments in a list you can add them like this:
segments = ["This is ", bold, "bold", " and this is ", blue, "blue"]
worksheet.write_rich_string("A9", *segments)

workbook.close()

```

---

### File: `tmp\xlsxwriter_sdist\XlsxWriter-3.2.0\examples\right_to_left.py`

```python
#######################################################################
#
# Example of how to use Python and the XlsxWriter module to change the default
# worksheet and cell text direction from left-to-right to right-to-left as
# required by some middle eastern versions of Excel.
#
# SPDX-License-Identifier: BSD-2-Clause
# Copyright 2013-2024, John McNamara, jmcnamara@cpan.org
#
import xlsxwriter

workbook = xlsxwriter.Workbook("right_to_left.xlsx")

# Add two worksheets.
worksheet1 = workbook.add_worksheet()
worksheet2 = workbook.add_worksheet()

# Add the cell formats.
format_left_to_right = workbook.add_format({"reading_order": 1})
format_right_to_left = workbook.add_format({"reading_order": 2})

# Make the columns wider for clarity.
worksheet1.set_column("A:A", 25)
worksheet2.set_column("A:A", 25)

# Change the direction for worksheet2.
worksheet2.right_to_left()

# Write some data to show the difference.

# Standard direction:         | A1 | B1 | C1 | ...
worksheet1.write("A1", "  / English text")  # Default direction.
worksheet1.write("A2", "  / English text", format_left_to_right)
worksheet1.write("A3", "  / English text", format_right_to_left)

# Right to left direction:    ... | C1 | B1 | A1 |
worksheet2.write("A1", "  / English text")  # Default direction.
worksheet2.write("A2", "  / English text", format_left_to_right)
worksheet2.write("A3", "  / English text", format_right_to_left)

workbook.close()

```

---

### File: `tmp\xlsxwriter_sdist\XlsxWriter-3.2.0\examples\sparklines1.py`

```python
###############################################################################
#
# Example of how to add sparklines to a Python XlsxWriter file.
#
# Sparklines are small charts that fit in a single cell and are
# used to show trends in data.
#
# See sparklines2.py for examples of more complex sparkline formatting.
#
# SPDX-License-Identifier: BSD-2-Clause
# Copyright 2013-2024, John McNamara, jmcnamara@cpan.org
#
import xlsxwriter

workbook = xlsxwriter.Workbook("sparklines1.xlsx")
worksheet = workbook.add_worksheet()

# Some sample data to plot.
data = [
    [-2, 2, 3, -1, 0],
    [30, 20, 33, 20, 15],
    [1, -1, -1, 1, -1],
]


# Write the sample data to the worksheet.
worksheet.write_row("A1", data[0])
worksheet.write_row("A2", data[1])
worksheet.write_row("A3", data[2])


# Add a line sparkline (the default) with markers.
worksheet.add_sparkline("F1", {"range": "Sheet1!A1:E1", "markers": True})


# Add a column sparkline with non-default style.
worksheet.add_sparkline("F2", {"range": "Sheet1!A2:E2", "type": "column", "style": 12})


# Add a win/loss sparkline with negative values highlighted.
worksheet.add_sparkline(
    "F3", {"range": "Sheet1!A3:E3", "type": "win_loss", "negative_points": True}
)

workbook.close()

```

---

### File: `tmp\xlsxwriter_sdist\XlsxWriter-3.2.0\examples\sparklines2.py`

```python
###############################################################################
#
# Example of how to add sparklines to an XlsxWriter file with Python.
#
# Sparklines are small charts that fit in a single cell and are
# used to show trends in data. This example shows the majority of
# options that can be applied to sparklines.
#
# SPDX-License-Identifier: BSD-2-Clause
# Copyright 2013-2024, John McNamara, jmcnamara@cpan.org
#
import xlsxwriter

workbook = xlsxwriter.Workbook("sparklines2.xlsx")
worksheet1 = workbook.add_worksheet()
worksheet2 = workbook.add_worksheet()
bold = workbook.add_format({"bold": True})
row = 1

# Set the columns widths to make the output clearer.
worksheet1.set_column("A:A", 14)
worksheet1.set_column("B:B", 50)
worksheet1.set_zoom(150)

# Headings.
worksheet1.write("A1", "Sparkline", bold)
worksheet1.write("B1", "Description", bold)


###############################################################################
#
text = 'A default "line" sparkline.'

worksheet1.add_sparkline("A2", {"range": "Sheet2!A1:J1"})

worksheet1.write(row, 1, text)
row += 1


###############################################################################
#
text = 'A default "column" sparkline.'

worksheet1.add_sparkline("A3", {"range": "Sheet2!A2:J2", "type": "column"})

worksheet1.write(row, 1, text)
row += 1


###############################################################################
#
text = 'A default "win/loss" sparkline.'

worksheet1.add_sparkline("A4", {"range": "Sheet2!A3:J3", "type": "win_loss"})

worksheet1.write(row, 1, text)
row += 2


###############################################################################
#
text = "Line with markers."

worksheet1.add_sparkline("A6", {"range": "Sheet2!A1:J1", "markers": True})

worksheet1.write(row, 1, text)
row += 1


###############################################################################
#
text = "Line with high and low points."

worksheet1.add_sparkline(
    "A7", {"range": "Sheet2!A1:J1", "high_point": True, "low_point": True}
)

worksheet1.write(row, 1, text)
row += 1


###############################################################################
#
text = "Line with first and last point markers."

worksheet1.add_sparkline(
    "A8", {"range": "Sheet2!A1:J1", "first_point": True, "last_point": True}
)

worksheet1.write(row, 1, text)
row += 1


###############################################################################
#
text = "Line with negative point markers."

worksheet1.add_sparkline("A9", {"range": "Sheet2!A1:J1", "negative_points": True})

worksheet1.write(row, 1, text)
row += 1


###############################################################################
#
text = "Line with axis."

worksheet1.add_sparkline("A10", {"range": "Sheet2!A1:J1", "axis": True})

worksheet1.write(row, 1, text)
row += 2


###############################################################################
#
text = "Column with default style (1)."

worksheet1.add_sparkline("A12", {"range": "Sheet2!A2:J2", "type": "column"})

worksheet1.write(row, 1, text)
row += 1


###############################################################################
#
text = "Column with style 2."

worksheet1.add_sparkline("A13", {"range": "Sheet2!A2:J2", "type": "column", "style": 2})

worksheet1.write(row, 1, text)
row += 1


###############################################################################
#
text = "Column with style 3."

worksheet1.add_sparkline("A14", {"range": "Sheet2!A2:J2", "type": "column", "style": 3})

worksheet1.write(row, 1, text)
row += 1


###############################################################################
#
text = "Column with style 4."

worksheet1.add_sparkline("A15", {"range": "Sheet2!A2:J2", "type": "column", "style": 4})

worksheet1.write(row, 1, text)
row += 1


###############################################################################
#
text = "Column with style 5."

worksheet1.add_sparkline("A16", {"range": "Sheet2!A2:J2", "type": "column", "style": 5})

worksheet1.write(row, 1, text)
row += 1


###############################################################################
#
text = "Column with style 6."

worksheet1.add_sparkline("A17", {"range": "Sheet2!A2:J2", "type": "column", "style": 6})

worksheet1.write(row, 1, text)
row += 1


###############################################################################
#
text = "Column with a user defined color."

worksheet1.add_sparkline(
    "A18", {"range": "Sheet2!A2:J2", "type": "column", "series_color": "#E965E0"}
)

worksheet1.write(row, 1, text)
row += 2


###############################################################################
#
text = "A win/loss sparkline."

worksheet1.add_sparkline("A20", {"range": "Sheet2!A3:J3", "type": "win_loss"})

worksheet1.write(row, 1, text)
row += 1


###############################################################################
#
text = "A win/loss sparkline with negative points highlighted."

worksheet1.add_sparkline(
    "A21", {"range": "Sheet2!A3:J3", "type": "win_loss", "negative_points": True}
)

worksheet1.write(row, 1, text)
row += 2


###############################################################################
#
text = "A left to right column (the default)."

worksheet1.add_sparkline(
    "A23", {"range": "Sheet2!A4:J4", "type": "column", "style": 20}
)

worksheet1.write(row, 1, text)
row += 1


###############################################################################
#
text = "A right to left column."

worksheet1.add_sparkline(
    "A24", {"range": "Sheet2!A4:J4", "type": "column", "style": 20, "reverse": True}
)

worksheet1.write(row, 1, text)
row += 1


###############################################################################
#
text = "Sparkline and text in one cell."

worksheet1.add_sparkline(
    "A25", {"range": "Sheet2!A4:J4", "type": "column", "style": 20}
)

worksheet1.write(row, 0, "Growth")
worksheet1.write(row, 1, text)
row += 2


###############################################################################
#
text = "A grouped sparkline. Changes are applied to all three."

worksheet1.add_sparkline(
    "A27",
    {
        "location": ["A27", "A28", "A29"],
        "range": ["Sheet2!A5:J5", "Sheet2!A6:J6", "Sheet2!A7:J7"],
        "markers": True,
    },
)

worksheet1.write(row, 1, text)
row += 1


###############################################################################
#
# Create a second worksheet with data to plot.
#
worksheet2.set_column("A:J", 11)

data = [
    # Simple line data.
    [-2, 2, 3, -1, 0, -2, 3, 2, 1, 0],
    # Simple column data.
    [30, 20, 33, 20, 15, 5, 5, 15, 10, 15],
    # Simple win/loss data.
    [1, 1, -1, -1, 1, -1, 1, 1, 1, -1],
    # Unbalanced histogram.
    [5, 6, 7, 10, 15, 20, 30, 50, 70, 100],
    # Data for the grouped sparkline example.
    [-2, 2, 3, -1, 0, -2, 3, 2, 1, 0],
    [3, -1, 0, -2, 3, 2, 1, 0, 2, 1],
    [0, -2, 3, 2, 1, 0, 1, 2, 3, 1],
]

# Write the sample data to the worksheet.
worksheet2.write_row("A1", data[0])
worksheet2.write_row("A2", data[1])
worksheet2.write_row("A3", data[2])
worksheet2.write_row("A4", data[3])
worksheet2.write_row("A5", data[4])
worksheet2.write_row("A6", data[5])
worksheet2.write_row("A7", data[6])

workbook.close()

```

---

### File: `tmp\xlsxwriter_sdist\XlsxWriter-3.2.0\examples\tab_colors.py`

```python
#######################################################################
#
# Example of how to set Excel worksheet tab colors using Python
# and the XlsxWriter module.
#
# SPDX-License-Identifier: BSD-2-Clause
# Copyright 2013-2024, John McNamara, jmcnamara@cpan.org
#
import xlsxwriter

workbook = xlsxwriter.Workbook("tab_colors.xlsx")

# Set up some worksheets.
worksheet1 = workbook.add_worksheet()
worksheet2 = workbook.add_worksheet()
worksheet3 = workbook.add_worksheet()
worksheet4 = workbook.add_worksheet()

# Set tab colors
worksheet1.set_tab_color("red")
worksheet2.set_tab_color("green")
worksheet3.set_tab_color("#FF9900")  # Orange

# worksheet4 will have the default color.

workbook.close()

```

---

### File: `tmp\xlsxwriter_sdist\XlsxWriter-3.2.0\examples\tables.py`

```python
###############################################################################
#
# Example of how to add tables to an XlsxWriter worksheet.
#
# Tables in Excel are used to group rows and columns of data into a single
# structure that can be referenced in a formula or formatted collectively.
#
# SPDX-License-Identifier: BSD-2-Clause
# Copyright 2013-2024, John McNamara, jmcnamara@cpan.org
#
import xlsxwriter

workbook = xlsxwriter.Workbook("tables.xlsx")
worksheet1 = workbook.add_worksheet()
worksheet2 = workbook.add_worksheet()
worksheet3 = workbook.add_worksheet()
worksheet4 = workbook.add_worksheet()
worksheet5 = workbook.add_worksheet()
worksheet6 = workbook.add_worksheet()
worksheet7 = workbook.add_worksheet()
worksheet8 = workbook.add_worksheet()
worksheet9 = workbook.add_worksheet()
worksheet10 = workbook.add_worksheet()
worksheet11 = workbook.add_worksheet()
worksheet12 = workbook.add_worksheet()
worksheet13 = workbook.add_worksheet()

currency_format = workbook.add_format({"num_format": "$#,##0"})

# Some sample data for the table.
data = [
    ["Apples", 10000, 5000, 8000, 6000],
    ["Pears", 2000, 3000, 4000, 5000],
    ["Bananas", 6000, 6000, 6500, 6000],
    ["Oranges", 500, 300, 200, 700],
]


###############################################################################
#
# Example 1.
#
caption = "Default table with no data."

# Set the columns widths.
worksheet1.set_column("B:G", 12)

# Write the caption.
worksheet1.write("B1", caption)

# Add a table to the worksheet.
worksheet1.add_table("B3:F7")


###############################################################################
#
# Example 2.
#
caption = "Default table with data."

# Set the columns widths.
worksheet2.set_column("B:G", 12)

# Write the caption.
worksheet2.write("B1", caption)

# Add a table to the worksheet.
worksheet2.add_table("B3:F7", {"data": data})


###############################################################################
#
# Example 3.
#
caption = "Table without default autofilter."

# Set the columns widths.
worksheet3.set_column("B:G", 12)

# Write the caption.
worksheet3.write("B1", caption)

# Add a table to the worksheet.
worksheet3.add_table("B3:F7", {"autofilter": 0})

# Table data can also be written separately, as an array or individual cells.
worksheet3.write_row("B4", data[0])
worksheet3.write_row("B5", data[1])
worksheet3.write_row("B6", data[2])
worksheet3.write_row("B7", data[3])


###############################################################################
#
# Example 4.
#
caption = "Table without default header row."

# Set the columns widths.
worksheet4.set_column("B:G", 12)

# Write the caption.
worksheet4.write("B1", caption)

# Add a table to the worksheet.
worksheet4.add_table("B4:F7", {"header_row": 0})

# Table data can also be written separately, as an array or individual cells.
worksheet4.write_row("B4", data[0])
worksheet4.write_row("B5", data[1])
worksheet4.write_row("B6", data[2])
worksheet4.write_row("B7", data[3])


###############################################################################
#
# Example 5.
#
caption = 'Default table with "First Column" and "Last Column" options.'

# Set the columns widths.
worksheet5.set_column("B:G", 12)

# Write the caption.
worksheet5.write("B1", caption)

# Add a table to the worksheet.
worksheet5.add_table("B3:F7", {"first_column": 1, "last_column": 1})

# Table data can also be written separately, as an array or individual cells.
worksheet5.write_row("B4", data[0])
worksheet5.write_row("B5", data[1])
worksheet5.write_row("B6", data[2])
worksheet5.write_row("B7", data[3])


###############################################################################
#
# Example 6.
#
caption = "Table with banded columns but without default banded rows."

# Set the columns widths.
worksheet6.set_column("B:G", 12)

# Write the caption.
worksheet6.write("B1", caption)

# Add a table to the worksheet.
worksheet6.add_table("B3:F7", {"banded_rows": 0, "banded_columns": 1})

# Table data can also be written separately, as an array or individual cells.
worksheet6.write_row("B4", data[0])
worksheet6.write_row("B5", data[1])
worksheet6.write_row("B6", data[2])
worksheet6.write_row("B7", data[3])


###############################################################################
#
# Example 7.
#
caption = "Table with user defined column headers."

# Set the columns widths.
worksheet7.set_column("B:G", 12)

# Write the caption.
worksheet7.write("B1", caption)

# Add a table to the worksheet.
worksheet7.add_table(
    "B3:F7",
    {
        "data": data,
        "columns": [
            {"header": "Product"},
            {"header": "Quarter 1"},
            {"header": "Quarter 2"},
            {"header": "Quarter 3"},
            {"header": "Quarter 4"},
        ],
    },
)


###############################################################################
#
# Example 8.
#
caption = "Table with user defined column headers."

# Set the columns widths.
worksheet8.set_column("B:G", 12)

# Write the caption.
worksheet8.write("B1", caption)

# Formula to use in the table.
formula = "=SUM(Table8[@[Quarter 1]:[Quarter 4]])"

# Add a table to the worksheet.
worksheet8.add_table(
    "B3:G7",
    {
        "data": data,
        "columns": [
            {"header": "Product"},
            {"header": "Quarter 1"},
            {"header": "Quarter 2"},
            {"header": "Quarter 3"},
            {"header": "Quarter 4"},
            {"header": "Year", "formula": formula},
        ],
    },
)


###############################################################################
#
# Example 9.
#
caption = "Table with totals row (but no caption or totals)."

# Set the columns widths.
worksheet9.set_column("B:G", 12)

# Write the caption.
worksheet9.write("B1", caption)

# Formula to use in the table.
formula = "=SUM(Table9[@[Quarter 1]:[Quarter 4]])"

# Add a table to the worksheet.
worksheet9.add_table(
    "B3:G8",
    {
        "data": data,
        "total_row": 1,
        "columns": [
            {"header": "Product"},
            {"header": "Quarter 1"},
            {"header": "Quarter 2"},
            {"header": "Quarter 3"},
            {"header": "Quarter 4"},
            {"header": "Year", "formula": formula},
        ],
    },
)


###############################################################################
#
# Example 10.
#
caption = "Table with totals row with user captions and functions."

# Set the columns widths.
worksheet10.set_column("B:G", 12)

# Write the caption.
worksheet10.write("B1", caption)

# Options to use in the table.
options = {
    "data": data,
    "total_row": 1,
    "columns": [
        {"header": "Product", "total_string": "Totals"},
        {"header": "Quarter 1", "total_function": "sum"},
        {"header": "Quarter 2", "total_function": "sum"},
        {"header": "Quarter 3", "total_function": "sum"},
        {"header": "Quarter 4", "total_function": "sum"},
        {
            "header": "Year",
            "formula": "=SUM(Table10[@[Quarter 1]:[Quarter 4]])",
            "total_function": "sum",
        },
    ],
}

# Add a table to the worksheet.
worksheet10.add_table("B3:G8", options)


###############################################################################
#
# Example 11.
#
caption = "Table with alternative Excel style."

# Set the columns widths.
worksheet11.set_column("B:G", 12)

# Write the caption.
worksheet11.write("B1", caption)

# Options to use in the table.
options = {
    "data": data,
    "style": "Table Style Light 11",
    "total_row": 1,
    "columns": [
        {"header": "Product", "total_string": "Totals"},
        {"header": "Quarter 1", "total_function": "sum"},
        {"header": "Quarter 2", "total_function": "sum"},
        {"header": "Quarter 3", "total_function": "sum"},
        {"header": "Quarter 4", "total_function": "sum"},
        {
            "header": "Year",
            "formula": "=SUM(Table11[@[Quarter 1]:[Quarter 4]])",
            "total_function": "sum",
        },
    ],
}


# Add a table to the worksheet.
worksheet11.add_table("B3:G8", options)


###############################################################################
#
# Example 12.
#
caption = "Table with Excel style removed."

# Set the columns widths.
worksheet12.set_column("B:G", 12)

# Write the caption.
worksheet12.write("B1", caption)

# Options to use in the table.
options = {
    "data": data,
    "style": None,
    "total_row": 1,
    "columns": [
        {"header": "Product", "total_string": "Totals"},
        {"header": "Quarter 1", "total_function": "sum"},
        {"header": "Quarter 2", "total_function": "sum"},
        {"header": "Quarter 3", "total_function": "sum"},
        {"header": "Quarter 4", "total_function": "sum"},
        {
            "header": "Year",
            "formula": "=SUM(Table12[@[Quarter 1]:[Quarter 4]])",
            "total_function": "sum",
        },
    ],
}


# Add a table to the worksheet.
worksheet12.add_table("B3:G8", options)


###############################################################################
#
# Example 13.
#
caption = "Table with column formats."

# Set the columns widths.
worksheet13.set_column("B:G", 12)

# Write the caption.
worksheet13.write("B1", caption)

# Options to use in the table.
options = {
    "data": data,
    "total_row": 1,
    "columns": [
        {"header": "Product", "total_string": "Totals"},
        {
            "header": "Quarter 1",
            "total_function": "sum",
            "format": currency_format,
        },
        {
            "header": "Quarter 2",
            "total_function": "sum",
            "format": currency_format,
        },
        {
            "header": "Quarter 3",
            "total_function": "sum",
            "format": currency_format,
        },
        {
            "header": "Quarter 4",
            "total_function": "sum",
            "format": currency_format,
        },
        {
            "header": "Year",
            "formula": "=SUM(Table13[@[Quarter 1]:[Quarter 4]])",
            "total_function": "sum",
            "format": currency_format,
        },
    ],
}

# Add a table to the worksheet.
worksheet13.add_table("B3:G8", options)

workbook.close()

```

---

### File: `tmp\xlsxwriter_sdist\XlsxWriter-3.2.0\examples\text_indent.py`

```python
##############################################################################
#
# A simple formatting example using XlsxWriter.
#
# This program demonstrates the indentation cell format.
#
# SPDX-License-Identifier: BSD-2-Clause
# Copyright 2013-2024, John McNamara, jmcnamara@cpan.org
#
import xlsxwriter

workbook = xlsxwriter.Workbook("text_indent.xlsx")

worksheet = workbook.add_worksheet()
indent1 = workbook.add_format({"indent": 1})
indent2 = workbook.add_format({"indent": 2})

worksheet.set_column("A:A", 40)

worksheet.write("A1", "This text is indented 1 level", indent1)
worksheet.write("A2", "This text is indented 2 levels", indent2)

workbook.close()

```

---

### File: `tmp\xlsxwriter_sdist\XlsxWriter-3.2.0\examples\textbox.py`

```python
#######################################################################
#
# An example of inserting textboxes into an Excel worksheet using
# Python and XlsxWriter.
#
# SPDX-License-Identifier: BSD-2-Clause
# Copyright 2013-2024, John McNamara, jmcnamara@cpan.org
#
import xlsxwriter

workbook = xlsxwriter.Workbook("textbox.xlsx")
worksheet = workbook.add_worksheet()
row = 4
col = 1

# The examples below show different textbox options and formatting. In each
# example the text describes the formatting.


# Example
text = "A simple textbox with some text"
worksheet.insert_textbox(row, col, text)
row += 10

# Example
text = "A textbox with changed dimensions"
options = {
    "width": 256,
    "height": 100,
}
worksheet.insert_textbox(row, col, text, options)
row += 10

# Example
text = "A textbox with an offset in the cell"
options = {
    "x_offset": 10,
    "y_offset": 10,
}
worksheet.insert_textbox(row, col, text, options)
row += 10

# Example
text = "A textbox with scaling"
options = {
    "x_scale": 1.5,
    "y_scale": 0.8,
}
worksheet.insert_textbox(row, col, text, options)
row += 10

# Example
text = "A textbox with some long text that wraps around onto several lines"
worksheet.insert_textbox(row, col, text)
row += 10

# Example
text = "A textbox\nwith some\nnewlines\n\nand paragraphs"
worksheet.insert_textbox(row, col, text)
row += 10

# Example
text = "A textbox with a solid fill background"
options = {
    "fill": {"color": "red"},
}
worksheet.insert_textbox(row, col, text, options)
row += 10

# Example
text = "A textbox with a no fill background"
options = {
    "fill": {"none": True},
}
worksheet.insert_textbox(row, col, text, options)
row += 10

# Example
text = "A textbox with a gradient fill background"
options = {
    "gradient": {"colors": ["#DDEBCF", "#9CB86E", "#156B13"]},
}
worksheet.insert_textbox(row, col, text, options)
row += 10

# Example
text = "A textbox with a user defined border line"
options = {
    "border": {"color": "red", "width": 3, "dash_type": "round_dot"},
}
worksheet.insert_textbox(row, col, text, options)
row += 10

# Example
text = "A textbox with no border line"
options = {
    "border": {"none": True},
}
worksheet.insert_textbox(row, col, text, options)
row += 10

# Example
text = "Default alignment: top - left"
worksheet.insert_textbox(row, col, text)
row += 10

# Example
text = "Alignment: top - center"
options = {
    "align": {"horizontal": "center"},
}
worksheet.insert_textbox(row, col, text, options)
row += 10

# Example
text = "Alignment: middle - center"
options = {
    "align": {"vertical": "middle", "horizontal": "center"},
}
worksheet.insert_textbox(row, col, text, options)
row += 10

# Example
text = "Alignment: long text line that wraps and is centered"
options = {
    "align": {"vertical": "middle", "horizontal": "center", "text": "center"},
}
worksheet.insert_textbox(row, col, text, options)
row += 10

# Example
text = "Font properties: bold"
options = {
    "font": {"bold": True},
}
worksheet.insert_textbox(row, col, text, options)
row += 10

# Example
text = "Font properties: various"
options = {
    "font": {"bold": True},
}
worksheet.insert_textbox(row, col, text, options)
row += 10

# Example
text = "Font properties: various"
options = {
    "font": {
        "bold": True,
        "italic": True,
        "underline": True,
        "name": "Arial",
        "color": "red",
        "size": 12,
    }
}
worksheet.insert_textbox(row, col, text, options)
row += 10

# Example
text = "Some text in a textbox with formatting"
options = {
    "font": {"color": "white"},
    "align": {"vertical": "middle", "horizontal": "center"},
    "gradient": {"colors": ["red", "blue"]},
}
worksheet.insert_textbox(row, col, text, options)
row += 10

# Example
text = ""
options = {
    "textlink": "=$F$185",
}
worksheet.write("F185", "Text in a cell")
worksheet.insert_textbox(row, col, text, options)
row += 10

# Example
text = "Text rotated up"
options = {"text_rotation": 90}
worksheet.insert_textbox(row, col, text, options)
row += 10

# Example
text = "Text rotated down"
options = {"text_rotation": -90}
worksheet.insert_textbox(row, col, text, options)
row += 10

# Example
text = "Text rotated vertically"
options = {"text_rotation": 270}
worksheet.insert_textbox(row, col, text, options)
row += 10

# Example
text = "Textbox with hyperlink"
options = {"url": "https://github.com/jmcnamara", "tip": "GitHub"}
worksheet.insert_textbox(row, col, text, options)
row += 10

workbook.close()

```

---

### File: `tmp\xlsxwriter_sdist\XlsxWriter-3.2.0\examples\tutorial1.py`

```python
##############################################################################
#
# A simple program to write some data to an Excel file using the XlsxWriter
# Python module.
#
# This program is shown, with explanations, in Tutorial 1 of the XlsxWriter
# documentation.
#
# SPDX-License-Identifier: BSD-2-Clause
# Copyright 2013-2024, John McNamara, jmcnamara@cpan.org
#
import xlsxwriter

# Create a workbook and add a worksheet.
workbook = xlsxwriter.Workbook("Expenses01.xlsx")
worksheet = workbook.add_worksheet()

# Some data we want to write to the worksheet.
expenses = (
    ["Rent", 1000],
    ["Gas", 100],
    ["Food", 300],
    ["Gym", 50],
)

# Start from the first cell. Rows and columns are zero indexed.
row = 0
col = 0

# Iterate over the data and write it out row by row.
for item, cost in expenses:
    worksheet.write(row, col, item)
    worksheet.write(row, col + 1, cost)
    row += 1

# Write a total using a formula.
worksheet.write(row, 0, "Total")
worksheet.write(row, 1, "=SUM(B1:B4)")

workbook.close()

```

---

### File: `tmp\xlsxwriter_sdist\XlsxWriter-3.2.0\examples\tutorial2.py`

```python
##############################################################################
#
# A simple program to write some data to an Excel file using the XlsxWriter
# Python module.
#
# This program is shown, with explanations, in Tutorial 2 of the XlsxWriter
# documentation.
#
# SPDX-License-Identifier: BSD-2-Clause
# Copyright 2013-2024, John McNamara, jmcnamara@cpan.org
#
import xlsxwriter

# Create a workbook and add a worksheet.
workbook = xlsxwriter.Workbook("Expenses02.xlsx")
worksheet = workbook.add_worksheet()

# Add a bold format to use to highlight cells.
bold = workbook.add_format({"bold": True})

# Add a number format for cells with money.
money = workbook.add_format({"num_format": "$#,##0"})

# Write some data header.
worksheet.write("A1", "Item", bold)
worksheet.write("B1", "Cost", bold)

# Some data we want to write to the worksheet.
expenses = (
    ["Rent", 1000],
    ["Gas", 100],
    ["Food", 300],
    ["Gym", 50],
)

# Start from the first cell below the headers.
row = 1
col = 0

# Iterate over the data and write it out row by row.
for item, cost in expenses:
    worksheet.write(row, col, item)
    worksheet.write(row, col + 1, cost, money)
    row += 1

# Write a total using a formula.
worksheet.write(row, 0, "Total", bold)
worksheet.write(row, 1, "=SUM(B2:B5)", money)

workbook.close()

```

---

### File: `tmp\xlsxwriter_sdist\XlsxWriter-3.2.0\examples\tutorial3.py`

```python
##############################################################################
#
# A simple program to write some data to an Excel file using the XlsxWriter
# Python module.
#
# This program is shown, with explanations, in Tutorial 3 of the XlsxWriter
# documentation.
#
# SPDX-License-Identifier: BSD-2-Clause
# Copyright 2013-2024, John McNamara, jmcnamara@cpan.org
#
from datetime import datetime
import xlsxwriter

# Create a workbook and add a worksheet.
workbook = xlsxwriter.Workbook("Expenses03.xlsx")
worksheet = workbook.add_worksheet()

# Add a bold format to use to highlight cells.
bold = workbook.add_format({"bold": 1})

# Add a number format for cells with money.
money_format = workbook.add_format({"num_format": "$#,##0"})

# Add an Excel date format.
date_format = workbook.add_format({"num_format": "mmmm d yyyy"})

# Adjust the column width.
worksheet.set_column(1, 1, 15)

# Write some data headers.
worksheet.write("A1", "Item", bold)
worksheet.write("B1", "Date", bold)
worksheet.write("C1", "Cost", bold)

# Some data we want to write to the worksheet.
expenses = (
    ["Rent", "2013-01-13", 1000],
    ["Gas", "2013-01-14", 100],
    ["Food", "2013-01-16", 300],
    ["Gym", "2013-01-20", 50],
)

# Start from the first cell below the headers.
row = 1
col = 0

for item, date_str, cost in expenses:
    # Convert the date string into a datetime object.
    date = datetime.strptime(date_str, "%Y-%m-%d")

    worksheet.write_string(row, col, item)
    worksheet.write_datetime(row, col + 1, date, date_format)
    worksheet.write_number(row, col + 2, cost, money_format)
    row += 1

# Write a total using a formula.
worksheet.write(row, 0, "Total", bold)
worksheet.write(row, 2, "=SUM(C2:C5)", money_format)

workbook.close()

```

---

### File: `tmp\xlsxwriter_sdist\XlsxWriter-3.2.0\examples\unicode.py`

```python
###############################################################################
#
# A simple Unicode spreadsheet in Python 3 using the XlsxWriter Python module.
#
# SPDX-License-Identifier: BSD-2-Clause
# Copyright 2013-2024, John McNamara, jmcnamara@cpan.org
#

# To write Unicode text in UTF-8 to a xlsxwriter file in Python 3 you just
# need to encode the file as UTF-8.
import xlsxwriter

workbook = xlsxwriter.Workbook("unicode_python3.xlsx")
worksheet = workbook.add_worksheet()

worksheet.write("B3", "   !")

workbook.close()

```

---

### File: `tmp\xlsxwriter_sdist\XlsxWriter-3.2.0\examples\unicode_polish_utf8.py`

```python
##############################################################################
#
# A simple example of converting some Unicode text to an Excel file using
# the XlsxWriter Python module.
#
# This example generates a spreadsheet with some Polish text from a file
# with UTF8 encoded text.
#
# SPDX-License-Identifier: BSD-2-Clause
# Copyright 2013-2024, John McNamara, jmcnamara@cpan.org
#
import xlsxwriter

# Open the input file with the correct encoding.
textfile = open("unicode_polish_utf8.txt", mode="r", encoding="utf-8")

# Create an new Excel file and convert the text data.
workbook = xlsxwriter.Workbook("unicode_polish_utf8.xlsx")
worksheet = workbook.add_worksheet()

# Widen the first column to make the text clearer.
worksheet.set_column("A:A", 50)

# Start from the first cell.
row = 0
col = 0

# Read the text file and write it to the worksheet.
for line in textfile:
    # Ignore the comments in the text file.
    if line.startswith("#"):
        continue

    # Write any other lines to the worksheet.
    worksheet.write(row, col, line.rstrip("\n"))
    row += 1

workbook.close()

```

---

### File: `tmp\xlsxwriter_sdist\XlsxWriter-3.2.0\examples\unicode_shift_jis.py`

```python
##############################################################################
#
# A simple example of converting some Unicode text to an Excel file using
# the XlsxWriter Python module.
#
# This example generates a spreadsheet with some Japanese text from a file
# with Shift-JIS encoded text.
#
# SPDX-License-Identifier: BSD-2-Clause
# Copyright 2013-2024, John McNamara, jmcnamara@cpan.org
#
import xlsxwriter

# Open the input file with the correct encoding.
textfile = open("unicode_shift_jis.txt", mode="r", encoding="shift_jis")

# Create an new Excel file and convert the text data.
workbook = xlsxwriter.Workbook("unicode_shift_jis.xlsx")
worksheet = workbook.add_worksheet()

# Widen the first column to make the text clearer.
worksheet.set_column("A:A", 50)

# Start from the first cell.
row = 0
col = 0

# Read the text file and write it to the worksheet.
for line in textfile:
    # Ignore the comments in the text file.
    if line.startswith("#"):
        continue

    # Write any other lines to the worksheet.
    worksheet.write(row, col, line.rstrip("\n"))
    row += 1

workbook.close()

```

---

### File: `tmp\xlsxwriter_sdist\XlsxWriter-3.2.0\examples\user_types1.py`

```python
##############################################################################
#
# An example of adding support for user defined types to the XlsxWriter write()
# method.
#
# SPDX-License-Identifier: BSD-2-Clause
# Copyright 2013-2024, John McNamara, jmcnamara@cpan.org
#
import xlsxwriter
import uuid


# Create a function that will behave like a worksheet write() method.
#
# This function takes a UUID and writes it as as string. It should take the
# parameters shown below and return the return value from the called worksheet
# write_*() method. In this case it changes the UUID to a string and calls
# write_string() to write it.
#
def write_uuid(worksheet, row, col, token, format=None):
    return worksheet.write_string(row, col, str(token), format)


# Set up the workbook as usual.
workbook = xlsxwriter.Workbook("user_types1.xlsx")
worksheet = workbook.add_worksheet()

# Make the first column wider for clarity.
worksheet.set_column("A:A", 40)

# Add the write() handler/callback to the worksheet.
worksheet.add_write_handler(uuid.UUID, write_uuid)

# Create a UUID.
my_uuid = uuid.uuid3(uuid.NAMESPACE_DNS, "python.org")

# Write the UUID. This would raise a TypeError without the handler.
worksheet.write("A1", my_uuid)

workbook.close()

```

---

### File: `tmp\xlsxwriter_sdist\XlsxWriter-3.2.0\examples\user_types2.py`

```python
##############################################################################
#
# An example of adding support for user defined types to the XlsxWriter write()
# method.
#
# SPDX-License-Identifier: BSD-2-Clause
# Copyright 2013-2024, John McNamara, jmcnamara@cpan.org
#
import xlsxwriter
import math


# Create a function that will behave like a worksheet write() method.
#
# This function takes a float and if it is NaN then it writes a blank cell
# instead. It should take the parameters shown below and return the return
# value from the called worksheet write_*() method.
#
def ignore_nan(worksheet, row, col, number, format=None):
    if math.isnan(number):
        return worksheet.write_blank(row, col, None, format)
    else:
        # Return control to the calling write() method for any other number.
        return None


# Set up the workbook as usual.
workbook = xlsxwriter.Workbook("user_types2.xlsx")
worksheet = workbook.add_worksheet()


# Add the write() handler/callback to the worksheet.
worksheet.add_write_handler(float, ignore_nan)

# Create some data to write.
my_data = [1, 2, float("nan"), 4, 5]

# Write the data. Note that write_row() calls write() so this will work as
# expected. Writing NaN values would raise a TypeError without the handler.
worksheet.write_row("A1", my_data)

workbook.close()

```

---

### File: `tmp\xlsxwriter_sdist\XlsxWriter-3.2.0\examples\user_types3.py`

```python
##############################################################################
#
# An example of adding support for user defined types to the XlsxWriter write()
# method.
#
# SPDX-License-Identifier: BSD-2-Clause
# Copyright 2013-2024, John McNamara, jmcnamara@cpan.org
#
import xlsxwriter


# Create a function that changes the worksheet write() method so that it
# hides/replaces user passwords when writing string data. The password data,
# based on the sample data structure, will be data in the second column, apart
# from the header row.
def hide_password(worksheet, row, col, string, format=None):
    if col == 1 and row > 0:
        return worksheet.write_string(row, col, "****", format)
    else:
        return worksheet.write_string(row, col, string, format)


# Set up the workbook as usual.
workbook = xlsxwriter.Workbook("user_types3.xlsx")
worksheet = workbook.add_worksheet()

# Make the headings in the first row bold.
bold = workbook.add_format({"bold": True})
worksheet.set_row(0, None, bold)

# Add the write() handler/callback to the worksheet.
worksheet.add_write_handler(str, hide_password)

# Create some data to write.
my_data = [
    ["Name", "Password", "City"],
    ["Sara", "$5%^6&", "Rome"],
    ["Michele", "123abc", "Milano"],
    ["Maria", "juvexme", "Torino"],
    ["Paolo", "qwerty", "Fano"],
]

# Write the data. Note that write_row() calls write() so this will work as
# expected.
for row_num, row_data in enumerate(my_data):
    worksheet.write_row(row_num, 0, row_data)

workbook.close()

```

---

### File: `tmp\xlsxwriter_sdist\XlsxWriter-3.2.0\examples\vba_extract.py`

```python
#!python

##############################################################################
#
# vba_extract - A simple utility to extract a vbaProject.bin binary from an
# Excel 2007+ xlsm file for insertion into an XlsxWriter file.
#
# SPDX-License-Identifier: BSD-2-Clause
# Copyright 2013-2024, John McNamara, jmcnamara@cpan.org
#
import sys
from zipfile import ZipFile
from zipfile import BadZipFile


def extract_file(xlsm_zip, filename):
    # Extract a single file from an Excel xlsm macro file.
    data = xlsm_zip.read("xl/" + filename)

    # Write the data to a local file.
    file = open(filename, "wb")
    file.write(data)
    file.close()


# The VBA project file and project signature file we want to extract.
vba_filename = "vbaProject.bin"
vba_signature_filename = "vbaProjectSignature.bin"

# Get the xlsm file name from the commandline.
if len(sys.argv) > 1:
    xlsm_file = sys.argv[1]
else:
    print(
        "\nUtility to extract a vbaProject.bin binary from an Excel 2007+ "
        "xlsm macro file for insertion into an XlsxWriter file.\n"
        "If the macros are digitally signed, extracts also a vbaProjectSignature.bin "
        "file.\n"
        "\n"
        "See: https://xlsxwriter.readthedocs.io/working_with_macros.html\n"
        "\n"
        "Usage: vba_extract file.xlsm\n"
    )
    exit()

try:
    # Open the Excel xlsm file as a zip file.
    xlsm_zip = ZipFile(xlsm_file, "r")

    # Read the xl/vbaProject.bin file.
    extract_file(xlsm_zip, vba_filename)
    print("Extracted: %s" % vba_filename)

    if "xl/" + vba_signature_filename in xlsm_zip.namelist():
        extract_file(xlsm_zip, vba_signature_filename)
        print("Extracted: %s" % vba_signature_filename)


except IOError as e:
    print("File error: %s" % str(e))
    exit()

except KeyError as e:
    # Usually when there isn't a xl/vbaProject.bin member in the file.
    print("File error: %s" % str(e))
    print("File may not be an Excel xlsm macro file: '%s'" % xlsm_file)
    exit()

except BadZipFile as e:
    # Usually if the file is an xls file and not an xlsm file.
    print("File error: %s: '%s'" % (str(e), xlsm_file))
    print("File may not be an Excel xlsm macro file.")
    exit()

except Exception as e:
    # Catch any other exceptions.
    print("File error: %s" % str(e))
    exit()

```

---

### File: `tmp\xlsxwriter_sdist\XlsxWriter-3.2.0\examples\watermark.py`

```python
##############################################################################
#
# An example of adding a worksheet watermark image using the XlsxWriter Python
# module. This is based on the method of putting an image in the worksheet
# header as suggested in the Microsoft documentation:
# https://support.microsoft.com/en-us/office/add-a-watermark-in-excel-a372182a-d733-484e-825c-18ddf3edf009
#
# SPDX-License-Identifier: BSD-2-Clause
# Copyright 2013-2024, John McNamara, jmcnamara@cpan.org
#
import xlsxwriter

workbook = xlsxwriter.Workbook("watermark.xlsx")
worksheet = workbook.add_worksheet()

# Set a worksheet header with the watermark image.
worksheet.set_header("&C&[Picture]", {"image_center": "watermark.png"})

workbook.close()

```

---

### File: `tmp\xlsxwriter_sdist\XlsxWriter-3.2.0\examples\worksheet_protection.py`

```python
########################################################################
#
# Example of cell locking and formula hiding in an Excel worksheet
# using Python and the XlsxWriter module.
#
# SPDX-License-Identifier: BSD-2-Clause
# Copyright 2013-2024, John McNamara, jmcnamara@cpan.org
#
import xlsxwriter

workbook = xlsxwriter.Workbook("protection.xlsx")
worksheet = workbook.add_worksheet()

# Create some cell formats with protection properties.
unlocked = workbook.add_format({"locked": False})
hidden = workbook.add_format({"hidden": True})

# Format the columns to make the text more visible.
worksheet.set_column("A:A", 40)

# Turn worksheet protection on.
worksheet.protect()

# Write a locked, unlocked and hidden cell.
worksheet.write("A1", "Cell B1 is locked. It cannot be edited.")
worksheet.write("A2", "Cell B2 is unlocked. It can be edited.")
worksheet.write("A3", "Cell B3 is hidden. The formula isn't visible.")

worksheet.write_formula("B1", "=1+2")  # Locked by default.
worksheet.write_formula("B2", "=1+2", unlocked)
worksheet.write_formula("B3", "=1+2", hidden)

workbook.close()

```

---

### File: `tmp\xlsxwriter_sdist\XlsxWriter-3.2.0\setup.py`

```python
import sys
import subprocess
from warnings import warn

try:
    from setuptools import setup, Command
except ImportError:
    from distutils.core import setup, Command

if sys.version_info < (3, 6):
    warn("The minimum Python version supported by XlsxWriter is 3.6")
    exit()


class PyTest(Command):

    user_options = []

    def initialize_options(self):
        pass

    def finalize_options(self):
        pass

    def run(self):
        errno = subprocess.call(['python',  '-m', 'unittest', 'discover'])
        raise SystemExit(errno)

setup(
    name='XlsxWriter',
    version='3.2.0',
    author='John McNamara',
    author_email='jmcnamara@cpan.org',
    url='https://github.com/jmcnamara/XlsxWriter',
    packages=['xlsxwriter'],
    scripts=['examples/vba_extract.py'],
    cmdclass={'test': PyTest},
    license='BSD-2-Clause',
    description='A Python module for creating Excel XLSX files.',
    long_description=open('README.rst').read(),
    classifiers=[
        'Development Status :: 5 - Production/Stable',
        'License :: OSI Approved :: BSD License',
        'Programming Language :: Python',
        'Programming Language :: Python :: 3 :: Only',
        'Programming Language :: Python :: 3',
        'Programming Language :: Python :: 3.6',
        'Programming Language :: Python :: 3.7',
        'Programming Language :: Python :: 3.8',
        'Programming Language :: Python :: 3.9',
        'Programming Language :: Python :: 3.10',
        'Programming Language :: Python :: 3.11',
        'Programming Language :: Python :: 3.12',
    ],
    python_requires='>=3.6',
)

```

---

### File: `tmp\xlsxwriter_sdist\XlsxWriter-3.2.0\xlsxwriter\__init__.py`

```python
#
# SPDX-License-Identifier: BSD-2-Clause
# Copyright 2013-2024, John McNamara, jmcnamara@cpan.org
#
__version__ = "3.2.0"
__VERSION__ = __version__
from .workbook import Workbook  # noqa

```

---

### File: `tmp\xlsxwriter_sdist\XlsxWriter-3.2.0\xlsxwriter\app.py`

```python
###############################################################################
#
# App - A class for writing the Excel XLSX App file.
#
# SPDX-License-Identifier: BSD-2-Clause
# Copyright 2013-2024, John McNamara, jmcnamara@cpan.org
#

# Package imports.
from . import xmlwriter


class App(xmlwriter.XMLwriter):
    """
    A class for writing the Excel XLSX App file.


    """

    ###########################################################################
    #
    # Public API.
    #
    ###########################################################################

    def __init__(self):
        """
        Constructor.

        """

        super(App, self).__init__()

        self.part_names = []
        self.heading_pairs = []
        self.properties = {}
        self.doc_security = 0

    def _add_part_name(self, part_name):
        # Add the name of a workbook Part such as 'Sheet1' or 'Print_Titles'.
        self.part_names.append(part_name)

    def _add_heading_pair(self, heading_pair):
        # Add the name of a workbook Heading Pair such as 'Worksheets',
        # 'Charts' or 'Named Ranges'.

        # Ignore empty pairs such as chartsheets.
        if not heading_pair[1]:
            return

        self.heading_pairs.append(("lpstr", heading_pair[0]))
        self.heading_pairs.append(("i4", heading_pair[1]))

    def _set_properties(self, properties):
        # Set the document properties.
        self.properties = properties

    ###########################################################################
    #
    # Private API.
    #
    ###########################################################################

    def _assemble_xml_file(self):
        # Assemble and write the XML file.

        # Write the XML declaration.
        self._xml_declaration()

        self._write_properties()
        self._write_application()
        self._write_doc_security()
        self._write_scale_crop()
        self._write_heading_pairs()
        self._write_titles_of_parts()
        self._write_manager()
        self._write_company()
        self._write_links_up_to_date()
        self._write_shared_doc()
        self._write_hyperlink_base()
        self._write_hyperlinks_changed()
        self._write_app_version()

        self._xml_end_tag("Properties")

        # Close the file.
        self._xml_close()

    ###########################################################################
    #
    # XML methods.
    #
    ###########################################################################

    def _write_properties(self):
        # Write the <Properties> element.
        schema = "http://schemas.openxmlformats.org/officeDocument/2006/"
        xmlns = schema + "extended-properties"
        xmlns_vt = schema + "docPropsVTypes"

        attributes = [
            ("xmlns", xmlns),
            ("xmlns:vt", xmlns_vt),
        ]

        self._xml_start_tag("Properties", attributes)

    def _write_application(self):
        # Write the <Application> element.
        self._xml_data_element("Application", "Microsoft Excel")

    def _write_doc_security(self):
        # Write the <DocSecurity> element.
        self._xml_data_element("DocSecurity", self.doc_security)

    def _write_scale_crop(self):
        # Write the <ScaleCrop> element.
        self._xml_data_element("ScaleCrop", "false")

    def _write_heading_pairs(self):
        # Write the <HeadingPairs> element.
        self._xml_start_tag("HeadingPairs")
        self._write_vt_vector("variant", self.heading_pairs)
        self._xml_end_tag("HeadingPairs")

    def _write_titles_of_parts(self):
        # Write the <TitlesOfParts> element.
        parts_data = []

        self._xml_start_tag("TitlesOfParts")

        for part_name in self.part_names:
            parts_data.append(("lpstr", part_name))

        self._write_vt_vector("lpstr", parts_data)

        self._xml_end_tag("TitlesOfParts")

    def _write_vt_vector(self, base_type, vector_data):
        # Write the <vt:vector> element.
        attributes = [
            ("size", len(vector_data)),
            ("baseType", base_type),
        ]

        self._xml_start_tag("vt:vector", attributes)

        for vt_data in vector_data:
            if base_type == "variant":
                self._xml_start_tag("vt:variant")

            self._write_vt_data(vt_data)

            if base_type == "variant":
                self._xml_end_tag("vt:variant")

        self._xml_end_tag("vt:vector")

    def _write_vt_data(self, vt_data):
        # Write the <vt:*> elements such as <vt:lpstr> and <vt:if>.
        self._xml_data_element("vt:%s" % vt_data[0], vt_data[1])

    def _write_company(self):
        company = self.properties.get("company", "")

        self._xml_data_element("Company", company)

    def _write_manager(self):
        # Write the <Manager> element.
        if "manager" not in self.properties:
            return

        self._xml_data_element("Manager", self.properties["manager"])

    def _write_links_up_to_date(self):
        # Write the <LinksUpToDate> element.
        self._xml_data_element("LinksUpToDate", "false")

    def _write_shared_doc(self):
        # Write the <SharedDoc> element.
        self._xml_data_element("SharedDoc", "false")

    def _write_hyperlink_base(self):
        # Write the <HyperlinkBase> element.
        hyperlink_base = self.properties.get("hyperlink_base")

        if hyperlink_base is None:
            return

        self._xml_data_element("HyperlinkBase", hyperlink_base)

    def _write_hyperlinks_changed(self):
        # Write the <HyperlinksChanged> element.
        self._xml_data_element("HyperlinksChanged", "false")

    def _write_app_version(self):
        # Write the <AppVersion> element.
        self._xml_data_element("AppVersion", "12.0000")

```

---

### File: `tmp\xlsxwriter_sdist\XlsxWriter-3.2.0\xlsxwriter\chart.py`

```python
###############################################################################
#
# Chart - A class for writing the Excel XLSX Worksheet file.
#
# SPDX-License-Identifier: BSD-2-Clause
# Copyright 2013-2024, John McNamara, jmcnamara@cpan.org
#
import re
import copy
from warnings import warn

from .shape import Shape
from . import xmlwriter
from .utility import get_rgb_color
from .utility import xl_rowcol_to_cell
from .utility import xl_range_formula
from .utility import supported_datetime
from .utility import datetime_to_excel_datetime
from .utility import quote_sheetname


class Chart(xmlwriter.XMLwriter):
    """
    A class for writing the Excel XLSX Chart file.


    """

    ###########################################################################
    #
    # Public API.
    #
    ###########################################################################

    def __init__(self, options=None):
        """
        Constructor.

        """

        super(Chart, self).__init__()

        self.subtype = None
        self.sheet_type = 0x0200
        self.orientation = 0x0
        self.series = []
        self.embedded = 0
        self.id = -1
        self.series_index = 0
        self.style_id = 2
        self.axis_ids = []
        self.axis2_ids = []
        self.cat_has_num_fmt = 0
        self.requires_category = False
        self.legend = {}
        self.cat_axis_position = "b"
        self.val_axis_position = "l"
        self.formula_ids = {}
        self.formula_data = []
        self.horiz_cat_axis = 0
        self.horiz_val_axis = 1
        self.protection = 0
        self.chartarea = {}
        self.plotarea = {}
        self.x_axis = {}
        self.y_axis = {}
        self.y2_axis = {}
        self.x2_axis = {}
        self.chart_name = ""
        self.show_blanks = "gap"
        self.show_na_as_empty = False
        self.show_hidden = False
        self.show_crosses = 1
        self.width = 480
        self.height = 288
        self.x_scale = 1
        self.y_scale = 1
        self.x_offset = 0
        self.y_offset = 0
        self.table = None
        self.cross_between = "between"
        self.default_marker = None
        self.series_gap_1 = None
        self.series_gap_2 = None
        self.series_overlap_1 = None
        self.series_overlap_2 = None
        self.drop_lines = None
        self.hi_low_lines = None
        self.up_down_bars = None
        self.smooth_allowed = False
        self.title_font = None
        self.title_name = None
        self.title_formula = None
        self.title_data_id = None
        self.title_layout = None
        self.title_overlay = None
        self.title_none = False
        self.date_category = False
        self.date_1904 = False
        self.remove_timezone = False
        self.label_positions = {}
        self.label_position_default = ""
        self.already_inserted = False
        self.combined = None
        self.is_secondary = False
        self.warn_sheetname = True
        self._set_default_properties()

    def add_series(self, options=None):
        """
        Add a data series to a chart.

        Args:
            options:  A dictionary of chart series options.

        Returns:
            Nothing.

        """
        # Add a series and it's properties to a chart.
        if options is None:
            options = {}

        # Check that the required input has been specified.
        if "values" not in options:
            warn("Must specify 'values' in add_series()")
            return

        if self.requires_category and "categories" not in options:
            warn("Must specify 'categories' in add_series() for this chart type")
            return

        if len(self.series) == 255:
            warn(
                "The maximum number of series that can be added to an "
                "Excel Chart is 255"
            )
            return

        # Convert list into a formula string.
        values = self._list_to_formula(options.get("values"))
        categories = self._list_to_formula(options.get("categories"))

        # Switch name and name_formula parameters if required.
        name, name_formula = self._process_names(
            options.get("name"), options.get("name_formula")
        )

        # Get an id for the data equivalent to the range formula.
        cat_id = self._get_data_id(categories, options.get("categories_data"))
        val_id = self._get_data_id(values, options.get("values_data"))
        name_id = self._get_data_id(name_formula, options.get("name_data"))

        # Set the line properties for the series.
        line = Shape._get_line_properties(options.get("line"))

        # Allow 'border' as a synonym for 'line' in bar/column style charts.
        if options.get("border"):
            line = Shape._get_line_properties(options["border"])

        # Set the fill properties for the series.
        fill = Shape._get_fill_properties(options.get("fill"))

        # Set the pattern fill properties for the series.
        pattern = Shape._get_pattern_properties(options.get("pattern"))

        # Set the gradient fill properties for the series.
        gradient = Shape._get_gradient_properties(options.get("gradient"))

        # Pattern fill overrides solid fill.
        if pattern:
            self.fill = None

        # Gradient fill overrides the solid and pattern fill.
        if gradient:
            pattern = None
            fill = None

        # Set the marker properties for the series.
        marker = self._get_marker_properties(options.get("marker"))

        # Set the trendline properties for the series.
        trendline = self._get_trendline_properties(options.get("trendline"))

        # Set the line smooth property for the series.
        smooth = options.get("smooth")

        # Set the error bars properties for the series.
        y_error_bars = self._get_error_bars_props(options.get("y_error_bars"))
        x_error_bars = self._get_error_bars_props(options.get("x_error_bars"))

        error_bars = {"x_error_bars": x_error_bars, "y_error_bars": y_error_bars}

        # Set the point properties for the series.
        points = self._get_points_properties(options.get("points"))

        # Set the labels properties for the series.
        labels = self._get_labels_properties(options.get("data_labels"))

        # Set the "invert if negative" fill property.
        invert_if_neg = options.get("invert_if_negative", False)
        inverted_color = options.get("invert_if_negative_color", False)

        # Set the secondary axis properties.
        x2_axis = options.get("x2_axis")
        y2_axis = options.get("y2_axis")

        # Store secondary status for combined charts.
        if x2_axis or y2_axis:
            self.is_secondary = True

        # Set the gap for Bar/Column charts.
        if options.get("gap") is not None:
            if y2_axis:
                self.series_gap_2 = options["gap"]
            else:
                self.series_gap_1 = options["gap"]

        # Set the overlap for Bar/Column charts.
        if options.get("overlap"):
            if y2_axis:
                self.series_overlap_2 = options["overlap"]
            else:
                self.series_overlap_1 = options["overlap"]

        # Add the user supplied data to the internal structures.
        series = {
            "values": values,
            "categories": categories,
            "name": name,
            "name_formula": name_formula,
            "name_id": name_id,
            "val_data_id": val_id,
            "cat_data_id": cat_id,
            "line": line,
            "fill": fill,
            "pattern": pattern,
            "gradient": gradient,
            "marker": marker,
            "trendline": trendline,
            "labels": labels,
            "invert_if_neg": invert_if_neg,
            "inverted_color": inverted_color,
            "x2_axis": x2_axis,
            "y2_axis": y2_axis,
            "points": points,
            "error_bars": error_bars,
            "smooth": smooth,
        }

        self.series.append(series)

    def set_x_axis(self, options):
        """
        Set the chart X axis options.

        Args:
            options:  A dictionary of axis options.

        Returns:
            Nothing.

        """
        axis = self._convert_axis_args(self.x_axis, options)

        self.x_axis = axis

    def set_y_axis(self, options):
        """
        Set the chart Y axis options.

        Args:
            options: A dictionary of axis options.

        Returns:
            Nothing.

        """
        axis = self._convert_axis_args(self.y_axis, options)

        self.y_axis = axis

    def set_x2_axis(self, options):
        """
        Set the chart secondary X axis options.

        Args:
            options: A dictionary of axis options.

        Returns:
            Nothing.

        """
        axis = self._convert_axis_args(self.x2_axis, options)

        self.x2_axis = axis

    def set_y2_axis(self, options):
        """
        Set the chart secondary Y axis options.

        Args:
            options: A dictionary of axis options.

        Returns:
            Nothing.

        """
        axis = self._convert_axis_args(self.y2_axis, options)

        self.y2_axis = axis

    def set_title(self, options=None):
        """
        Set the chart title options.

        Args:
            options: A dictionary of chart title options.

        Returns:
            Nothing.

        """
        if options is None:
            options = {}

        name, name_formula = self._process_names(
            options.get("name"), options.get("name_formula")
        )

        data_id = self._get_data_id(name_formula, options.get("data"))

        self.title_name = name
        self.title_formula = name_formula
        self.title_data_id = data_id

        # Set the font properties if present.
        self.title_font = self._convert_font_args(options.get("name_font"))

        # Set the axis name layout.
        self.title_layout = self._get_layout_properties(options.get("layout"), True)
        # Set the title overlay option.
        self.title_overlay = options.get("overlay")

        # Set the automatic title option.
        self.title_none = options.get("none")

    def set_legend(self, options):
        """
        Set the chart legend options.

        Args:
            options: A dictionary of chart legend options.

        Returns:
            Nothing.
        """
        # Convert the user defined properties to internal properties.
        self.legend = self._get_legend_properties(options)

    def set_plotarea(self, options):
        """
        Set the chart plot area options.

        Args:
            options: A dictionary of chart plot area options.

        Returns:
            Nothing.
        """
        # Convert the user defined properties to internal properties.
        self.plotarea = self._get_area_properties(options)

    def set_chartarea(self, options):
        """
        Set the chart area options.

        Args:
            options: A dictionary of chart area options.

        Returns:
            Nothing.
        """
        # Convert the user defined properties to internal properties.
        self.chartarea = self._get_area_properties(options)

    def set_style(self, style_id):
        """
        Set the chart style type.

        Args:
            style_id: An int representing the chart style.

        Returns:
            Nothing.
        """
        # Set one of the 48 built-in Excel chart styles. The default is 2.
        if style_id is None:
            style_id = 2

        if style_id < 1 or style_id > 48:
            style_id = 2

        self.style_id = style_id

    def show_blanks_as(self, option):
        """
        Set the option for displaying blank data in a chart.

        Args:
            option: A string representing the display option.

        Returns:
            Nothing.
        """
        if not option:
            return

        valid_options = {
            "gap": 1,
            "zero": 1,
            "span": 1,
        }

        if option not in valid_options:
            warn("Unknown show_blanks_as() option '%s'" % option)
            return

        self.show_blanks = option

    def show_na_as_empty_cell(self):
        """
        Display ``#N/A`` on charts as blank/empty cells.

        Args:
            None.

        Returns:
            Nothing.
        """
        self.show_na_as_empty = True

    def show_hidden_data(self):
        """
        Display data on charts from hidden rows or columns.

        Args:
            None.

        Returns:
            Nothing.
        """
        self.show_hidden = True

    def set_size(self, options=None):
        """
        Set size or scale of the chart.

        Args:
            options: A dictionary of chart size options.

        Returns:
            Nothing.
        """
        if options is None:
            options = {}

        # Set dimensions or scale for the chart.
        self.width = options.get("width", self.width)
        self.height = options.get("height", self.height)
        self.x_scale = options.get("x_scale", 1)
        self.y_scale = options.get("y_scale", 1)
        self.x_offset = options.get("x_offset", 0)
        self.y_offset = options.get("y_offset", 0)

    def set_table(self, options=None):
        """
        Set properties for an axis data table.

        Args:
            options: A dictionary of axis table options.

        Returns:
            Nothing.

        """
        if options is None:
            options = {}

        table = {}

        table["horizontal"] = options.get("horizontal", 1)
        table["vertical"] = options.get("vertical", 1)
        table["outline"] = options.get("outline", 1)
        table["show_keys"] = options.get("show_keys", 0)
        table["font"] = self._convert_font_args(options.get("font"))

        self.table = table

    def set_up_down_bars(self, options=None):
        """
        Set properties for the chart up-down bars.

        Args:
            options: A dictionary of options.

        Returns:
            Nothing.

        """
        if options is None:
            options = {}

        # Defaults.
        up_line = None
        up_fill = None
        down_line = None
        down_fill = None

        # Set properties for 'up' bar.
        if options.get("up"):
            if "border" in options["up"]:
                # Map border to line.
                up_line = Shape._get_line_properties(options["up"]["border"])

            if "line" in options["up"]:
                up_line = Shape._get_line_properties(options["up"]["line"])

            if "fill" in options["up"]:
                up_fill = Shape._get_fill_properties(options["up"]["fill"])

        # Set properties for 'down' bar.
        if options.get("down"):
            if "border" in options["down"]:
                # Map border to line.
                down_line = Shape._get_line_properties(options["down"]["border"])

            if "line" in options["down"]:
                down_line = Shape._get_line_properties(options["down"]["line"])

            if "fill" in options["down"]:
                down_fill = Shape._get_fill_properties(options["down"]["fill"])

        self.up_down_bars = {
            "up": {
                "line": up_line,
                "fill": up_fill,
            },
            "down": {
                "line": down_line,
                "fill": down_fill,
            },
        }

    def set_drop_lines(self, options=None):
        """
        Set properties for the chart drop lines.

        Args:
            options: A dictionary of options.

        Returns:
            Nothing.

        """
        if options is None:
            options = {}

        line = Shape._get_line_properties(options.get("line"))
        fill = Shape._get_fill_properties(options.get("fill"))

        # Set the pattern fill properties for the series.
        pattern = Shape._get_pattern_properties(options.get("pattern"))

        # Set the gradient fill properties for the series.
        gradient = Shape._get_gradient_properties(options.get("gradient"))

        # Pattern fill overrides solid fill.
        if pattern:
            self.fill = None

        # Gradient fill overrides the solid and pattern fill.
        if gradient:
            pattern = None
            fill = None

        self.drop_lines = {
            "line": line,
            "fill": fill,
            "pattern": pattern,
            "gradient": gradient,
        }

    def set_high_low_lines(self, options=None):
        """
        Set properties for the chart high-low lines.

        Args:
            options: A dictionary of options.

        Returns:
            Nothing.

        """
        if options is None:
            options = {}

        line = Shape._get_line_properties(options.get("line"))
        fill = Shape._get_fill_properties(options.get("fill"))

        # Set the pattern fill properties for the series.
        pattern = Shape._get_pattern_properties(options.get("pattern"))

        # Set the gradient fill properties for the series.
        gradient = Shape._get_gradient_properties(options.get("gradient"))

        # Pattern fill overrides solid fill.
        if pattern:
            self.fill = None

        # Gradient fill overrides the solid and pattern fill.
        if gradient:
            pattern = None
            fill = None

        self.hi_low_lines = {
            "line": line,
            "fill": fill,
            "pattern": pattern,
            "gradient": gradient,
        }

    def combine(self, chart=None):
        """
        Create a combination chart with a secondary chart.

        Args:
            chart: The secondary chart to combine with the primary chart.

        Returns:
            Nothing.

        """
        if chart is None:
            return

        self.combined = chart

    ###########################################################################
    #
    # Private API.
    #
    ###########################################################################

    def _assemble_xml_file(self):
        # Assemble and write the XML file.

        # Write the XML declaration.
        self._xml_declaration()

        # Write the c:chartSpace element.
        self._write_chart_space()

        # Write the c:lang element.
        self._write_lang()

        # Write the c:style element.
        self._write_style()

        # Write the c:protection element.
        self._write_protection()

        # Write the c:chart element.
        self._write_chart()

        # Write the c:spPr element for the chartarea formatting.
        self._write_sp_pr(self.chartarea)

        # Write the c:printSettings element.
        if self.embedded:
            self._write_print_settings()

        # Close the worksheet tag.
        self._xml_end_tag("c:chartSpace")
        # Close the file.
        self._xml_close()

    def _convert_axis_args(self, axis, user_options):
        # Convert user defined axis values into private hash values.
        options = axis["defaults"].copy()
        options.update(user_options)

        name, name_formula = self._process_names(
            options.get("name"), options.get("name_formula")
        )

        data_id = self._get_data_id(name_formula, options.get("data"))

        axis = {
            "defaults": axis["defaults"],
            "name": name,
            "formula": name_formula,
            "data_id": data_id,
            "reverse": options.get("reverse"),
            "min": options.get("min"),
            "max": options.get("max"),
            "minor_unit": options.get("minor_unit"),
            "major_unit": options.get("major_unit"),
            "minor_unit_type": options.get("minor_unit_type"),
            "major_unit_type": options.get("major_unit_type"),
            "display_units": options.get("display_units"),
            "log_base": options.get("log_base"),
            "crossing": options.get("crossing"),
            "position_axis": options.get("position_axis"),
            "position": options.get("position"),
            "label_position": options.get("label_position"),
            "label_align": options.get("label_align"),
            "num_format": options.get("num_format"),
            "num_format_linked": options.get("num_format_linked"),
            "interval_unit": options.get("interval_unit"),
            "interval_tick": options.get("interval_tick"),
            "text_axis": False,
        }

        if "visible" in options:
            axis["visible"] = options.get("visible")
        else:
            axis["visible"] = 1

        # Convert the display units.
        axis["display_units"] = self._get_display_units(axis["display_units"])
        axis["display_units_visible"] = options.get("display_units_visible", True)

        # Map major_gridlines properties.
        if options.get("major_gridlines") and options["major_gridlines"]["visible"]:
            axis["major_gridlines"] = self._get_gridline_properties(
                options["major_gridlines"]
            )

        # Map minor_gridlines properties.
        if options.get("minor_gridlines") and options["minor_gridlines"]["visible"]:
            axis["minor_gridlines"] = self._get_gridline_properties(
                options["minor_gridlines"]
            )

        # Only use the first letter of bottom, top, left or right.
        if axis.get("position"):
            axis["position"] = axis["position"].lower()[0]

        # Set the position for a category axis on or between the tick marks.
        if axis.get("position_axis"):
            if axis["position_axis"] == "on_tick":
                axis["position_axis"] = "midCat"
            elif axis["position_axis"] == "between":
                # Doesn't need to be modified.
                pass
            else:
                # Otherwise use the default value.
                axis["position_axis"] = None

        # Set the category axis as a date axis.
        if options.get("date_axis"):
            self.date_category = True

        # Set the category axis as a text axis.
        if options.get("text_axis"):
            self.date_category = False
            axis["text_axis"] = True

        # Convert datetime args if required.
        if axis.get("min") and supported_datetime(axis["min"]):
            axis["min"] = datetime_to_excel_datetime(
                axis["min"], self.date_1904, self.remove_timezone
            )
        if axis.get("max") and supported_datetime(axis["max"]):
            axis["max"] = datetime_to_excel_datetime(
                axis["max"], self.date_1904, self.remove_timezone
            )
        if axis.get("crossing") and supported_datetime(axis["crossing"]):
            axis["crossing"] = datetime_to_excel_datetime(
                axis["crossing"], self.date_1904, self.remove_timezone
            )

        # Set the font properties if present.
        axis["num_font"] = self._convert_font_args(options.get("num_font"))
        axis["name_font"] = self._convert_font_args(options.get("name_font"))

        # Set the axis name layout.
        axis["name_layout"] = self._get_layout_properties(
            options.get("name_layout"), True
        )

        # Set the line properties for the axis.
        axis["line"] = Shape._get_line_properties(options.get("line"))

        # Set the fill properties for the axis.
        axis["fill"] = Shape._get_fill_properties(options.get("fill"))

        # Set the pattern fill properties for the series.
        axis["pattern"] = Shape._get_pattern_properties(options.get("pattern"))

        # Set the gradient fill properties for the series.
        axis["gradient"] = Shape._get_gradient_properties(options.get("gradient"))

        # Pattern fill overrides solid fill.
        if axis.get("pattern"):
            axis["fill"] = None

        # Gradient fill overrides the solid and pattern fill.
        if axis.get("gradient"):
            axis["pattern"] = None
            axis["fill"] = None

        # Set the tick marker types.
        axis["minor_tick_mark"] = self._get_tick_type(options.get("minor_tick_mark"))
        axis["major_tick_mark"] = self._get_tick_type(options.get("major_tick_mark"))

        return axis

    def _convert_font_args(self, options):
        # Convert user defined font values into private dict values.
        if not options:
            return

        font = {
            "name": options.get("name"),
            "color": options.get("color"),
            "size": options.get("size"),
            "bold": options.get("bold"),
            "italic": options.get("italic"),
            "underline": options.get("underline"),
            "pitch_family": options.get("pitch_family"),
            "charset": options.get("charset"),
            "baseline": options.get("baseline", 0),
            "rotation": options.get("rotation"),
        }

        # Convert font size units.
        if font["size"]:
            font["size"] = int(font["size"] * 100)

        # Convert rotation into 60,000ths of a degree.
        if font["rotation"]:
            font["rotation"] = 60000 * int(font["rotation"])

        return font

    def _list_to_formula(self, data):
        # Convert and list of row col values to a range formula.

        # If it isn't an array ref it is probably a formula already.
        if not isinstance(data, list):
            # Check for unquoted sheetnames.
            if data and " " in data and "'" not in data and self.warn_sheetname:
                warn(
                    "Sheetname in '%s' contains spaces but isn't quoted. "
                    "This may cause errors in Excel." % data
                )
            return data

        formula = xl_range_formula(*data)

        return formula

    def _process_names(self, name, name_formula):
        # Switch name and name_formula parameters if required.

        if name is not None:
            if isinstance(name, list):
                # Convert a list of values into a name formula.
                cell = xl_rowcol_to_cell(name[1], name[2], True, True)
                name_formula = quote_sheetname(name[0]) + "!" + cell
                name = ""
            elif re.match(r"^=?[^!]+!\$?[A-Z]+\$?\d+", name):
                # Name looks like a formula, use it to set name_formula.
                name_formula = name
                name = ""

        return name, name_formula

    def _get_data_type(self, data):
        # Find the overall type of the data associated with a series.

        # Check for no data in the series.
        if data is None or len(data) == 0:
            return "none"

        if isinstance(data[0], list):
            return "multi_str"

        # Determine if data is numeric or strings.
        for token in data:
            if token is None:
                continue

            # Check for strings that would evaluate to float like
            # '1.1_1' of ' 1'.
            if isinstance(token, str) and re.search("[_ ]", token):
                # Assume entire data series is string data.
                return "str"

            try:
                float(token)
            except ValueError:
                # Not a number. Assume entire data series is string data.
                return "str"

        # The series data was all numeric.
        return "num"

    def _get_data_id(self, formula, data):
        # Assign an id to a each unique series formula or title/axis formula.
        # Repeated formulas such as for categories get the same id. If the
        # series or title has user specified data associated with it then
        # that is also stored. This data is used to populate cached Excel
        # data when creating a chart. If there is no user defined data then
        # it will be populated by the parent Workbook._add_chart_data().

        # Ignore series without a range formula.
        if not formula:
            return

        # Strip the leading '=' from the formula.
        if formula.startswith("="):
            formula = formula.lstrip("=")

        # Store the data id in a hash keyed by the formula and store the data
        # in a separate array with the same id.
        if formula not in self.formula_ids:
            # Haven't seen this formula before.
            formula_id = len(self.formula_data)

            self.formula_data.append(data)
            self.formula_ids[formula] = formula_id
        else:
            # Formula already seen. Return existing id.
            formula_id = self.formula_ids[formula]

            # Store user defined data if it isn't already there.
            if self.formula_data[formula_id] is None:
                self.formula_data[formula_id] = data

        return formula_id

    def _get_marker_properties(self, marker):
        # Convert user marker properties to the structure required internally.

        if not marker:
            return

        # Copy the user defined properties since they will be modified.
        marker = copy.deepcopy(marker)

        types = {
            "automatic": "automatic",
            "none": "none",
            "square": "square",
            "diamond": "diamond",
            "triangle": "triangle",
            "x": "x",
            "star": "star",
            "dot": "dot",
            "short_dash": "dot",
            "dash": "dash",
            "long_dash": "dash",
            "circle": "circle",
            "plus": "plus",
            "picture": "picture",
        }

        # Check for valid types.
        marker_type = marker.get("type")

        if marker_type is not None:
            if marker_type in types:
                marker["type"] = types[marker_type]
            else:
                warn("Unknown marker type '%s" % marker_type)
                return

        # Set the line properties for the marker.
        line = Shape._get_line_properties(marker.get("line"))

        # Allow 'border' as a synonym for 'line'.
        if "border" in marker:
            line = Shape._get_line_properties(marker["border"])

        # Set the fill properties for the marker.
        fill = Shape._get_fill_properties(marker.get("fill"))

        # Set the pattern fill properties for the series.
        pattern = Shape._get_pattern_properties(marker.get("pattern"))

        # Set the gradient fill properties for the series.
        gradient = Shape._get_gradient_properties(marker.get("gradient"))

        # Pattern fill overrides solid fill.
        if pattern:
            self.fill = None

        # Gradient fill overrides the solid and pattern fill.
        if gradient:
            pattern = None
            fill = None

        marker["line"] = line
        marker["fill"] = fill
        marker["pattern"] = pattern
        marker["gradient"] = gradient

        return marker

    def _get_trendline_properties(self, trendline):
        # Convert user trendline properties to structure required internally.

        if not trendline:
            return

        # Copy the user defined properties since they will be modified.
        trendline = copy.deepcopy(trendline)

        types = {
            "exponential": "exp",
            "linear": "linear",
            "log": "log",
            "moving_average": "movingAvg",
            "polynomial": "poly",
            "power": "power",
        }

        # Check the trendline type.
        trend_type = trendline.get("type")

        if trend_type in types:
            trendline["type"] = types[trend_type]
        else:
            warn("Unknown trendline type '%s'" % trend_type)
            return

        # Set the line properties for the trendline.
        line = Shape._get_line_properties(trendline.get("line"))

        # Allow 'border' as a synonym for 'line'.
        if "border" in trendline:
            line = Shape._get_line_properties(trendline["border"])

        # Set the fill properties for the trendline.
        fill = Shape._get_fill_properties(trendline.get("fill"))

        # Set the pattern fill properties for the trendline.
        pattern = Shape._get_pattern_properties(trendline.get("pattern"))

        # Set the gradient fill properties for the trendline.
        gradient = Shape._get_gradient_properties(trendline.get("gradient"))

        # Set the format properties for the trendline label.
        label = self._get_trendline_label_properties(trendline.get("label"))

        # Pattern fill overrides solid fill.
        if pattern:
            self.fill = None

        # Gradient fill overrides the solid and pattern fill.
        if gradient:
            pattern = None
            fill = None

        trendline["line"] = line
        trendline["fill"] = fill
        trendline["pattern"] = pattern
        trendline["gradient"] = gradient
        trendline["label"] = label

        return trendline

    def _get_trendline_label_properties(self, label):
        # Convert user trendline properties to structure required internally.

        if not label:
            return {}

        # Copy the user defined properties since they will be modified.
        label = copy.deepcopy(label)

        # Set the font properties if present.
        font = self._convert_font_args(label.get("font"))

        # Set the line properties for the label.
        line = Shape._get_line_properties(label.get("line"))

        # Allow 'border' as a synonym for 'line'.
        if "border" in label:
            line = Shape._get_line_properties(label["border"])

        # Set the fill properties for the label.
        fill = Shape._get_fill_properties(label.get("fill"))

        # Set the pattern fill properties for the label.
        pattern = Shape._get_pattern_properties(label.get("pattern"))

        # Set the gradient fill properties for the label.
        gradient = Shape._get_gradient_properties(label.get("gradient"))

        # Pattern fill overrides solid fill.
        if pattern:
            self.fill = None

        # Gradient fill overrides the solid and pattern fill.
        if gradient:
            pattern = None
            fill = None

        label["font"] = font
        label["line"] = line
        label["fill"] = fill
        label["pattern"] = pattern
        label["gradient"] = gradient

        return label

    def _get_error_bars_props(self, options):
        # Convert user error bars properties to structure required internally.
        if not options:
            return

        # Default values.
        error_bars = {"type": "fixedVal", "value": 1, "endcap": 1, "direction": "both"}

        types = {
            "fixed": "fixedVal",
            "percentage": "percentage",
            "standard_deviation": "stdDev",
            "standard_error": "stdErr",
            "custom": "cust",
        }

        # Check the error bars type.
        error_type = options["type"]

        if error_type in types:
            error_bars["type"] = types[error_type]
        else:
            warn("Unknown error bars type '%s" % error_type)
            return

        # Set the value for error types that require it.
        if "value" in options:
            error_bars["value"] = options["value"]

        # Set the end-cap style.
        if "end_style" in options:
            error_bars["endcap"] = options["end_style"]

        # Set the error bar direction.
        if "direction" in options:
            if options["direction"] == "minus":
                error_bars["direction"] = "minus"
            elif options["direction"] == "plus":
                error_bars["direction"] = "plus"
            else:
                # Default to 'both'.
                pass

        # Set any custom values.
        error_bars["plus_values"] = options.get("plus_values")
        error_bars["minus_values"] = options.get("minus_values")
        error_bars["plus_data"] = options.get("plus_data")
        error_bars["minus_data"] = options.get("minus_data")

        # Set the line properties for the error bars.
        error_bars["line"] = Shape._get_line_properties(options.get("line"))

        return error_bars

    def _get_gridline_properties(self, options):
        # Convert user gridline properties to structure required internally.

        # Set the visible property for the gridline.
        gridline = {"visible": options.get("visible")}

        # Set the line properties for the gridline.
        gridline["line"] = Shape._get_line_properties(options.get("line"))

        return gridline

    def _get_labels_properties(self, labels):
        # Convert user labels properties to the structure required internally.

        if not labels:
            return None

        # Copy the user defined properties since they will be modified.
        labels = copy.deepcopy(labels)

        # Map user defined label positions to Excel positions.
        position = labels.get("position")

        if position:
            if position in self.label_positions:
                if position == self.label_position_default:
                    labels["position"] = None
                else:
                    labels["position"] = self.label_positions[position]
            else:
                warn("Unsupported label position '%s' for this chart type" % position)
                return

        # Map the user defined label separator to the Excel separator.
        separator = labels.get("separator")
        separators = {
            ",": ", ",
            ";": "; ",
            ".": ". ",
            "\n": "\n",
            " ": " ",
        }

        if separator:
            if separator in separators:
                labels["separator"] = separators[separator]
            else:
                warn("Unsupported label separator")
                return

        # Set the font properties if present.
        labels["font"] = self._convert_font_args(labels.get("font"))

        # Set the line properties for the labels.
        line = Shape._get_line_properties(labels.get("line"))

        # Allow 'border' as a synonym for 'line'.
        if "border" in labels:
            line = Shape._get_line_properties(labels["border"])

        # Set the fill properties for the labels.
        fill = Shape._get_fill_properties(labels.get("fill"))

        # Set the pattern fill properties for the labels.
        pattern = Shape._get_pattern_properties(labels.get("pattern"))

        # Set the gradient fill properties for the labels.
        gradient = Shape._get_gradient_properties(labels.get("gradient"))

        # Pattern fill overrides solid fill.
        if pattern:
            self.fill = None

        # Gradient fill overrides the solid and pattern fill.
        if gradient:
            pattern = None
            fill = None

        labels["line"] = line
        labels["fill"] = fill
        labels["pattern"] = pattern
        labels["gradient"] = gradient

        if labels.get("custom"):
            for label in labels["custom"]:
                if label is None:
                    continue

                value = label.get("value")
                if value and re.match(r"^=?[^!]+!\$?[A-Z]+\$?\d+", str(value)):
                    label["formula"] = value

                formula = label.get("formula")
                if formula and formula.startswith("="):
                    label["formula"] = formula.lstrip("=")

                data_id = self._get_data_id(formula, label.get("data"))
                label["data_id"] = data_id

                label["font"] = self._convert_font_args(label.get("font"))

                # Set the line properties for the label.
                line = Shape._get_line_properties(label.get("line"))

                # Allow 'border' as a synonym for 'line'.
                if "border" in label:
                    line = Shape._get_line_properties(label["border"])

                # Set the fill properties for the label.
                fill = Shape._get_fill_properties(label.get("fill"))

                # Set the pattern fill properties for the label.
                pattern = Shape._get_pattern_properties(label.get("pattern"))

                # Set the gradient fill properties for the label.
                gradient = Shape._get_gradient_properties(label.get("gradient"))

                # Pattern fill overrides solid fill.
                if pattern:
                    self.fill = None

                # Gradient fill overrides the solid and pattern fill.
                if gradient:
                    pattern = None
                    fill = None

                label["line"] = line
                label["fill"] = fill
                label["pattern"] = pattern
                label["gradient"] = gradient

        return labels

    def _get_area_properties(self, options):
        # Convert user area properties to the structure required internally.
        area = {}

        # Set the line properties for the chartarea.
        line = Shape._get_line_properties(options.get("line"))

        # Allow 'border' as a synonym for 'line'.
        if options.get("border"):
            line = Shape._get_line_properties(options["border"])

        # Set the fill properties for the chartarea.
        fill = Shape._get_fill_properties(options.get("fill"))

        # Set the pattern fill properties for the series.
        pattern = Shape._get_pattern_properties(options.get("pattern"))

        # Set the gradient fill properties for the series.
        gradient = Shape._get_gradient_properties(options.get("gradient"))

        # Pattern fill overrides solid fill.
        if pattern:
            self.fill = None

        # Gradient fill overrides the solid and pattern fill.
        if gradient:
            pattern = None
            fill = None

        # Set the plotarea layout.
        layout = self._get_layout_properties(options.get("layout"), False)

        area["line"] = line
        area["fill"] = fill
        area["pattern"] = pattern
        area["layout"] = layout
        area["gradient"] = gradient

        return area

    def _get_legend_properties(self, options=None):
        # Convert user legend properties to the structure required internally.
        legend = {}

        if options is None:
            options = {}

        legend["position"] = options.get("position", "right")
        legend["delete_series"] = options.get("delete_series")
        legend["font"] = self._convert_font_args(options.get("font"))
        legend["layout"] = self._get_layout_properties(options.get("layout"), False)

        # Turn off the legend.
        if options.get("none"):
            legend["position"] = "none"

        # Set the line properties for the legend.
        line = Shape._get_line_properties(options.get("line"))

        # Allow 'border' as a synonym for 'line'.
        if options.get("border"):
            line = Shape._get_line_properties(options["border"])

        # Set the fill properties for the legend.
        fill = Shape._get_fill_properties(options.get("fill"))

        # Set the pattern fill properties for the series.
        pattern = Shape._get_pattern_properties(options.get("pattern"))

        # Set the gradient fill properties for the series.
        gradient = Shape._get_gradient_properties(options.get("gradient"))

        # Pattern fill overrides solid fill.
        if pattern:
            self.fill = None

        # Gradient fill overrides the solid and pattern fill.
        if gradient:
            pattern = None
            fill = None

        # Set the legend layout.
        layout = self._get_layout_properties(options.get("layout"), False)

        legend["line"] = line
        legend["fill"] = fill
        legend["pattern"] = pattern
        legend["layout"] = layout
        legend["gradient"] = gradient

        return legend

    def _get_layout_properties(self, args, is_text):
        # Convert user defined layout properties to format used internally.
        layout = {}

        if not args:
            return

        if is_text:
            properties = ("x", "y")
        else:
            properties = ("x", "y", "width", "height")

        # Check for valid properties.
        for key in args.keys():
            if key not in properties:
                warn("Property '%s' allowed not in layout options" % key)
                return

        # Set the layout properties.
        for prop in properties:
            if prop not in args.keys():
                warn("Property '%s' must be specified in layout options" % prop)
                return

            value = args[prop]

            try:
                float(value)
            except ValueError:
                warn(
                    "Property '%s' value '%s' must be numeric in layout" % (prop, value)
                )
                return

            if value < 0 or value > 1:
                warn(
                    "Property '%s' value '%s' must be in range "
                    "0 < x <= 1 in layout options" % (prop, value)
                )
                return

            # Convert to the format used by Excel for easier testing
            layout[prop] = "%.17g" % value

        return layout

    def _get_points_properties(self, user_points):
        # Convert user points properties to structure required internally.
        points = []

        if not user_points:
            return

        for user_point in user_points:
            point = {}

            if user_point is not None:
                # Set the line properties for the point.
                line = Shape._get_line_properties(user_point.get("line"))

                # Allow 'border' as a synonym for 'line'.
                if "border" in user_point:
                    line = Shape._get_line_properties(user_point["border"])

                # Set the fill properties for the chartarea.
                fill = Shape._get_fill_properties(user_point.get("fill"))

                # Set the pattern fill properties for the series.
                pattern = Shape._get_pattern_properties(user_point.get("pattern"))

                # Set the gradient fill properties for the series.
                gradient = Shape._get_gradient_properties(user_point.get("gradient"))

                # Pattern fill overrides solid fill.
                if pattern:
                    self.fill = None

                # Gradient fill overrides the solid and pattern fill.
                if gradient:
                    pattern = None
                    fill = None

                point["line"] = line
                point["fill"] = fill
                point["pattern"] = pattern
                point["gradient"] = gradient

            points.append(point)

        return points

    def _has_fill_formatting(self, element):
        # Check if a chart element has line, fill or gradient formatting.
        has_fill = False
        has_line = False
        has_pattern = element.get("pattern")
        has_gradient = element.get("gradient")

        if element.get("fill") and element["fill"]["defined"]:
            has_fill = True

        if element.get("line") and element["line"]["defined"]:
            has_line = True

        if not has_fill and not has_line and not has_pattern and not has_gradient:
            return False
        else:
            return True

    def _get_display_units(self, display_units):
        # Convert user defined display units to internal units.
        if not display_units:
            return

        types = {
            "hundreds": "hundreds",
            "thousands": "thousands",
            "ten_thousands": "tenThousands",
            "hundred_thousands": "hundredThousands",
            "millions": "millions",
            "ten_millions": "tenMillions",
            "hundred_millions": "hundredMillions",
            "billions": "billions",
            "trillions": "trillions",
        }

        if display_units in types:
            display_units = types[display_units]
        else:
            warn("Unknown display_units type '%s'" % display_units)
            return

        return display_units

    def _get_tick_type(self, tick_type):
        # Convert user defined display units to internal units.
        if not tick_type:
            return

        types = {
            "outside": "out",
            "inside": "in",
            "none": "none",
            "cross": "cross",
        }

        if tick_type in types:
            tick_type = types[tick_type]
        else:
            warn("Unknown tick_type  '%s'" % tick_type)
            return

        return tick_type

    def _get_primary_axes_series(self):
        # Returns series which use the primary axes.
        primary_axes_series = []

        for series in self.series:
            if not series["y2_axis"]:
                primary_axes_series.append(series)

        return primary_axes_series

    def _get_secondary_axes_series(self):
        # Returns series which use the secondary axes.
        secondary_axes_series = []

        for series in self.series:
            if series["y2_axis"]:
                secondary_axes_series.append(series)

        return secondary_axes_series

    def _add_axis_ids(self, args):
        # Add unique ids for primary or secondary axes
        chart_id = 5001 + int(self.id)
        axis_count = 1 + len(self.axis2_ids) + len(self.axis_ids)

        id1 = "%04d%04d" % (chart_id, axis_count)
        id2 = "%04d%04d" % (chart_id, axis_count + 1)

        if args["primary_axes"]:
            self.axis_ids.append(id1)
            self.axis_ids.append(id2)

        if not args["primary_axes"]:
            self.axis2_ids.append(id1)
            self.axis2_ids.append(id2)

    def _set_default_properties(self):
        # Setup the default properties for a chart.

        self.x_axis["defaults"] = {
            "num_format": "General",
            "major_gridlines": {"visible": 0},
        }

        self.y_axis["defaults"] = {
            "num_format": "General",
            "major_gridlines": {"visible": 1},
        }

        self.x2_axis["defaults"] = {
            "num_format": "General",
            "label_position": "none",
            "crossing": "max",
            "visible": 0,
        }

        self.y2_axis["defaults"] = {
            "num_format": "General",
            "major_gridlines": {"visible": 0},
            "position": "right",
            "visible": 1,
        }

        self.set_x_axis({})
        self.set_y_axis({})

        self.set_x2_axis({})
        self.set_y2_axis({})

    ###########################################################################
    #
    # XML methods.
    #
    ###########################################################################

    def _write_chart_space(self):
        # Write the <c:chartSpace> element.
        schema = "http://schemas.openxmlformats.org/"
        xmlns_c = schema + "drawingml/2006/chart"
        xmlns_a = schema + "drawingml/2006/main"
        xmlns_r = schema + "officeDocument/2006/relationships"

        attributes = [
            ("xmlns:c", xmlns_c),
            ("xmlns:a", xmlns_a),
            ("xmlns:r", xmlns_r),
        ]

        self._xml_start_tag("c:chartSpace", attributes)

    def _write_lang(self):
        # Write the <c:lang> element.
        val = "en-US"

        attributes = [("val", val)]

        self._xml_empty_tag("c:lang", attributes)

    def _write_style(self):
        # Write the <c:style> element.
        style_id = self.style_id

        # Don't write an element for the default style, 2.
        if style_id == 2:
            return

        attributes = [("val", style_id)]

        self._xml_empty_tag("c:style", attributes)

    def _write_chart(self):
        # Write the <c:chart> element.
        self._xml_start_tag("c:chart")

        if self.title_none:
            # Turn off the title.
            self._write_c_auto_title_deleted()
        else:
            # Write the chart title elements.
            if self.title_formula is not None:
                self._write_title_formula(
                    self.title_formula,
                    self.title_data_id,
                    None,
                    self.title_font,
                    self.title_layout,
                    self.title_overlay,
                )
            elif self.title_name is not None:
                self._write_title_rich(
                    self.title_name,
                    None,
                    self.title_font,
                    self.title_layout,
                    self.title_overlay,
                )

        # Write the c:plotArea element.
        self._write_plot_area()

        # Write the c:legend element.
        self._write_legend()

        # Write the c:plotVisOnly element.
        self._write_plot_vis_only()

        # Write the c:dispBlanksAs element.
        self._write_disp_blanks_as()

        # Write the c:extLst element.
        if self.show_na_as_empty:
            self._write_c_ext_lst_display_na()

        self._xml_end_tag("c:chart")

    def _write_disp_blanks_as(self):
        # Write the <c:dispBlanksAs> element.
        val = self.show_blanks

        # Ignore the default value.
        if val == "gap":
            return

        attributes = [("val", val)]

        self._xml_empty_tag("c:dispBlanksAs", attributes)

    def _write_plot_area(self):
        # Write the <c:plotArea> element.
        self._xml_start_tag("c:plotArea")

        # Write the c:layout element.
        self._write_layout(self.plotarea.get("layout"), "plot")

        # Write  subclass chart type elements for primary and secondary axes.
        self._write_chart_type({"primary_axes": True})
        self._write_chart_type({"primary_axes": False})

        # Configure a combined chart if present.
        second_chart = self.combined
        if second_chart:
            # Secondary axis has unique id otherwise use same as primary.
            if second_chart.is_secondary:
                second_chart.id = 1000 + self.id
            else:
                second_chart.id = self.id

            # Share the same filehandle for writing.
            second_chart.fh = self.fh

            # Share series index with primary chart.
            second_chart.series_index = self.series_index

            # Write the subclass chart type elements for combined chart.
            second_chart._write_chart_type({"primary_axes": True})
            second_chart._write_chart_type({"primary_axes": False})

        # Write the category and value elements for the primary axes.
        args = {"x_axis": self.x_axis, "y_axis": self.y_axis, "axis_ids": self.axis_ids}

        if self.date_category:
            self._write_date_axis(args)
        else:
            self._write_cat_axis(args)

        self._write_val_axis(args)

        # Write the category and value elements for the secondary axes.
        args = {
            "x_axis": self.x2_axis,
            "y_axis": self.y2_axis,
            "axis_ids": self.axis2_ids,
        }

        self._write_val_axis(args)

        # Write the secondary axis for the secondary chart.
        if second_chart and second_chart.is_secondary:
            args = {
                "x_axis": second_chart.x2_axis,
                "y_axis": second_chart.y2_axis,
                "axis_ids": second_chart.axis2_ids,
            }

            second_chart._write_val_axis(args)

        if self.date_category:
            self._write_date_axis(args)
        else:
            self._write_cat_axis(args)

        # Write the c:dTable element.
        self._write_d_table()

        # Write the c:spPr element for the plotarea formatting.
        self._write_sp_pr(self.plotarea)

        self._xml_end_tag("c:plotArea")

    def _write_layout(self, layout, layout_type):
        # Write the <c:layout> element.

        if not layout:
            # Automatic layout.
            self._xml_empty_tag("c:layout")
        else:
            # User defined manual layout.
            self._xml_start_tag("c:layout")
            self._write_manual_layout(layout, layout_type)
            self._xml_end_tag("c:layout")

    def _write_manual_layout(self, layout, layout_type):
        # Write the <c:manualLayout> element.
        self._xml_start_tag("c:manualLayout")

        # Plotarea has a layoutTarget element.
        if layout_type == "plot":
            self._xml_empty_tag("c:layoutTarget", [("val", "inner")])

        # Set the x, y positions.
        self._xml_empty_tag("c:xMode", [("val", "edge")])
        self._xml_empty_tag("c:yMode", [("val", "edge")])
        self._xml_empty_tag("c:x", [("val", layout["x"])])
        self._xml_empty_tag("c:y", [("val", layout["y"])])

        # For plotarea and legend set the width and height.
        if layout_type != "text":
            self._xml_empty_tag("c:w", [("val", layout["width"])])
            self._xml_empty_tag("c:h", [("val", layout["height"])])

        self._xml_end_tag("c:manualLayout")

    def _write_chart_type(self, options):
        # Write the chart type element. This method should be overridden
        # by the subclasses.
        return

    def _write_grouping(self, val):
        # Write the <c:grouping> element.
        attributes = [("val", val)]

        self._xml_empty_tag("c:grouping", attributes)

    def _write_series(self, series):
        # Write the series elements.
        self._write_ser(series)

    def _write_ser(self, series):
        # Write the <c:ser> element.
        index = self.series_index
        self.series_index += 1

        self._xml_start_tag("c:ser")

        # Write the c:idx element.
        self._write_idx(index)

        # Write the c:order element.
        self._write_order(index)

        # Write the series name.
        self._write_series_name(series)

        # Write the c:spPr element.
        self._write_sp_pr(series)

        # Write the c:marker element.
        self._write_marker(series["marker"])

        # Write the c:invertIfNegative element.
        self._write_c_invert_if_negative(series["invert_if_neg"])

        # Write the c:dPt element.
        self._write_d_pt(series["points"])

        # Write the c:dLbls element.
        self._write_d_lbls(series["labels"])

        # Write the c:trendline element.
        self._write_trendline(series["trendline"])

        # Write the c:errBars element.
        self._write_error_bars(series["error_bars"])

        # Write the c:cat element.
        self._write_cat(series)

        # Write the c:val element.
        self._write_val(series)

        # Write the c:smooth element.
        if self.smooth_allowed:
            self._write_c_smooth(series["smooth"])

        # Write the c:extLst element.
        if series.get("inverted_color"):
            self._write_c_ext_lst_inverted_color(series["inverted_color"])

        self._xml_end_tag("c:ser")

    def _write_c_ext_lst_inverted_color(self, color):
        # Write the <c:extLst> element for the inverted fill color.

        uri = "{6F2FDCE9-48DA-4B69-8628-5D25D57E5C99}"
        xmlns_c_14 = "http://schemas.microsoft.com/office/drawing/2007/8/2/chart"

        attributes1 = [
            ("uri", uri),
            ("xmlns:c14", xmlns_c_14),
        ]

        attributes2 = [("xmlns:c14", xmlns_c_14)]

        self._xml_start_tag("c:extLst")
        self._xml_start_tag("c:ext", attributes1)
        self._xml_start_tag("c14:invertSolidFillFmt")
        self._xml_start_tag("c14:spPr", attributes2)

        self._write_a_solid_fill({"color": color})

        self._xml_end_tag("c14:spPr")
        self._xml_end_tag("c14:invertSolidFillFmt")
        self._xml_end_tag("c:ext")
        self._xml_end_tag("c:extLst")

    def _write_c_ext_lst_display_na(self):
        # Write the <c:extLst> element for the display NA as empty cell option.

        uri = "{56B9EC1D-385E-4148-901F-78D8002777C0}"
        xmlns_c_16 = "http://schemas.microsoft.com/office/drawing/2017/03/chart"

        attributes1 = [
            ("uri", uri),
            ("xmlns:c16r3", xmlns_c_16),
        ]

        attributes2 = [("val", 1)]

        self._xml_start_tag("c:extLst")
        self._xml_start_tag("c:ext", attributes1)
        self._xml_start_tag("c16r3:dataDisplayOptions16")
        self._xml_empty_tag("c16r3:dispNaAsBlank", attributes2)
        self._xml_end_tag("c16r3:dataDisplayOptions16")
        self._xml_end_tag("c:ext")
        self._xml_end_tag("c:extLst")

    def _write_idx(self, val):
        # Write the <c:idx> element.

        attributes = [("val", val)]

        self._xml_empty_tag("c:idx", attributes)

    def _write_order(self, val):
        # Write the <c:order> element.

        attributes = [("val", val)]

        self._xml_empty_tag("c:order", attributes)

    def _write_series_name(self, series):
        # Write the series name.

        if series["name_formula"] is not None:
            self._write_tx_formula(series["name_formula"], series["name_id"])
        elif series["name"] is not None:
            self._write_tx_value(series["name"])

    def _write_c_smooth(self, smooth):
        # Write the <c:smooth> element.

        if smooth:
            self._xml_empty_tag("c:smooth", [("val", "1")])

    def _write_cat(self, series):
        # Write the <c:cat> element.
        formula = series["categories"]
        data_id = series["cat_data_id"]
        data = None

        if data_id is not None:
            data = self.formula_data[data_id]

        # Ignore <c:cat> elements for charts without category values.
        if not formula:
            return

        self._xml_start_tag("c:cat")

        # Check the type of cached data.
        cat_type = self._get_data_type(data)

        if cat_type == "str":
            self.cat_has_num_fmt = 0
            # Write the c:numRef element.
            self._write_str_ref(formula, data, cat_type)

        elif cat_type == "multi_str":
            self.cat_has_num_fmt = 0
            # Write the c:numRef element.
            self._write_multi_lvl_str_ref(formula, data)

        else:
            self.cat_has_num_fmt = 1
            # Write the c:numRef element.
            self._write_num_ref(formula, data, cat_type)

        self._xml_end_tag("c:cat")

    def _write_val(self, series):
        # Write the <c:val> element.
        formula = series["values"]
        data_id = series["val_data_id"]
        data = self.formula_data[data_id]

        self._xml_start_tag("c:val")

        # Unlike Cat axes data should only be numeric.
        # Write the c:numRef element.
        self._write_num_ref(formula, data, "num")

        self._xml_end_tag("c:val")

    def _write_num_ref(self, formula, data, ref_type):
        # Write the <c:numRef> element.
        self._xml_start_tag("c:numRef")

        # Write the c:f element.
        self._write_series_formula(formula)

        if ref_type == "num":
            # Write the c:numCache element.
            self._write_num_cache(data)
        elif ref_type == "str":
            # Write the c:strCache element.
            self._write_str_cache(data)

        self._xml_end_tag("c:numRef")

    def _write_str_ref(self, formula, data, ref_type):
        # Write the <c:strRef> element.

        self._xml_start_tag("c:strRef")

        # Write the c:f element.
        self._write_series_formula(formula)

        if ref_type == "num":
            # Write the c:numCache element.
            self._write_num_cache(data)
        elif ref_type == "str":
            # Write the c:strCache element.
            self._write_str_cache(data)

        self._xml_end_tag("c:strRef")

    def _write_multi_lvl_str_ref(self, formula, data):
        # Write the <c:multiLvlStrRef> element.

        if not data:
            return

        self._xml_start_tag("c:multiLvlStrRef")

        # Write the c:f element.
        self._write_series_formula(formula)

        self._xml_start_tag("c:multiLvlStrCache")

        # Write the c:ptCount element.
        count = len(data[-1])
        self._write_pt_count(count)

        for cat_data in reversed(data):
            self._xml_start_tag("c:lvl")

            for i, point in enumerate(cat_data):
                # Write the c:pt element.
                self._write_pt(i, cat_data[i])

            self._xml_end_tag("c:lvl")

        self._xml_end_tag("c:multiLvlStrCache")
        self._xml_end_tag("c:multiLvlStrRef")

    def _write_series_formula(self, formula):
        # Write the <c:f> element.

        # Strip the leading '=' from the formula.
        if formula.startswith("="):
            formula = formula.lstrip("=")

        self._xml_data_element("c:f", formula)

    def _write_axis_ids(self, args):
        # Write the <c:axId> elements for the primary or secondary axes.

        # Generate the axis ids.
        self._add_axis_ids(args)

        if args["primary_axes"]:
            # Write the axis ids for the primary axes.
            self._write_axis_id(self.axis_ids[0])
            self._write_axis_id(self.axis_ids[1])
        else:
            # Write the axis ids for the secondary axes.
            self._write_axis_id(self.axis2_ids[0])
            self._write_axis_id(self.axis2_ids[1])

    def _write_axis_id(self, val):
        # Write the <c:axId> element.

        attributes = [("val", val)]

        self._xml_empty_tag("c:axId", attributes)

    def _write_cat_axis(self, args):
        # Write the <c:catAx> element. Usually the X axis.
        x_axis = args["x_axis"]
        y_axis = args["y_axis"]
        axis_ids = args["axis_ids"]

        # If there are no axis_ids then we don't need to write this element.
        if axis_ids is None or not len(axis_ids):
            return

        position = self.cat_axis_position
        is_y_axis = self.horiz_cat_axis

        # Overwrite the default axis position with a user supplied value.
        if x_axis.get("position"):
            position = x_axis["position"]

        self._xml_start_tag("c:catAx")

        self._write_axis_id(axis_ids[0])

        # Write the c:scaling element.
        self._write_scaling(x_axis.get("reverse"), None, None, None)

        if not x_axis.get("visible"):
            self._write_delete(1)

        # Write the c:axPos element.
        self._write_axis_pos(position, y_axis.get("reverse"))

        # Write the c:majorGridlines element.
        self._write_major_gridlines(x_axis.get("major_gridlines"))

        # Write the c:minorGridlines element.
        self._write_minor_gridlines(x_axis.get("minor_gridlines"))

        # Write the axis title elements.
        if x_axis["formula"] is not None:
            self._write_title_formula(
                x_axis["formula"],
                x_axis["data_id"],
                is_y_axis,
                x_axis["name_font"],
                x_axis["name_layout"],
            )
        elif x_axis["name"] is not None:
            self._write_title_rich(
                x_axis["name"], is_y_axis, x_axis["name_font"], x_axis["name_layout"]
            )

        # Write the c:numFmt element.
        self._write_cat_number_format(x_axis)

        # Write the c:majorTickMark element.
        self._write_major_tick_mark(x_axis.get("major_tick_mark"))

        # Write the c:minorTickMark element.
        self._write_minor_tick_mark(x_axis.get("minor_tick_mark"))

        # Write the c:tickLblPos element.
        self._write_tick_label_pos(x_axis.get("label_position"))

        # Write the c:spPr element for the axis line.
        self._write_sp_pr(x_axis)

        # Write the axis font elements.
        self._write_axis_font(x_axis.get("num_font"))

        # Write the c:crossAx element.
        self._write_cross_axis(axis_ids[1])

        if self.show_crosses or x_axis.get("visible"):
            # Note, the category crossing comes from the value axis.
            if (
                y_axis.get("crossing") is None
                or y_axis.get("crossing") == "max"
                or y_axis["crossing"] == "min"
            ):
                # Write the c:crosses element.
                self._write_crosses(y_axis.get("crossing"))
            else:
                # Write the c:crossesAt element.
                self._write_c_crosses_at(y_axis.get("crossing"))

        # Write the c:auto element.
        if not x_axis.get("text_axis"):
            self._write_auto(1)

        # Write the c:labelAlign element.
        self._write_label_align(x_axis.get("label_align"))

        # Write the c:labelOffset element.
        self._write_label_offset(100)

        # Write the c:tickLblSkip element.
        self._write_c_tick_lbl_skip(x_axis.get("interval_unit"))

        # Write the c:tickMarkSkip element.
        self._write_c_tick_mark_skip(x_axis.get("interval_tick"))

        self._xml_end_tag("c:catAx")

    def _write_val_axis(self, args):
        # Write the <c:valAx> element. Usually the Y axis.
        x_axis = args["x_axis"]
        y_axis = args["y_axis"]
        axis_ids = args["axis_ids"]
        position = args.get("position", self.val_axis_position)
        is_y_axis = self.horiz_val_axis

        # If there are no axis_ids then we don't need to write this element.
        if axis_ids is None or not len(axis_ids):
            return

        # Overwrite the default axis position with a user supplied value.
        position = y_axis.get("position") or position

        self._xml_start_tag("c:valAx")

        self._write_axis_id(axis_ids[1])

        # Write the c:scaling element.
        self._write_scaling(
            y_axis.get("reverse"),
            y_axis.get("min"),
            y_axis.get("max"),
            y_axis.get("log_base"),
        )

        if not y_axis.get("visible"):
            self._write_delete(1)

        # Write the c:axPos element.
        self._write_axis_pos(position, x_axis.get("reverse"))

        # Write the c:majorGridlines element.
        self._write_major_gridlines(y_axis.get("major_gridlines"))

        # Write the c:minorGridlines element.
        self._write_minor_gridlines(y_axis.get("minor_gridlines"))

        # Write the axis title elements.
        if y_axis["formula"] is not None:
            self._write_title_formula(
                y_axis["formula"],
                y_axis["data_id"],
                is_y_axis,
                y_axis["name_font"],
                y_axis["name_layout"],
            )
        elif y_axis["name"] is not None:
            self._write_title_rich(
                y_axis["name"],
                is_y_axis,
                y_axis.get("name_font"),
                y_axis.get("name_layout"),
            )

        # Write the c:numberFormat element.
        self._write_number_format(y_axis)

        # Write the c:majorTickMark element.
        self._write_major_tick_mark(y_axis.get("major_tick_mark"))

        # Write the c:minorTickMark element.
        self._write_minor_tick_mark(y_axis.get("minor_tick_mark"))

        # Write the c:tickLblPos element.
        self._write_tick_label_pos(y_axis.get("label_position"))

        # Write the c:spPr element for the axis line.
        self._write_sp_pr(y_axis)

        # Write the axis font elements.
        self._write_axis_font(y_axis.get("num_font"))

        # Write the c:crossAx element.
        self._write_cross_axis(axis_ids[0])

        # Note, the category crossing comes from the value axis.
        if (
            x_axis.get("crossing") is None
            or x_axis["crossing"] == "max"
            or x_axis["crossing"] == "min"
        ):
            # Write the c:crosses element.
            self._write_crosses(x_axis.get("crossing"))
        else:
            # Write the c:crossesAt element.
            self._write_c_crosses_at(x_axis.get("crossing"))

        # Write the c:crossBetween element.
        self._write_cross_between(x_axis.get("position_axis"))

        # Write the c:majorUnit element.
        self._write_c_major_unit(y_axis.get("major_unit"))

        # Write the c:minorUnit element.
        self._write_c_minor_unit(y_axis.get("minor_unit"))

        # Write the c:dispUnits element.
        self._write_disp_units(
            y_axis.get("display_units"), y_axis.get("display_units_visible")
        )

        self._xml_end_tag("c:valAx")

    def _write_cat_val_axis(self, args):
        # Write the <c:valAx> element. This is for the second valAx
        # in scatter plots. Usually the X axis.
        x_axis = args["x_axis"]
        y_axis = args["y_axis"]
        axis_ids = args["axis_ids"]
        position = args["position"] or self.val_axis_position
        is_y_axis = self.horiz_val_axis

        # If there are no axis_ids then we don't need to write this element.
        if axis_ids is None or not len(axis_ids):
            return

        # Overwrite the default axis position with a user supplied value.
        position = x_axis.get("position") or position

        self._xml_start_tag("c:valAx")

        self._write_axis_id(axis_ids[0])

        # Write the c:scaling element.
        self._write_scaling(
            x_axis.get("reverse"),
            x_axis.get("min"),
            x_axis.get("max"),
            x_axis.get("log_base"),
        )

        if not x_axis.get("visible"):
            self._write_delete(1)

        # Write the c:axPos element.
        self._write_axis_pos(position, y_axis.get("reverse"))

        # Write the c:majorGridlines element.
        self._write_major_gridlines(x_axis.get("major_gridlines"))

        # Write the c:minorGridlines element.
        self._write_minor_gridlines(x_axis.get("minor_gridlines"))

        # Write the axis title elements.
        if x_axis["formula"] is not None:
            self._write_title_formula(
                x_axis["formula"],
                x_axis["data_id"],
                is_y_axis,
                x_axis["name_font"],
                x_axis["name_layout"],
            )
        elif x_axis["name"] is not None:
            self._write_title_rich(
                x_axis["name"], is_y_axis, x_axis["name_font"], x_axis["name_layout"]
            )

        # Write the c:numberFormat element.
        self._write_number_format(x_axis)

        # Write the c:majorTickMark element.
        self._write_major_tick_mark(x_axis.get("major_tick_mark"))

        # Write the c:minorTickMark element.
        self._write_minor_tick_mark(x_axis.get("minor_tick_mark"))

        # Write the c:tickLblPos element.
        self._write_tick_label_pos(x_axis.get("label_position"))

        # Write the c:spPr element for the axis line.
        self._write_sp_pr(x_axis)

        # Write the axis font elements.
        self._write_axis_font(x_axis.get("num_font"))

        # Write the c:crossAx element.
        self._write_cross_axis(axis_ids[1])

        # Note, the category crossing comes from the value axis.
        if (
            y_axis.get("crossing") is None
            or y_axis["crossing"] == "max"
            or y_axis["crossing"] == "min"
        ):
            # Write the c:crosses element.
            self._write_crosses(y_axis.get("crossing"))
        else:
            # Write the c:crossesAt element.
            self._write_c_crosses_at(y_axis.get("crossing"))

        # Write the c:crossBetween element.
        self._write_cross_between(y_axis.get("position_axis"))

        # Write the c:majorUnit element.
        self._write_c_major_unit(x_axis.get("major_unit"))

        # Write the c:minorUnit element.
        self._write_c_minor_unit(x_axis.get("minor_unit"))

        # Write the c:dispUnits element.
        self._write_disp_units(
            x_axis.get("display_units"), x_axis.get("display_units_visible")
        )

        self._xml_end_tag("c:valAx")

    def _write_date_axis(self, args):
        # Write the <c:dateAx> element. Usually the X axis.
        x_axis = args["x_axis"]
        y_axis = args["y_axis"]
        axis_ids = args["axis_ids"]

        # If there are no axis_ids then we don't need to write this element.
        if axis_ids is None or not len(axis_ids):
            return

        position = self.cat_axis_position

        # Overwrite the default axis position with a user supplied value.
        position = x_axis.get("position") or position

        self._xml_start_tag("c:dateAx")

        self._write_axis_id(axis_ids[0])

        # Write the c:scaling element.
        self._write_scaling(
            x_axis.get("reverse"),
            x_axis.get("min"),
            x_axis.get("max"),
            x_axis.get("log_base"),
        )

        if not x_axis.get("visible"):
            self._write_delete(1)

        # Write the c:axPos element.
        self._write_axis_pos(position, y_axis.get("reverse"))

        # Write the c:majorGridlines element.
        self._write_major_gridlines(x_axis.get("major_gridlines"))

        # Write the c:minorGridlines element.
        self._write_minor_gridlines(x_axis.get("minor_gridlines"))

        # Write the axis title elements.
        if x_axis["formula"] is not None:
            self._write_title_formula(
                x_axis["formula"],
                x_axis["data_id"],
                None,
                x_axis["name_font"],
                x_axis["name_layout"],
            )
        elif x_axis["name"] is not None:
            self._write_title_rich(
                x_axis["name"], None, x_axis["name_font"], x_axis["name_layout"]
            )

        # Write the c:numFmt element.
        self._write_number_format(x_axis)

        # Write the c:majorTickMark element.
        self._write_major_tick_mark(x_axis.get("major_tick_mark"))

        # Write the c:minorTickMark element.
        self._write_minor_tick_mark(x_axis.get("minor_tick_mark"))

        # Write the c:tickLblPos element.
        self._write_tick_label_pos(x_axis.get("label_position"))

        # Write the c:spPr element for the axis line.
        self._write_sp_pr(x_axis)

        # Write the axis font elements.
        self._write_axis_font(x_axis.get("num_font"))

        # Write the c:crossAx element.
        self._write_cross_axis(axis_ids[1])

        if self.show_crosses or x_axis.get("visible"):
            # Note, the category crossing comes from the value axis.
            if (
                y_axis.get("crossing") is None
                or y_axis.get("crossing") == "max"
                or y_axis["crossing"] == "min"
            ):
                # Write the c:crosses element.
                self._write_crosses(y_axis.get("crossing"))
            else:
                # Write the c:crossesAt element.
                self._write_c_crosses_at(y_axis.get("crossing"))

        # Write the c:auto element.
        self._write_auto(1)

        # Write the c:labelOffset element.
        self._write_label_offset(100)

        # Write the c:tickLblSkip element.
        self._write_c_tick_lbl_skip(x_axis.get("interval_unit"))

        # Write the c:tickMarkSkip element.
        self._write_c_tick_mark_skip(x_axis.get("interval_tick"))

        # Write the c:majorUnit element.
        self._write_c_major_unit(x_axis.get("major_unit"))

        # Write the c:majorTimeUnit element.
        if x_axis.get("major_unit"):
            self._write_c_major_time_unit(x_axis["major_unit_type"])

        # Write the c:minorUnit element.
        self._write_c_minor_unit(x_axis.get("minor_unit"))

        # Write the c:minorTimeUnit element.
        if x_axis.get("minor_unit"):
            self._write_c_minor_time_unit(x_axis["minor_unit_type"])

        self._xml_end_tag("c:dateAx")

    def _write_scaling(self, reverse, min_val, max_val, log_base):
        # Write the <c:scaling> element.

        self._xml_start_tag("c:scaling")

        # Write the c:logBase element.
        self._write_c_log_base(log_base)

        # Write the c:orientation element.
        self._write_orientation(reverse)

        # Write the c:max element.
        self._write_c_max(max_val)

        # Write the c:min element.
        self._write_c_min(min_val)

        self._xml_end_tag("c:scaling")

    def _write_c_log_base(self, val):
        # Write the <c:logBase> element.

        if not val:
            return

        attributes = [("val", val)]

        self._xml_empty_tag("c:logBase", attributes)

    def _write_orientation(self, reverse):
        # Write the <c:orientation> element.
        val = "minMax"

        if reverse:
            val = "maxMin"

        attributes = [("val", val)]

        self._xml_empty_tag("c:orientation", attributes)

    def _write_c_max(self, max_val):
        # Write the <c:max> element.

        if max_val is None:
            return

        attributes = [("val", max_val)]

        self._xml_empty_tag("c:max", attributes)

    def _write_c_min(self, min_val):
        # Write the <c:min> element.

        if min_val is None:
            return

        attributes = [("val", min_val)]

        self._xml_empty_tag("c:min", attributes)

    def _write_axis_pos(self, val, reverse):
        # Write the <c:axPos> element.

        if reverse:
            if val == "l":
                val = "r"
            if val == "b":
                val = "t"

        attributes = [("val", val)]

        self._xml_empty_tag("c:axPos", attributes)

    def _write_number_format(self, axis):
        # Write the <c:numberFormat> element. Note: It is assumed that if
        # a user defined number format is supplied (i.e., non-default) then
        # the sourceLinked attribute is 0.
        # The user can override this if required.
        format_code = axis.get("num_format")
        source_linked = 1

        # Check if a user defined number format has been set.
        if format_code is not None and format_code != axis["defaults"]["num_format"]:
            source_linked = 0

        # User override of sourceLinked.
        if axis.get("num_format_linked"):
            source_linked = 1

        attributes = [
            ("formatCode", format_code),
            ("sourceLinked", source_linked),
        ]

        self._xml_empty_tag("c:numFmt", attributes)

    def _write_cat_number_format(self, axis):
        # Write the <c:numFmt> element. Special case handler for category
        # axes which don't always have a number format.
        format_code = axis.get("num_format")
        source_linked = 1
        default_format = 1

        # Check if a user defined number format has been set.
        if format_code is not None and format_code != axis["defaults"]["num_format"]:
            source_linked = 0
            default_format = 0

        # User override of sourceLinked.
        if axis.get("num_format_linked"):
            source_linked = 1

        # Skip if cat doesn't have a num format (unless it is non-default).
        if not self.cat_has_num_fmt and default_format:
            return

        attributes = [
            ("formatCode", format_code),
            ("sourceLinked", source_linked),
        ]

        self._xml_empty_tag("c:numFmt", attributes)

    def _write_data_label_number_format(self, format_code):
        # Write the <c:numberFormat> element for data labels.
        source_linked = 0

        attributes = [
            ("formatCode", format_code),
            ("sourceLinked", source_linked),
        ]

        self._xml_empty_tag("c:numFmt", attributes)

    def _write_major_tick_mark(self, val):
        # Write the <c:majorTickMark> element.

        if not val:
            return

        attributes = [("val", val)]

        self._xml_empty_tag("c:majorTickMark", attributes)

    def _write_minor_tick_mark(self, val):
        # Write the <c:minorTickMark> element.

        if not val:
            return

        attributes = [("val", val)]

        self._xml_empty_tag("c:minorTickMark", attributes)

    def _write_tick_label_pos(self, val=None):
        # Write the <c:tickLblPos> element.
        if val is None or val == "next_to":
            val = "nextTo"

        attributes = [("val", val)]

        self._xml_empty_tag("c:tickLblPos", attributes)

    def _write_cross_axis(self, val):
        # Write the <c:crossAx> element.

        attributes = [("val", val)]

        self._xml_empty_tag("c:crossAx", attributes)

    def _write_crosses(self, val=None):
        # Write the <c:crosses> element.
        if val is None:
            val = "autoZero"

        attributes = [("val", val)]

        self._xml_empty_tag("c:crosses", attributes)

    def _write_c_crosses_at(self, val):
        # Write the <c:crossesAt> element.

        attributes = [("val", val)]

        self._xml_empty_tag("c:crossesAt", attributes)

    def _write_auto(self, val):
        # Write the <c:auto> element.

        attributes = [("val", val)]

        self._xml_empty_tag("c:auto", attributes)

    def _write_label_align(self, val=None):
        # Write the <c:labelAlign> element.

        if val is None:
            val = "ctr"

        if val == "right":
            val = "r"

        if val == "left":
            val = "l"

        attributes = [("val", val)]

        self._xml_empty_tag("c:lblAlgn", attributes)

    def _write_label_offset(self, val):
        # Write the <c:labelOffset> element.

        attributes = [("val", val)]

        self._xml_empty_tag("c:lblOffset", attributes)

    def _write_c_tick_lbl_skip(self, val):
        # Write the <c:tickLblSkip> element.
        if val is None:
            return

        attributes = [("val", val)]

        self._xml_empty_tag("c:tickLblSkip", attributes)

    def _write_c_tick_mark_skip(self, val):
        # Write the <c:tickMarkSkip> element.
        if val is None:
            return

        attributes = [("val", val)]

        self._xml_empty_tag("c:tickMarkSkip", attributes)

    def _write_major_gridlines(self, gridlines):
        # Write the <c:majorGridlines> element.

        if not gridlines:
            return

        if not gridlines["visible"]:
            return

        if gridlines["line"]["defined"]:
            self._xml_start_tag("c:majorGridlines")

            # Write the c:spPr element.
            self._write_sp_pr(gridlines)

            self._xml_end_tag("c:majorGridlines")
        else:
            self._xml_empty_tag("c:majorGridlines")

    def _write_minor_gridlines(self, gridlines):
        # Write the <c:minorGridlines> element.

        if not gridlines:
            return

        if not gridlines["visible"]:
            return

        if gridlines["line"]["defined"]:
            self._xml_start_tag("c:minorGridlines")

            # Write the c:spPr element.
            self._write_sp_pr(gridlines)

            self._xml_end_tag("c:minorGridlines")
        else:
            self._xml_empty_tag("c:minorGridlines")

    def _write_cross_between(self, val):
        # Write the <c:crossBetween> element.
        if val is None:
            val = self.cross_between

        attributes = [("val", val)]

        self._xml_empty_tag("c:crossBetween", attributes)

    def _write_c_major_unit(self, val):
        # Write the <c:majorUnit> element.

        if not val:
            return

        attributes = [("val", val)]

        self._xml_empty_tag("c:majorUnit", attributes)

    def _write_c_minor_unit(self, val):
        # Write the <c:minorUnit> element.

        if not val:
            return

        attributes = [("val", val)]

        self._xml_empty_tag("c:minorUnit", attributes)

    def _write_c_major_time_unit(self, val=None):
        # Write the <c:majorTimeUnit> element.
        if val is None:
            val = "days"

        attributes = [("val", val)]

        self._xml_empty_tag("c:majorTimeUnit", attributes)

    def _write_c_minor_time_unit(self, val=None):
        # Write the <c:minorTimeUnit> element.
        if val is None:
            val = "days"

        attributes = [("val", val)]

        self._xml_empty_tag("c:minorTimeUnit", attributes)

    def _write_legend(self):
        # Write the <c:legend> element.
        legend = self.legend
        position = legend.get("position", "right")
        font = legend.get("font")
        delete_series = []
        overlay = 0

        if legend.get("delete_series") and isinstance(legend["delete_series"], list):
            delete_series = legend["delete_series"]

        if position.startswith("overlay_"):
            position = position.replace("overlay_", "")
            overlay = 1

        allowed = {
            "right": "r",
            "left": "l",
            "top": "t",
            "bottom": "b",
            "top_right": "tr",
        }

        if position == "none":
            return

        if position not in allowed:
            return

        position = allowed[position]

        self._xml_start_tag("c:legend")

        # Write the c:legendPos element.
        self._write_legend_pos(position)

        # Remove series labels from the legend.
        for index in delete_series:
            # Write the c:legendEntry element.
            self._write_legend_entry(index)

        # Write the c:layout element.
        self._write_layout(legend.get("layout"), "legend")

        # Write the c:overlay element.
        if overlay:
            self._write_overlay()

        if font:
            self._write_tx_pr(font)

        # Write the c:spPr element.
        self._write_sp_pr(legend)

        self._xml_end_tag("c:legend")

    def _write_legend_pos(self, val):
        # Write the <c:legendPos> element.

        attributes = [("val", val)]

        self._xml_empty_tag("c:legendPos", attributes)

    def _write_legend_entry(self, index):
        # Write the <c:legendEntry> element.

        self._xml_start_tag("c:legendEntry")

        # Write the c:idx element.
        self._write_idx(index)

        # Write the c:delete element.
        self._write_delete(1)

        self._xml_end_tag("c:legendEntry")

    def _write_overlay(self):
        # Write the <c:overlay> element.
        val = 1

        attributes = [("val", val)]

        self._xml_empty_tag("c:overlay", attributes)

    def _write_plot_vis_only(self):
        # Write the <c:plotVisOnly> element.
        val = 1

        # Ignore this element if we are plotting hidden data.
        if self.show_hidden:
            return

        attributes = [("val", val)]

        self._xml_empty_tag("c:plotVisOnly", attributes)

    def _write_print_settings(self):
        # Write the <c:printSettings> element.
        self._xml_start_tag("c:printSettings")

        # Write the c:headerFooter element.
        self._write_header_footer()

        # Write the c:pageMargins element.
        self._write_page_margins()

        # Write the c:pageSetup element.
        self._write_page_setup()

        self._xml_end_tag("c:printSettings")

    def _write_header_footer(self):
        # Write the <c:headerFooter> element.
        self._xml_empty_tag("c:headerFooter")

    def _write_page_margins(self):
        # Write the <c:pageMargins> element.
        bottom = 0.75
        left = 0.7
        right = 0.7
        top = 0.75
        header = 0.3
        footer = 0.3

        attributes = [
            ("b", bottom),
            ("l", left),
            ("r", right),
            ("t", top),
            ("header", header),
            ("footer", footer),
        ]

        self._xml_empty_tag("c:pageMargins", attributes)

    def _write_page_setup(self):
        # Write the <c:pageSetup> element.
        self._xml_empty_tag("c:pageSetup")

    def _write_c_auto_title_deleted(self):
        # Write the <c:autoTitleDeleted> element.
        self._xml_empty_tag("c:autoTitleDeleted", [("val", 1)])

    def _write_title_rich(self, title, is_y_axis, font, layout, overlay=False):
        # Write the <c:title> element for a rich string.

        self._xml_start_tag("c:title")

        # Write the c:tx element.
        self._write_tx_rich(title, is_y_axis, font)

        # Write the c:layout element.
        self._write_layout(layout, "text")

        # Write the c:overlay element.
        if overlay:
            self._write_overlay()

        self._xml_end_tag("c:title")

    def _write_title_formula(
        self, title, data_id, is_y_axis, font, layout, overlay=False
    ):
        # Write the <c:title> element for a rich string.

        self._xml_start_tag("c:title")

        # Write the c:tx element.
        self._write_tx_formula(title, data_id)

        # Write the c:layout element.
        self._write_layout(layout, "text")

        # Write the c:overlay element.
        if overlay:
            self._write_overlay()

        # Write the c:txPr element.
        self._write_tx_pr(font, is_y_axis)

        self._xml_end_tag("c:title")

    def _write_tx_rich(self, title, is_y_axis, font):
        # Write the <c:tx> element.

        self._xml_start_tag("c:tx")

        # Write the c:rich element.
        self._write_rich(title, font, is_y_axis, ignore_rich_pr=False)

        self._xml_end_tag("c:tx")

    def _write_tx_value(self, title):
        # Write the <c:tx> element with a value such as for series names.

        self._xml_start_tag("c:tx")

        # Write the c:v element.
        self._write_v(title)

        self._xml_end_tag("c:tx")

    def _write_tx_formula(self, title, data_id):
        # Write the <c:tx> element.
        data = None

        if data_id is not None:
            data = self.formula_data[data_id]

        self._xml_start_tag("c:tx")

        # Write the c:strRef element.
        self._write_str_ref(title, data, "str")

        self._xml_end_tag("c:tx")

    def _write_rich(self, title, font, is_y_axis, ignore_rich_pr):
        # Write the <c:rich> element.

        if font and font.get("rotation") is not None:
            rotation = font["rotation"]
        else:
            rotation = None

        self._xml_start_tag("c:rich")

        # Write the a:bodyPr element.
        self._write_a_body_pr(rotation, is_y_axis)

        # Write the a:lstStyle element.
        self._write_a_lst_style()

        # Write the a:p element.
        self._write_a_p_rich(title, font, ignore_rich_pr)

        self._xml_end_tag("c:rich")

    def _write_a_body_pr(self, rotation, is_y_axis):
        # Write the <a:bodyPr> element.
        attributes = []

        if rotation is None and is_y_axis:
            rotation = -5400000

        if rotation is not None:
            if rotation == 16200000:
                # 270 deg/stacked angle.
                attributes.append(("rot", 0))
                attributes.append(("vert", "wordArtVert"))
            elif rotation == 16260000:
                # 271 deg/East Asian vertical.
                attributes.append(("rot", 0))
                attributes.append(("vert", "eaVert"))
            else:
                attributes.append(("rot", rotation))
                attributes.append(("vert", "horz"))

        self._xml_empty_tag("a:bodyPr", attributes)

    def _write_a_lst_style(self):
        # Write the <a:lstStyle> element.
        self._xml_empty_tag("a:lstStyle")

    def _write_a_p_rich(self, title, font, ignore_rich_pr):
        # Write the <a:p> element for rich string titles.

        self._xml_start_tag("a:p")

        # Write the a:pPr element.
        if not ignore_rich_pr:
            self._write_a_p_pr_rich(font)

        # Write the a:r element.
        self._write_a_r(title, font)

        self._xml_end_tag("a:p")

    def _write_a_p_formula(self, font):
        # Write the <a:p> element for formula titles.

        self._xml_start_tag("a:p")

        # Write the a:pPr element.
        self._write_a_p_pr_rich(font)

        # Write the a:endParaRPr element.
        self._write_a_end_para_rpr()

        self._xml_end_tag("a:p")

    def _write_a_p_pr_rich(self, font):
        # Write the <a:pPr> element for rich string titles.

        self._xml_start_tag("a:pPr")

        # Write the a:defRPr element.
        self._write_a_def_rpr(font)

        self._xml_end_tag("a:pPr")

    def _write_a_def_rpr(self, font):
        # Write the <a:defRPr> element.
        has_color = 0

        style_attributes = Shape._get_font_style_attributes(font)
        latin_attributes = Shape._get_font_latin_attributes(font)

        if font and font.get("color") is not None:
            has_color = 1

        if latin_attributes or has_color:
            self._xml_start_tag("a:defRPr", style_attributes)

            if has_color:
                self._write_a_solid_fill({"color": font["color"]})

            if latin_attributes:
                self._write_a_latin(latin_attributes)

            self._xml_end_tag("a:defRPr")
        else:
            self._xml_empty_tag("a:defRPr", style_attributes)

    def _write_a_end_para_rpr(self):
        # Write the <a:endParaRPr> element.
        lang = "en-US"

        attributes = [("lang", lang)]

        self._xml_empty_tag("a:endParaRPr", attributes)

    def _write_a_r(self, title, font):
        # Write the <a:r> element.

        self._xml_start_tag("a:r")

        # Write the a:rPr element.
        self._write_a_r_pr(font)

        # Write the a:t element.
        self._write_a_t(title)

        self._xml_end_tag("a:r")

    def _write_a_r_pr(self, font):
        # Write the <a:rPr> element.
        has_color = 0
        lang = "en-US"

        style_attributes = Shape._get_font_style_attributes(font)
        latin_attributes = Shape._get_font_latin_attributes(font)

        if font and font["color"] is not None:
            has_color = 1

        # Add the lang type to the attributes.
        style_attributes.insert(0, ("lang", lang))

        if latin_attributes or has_color:
            self._xml_start_tag("a:rPr", style_attributes)

            if has_color:
                self._write_a_solid_fill({"color": font["color"]})

            if latin_attributes:
                self._write_a_latin(latin_attributes)

            self._xml_end_tag("a:rPr")
        else:
            self._xml_empty_tag("a:rPr", style_attributes)

    def _write_a_t(self, title):
        # Write the <a:t> element.

        self._xml_data_element("a:t", title)

    def _write_tx_pr(self, font, is_y_axis=False):
        # Write the <c:txPr> element.

        if font and font.get("rotation") is not None:
            rotation = font["rotation"]
        else:
            rotation = None

        self._xml_start_tag("c:txPr")

        # Write the a:bodyPr element.
        self._write_a_body_pr(rotation, is_y_axis)

        # Write the a:lstStyle element.
        self._write_a_lst_style()

        # Write the a:p element.
        self._write_a_p_formula(font)

        self._xml_end_tag("c:txPr")

    def _write_marker(self, marker):
        # Write the <c:marker> element.
        if marker is None:
            marker = self.default_marker

        if not marker:
            return

        if marker["type"] == "automatic":
            return

        self._xml_start_tag("c:marker")

        # Write the c:symbol element.
        self._write_symbol(marker["type"])

        # Write the c:size element.
        if marker.get("size"):
            self._write_marker_size(marker["size"])

        # Write the c:spPr element.
        self._write_sp_pr(marker)

        self._xml_end_tag("c:marker")

    def _write_marker_size(self, val):
        # Write the <c:size> element.

        attributes = [("val", val)]

        self._xml_empty_tag("c:size", attributes)

    def _write_symbol(self, val):
        # Write the <c:symbol> element.

        attributes = [("val", val)]

        self._xml_empty_tag("c:symbol", attributes)

    def _write_sp_pr(self, series):
        # Write the <c:spPr> element.

        if not self._has_fill_formatting(series):
            return

        self._xml_start_tag("c:spPr")

        # Write the fill elements for solid charts such as pie and bar.
        if series.get("fill") and series["fill"]["defined"]:
            if "none" in series["fill"]:
                # Write the a:noFill element.
                self._write_a_no_fill()
            else:
                # Write the a:solidFill element.
                self._write_a_solid_fill(series["fill"])

        if series.get("pattern"):
            # Write the a:gradFill element.
            self._write_a_patt_fill(series["pattern"])

        if series.get("gradient"):
            # Write the a:gradFill element.
            self._write_a_grad_fill(series["gradient"])

        # Write the a:ln element.
        if series.get("line") and series["line"]["defined"]:
            self._write_a_ln(series["line"])

        self._xml_end_tag("c:spPr")

    def _write_a_ln(self, line):
        # Write the <a:ln> element.
        attributes = []

        # Add the line width as an attribute.
        width = line.get("width")

        if width is not None:
            # Round width to nearest 0.25, like Excel.
            width = int((width + 0.125) * 4) / 4.0

            # Convert to internal units.
            width = int(0.5 + (12700 * width))

            attributes = [("w", width)]

        if line.get("none") or line.get("color") or line.get("dash_type"):
            self._xml_start_tag("a:ln", attributes)

            # Write the line fill.
            if "none" in line:
                # Write the a:noFill element.
                self._write_a_no_fill()
            elif "color" in line:
                # Write the a:solidFill element.
                self._write_a_solid_fill(line)

            # Write the line/dash type.
            line_type = line.get("dash_type")
            if line_type:
                # Write the a:prstDash element.
                self._write_a_prst_dash(line_type)

            self._xml_end_tag("a:ln")
        else:
            self._xml_empty_tag("a:ln", attributes)

    def _write_a_no_fill(self):
        # Write the <a:noFill> element.
        self._xml_empty_tag("a:noFill")

    def _write_a_solid_fill(self, fill):
        # Write the <a:solidFill> element.

        self._xml_start_tag("a:solidFill")

        if "color" in fill:
            color = get_rgb_color(fill["color"])
            transparency = fill.get("transparency")
            # Write the a:srgbClr element.
            self._write_a_srgb_clr(color, transparency)

        self._xml_end_tag("a:solidFill")

    def _write_a_srgb_clr(self, val, transparency=None):
        # Write the <a:srgbClr> element.
        attributes = [("val", val)]

        if transparency:
            self._xml_start_tag("a:srgbClr", attributes)

            # Write the a:alpha element.
            self._write_a_alpha(transparency)

            self._xml_end_tag("a:srgbClr")
        else:
            self._xml_empty_tag("a:srgbClr", attributes)

    def _write_a_alpha(self, val):
        # Write the <a:alpha> element.

        val = int((100 - int(val)) * 1000)

        attributes = [("val", val)]

        self._xml_empty_tag("a:alpha", attributes)

    def _write_a_prst_dash(self, val):
        # Write the <a:prstDash> element.

        attributes = [("val", val)]

        self._xml_empty_tag("a:prstDash", attributes)

    def _write_trendline(self, trendline):
        # Write the <c:trendline> element.

        if not trendline:
            return

        self._xml_start_tag("c:trendline")

        # Write the c:name element.
        self._write_name(trendline.get("name"))

        # Write the c:spPr element.
        self._write_sp_pr(trendline)

        # Write the c:trendlineType element.
        self._write_trendline_type(trendline["type"])

        # Write the c:order element for polynomial trendlines.
        if trendline["type"] == "poly":
            self._write_trendline_order(trendline.get("order"))

        # Write the c:period element for moving average trendlines.
        if trendline["type"] == "movingAvg":
            self._write_period(trendline.get("period"))

        # Write the c:forward element.
        self._write_forward(trendline.get("forward"))

        # Write the c:backward element.
        self._write_backward(trendline.get("backward"))

        if "intercept" in trendline:
            # Write the c:intercept element.
            self._write_c_intercept(trendline["intercept"])

        if trendline.get("display_r_squared"):
            # Write the c:dispRSqr element.
            self._write_c_disp_rsqr()

        if trendline.get("display_equation"):
            # Write the c:dispEq element.
            self._write_c_disp_eq()

            # Write the c:trendlineLbl element.
            self._write_c_trendline_lbl(trendline)

        self._xml_end_tag("c:trendline")

    def _write_trendline_type(self, val):
        # Write the <c:trendlineType> element.

        attributes = [("val", val)]

        self._xml_empty_tag("c:trendlineType", attributes)

    def _write_name(self, data):
        # Write the <c:name> element.

        if data is None:
            return

        self._xml_data_element("c:name", data)

    def _write_trendline_order(self, val):
        # Write the <c:order> element.
        if val < 2:
            val = 2

        attributes = [("val", val)]

        self._xml_empty_tag("c:order", attributes)

    def _write_period(self, val):
        # Write the <c:period> element.
        if val < 2:
            val = 2

        attributes = [("val", val)]

        self._xml_empty_tag("c:period", attributes)

    def _write_forward(self, val):
        # Write the <c:forward> element.

        if not val:
            return

        attributes = [("val", val)]

        self._xml_empty_tag("c:forward", attributes)

    def _write_backward(self, val):
        # Write the <c:backward> element.

        if not val:
            return

        attributes = [("val", val)]

        self._xml_empty_tag("c:backward", attributes)

    def _write_c_intercept(self, val):
        # Write the <c:intercept> element.
        attributes = [("val", val)]

        self._xml_empty_tag("c:intercept", attributes)

    def _write_c_disp_eq(self):
        # Write the <c:dispEq> element.
        attributes = [("val", 1)]

        self._xml_empty_tag("c:dispEq", attributes)

    def _write_c_disp_rsqr(self):
        # Write the <c:dispRSqr> element.
        attributes = [("val", 1)]

        self._xml_empty_tag("c:dispRSqr", attributes)

    def _write_c_trendline_lbl(self, trendline):
        # Write the <c:trendlineLbl> element.
        self._xml_start_tag("c:trendlineLbl")

        # Write the c:layout element.
        self._write_layout(None, None)

        # Write the c:numFmt element.
        self._write_trendline_num_fmt()

        # Write the c:spPr element.
        self._write_sp_pr(trendline["label"])

        # Write the data label font elements.
        if trendline["label"]:
            font = trendline["label"].get("font")
            if font:
                self._write_axis_font(font)

        self._xml_end_tag("c:trendlineLbl")

    def _write_trendline_num_fmt(self):
        # Write the <c:numFmt> element.
        attributes = [
            ("formatCode", "General"),
            ("sourceLinked", 0),
        ]

        self._xml_empty_tag("c:numFmt", attributes)

    def _write_hi_low_lines(self):
        # Write the <c:hiLowLines> element.
        hi_low_lines = self.hi_low_lines

        if hi_low_lines is None:
            return

        if "line" in hi_low_lines and hi_low_lines["line"]["defined"]:
            self._xml_start_tag("c:hiLowLines")

            # Write the c:spPr element.
            self._write_sp_pr(hi_low_lines)

            self._xml_end_tag("c:hiLowLines")
        else:
            self._xml_empty_tag("c:hiLowLines")

    def _write_drop_lines(self):
        # Write the <c:dropLines> element.
        drop_lines = self.drop_lines

        if drop_lines is None:
            return

        if drop_lines["line"]["defined"]:
            self._xml_start_tag("c:dropLines")

            # Write the c:spPr element.
            self._write_sp_pr(drop_lines)

            self._xml_end_tag("c:dropLines")
        else:
            self._xml_empty_tag("c:dropLines")

    def _write_overlap(self, val):
        # Write the <c:overlap> element.

        if val is None:
            return

        attributes = [("val", val)]

        self._xml_empty_tag("c:overlap", attributes)

    def _write_num_cache(self, data):
        # Write the <c:numCache> element.
        if data:
            count = len(data)
        else:
            count = 0

        self._xml_start_tag("c:numCache")

        # Write the c:formatCode element.
        self._write_format_code("General")

        # Write the c:ptCount element.
        self._write_pt_count(count)

        for i in range(count):
            token = data[i]

            if token is None:
                continue

            try:
                float(token)
            except ValueError:
                # Write non-numeric data as 0.
                token = 0

            # Write the c:pt element.
            self._write_pt(i, token)

        self._xml_end_tag("c:numCache")

    def _write_str_cache(self, data):
        # Write the <c:strCache> element.
        count = len(data)

        self._xml_start_tag("c:strCache")

        # Write the c:ptCount element.
        self._write_pt_count(count)

        for i in range(count):
            # Write the c:pt element.
            self._write_pt(i, data[i])

        self._xml_end_tag("c:strCache")

    def _write_format_code(self, data):
        # Write the <c:formatCode> element.

        self._xml_data_element("c:formatCode", data)

    def _write_pt_count(self, val):
        # Write the <c:ptCount> element.

        attributes = [("val", val)]

        self._xml_empty_tag("c:ptCount", attributes)

    def _write_pt(self, idx, value):
        # Write the <c:pt> element.

        if value is None:
            return

        attributes = [("idx", idx)]

        self._xml_start_tag("c:pt", attributes)

        # Write the c:v element.
        self._write_v(value)

        self._xml_end_tag("c:pt")

    def _write_v(self, data):
        # Write the <c:v> element.

        self._xml_data_element("c:v", data)

    def _write_protection(self):
        # Write the <c:protection> element.
        if not self.protection:
            return

        self._xml_empty_tag("c:protection")

    def _write_d_pt(self, points):
        # Write the <c:dPt> elements.
        index = -1

        if not points:
            return

        for point in points:
            index += 1
            if not point:
                continue

            self._write_d_pt_point(index, point)

    def _write_d_pt_point(self, index, point):
        # Write an individual <c:dPt> element.

        self._xml_start_tag("c:dPt")

        # Write the c:idx element.
        self._write_idx(index)

        # Write the c:spPr element.
        self._write_sp_pr(point)

        self._xml_end_tag("c:dPt")

    def _write_d_lbls(self, labels):
        # Write the <c:dLbls> element.

        if not labels:
            return

        self._xml_start_tag("c:dLbls")

        # Write the custom c:dLbl elements.
        if labels.get("custom"):
            self._write_custom_labels(labels, labels["custom"])

        # Write the c:numFmt element.
        if labels.get("num_format"):
            self._write_data_label_number_format(labels["num_format"])

        # Write the c:spPr element for the plotarea formatting.
        self._write_sp_pr(labels)

        # Write the data label font elements.
        if labels.get("font"):
            self._write_axis_font(labels["font"])

        # Write the c:dLblPos element.
        if labels.get("position"):
            self._write_d_lbl_pos(labels["position"])

        # Write the c:showLegendKey element.
        if labels.get("legend_key"):
            self._write_show_legend_key()

        # Write the c:showVal element.
        if labels.get("value"):
            self._write_show_val()

        # Write the c:showCatName element.
        if labels.get("category"):
            self._write_show_cat_name()

        # Write the c:showSerName element.
        if labels.get("series_name"):
            self._write_show_ser_name()

        # Write the c:showPercent element.
        if labels.get("percentage"):
            self._write_show_percent()

        # Write the c:separator element.
        if labels.get("separator"):
            self._write_separator(labels["separator"])

        # Write the c:showLeaderLines element.
        if labels.get("leader_lines"):
            self._write_show_leader_lines()

        self._xml_end_tag("c:dLbls")

    def _write_custom_labels(self, parent, labels):
        # Write the <c:showLegendKey> element.
        index = 0

        for label in labels:
            index += 1

            if label is None:
                continue

            self._xml_start_tag("c:dLbl")

            # Write the c:idx element.
            self._write_idx(index - 1)

            delete_label = label.get("delete")

            if delete_label:
                self._write_delete(1)

            elif label.get("formula"):
                self._write_custom_label_formula(label)

                if parent.get("position"):
                    self._write_d_lbl_pos(parent["position"])

                if parent.get("value"):
                    self._write_show_val()
                if parent.get("category"):
                    self._write_show_cat_name()
                if parent.get("series_name"):
                    self._write_show_ser_name()

            elif label.get("value"):
                self._write_custom_label_str(label)

                if parent.get("position"):
                    self._write_d_lbl_pos(parent["position"])

                if parent.get("value"):
                    self._write_show_val()
                if parent.get("category"):
                    self._write_show_cat_name()
                if parent.get("series_name"):
                    self._write_show_ser_name()
            else:
                self._write_custom_label_format_only(label)

            self._xml_end_tag("c:dLbl")

    def _write_custom_label_str(self, label):
        # Write parts of the <c:dLbl> element for strings.
        title = label.get("value")
        font = label.get("font")
        has_formatting = self._has_fill_formatting(label)

        # Write the c:layout element.
        self._write_layout(None, None)

        self._xml_start_tag("c:tx")

        # Write the c:rich element.
        self._write_rich(title, font, False, not has_formatting)

        self._xml_end_tag("c:tx")

        # Write the c:spPr element.
        self._write_sp_pr(label)

    def _write_custom_label_formula(self, label):
        # Write parts of the <c:dLbl> element for formulas.
        formula = label.get("formula")
        data_id = label.get("data_id")
        data = None

        if data_id is not None:
            data = self.formula_data[data_id]

        # Write the c:layout element.
        self._write_layout(None, None)

        self._xml_start_tag("c:tx")

        # Write the c:strRef element.
        self._write_str_ref(formula, data, "str")

        self._xml_end_tag("c:tx")

        # Write the data label formatting, if any.
        self._write_custom_label_format_only(label)

    def _write_custom_label_format_only(self, label):
        # Write parts of the <c:dLbl> labels with changed formatting.
        font = label.get("font")
        has_formatting = self._has_fill_formatting(label)

        if has_formatting:
            self._write_sp_pr(label)
            self._write_tx_pr(font)
        elif font:
            self._xml_empty_tag("c:spPr")
            self._write_tx_pr(font)

    def _write_show_legend_key(self):
        # Write the <c:showLegendKey> element.
        val = "1"

        attributes = [("val", val)]

        self._xml_empty_tag("c:showLegendKey", attributes)

    def _write_show_val(self):
        # Write the <c:showVal> element.
        val = 1

        attributes = [("val", val)]

        self._xml_empty_tag("c:showVal", attributes)

    def _write_show_cat_name(self):
        # Write the <c:showCatName> element.
        val = 1

        attributes = [("val", val)]

        self._xml_empty_tag("c:showCatName", attributes)

    def _write_show_ser_name(self):
        # Write the <c:showSerName> element.
        val = 1

        attributes = [("val", val)]

        self._xml_empty_tag("c:showSerName", attributes)

    def _write_show_percent(self):
        # Write the <c:showPercent> element.
        val = 1

        attributes = [("val", val)]

        self._xml_empty_tag("c:showPercent", attributes)

    def _write_separator(self, data):
        # Write the <c:separator> element.
        self._xml_data_element("c:separator", data)

    def _write_show_leader_lines(self):
        # Write the <c:showLeaderLines> element.
        #
        # This is different for Pie/Doughnut charts. Other chart types only
        # supported leader lines after Excel 2015 via an extension element.
        #
        uri = "{CE6537A1-D6FC-4f65-9D91-7224C49458BB}"
        xmlns_c_15 = "http://schemas.microsoft.com/office/drawing/2012/chart"

        attributes = [
            ("uri", uri),
            ("xmlns:c15", xmlns_c_15),
        ]

        self._xml_start_tag("c:extLst")
        self._xml_start_tag("c:ext", attributes)
        self._xml_empty_tag("c15:showLeaderLines", [("val", 1)])
        self._xml_end_tag("c:ext")
        self._xml_end_tag("c:extLst")

    def _write_d_lbl_pos(self, val):
        # Write the <c:dLblPos> element.

        attributes = [("val", val)]

        self._xml_empty_tag("c:dLblPos", attributes)

    def _write_delete(self, val):
        # Write the <c:delete> element.

        attributes = [("val", val)]

        self._xml_empty_tag("c:delete", attributes)

    def _write_c_invert_if_negative(self, invert):
        # Write the <c:invertIfNegative> element.
        val = 1

        if not invert:
            return

        attributes = [("val", val)]

        self._xml_empty_tag("c:invertIfNegative", attributes)

    def _write_axis_font(self, font):
        # Write the axis font elements.

        if not font:
            return

        self._xml_start_tag("c:txPr")
        self._write_a_body_pr(font.get("rotation"), None)
        self._write_a_lst_style()
        self._xml_start_tag("a:p")

        self._write_a_p_pr_rich(font)

        self._write_a_end_para_rpr()
        self._xml_end_tag("a:p")
        self._xml_end_tag("c:txPr")

    def _write_a_latin(self, attributes):
        # Write the <a:latin> element.
        self._xml_empty_tag("a:latin", attributes)

    def _write_d_table(self):
        # Write the <c:dTable> element.
        table = self.table

        if not table:
            return

        self._xml_start_tag("c:dTable")

        if table["horizontal"]:
            # Write the c:showHorzBorder element.
            self._write_show_horz_border()

        if table["vertical"]:
            # Write the c:showVertBorder element.
            self._write_show_vert_border()

        if table["outline"]:
            # Write the c:showOutline element.
            self._write_show_outline()

        if table["show_keys"]:
            # Write the c:showKeys element.
            self._write_show_keys()

        if table["font"]:
            # Write the table font.
            self._write_tx_pr(table["font"])

        self._xml_end_tag("c:dTable")

    def _write_show_horz_border(self):
        # Write the <c:showHorzBorder> element.
        attributes = [("val", 1)]

        self._xml_empty_tag("c:showHorzBorder", attributes)

    def _write_show_vert_border(self):
        # Write the <c:showVertBorder> element.
        attributes = [("val", 1)]

        self._xml_empty_tag("c:showVertBorder", attributes)

    def _write_show_outline(self):
        # Write the <c:showOutline> element.
        attributes = [("val", 1)]

        self._xml_empty_tag("c:showOutline", attributes)

    def _write_show_keys(self):
        # Write the <c:showKeys> element.
        attributes = [("val", 1)]

        self._xml_empty_tag("c:showKeys", attributes)

    def _write_error_bars(self, error_bars):
        # Write the X and Y error bars.

        if not error_bars:
            return

        if error_bars["x_error_bars"]:
            self._write_err_bars("x", error_bars["x_error_bars"])

        if error_bars["y_error_bars"]:
            self._write_err_bars("y", error_bars["y_error_bars"])

    def _write_err_bars(self, direction, error_bars):
        # Write the <c:errBars> element.

        if not error_bars:
            return

        self._xml_start_tag("c:errBars")

        # Write the c:errDir element.
        self._write_err_dir(direction)

        # Write the c:errBarType element.
        self._write_err_bar_type(error_bars["direction"])

        # Write the c:errValType element.
        self._write_err_val_type(error_bars["type"])

        if not error_bars["endcap"]:
            # Write the c:noEndCap element.
            self._write_no_end_cap()

        if error_bars["type"] == "stdErr":
            # Don't need to write a c:errValType tag.
            pass
        elif error_bars["type"] == "cust":
            # Write the custom error tags.
            self._write_custom_error(error_bars)
        else:
            # Write the c:val element.
            self._write_error_val(error_bars["value"])

        # Write the c:spPr element.
        self._write_sp_pr(error_bars)

        self._xml_end_tag("c:errBars")

    def _write_err_dir(self, val):
        # Write the <c:errDir> element.

        attributes = [("val", val)]

        self._xml_empty_tag("c:errDir", attributes)

    def _write_err_bar_type(self, val):
        # Write the <c:errBarType> element.

        attributes = [("val", val)]

        self._xml_empty_tag("c:errBarType", attributes)

    def _write_err_val_type(self, val):
        # Write the <c:errValType> element.

        attributes = [("val", val)]

        self._xml_empty_tag("c:errValType", attributes)

    def _write_no_end_cap(self):
        # Write the <c:noEndCap> element.
        attributes = [("val", 1)]

        self._xml_empty_tag("c:noEndCap", attributes)

    def _write_error_val(self, val):
        # Write the <c:val> element for error bars.

        attributes = [("val", val)]

        self._xml_empty_tag("c:val", attributes)

    def _write_custom_error(self, error_bars):
        # Write the custom error bars tags.

        if error_bars["plus_values"]:
            # Write the c:plus element.
            self._xml_start_tag("c:plus")

            if isinstance(error_bars["plus_values"], list):
                self._write_num_lit(error_bars["plus_values"])
            else:
                self._write_num_ref(
                    error_bars["plus_values"], error_bars["plus_data"], "num"
                )
            self._xml_end_tag("c:plus")

        if error_bars["minus_values"]:
            # Write the c:minus element.
            self._xml_start_tag("c:minus")

            if isinstance(error_bars["minus_values"], list):
                self._write_num_lit(error_bars["minus_values"])
            else:
                self._write_num_ref(
                    error_bars["minus_values"], error_bars["minus_data"], "num"
                )
            self._xml_end_tag("c:minus")

    def _write_num_lit(self, data):
        # Write the <c:numLit> element for literal number list elements.
        count = len(data)

        # Write the c:numLit element.
        self._xml_start_tag("c:numLit")

        # Write the c:formatCode element.
        self._write_format_code("General")

        # Write the c:ptCount element.
        self._write_pt_count(count)

        for i in range(count):
            token = data[i]

            if token is None:
                continue

            try:
                float(token)
            except ValueError:
                # Write non-numeric data as 0.
                token = 0

            # Write the c:pt element.
            self._write_pt(i, token)

        self._xml_end_tag("c:numLit")

    def _write_up_down_bars(self):
        # Write the <c:upDownBars> element.
        up_down_bars = self.up_down_bars

        if up_down_bars is None:
            return

        self._xml_start_tag("c:upDownBars")

        # Write the c:gapWidth element.
        self._write_gap_width(150)

        # Write the c:upBars element.
        self._write_up_bars(up_down_bars.get("up"))

        # Write the c:downBars element.
        self._write_down_bars(up_down_bars.get("down"))

        self._xml_end_tag("c:upDownBars")

    def _write_gap_width(self, val):
        # Write the <c:gapWidth> element.

        if val is None:
            return

        attributes = [("val", val)]

        self._xml_empty_tag("c:gapWidth", attributes)

    def _write_up_bars(self, bar_format):
        # Write the <c:upBars> element.

        if bar_format["line"] and bar_format["line"]["defined"]:
            self._xml_start_tag("c:upBars")

            # Write the c:spPr element.
            self._write_sp_pr(bar_format)

            self._xml_end_tag("c:upBars")
        else:
            self._xml_empty_tag("c:upBars")

    def _write_down_bars(self, bar_format):
        # Write the <c:downBars> element.

        if bar_format["line"] and bar_format["line"]["defined"]:
            self._xml_start_tag("c:downBars")

            # Write the c:spPr element.
            self._write_sp_pr(bar_format)

            self._xml_end_tag("c:downBars")
        else:
            self._xml_empty_tag("c:downBars")

    def _write_disp_units(self, units, display):
        # Write the <c:dispUnits> element.

        if not units:
            return

        attributes = [("val", units)]

        self._xml_start_tag("c:dispUnits")
        self._xml_empty_tag("c:builtInUnit", attributes)

        if display:
            self._xml_start_tag("c:dispUnitsLbl")
            self._xml_empty_tag("c:layout")
            self._xml_end_tag("c:dispUnitsLbl")

        self._xml_end_tag("c:dispUnits")

    def _write_a_grad_fill(self, gradient):
        # Write the <a:gradFill> element.

        attributes = [("flip", "none"), ("rotWithShape", "1")]

        if gradient["type"] == "linear":
            attributes = []

        self._xml_start_tag("a:gradFill", attributes)

        # Write the a:gsLst element.
        self._write_a_gs_lst(gradient)

        if gradient["type"] == "linear":
            # Write the a:lin element.
            self._write_a_lin(gradient["angle"])
        else:
            # Write the a:path element.
            self._write_a_path(gradient["type"])

            # Write the a:tileRect element.
            self._write_a_tile_rect(gradient["type"])

        self._xml_end_tag("a:gradFill")

    def _write_a_gs_lst(self, gradient):
        # Write the <a:gsLst> element.
        positions = gradient["positions"]
        colors = gradient["colors"]

        self._xml_start_tag("a:gsLst")

        for i in range(len(colors)):
            pos = int(positions[i] * 1000)
            attributes = [("pos", pos)]
            self._xml_start_tag("a:gs", attributes)

            # Write the a:srgbClr element.
            color = get_rgb_color(colors[i])
            self._write_a_srgb_clr(color)

            self._xml_end_tag("a:gs")

        self._xml_end_tag("a:gsLst")

    def _write_a_lin(self, angle):
        # Write the <a:lin> element.

        angle = int(60000 * angle)

        attributes = [
            ("ang", angle),
            ("scaled", "0"),
        ]

        self._xml_empty_tag("a:lin", attributes)

    def _write_a_path(self, gradient_type):
        # Write the <a:path> element.

        attributes = [("path", gradient_type)]

        self._xml_start_tag("a:path", attributes)

        # Write the a:fillToRect element.
        self._write_a_fill_to_rect(gradient_type)

        self._xml_end_tag("a:path")

    def _write_a_fill_to_rect(self, gradient_type):
        # Write the <a:fillToRect> element.

        if gradient_type == "shape":
            attributes = [
                ("l", "50000"),
                ("t", "50000"),
                ("r", "50000"),
                ("b", "50000"),
            ]
        else:
            attributes = [
                ("l", "100000"),
                ("t", "100000"),
            ]

        self._xml_empty_tag("a:fillToRect", attributes)

    def _write_a_tile_rect(self, gradient_type):
        # Write the <a:tileRect> element.

        if gradient_type == "shape":
            attributes = []
        else:
            attributes = [
                ("r", "-100000"),
                ("b", "-100000"),
            ]

        self._xml_empty_tag("a:tileRect", attributes)

    def _write_a_patt_fill(self, pattern):
        # Write the <a:pattFill> element.

        attributes = [("prst", pattern["pattern"])]

        self._xml_start_tag("a:pattFill", attributes)

        # Write the a:fgClr element.
        self._write_a_fg_clr(pattern["fg_color"])

        # Write the a:bgClr element.
        self._write_a_bg_clr(pattern["bg_color"])

        self._xml_end_tag("a:pattFill")

    def _write_a_fg_clr(self, color):
        # Write the <a:fgClr> element.

        color = get_rgb_color(color)

        self._xml_start_tag("a:fgClr")

        # Write the a:srgbClr element.
        self._write_a_srgb_clr(color)

        self._xml_end_tag("a:fgClr")

    def _write_a_bg_clr(self, color):
        # Write the <a:bgClr> element.

        color = get_rgb_color(color)

        self._xml_start_tag("a:bgClr")

        # Write the a:srgbClr element.
        self._write_a_srgb_clr(color)

        self._xml_end_tag("a:bgClr")

```

---

### File: `tmp\xlsxwriter_sdist\XlsxWriter-3.2.0\xlsxwriter\chart_area.py`

```python
###############################################################################
#
# ChartArea - A class for writing the Excel XLSX Area charts.
#
# SPDX-License-Identifier: BSD-2-Clause
# Copyright 2013-2024, John McNamara, jmcnamara@cpan.org
#

from . import chart


class ChartArea(chart.Chart):
    """
    A class for writing the Excel XLSX Area charts.


    """

    ###########################################################################
    #
    # Public API.
    #
    ###########################################################################

    def __init__(self, options=None):
        """
        Constructor.

        """
        super(ChartArea, self).__init__()

        if options is None:
            options = {}

        self.subtype = options.get("subtype")

        if not self.subtype:
            self.subtype = "standard"

        self.cross_between = "midCat"
        self.show_crosses = 0

        # Override and reset the default axis values.
        if self.subtype == "percent_stacked":
            self.y_axis["defaults"]["num_format"] = "0%"

        # Set the available data label positions for this chart type.
        self.label_position_default = "center"
        self.label_positions = {"center": "ctr"}

        self.set_y_axis({})

    ###########################################################################
    #
    # Private API.
    #
    ###########################################################################

    def _write_chart_type(self, args):
        # Override the virtual superclass method with a chart specific method.
        # Write the c:areaChart element.
        self._write_area_chart(args)

    ###########################################################################
    #
    # XML methods.
    #
    ###########################################################################
    #
    def _write_area_chart(self, args):
        # Write the <c:areaChart> element.

        if args["primary_axes"]:
            series = self._get_primary_axes_series()
        else:
            series = self._get_secondary_axes_series()

        if not len(series):
            return

        subtype = self.subtype

        if subtype == "percent_stacked":
            subtype = "percentStacked"

        self._xml_start_tag("c:areaChart")

        # Write the c:grouping element.
        self._write_grouping(subtype)

        # Write the series elements.
        for data in series:
            self._write_ser(data)

        # Write the c:dropLines element.
        self._write_drop_lines()

        # Write the c:axId elements
        self._write_axis_ids(args)

        self._xml_end_tag("c:areaChart")

```

---

### File: `tmp\xlsxwriter_sdist\XlsxWriter-3.2.0\xlsxwriter\chart_bar.py`

```python
###############################################################################
#
# ChartBar - A class for writing the Excel XLSX Bar charts.
#
# SPDX-License-Identifier: BSD-2-Clause
# Copyright 2013-2024, John McNamara, jmcnamara@cpan.org
#

from . import chart
from warnings import warn


class ChartBar(chart.Chart):
    """
    A class for writing the Excel XLSX Bar charts.


    """

    ###########################################################################
    #
    # Public API.
    #
    ###########################################################################

    def __init__(self, options=None):
        """
        Constructor.

        """
        super(ChartBar, self).__init__()

        if options is None:
            options = {}

        self.subtype = options.get("subtype")

        if not self.subtype:
            self.subtype = "clustered"

        self.cat_axis_position = "l"
        self.val_axis_position = "b"
        self.horiz_val_axis = 0
        self.horiz_cat_axis = 1
        self.show_crosses = 0

        # Override and reset the default axis values.
        self.x_axis["defaults"]["major_gridlines"] = {"visible": 1}
        self.y_axis["defaults"]["major_gridlines"] = {"visible": 0}

        if self.subtype == "percent_stacked":
            self.x_axis["defaults"]["num_format"] = "0%"

        # Set the available data label positions for this chart type.
        self.label_position_default = "outside_end"
        self.label_positions = {
            "center": "ctr",
            "inside_base": "inBase",
            "inside_end": "inEnd",
            "outside_end": "outEnd",
        }

        self.set_x_axis({})
        self.set_y_axis({})

    def combine(self, chart=None):
        """
        Create a combination chart with a secondary chart.

        Note: Override parent method to add an extra check that is required
        for Bar charts to ensure that their combined chart is on a secondary
        axis.

        Args:
            chart: The secondary chart to combine with the primary chart.

        Returns:
            Nothing.

        """
        if chart is None:
            return

        if not chart.is_secondary:
            warn("Charts combined with Bar charts must be on a secondary axis")

        self.combined = chart

    ###########################################################################
    #
    # Private API.
    #
    ###########################################################################

    def _write_chart_type(self, args):
        # Override the virtual superclass method with a chart specific method.
        if args["primary_axes"]:
            # Reverse X and Y axes for Bar charts.
            tmp = self.y_axis
            self.y_axis = self.x_axis
            self.x_axis = tmp

            if self.y2_axis["position"] == "r":
                self.y2_axis["position"] = "t"

        # Write the c:barChart element.
        self._write_bar_chart(args)

    def _write_bar_chart(self, args):
        # Write the <c:barChart> element.

        if args["primary_axes"]:
            series = self._get_primary_axes_series()
        else:
            series = self._get_secondary_axes_series()

        if not len(series):
            return

        subtype = self.subtype
        if subtype == "percent_stacked":
            subtype = "percentStacked"

        # Set a default overlap for stacked charts.
        if "stacked" in self.subtype and self.series_overlap_1 is None:
            self.series_overlap_1 = 100

        self._xml_start_tag("c:barChart")

        # Write the c:barDir element.
        self._write_bar_dir()

        # Write the c:grouping element.
        self._write_grouping(subtype)

        # Write the c:ser elements.
        for data in series:
            self._write_ser(data)

        # Write the c:gapWidth element.
        if args["primary_axes"]:
            self._write_gap_width(self.series_gap_1)
        else:
            self._write_gap_width(self.series_gap_2)

        # Write the c:overlap element.
        if args["primary_axes"]:
            self._write_overlap(self.series_overlap_1)
        else:
            self._write_overlap(self.series_overlap_2)

        # Write the c:axId elements
        self._write_axis_ids(args)

        self._xml_end_tag("c:barChart")

    ###########################################################################
    #
    # XML methods.
    #
    ###########################################################################

    def _write_bar_dir(self):
        # Write the <c:barDir> element.
        val = "bar"

        attributes = [("val", val)]

        self._xml_empty_tag("c:barDir", attributes)

    def _write_err_dir(self, val):
        # Overridden from Chart class since it is not used in Bar charts.
        pass

```

---

### File: `tmp\xlsxwriter_sdist\XlsxWriter-3.2.0\xlsxwriter\chart_column.py`

```python
###############################################################################
#
# ChartColumn - A class for writing the Excel XLSX Column charts.
#
# SPDX-License-Identifier: BSD-2-Clause
# Copyright 2013-2024, John McNamara, jmcnamara@cpan.org
#

from . import chart


class ChartColumn(chart.Chart):
    """
    A class for writing the Excel XLSX Column charts.


    """

    ###########################################################################
    #
    # Public API.
    #
    ###########################################################################

    def __init__(self, options=None):
        """
        Constructor.

        """
        super(ChartColumn, self).__init__()

        if options is None:
            options = {}

        self.subtype = options.get("subtype")

        if not self.subtype:
            self.subtype = "clustered"

        self.horiz_val_axis = 0

        if self.subtype == "percent_stacked":
            self.y_axis["defaults"]["num_format"] = "0%"

        # Set the available data label positions for this chart type.
        self.label_position_default = "outside_end"
        self.label_positions = {
            "center": "ctr",
            "inside_base": "inBase",
            "inside_end": "inEnd",
            "outside_end": "outEnd",
        }

        self.set_y_axis({})

    ###########################################################################
    #
    # Private API.
    #
    ###########################################################################

    def _write_chart_type(self, args):
        # Override the virtual superclass method with a chart specific method.

        # Write the c:barChart element.
        self._write_bar_chart(args)

    def _write_bar_chart(self, args):
        # Write the <c:barChart> element.

        if args["primary_axes"]:
            series = self._get_primary_axes_series()
        else:
            series = self._get_secondary_axes_series()

        if not len(series):
            return

        subtype = self.subtype
        if subtype == "percent_stacked":
            subtype = "percentStacked"

        # Set a default overlap for stacked charts.
        if "stacked" in self.subtype and self.series_overlap_1 is None:
            self.series_overlap_1 = 100

        self._xml_start_tag("c:barChart")

        # Write the c:barDir element.
        self._write_bar_dir()

        # Write the c:grouping element.
        self._write_grouping(subtype)

        # Write the c:ser elements.
        for data in series:
            self._write_ser(data)

        # Write the c:gapWidth element.
        if args["primary_axes"]:
            self._write_gap_width(self.series_gap_1)
        else:
            self._write_gap_width(self.series_gap_2)

        # Write the c:overlap element.
        if args["primary_axes"]:
            self._write_overlap(self.series_overlap_1)
        else:
            self._write_overlap(self.series_overlap_2)

        # Write the c:axId elements
        self._write_axis_ids(args)

        self._xml_end_tag("c:barChart")

    ###########################################################################
    #
    # XML methods.
    #
    ###########################################################################

    def _write_bar_dir(self):
        # Write the <c:barDir> element.
        val = "col"

        attributes = [("val", val)]

        self._xml_empty_tag("c:barDir", attributes)

    def _write_err_dir(self, val):
        # Overridden from Chart class since it is not used in Column charts.
        pass

```

---

### File: `tmp\xlsxwriter_sdist\XlsxWriter-3.2.0\xlsxwriter\chart_doughnut.py`

```python
###############################################################################
#
# ChartDoughnut - A class for writing the Excel XLSX Doughnut charts.
#
# SPDX-License-Identifier: BSD-2-Clause
# Copyright 2013-2024, John McNamara, jmcnamara@cpan.org
#

from warnings import warn
from . import chart_pie


class ChartDoughnut(chart_pie.ChartPie):
    """
    A class for writing the Excel XLSX Doughnut charts.


    """

    ###########################################################################
    #
    # Public API.
    #
    ###########################################################################

    def __init__(self, options=None):
        """
        Constructor.

        """
        super(ChartDoughnut, self).__init__()

        self.vary_data_color = 1
        self.rotation = 0
        self.hole_size = 50

    def set_hole_size(self, size):
        """
        Set the Doughnut chart hole size.

        Args:
            size: 10 <= size <= 90.

        Returns:
            Nothing.

        """
        if size is None:
            return

        # Ensure the size is in Excel's range.
        if size < 10 or size > 90:
            warn("Chart hole size %d outside Excel range: 10 <= size <= 90" % size)
            return

        self.hole_size = int(size)

    ###########################################################################
    #
    # Private API.
    #
    ###########################################################################

    def _write_chart_type(self, args):
        # Override the virtual superclass method with a chart specific method.
        # Write the c:doughnutChart element.
        self._write_doughnut_chart(args)

    ###########################################################################
    #
    # XML methods.
    #
    ###########################################################################

    def _write_doughnut_chart(self, args):
        # Write the <c:doughnutChart> element.  Over-ridden method to remove
        # axis_id code since Doughnut charts don't require val and cat axes.
        self._xml_start_tag("c:doughnutChart")

        # Write the c:varyColors element.
        self._write_vary_colors()

        # Write the series elements.
        for data in self.series:
            self._write_ser(data)

        # Write the c:firstSliceAng element.
        self._write_first_slice_ang()

        # Write the c:holeSize element.
        self._write_c_hole_size()

        self._xml_end_tag("c:doughnutChart")

    def _write_c_hole_size(self):
        # Write the <c:holeSize> element.
        attributes = [("val", self.hole_size)]

        self._xml_empty_tag("c:holeSize", attributes)

```

---

### File: `tmp\xlsxwriter_sdist\XlsxWriter-3.2.0\xlsxwriter\chart_line.py`

```python
###############################################################################
#
# ChartLine - A class for writing the Excel XLSX Line charts.
#
# SPDX-License-Identifier: BSD-2-Clause
# Copyright 2013-2024, John McNamara, jmcnamara@cpan.org
#

from . import chart


class ChartLine(chart.Chart):
    """
    A class for writing the Excel XLSX Line charts.


    """

    ###########################################################################
    #
    # Public API.
    #
    ###########################################################################

    def __init__(self, options=None):
        """
        Constructor.

        """
        super(ChartLine, self).__init__()

        if options is None:
            options = {}

        self.subtype = options.get("subtype")

        if not self.subtype:
            self.subtype = "standard"

        self.default_marker = {"type": "none"}
        self.smooth_allowed = True

        # Override and reset the default axis values.
        if self.subtype == "percent_stacked":
            self.y_axis["defaults"]["num_format"] = "0%"

        # Set the available data label positions for this chart type.
        self.label_position_default = "right"
        self.label_positions = {
            "center": "ctr",
            "right": "r",
            "left": "l",
            "above": "t",
            "below": "b",
            # For backward compatibility.
            "top": "t",
            "bottom": "b",
        }

        self.set_y_axis({})

    ###########################################################################
    #
    # Private API.
    #
    ###########################################################################

    def _write_chart_type(self, args):
        # Override the virtual superclass method with a chart specific method.
        # Write the c:lineChart element.
        self._write_line_chart(args)

    ###########################################################################
    #
    # XML methods.
    #
    ###########################################################################

    def _write_line_chart(self, args):
        # Write the <c:lineChart> element.

        if args["primary_axes"]:
            series = self._get_primary_axes_series()
        else:
            series = self._get_secondary_axes_series()

        if not len(series):
            return

        subtype = self.subtype

        if subtype == "percent_stacked":
            subtype = "percentStacked"

        self._xml_start_tag("c:lineChart")

        # Write the c:grouping element.
        self._write_grouping(subtype)

        # Write the series elements.
        for data in series:
            self._write_ser(data)

        # Write the c:dropLines element.
        self._write_drop_lines()

        # Write the c:hiLowLines element.
        self._write_hi_low_lines()

        # Write the c:upDownBars element.
        self._write_up_down_bars()

        # Write the c:marker element.
        self._write_marker_value()

        # Write the c:axId elements
        self._write_axis_ids(args)

        self._xml_end_tag("c:lineChart")

    def _write_d_pt_point(self, index, point):
        # Write an individual <c:dPt> element. Override the parent method to
        # add markers.

        self._xml_start_tag("c:dPt")

        # Write the c:idx element.
        self._write_idx(index)

        self._xml_start_tag("c:marker")

        # Write the c:spPr element.
        self._write_sp_pr(point)

        self._xml_end_tag("c:marker")

        self._xml_end_tag("c:dPt")

    def _write_marker_value(self):
        # Write the <c:marker> element without a sub-element.
        attributes = [("val", 1)]

        self._xml_empty_tag("c:marker", attributes)

```

---

### File: `tmp\xlsxwriter_sdist\XlsxWriter-3.2.0\xlsxwriter\chart_pie.py`

```python
###############################################################################
#
# ChartPie - A class for writing the Excel XLSX Pie charts.
#
# SPDX-License-Identifier: BSD-2-Clause
# Copyright 2013-2024, John McNamara, jmcnamara@cpan.org
#

from warnings import warn
from . import chart


class ChartPie(chart.Chart):
    """
    A class for writing the Excel XLSX Pie charts.


    """

    ###########################################################################
    #
    # Public API.
    #
    ###########################################################################

    def __init__(self, options=None):
        """
        Constructor.

        """
        super(ChartPie, self).__init__()

        self.vary_data_color = 1
        self.rotation = 0

        # Set the available data label positions for this chart type.
        self.label_position_default = "best_fit"
        self.label_positions = {
            "center": "ctr",
            "inside_end": "inEnd",
            "outside_end": "outEnd",
            "best_fit": "bestFit",
        }

    def set_rotation(self, rotation):
        """
        Set the Pie/Doughnut chart rotation: the angle of the first slice.

        Args:
            rotation: First segment angle: 0 <= rotation <= 360.

        Returns:
            Nothing.

        """
        if rotation is None:
            return

        # Ensure the rotation is in Excel's range.
        if rotation < 0 or rotation > 360:
            warn(
                "Chart rotation %d outside Excel range: 0 <= rotation <= 360" % rotation
            )
            return

        self.rotation = int(rotation)

    ###########################################################################
    #
    # Private API.
    #
    ###########################################################################

    def _write_chart_type(self, args):
        # Override the virtual superclass method with a chart specific method.
        # Write the c:pieChart element.
        self._write_pie_chart(args)

    ###########################################################################
    #
    # XML methods.
    #
    ###########################################################################

    def _write_pie_chart(self, args):
        # Write the <c:pieChart> element.  Over-ridden method to remove
        # axis_id code since Pie charts don't require val and cat axes.
        self._xml_start_tag("c:pieChart")

        # Write the c:varyColors element.
        self._write_vary_colors()

        # Write the series elements.
        for data in self.series:
            self._write_ser(data)

        # Write the c:firstSliceAng element.
        self._write_first_slice_ang()

        self._xml_end_tag("c:pieChart")

    def _write_plot_area(self):
        # Over-ridden method to remove the cat_axis() and val_axis() code
        # since Pie charts don't require those axes.
        #
        # Write the <c:plotArea> element.

        self._xml_start_tag("c:plotArea")

        # Write the c:layout element.
        self._write_layout(self.plotarea.get("layout"), "plot")

        # Write the subclass chart type element.
        self._write_chart_type(None)
        # Configure a combined chart if present.
        second_chart = self.combined

        if second_chart:
            # Secondary axis has unique id otherwise use same as primary.
            if second_chart.is_secondary:
                second_chart.id = 1000 + self.id
            else:
                second_chart.id = self.id

            # Share the same filehandle for writing.
            second_chart.fh = self.fh

            # Share series index with primary chart.
            second_chart.series_index = self.series_index

            # Write the subclass chart type elements for combined chart.
            second_chart._write_chart_type(None)

        # Write the c:spPr element for the plotarea formatting.
        self._write_sp_pr(self.plotarea)

        self._xml_end_tag("c:plotArea")

    def _write_legend(self):
        # Over-ridden method to add <c:txPr> to legend.
        # Write the <c:legend> element.
        legend = self.legend
        position = legend.get("position", "right")
        font = legend.get("font")
        delete_series = []
        overlay = 0

        if legend.get("delete_series") and isinstance(legend["delete_series"], list):
            delete_series = legend["delete_series"]

        if position.startswith("overlay_"):
            position = position.replace("overlay_", "")
            overlay = 1

        allowed = {
            "right": "r",
            "left": "l",
            "top": "t",
            "bottom": "b",
            "top_right": "tr",
        }

        if position == "none":
            return

        if position not in allowed:
            return

        position = allowed[position]

        self._xml_start_tag("c:legend")

        # Write the c:legendPos element.
        self._write_legend_pos(position)

        # Remove series labels from the legend.
        for index in delete_series:
            # Write the c:legendEntry element.
            self._write_legend_entry(index)

        # Write the c:layout element.
        self._write_layout(legend.get("layout"), "legend")

        # Write the c:overlay element.
        if overlay:
            self._write_overlay()

        # Write the c:spPr element.
        self._write_sp_pr(legend)

        # Write the c:txPr element. Over-ridden.
        self._write_tx_pr_legend(None, font)

        self._xml_end_tag("c:legend")

    def _write_tx_pr_legend(self, horiz, font):
        # Write the <c:txPr> element for legends.

        if font and font.get("rotation"):
            rotation = font["rotation"]
        else:
            rotation = None

        self._xml_start_tag("c:txPr")

        # Write the a:bodyPr element.
        self._write_a_body_pr(rotation, horiz)

        # Write the a:lstStyle element.
        self._write_a_lst_style()

        # Write the a:p element.
        self._write_a_p_legend(font)

        self._xml_end_tag("c:txPr")

    def _write_a_p_legend(self, font):
        # Write the <a:p> element for legends.

        self._xml_start_tag("a:p")

        # Write the a:pPr element.
        self._write_a_p_pr_legend(font)

        # Write the a:endParaRPr element.
        self._write_a_end_para_rpr()

        self._xml_end_tag("a:p")

    def _write_a_p_pr_legend(self, font):
        # Write the <a:pPr> element for legends.
        attributes = [("rtl", 0)]

        self._xml_start_tag("a:pPr", attributes)

        # Write the a:defRPr element.
        self._write_a_def_rpr(font)

        self._xml_end_tag("a:pPr")

    def _write_vary_colors(self):
        # Write the <c:varyColors> element.
        attributes = [("val", 1)]

        self._xml_empty_tag("c:varyColors", attributes)

    def _write_first_slice_ang(self):
        # Write the <c:firstSliceAng> element.
        attributes = [("val", self.rotation)]

        self._xml_empty_tag("c:firstSliceAng", attributes)

    def _write_show_leader_lines(self):
        # Write the <c:showLeaderLines> element.
        #
        # This is for Pie/Doughnut charts. Other chart types only supported
        # leader lines after Excel 2015 via an extension element.
        attributes = [("val", 1)]

        self._xml_empty_tag("c:showLeaderLines", attributes)

```

---

### File: `tmp\xlsxwriter_sdist\XlsxWriter-3.2.0\xlsxwriter\chart_radar.py`

```python
###############################################################################
#
# ChartRadar - A class for writing the Excel XLSX Radar charts.
#
# SPDX-License-Identifier: BSD-2-Clause
# Copyright 2013-2024, John McNamara, jmcnamara@cpan.org
#

from . import chart


class ChartRadar(chart.Chart):
    """
    A class for writing the Excel XLSX Radar charts.


    """

    ###########################################################################
    #
    # Public API.
    #
    ###########################################################################

    def __init__(self, options=None):
        """
        Constructor.

        """
        super(ChartRadar, self).__init__()

        if options is None:
            options = {}

        self.subtype = options.get("subtype")

        if not self.subtype:
            self.subtype = "marker"
            self.default_marker = {"type": "none"}

        # Override and reset the default axis values.
        self.x_axis["defaults"]["major_gridlines"] = {"visible": 1}
        self.set_x_axis({})

        # Set the available data label positions for this chart type.
        self.label_position_default = "center"
        self.label_positions = {"center": "ctr"}

        # Hardcode major_tick_mark for now until there is an accessor.
        self.y_axis["major_tick_mark"] = "cross"

    ###########################################################################
    #
    # Private API.
    #
    ###########################################################################

    def _write_chart_type(self, args):
        # Write the c:radarChart element.
        self._write_radar_chart(args)

    ###########################################################################
    #
    # XML methods.
    #
    ###########################################################################

    def _write_radar_chart(self, args):
        # Write the <c:radarChart> element.

        if args["primary_axes"]:
            series = self._get_primary_axes_series()
        else:
            series = self._get_secondary_axes_series()

        if not len(series):
            return

        self._xml_start_tag("c:radarChart")

        # Write the c:radarStyle element.
        self._write_radar_style()

        # Write the series elements.
        for data in series:
            self._write_ser(data)

        # Write the c:axId elements
        self._write_axis_ids(args)

        self._xml_end_tag("c:radarChart")

    def _write_radar_style(self):
        # Write the <c:radarStyle> element.
        val = "marker"

        if self.subtype == "filled":
            val = "filled"

        attributes = [("val", val)]

        self._xml_empty_tag("c:radarStyle", attributes)

```

---

### File: `tmp\xlsxwriter_sdist\XlsxWriter-3.2.0\xlsxwriter\chart_scatter.py`

```python
###############################################################################
#
# ChartScatter - A class for writing the Excel XLSX Scatter charts.
#
# SPDX-License-Identifier: BSD-2-Clause
# Copyright 2013-2024, John McNamara, jmcnamara@cpan.org
#

from . import chart
from warnings import warn


class ChartScatter(chart.Chart):
    """
    A class for writing the Excel XLSX Scatter charts.


    """

    ###########################################################################
    #
    # Public API.
    #
    ###########################################################################

    def __init__(self, options=None):
        """
        Constructor.

        """
        super(ChartScatter, self).__init__()

        if options is None:
            options = {}

        self.subtype = options.get("subtype")

        if not self.subtype:
            self.subtype = "marker_only"

        self.cross_between = "midCat"
        self.horiz_val_axis = 0
        self.val_axis_position = "b"
        self.smooth_allowed = True
        self.requires_category = True

        # Set the available data label positions for this chart type.
        self.label_position_default = "right"
        self.label_positions = {
            "center": "ctr",
            "right": "r",
            "left": "l",
            "above": "t",
            "below": "b",
            # For backward compatibility.
            "top": "t",
            "bottom": "b",
        }

    def combine(self, chart=None):
        """
        Create a combination chart with a secondary chart.

        Note: Override parent method to add a warning.

        Args:
            chart: The secondary chart to combine with the primary chart.

        Returns:
            Nothing.

        """
        if chart is None:
            return

        warn(
            "Combined chart not currently supported with scatter chart "
            "as the primary chart"
        )

    ###########################################################################
    #
    # Private API.
    #
    ###########################################################################

    def _write_chart_type(self, args):
        # Override the virtual superclass method with a chart specific method.
        # Write the c:scatterChart element.
        self._write_scatter_chart(args)

    ###########################################################################
    #
    # XML methods.
    #
    ###########################################################################

    def _write_scatter_chart(self, args):
        # Write the <c:scatterChart> element.

        if args["primary_axes"]:
            series = self._get_primary_axes_series()
        else:
            series = self._get_secondary_axes_series()

        if not len(series):
            return

        style = "lineMarker"
        subtype = self.subtype

        # Set the user defined chart subtype.
        if subtype == "marker_only":
            style = "lineMarker"

        if subtype == "straight_with_markers":
            style = "lineMarker"

        if subtype == "straight":
            style = "lineMarker"
            self.default_marker = {"type": "none"}

        if subtype == "smooth_with_markers":
            style = "smoothMarker"

        if subtype == "smooth":
            style = "smoothMarker"
            self.default_marker = {"type": "none"}

        # Add default formatting to the series data.
        self._modify_series_formatting()

        self._xml_start_tag("c:scatterChart")

        # Write the c:scatterStyle element.
        self._write_scatter_style(style)

        # Write the series elements.
        for data in series:
            self._write_ser(data)

        # Write the c:axId elements
        self._write_axis_ids(args)

        self._xml_end_tag("c:scatterChart")

    def _write_ser(self, series):
        # Over-ridden to write c:xVal/c:yVal instead of c:cat/c:val elements.
        # Write the <c:ser> element.

        index = self.series_index
        self.series_index += 1

        self._xml_start_tag("c:ser")

        # Write the c:idx element.
        self._write_idx(index)

        # Write the c:order element.
        self._write_order(index)

        # Write the series name.
        self._write_series_name(series)

        # Write the c:spPr element.
        self._write_sp_pr(series)

        # Write the c:marker element.
        self._write_marker(series.get("marker"))

        # Write the c:dPt element.
        self._write_d_pt(series.get("points"))

        # Write the c:dLbls element.
        self._write_d_lbls(series.get("labels"))

        # Write the c:trendline element.
        self._write_trendline(series.get("trendline"))

        # Write the c:errBars element.
        self._write_error_bars(series.get("error_bars"))

        # Write the c:xVal element.
        self._write_x_val(series)

        # Write the c:yVal element.
        self._write_y_val(series)

        # Write the c:smooth element.
        if "smooth" in self.subtype and series["smooth"] is None:
            # Default is on for smooth scatter charts.
            self._write_c_smooth(True)
        else:
            self._write_c_smooth(series["smooth"])

        self._xml_end_tag("c:ser")

    def _write_plot_area(self):
        # Over-ridden to have 2 valAx elements for scatter charts instead
        # of catAx/valAx.
        #
        # Write the <c:plotArea> element.
        self._xml_start_tag("c:plotArea")

        # Write the c:layout element.
        self._write_layout(self.plotarea.get("layout"), "plot")

        # Write the subclass chart elements for primary and secondary axes.
        self._write_chart_type({"primary_axes": 1})
        self._write_chart_type({"primary_axes": 0})

        # Write c:catAx and c:valAx elements for series using primary axes.
        self._write_cat_val_axis(
            {
                "x_axis": self.x_axis,
                "y_axis": self.y_axis,
                "axis_ids": self.axis_ids,
                "position": "b",
            }
        )

        tmp = self.horiz_val_axis
        self.horiz_val_axis = 1

        self._write_val_axis(
            {
                "x_axis": self.x_axis,
                "y_axis": self.y_axis,
                "axis_ids": self.axis_ids,
                "position": "l",
            }
        )

        self.horiz_val_axis = tmp

        # Write c:valAx and c:catAx elements for series using secondary axes
        self._write_cat_val_axis(
            {
                "x_axis": self.x2_axis,
                "y_axis": self.y2_axis,
                "axis_ids": self.axis2_ids,
                "position": "b",
            }
        )
        self.horiz_val_axis = 1
        self._write_val_axis(
            {
                "x_axis": self.x2_axis,
                "y_axis": self.y2_axis,
                "axis_ids": self.axis2_ids,
                "position": "l",
            }
        )

        # Write the c:spPr element for the plotarea formatting.
        self._write_sp_pr(self.plotarea)

        self._xml_end_tag("c:plotArea")

    def _write_x_val(self, series):
        # Write the <c:xVal> element.
        formula = series.get("categories")
        data_id = series.get("cat_data_id")
        data = self.formula_data[data_id]

        self._xml_start_tag("c:xVal")

        # Check the type of cached data.
        data_type = self._get_data_type(data)

        if data_type == "str":
            # Write the c:numRef element.
            self._write_str_ref(formula, data, data_type)
        else:
            # Write the c:numRef element.
            self._write_num_ref(formula, data, data_type)

        self._xml_end_tag("c:xVal")

    def _write_y_val(self, series):
        # Write the <c:yVal> element.
        formula = series.get("values")
        data_id = series.get("val_data_id")
        data = self.formula_data[data_id]

        self._xml_start_tag("c:yVal")

        # Unlike Cat axes data should only be numeric.
        # Write the c:numRef element.
        self._write_num_ref(formula, data, "num")

        self._xml_end_tag("c:yVal")

    def _write_scatter_style(self, val):
        # Write the <c:scatterStyle> element.
        attributes = [("val", val)]

        self._xml_empty_tag("c:scatterStyle", attributes)

    def _modify_series_formatting(self):
        # Add default formatting to the series data unless it has already been
        # specified by the user.
        subtype = self.subtype

        # The default scatter style "markers only" requires a line type.
        if subtype == "marker_only":
            # Go through each series and define default values.
            for series in self.series:
                # Set a line type unless there is already a user defined type.
                if not series["line"]["defined"]:
                    series["line"] = {
                        "width": 2.25,
                        "none": 1,
                        "defined": 1,
                    }

    def _write_d_pt_point(self, index, point):
        # Write an individual <c:dPt> element. Override the parent method to
        # add markers.

        self._xml_start_tag("c:dPt")

        # Write the c:idx element.
        self._write_idx(index)

        self._xml_start_tag("c:marker")

        # Write the c:spPr element.
        self._write_sp_pr(point)

        self._xml_end_tag("c:marker")

        self._xml_end_tag("c:dPt")

```

---

### File: `tmp\xlsxwriter_sdist\XlsxWriter-3.2.0\xlsxwriter\chart_stock.py`

```python
###############################################################################
#
# ChartStock - A class for writing the Excel XLSX Stock charts.
#
# SPDX-License-Identifier: BSD-2-Clause
# Copyright 2013-2024, John McNamara, jmcnamara@cpan.org
#

from . import chart


class ChartStock(chart.Chart):
    """
    A class for writing the Excel XLSX Stock charts.

    """

    ###########################################################################
    #
    # Public API.
    #
    ###########################################################################

    def __init__(self, options=None):
        """
        Constructor.

        """
        super(ChartStock, self).__init__()

        self.show_crosses = 0
        self.hi_low_lines = {}
        self.date_category = True

        # Override and reset the default axis values.
        self.x_axis["defaults"]["num_format"] = "dd/mm/yyyy"
        self.x2_axis["defaults"]["num_format"] = "dd/mm/yyyy"

        # Set the available data label positions for this chart type.
        self.label_position_default = "right"
        self.label_positions = {
            "center": "ctr",
            "right": "r",
            "left": "l",
            "above": "t",
            "below": "b",
            # For backward compatibility.
            "top": "t",
            "bottom": "b",
        }

        self.set_x_axis({})
        self.set_x2_axis({})

    ###########################################################################
    #
    # Private API.
    #
    ###########################################################################

    def _write_chart_type(self, args):
        # Override the virtual superclass method with a chart specific method.
        # Write the c:stockChart element.
        self._write_stock_chart(args)

    ###########################################################################
    #
    # XML methods.
    #
    ###########################################################################

    def _write_stock_chart(self, args):
        # Write the <c:stockChart> element.
        # Overridden to add hi_low_lines().

        if args["primary_axes"]:
            series = self._get_primary_axes_series()
        else:
            series = self._get_secondary_axes_series()

        if not len(series):
            return

        # Add default formatting to the series data.
        self._modify_series_formatting()

        self._xml_start_tag("c:stockChart")

        # Write the series elements.
        for data in series:
            self._write_ser(data)

        # Write the c:dropLines element.
        self._write_drop_lines()

        # Write the c:hiLowLines element.
        if args.get("primary_axes"):
            self._write_hi_low_lines()

        # Write the c:upDownBars element.
        self._write_up_down_bars()

        # Write the c:axId elements
        self._write_axis_ids(args)

        self._xml_end_tag("c:stockChart")

    def _modify_series_formatting(self):
        # Add default formatting to the series data.

        index = 0

        for series in self.series:
            if index % 4 != 3:
                if not series["line"]["defined"]:
                    series["line"] = {"width": 2.25, "none": 1, "defined": 1}

                if series["marker"] is None:
                    if index % 4 == 2:
                        series["marker"] = {"type": "dot", "size": 3}
                    else:
                        series["marker"] = {"type": "none"}

            index += 1

```

---

### File: `tmp\xlsxwriter_sdist\XlsxWriter-3.2.0\xlsxwriter\chartsheet.py`

```python
###############################################################################
#
# Chartsheet - A class for writing the Excel XLSX Worksheet file.
#
# SPDX-License-Identifier: BSD-2-Clause
# Copyright 2013-2024, John McNamara, jmcnamara@cpan.org
#

from . import worksheet
from .drawing import Drawing


class Chartsheet(worksheet.Worksheet):
    """
    A class for writing the Excel XLSX Chartsheet file.


    """

    ###########################################################################
    #
    # Public API.
    #
    ###########################################################################

    def __init__(self):
        """
        Constructor.

        """

        super(Chartsheet, self).__init__()

        self.is_chartsheet = True
        self.drawing = None
        self.chart = None
        self.charts = []
        self.zoom_scale_normal = 0
        self.orientation = 0
        self.protection = False

    def set_chart(self, chart):
        """
        Set the chart object for the chartsheet.
        Args:
            chart:  Chart object.
        Returns:
            chart:  A reference to the chart object.
        """
        chart.embedded = False
        chart.protection = self.protection
        self.chart = chart
        self.charts.append([0, 0, chart, 0, 0, 1, 1])
        return chart

    def protect(self, password="", options=None):
        """
        Set the password and protection options of the worksheet.

        Args:
            password: An optional password string.
            options:  A dictionary of worksheet objects to protect.

        Returns:
            Nothing.

        """
        # This method is overridden from parent worksheet class.

        # Chartsheets only allow a reduced set of protect options.
        copy = {}

        if not options:
            options = {}

        if options.get("objects") is None:
            copy["objects"] = False
        else:
            # Objects are default on for chartsheets, so reverse state.
            copy["objects"] = not options["objects"]

        if options.get("content") is None:
            copy["content"] = True
        else:
            copy["content"] = options["content"]

        copy["sheet"] = False
        copy["scenarios"] = True

        # If objects and content are both off then the chartsheet isn't
        # protected, unless it has a password.
        if password == "" and copy["objects"] and not copy["content"]:
            return

        if self.chart:
            self.chart.protection = True
        else:
            self.protection = True

        # Call the parent method.
        super(Chartsheet, self).protect(password, copy)

    ###########################################################################
    #
    # Private API.
    #
    ###########################################################################
    def _assemble_xml_file(self):
        # Assemble and write the XML file.

        # Write the XML declaration.
        self._xml_declaration()

        # Write the root worksheet element.
        self._write_chartsheet()

        # Write the worksheet properties.
        self._write_sheet_pr()

        # Write the sheet view properties.
        self._write_sheet_views()

        # Write the sheetProtection element.
        self._write_sheet_protection()

        # Write the printOptions element.
        self._write_print_options()

        # Write the worksheet page_margins.
        self._write_page_margins()

        # Write the worksheet page setup.
        self._write_page_setup()

        # Write the headerFooter element.
        self._write_header_footer()

        # Write the drawing element.
        self._write_drawings()

        # Write the legacyDrawingHF element.
        self._write_legacy_drawing_hf()

        # Close the worksheet tag.
        self._xml_end_tag("chartsheet")

        # Close the file.
        self._xml_close()

    def _prepare_chart(self, index, chart_id, drawing_id):
        # Set up chart/drawings.

        self.chart.id = chart_id - 1

        self.drawing = Drawing()
        self.drawing.orientation = self.orientation

        self.external_drawing_links.append(
            ["/drawing", "../drawings/drawing" + str(drawing_id) + ".xml"]
        )

        self.drawing_links.append(
            ["/chart", "../charts/chart" + str(chart_id) + ".xml"]
        )

    ###########################################################################
    #
    # XML methods.
    #
    ###########################################################################

    def _write_chartsheet(self):
        # Write the <worksheet> element. This is the root element.

        schema = "http://schemas.openxmlformats.org/"
        xmlns = schema + "spreadsheetml/2006/main"
        xmlns_r = schema + "officeDocument/2006/relationships"

        attributes = [("xmlns", xmlns), ("xmlns:r", xmlns_r)]

        self._xml_start_tag("chartsheet", attributes)

    def _write_sheet_pr(self):
        # Write the <sheetPr> element for Sheet level properties.
        attributes = []

        if self.filter_on:
            attributes.append(("filterMode", 1))

        if self.fit_page or self.tab_color:
            self._xml_start_tag("sheetPr", attributes)
            self._write_tab_color()
            self._write_page_set_up_pr()
            self._xml_end_tag("sheetPr")
        else:
            self._xml_empty_tag("sheetPr", attributes)

```

---

### File: `tmp\xlsxwriter_sdist\XlsxWriter-3.2.0\xlsxwriter\comments.py`

```python
###############################################################################
#
# Comments - A class for writing the Excel XLSX Worksheet file.
#
# SPDX-License-Identifier: BSD-2-Clause
# Copyright 2013-2024, John McNamara, jmcnamara@cpan.org
#

from . import xmlwriter
from .utility import preserve_whitespace
from .utility import xl_rowcol_to_cell


class Comments(xmlwriter.XMLwriter):
    """
    A class for writing the Excel XLSX Comments file.


    """

    ###########################################################################
    #
    # Public API.
    #
    ###########################################################################

    def __init__(self):
        """
        Constructor.

        """

        super(Comments, self).__init__()
        self.author_ids = {}

    ###########################################################################
    #
    # Private API.
    #
    ###########################################################################

    def _assemble_xml_file(self, comments_data=[]):
        # Assemble and write the XML file.

        # Write the XML declaration.
        self._xml_declaration()

        # Write the comments element.
        self._write_comments()

        # Write the authors element.
        self._write_authors(comments_data)

        # Write the commentList element.
        self._write_comment_list(comments_data)

        self._xml_end_tag("comments")

        # Close the file.
        self._xml_close()

    ###########################################################################
    #
    # XML methods.
    #
    ###########################################################################

    def _write_comments(self):
        # Write the <comments> element.
        xmlns = "http://schemas.openxmlformats.org/spreadsheetml/2006/main"

        attributes = [("xmlns", xmlns)]

        self._xml_start_tag("comments", attributes)

    def _write_authors(self, comment_data):
        # Write the <authors> element.
        author_count = 0

        self._xml_start_tag("authors")

        for comment in comment_data:
            author = comment[3]

            if author is not None and author not in self.author_ids:
                # Store the author id.
                self.author_ids[author] = author_count
                author_count += 1

                # Write the author element.
                self._write_author(author)

        self._xml_end_tag("authors")

    def _write_author(self, data):
        # Write the <author> element.
        self._xml_data_element("author", data)

    def _write_comment_list(self, comment_data):
        # Write the <commentList> element.
        self._xml_start_tag("commentList")

        for comment in comment_data:
            row = comment[0]
            col = comment[1]
            text = comment[2]
            author = comment[3]
            font_name = comment[6]
            font_size = comment[7]
            font_family = comment[8]

            # Look up the author id.
            author_id = None
            if author is not None:
                author_id = self.author_ids[author]

            # Write the comment element.
            font = (font_name, font_size, font_family)
            self._write_comment(row, col, text, author_id, font)

        self._xml_end_tag("commentList")

    def _write_comment(self, row, col, text, author_id, font):
        # Write the <comment> element.
        ref = xl_rowcol_to_cell(row, col)

        attributes = [("ref", ref)]

        if author_id is not None:
            attributes.append(("authorId", author_id))

        self._xml_start_tag("comment", attributes)

        # Write the text element.
        self._write_text(text, font)

        self._xml_end_tag("comment")

    def _write_text(self, text, font):
        # Write the <text> element.
        self._xml_start_tag("text")

        # Write the text r element.
        self._write_text_r(text, font)

        self._xml_end_tag("text")

    def _write_text_r(self, text, font):
        # Write the <r> element.
        self._xml_start_tag("r")

        # Write the rPr element.
        self._write_r_pr(font)

        # Write the text r element.
        self._write_text_t(text)

        self._xml_end_tag("r")

    def _write_text_t(self, text):
        # Write the text <t> element.
        attributes = []

        if preserve_whitespace(text):
            attributes.append(("xml:space", "preserve"))

        self._xml_data_element("t", text, attributes)

    def _write_r_pr(self, font):
        # Write the <rPr> element.
        self._xml_start_tag("rPr")

        # Write the sz element.
        self._write_sz(font[1])

        # Write the color element.
        self._write_color()

        # Write the rFont element.
        self._write_r_font(font[0])

        # Write the family element.
        self._write_family(font[2])

        self._xml_end_tag("rPr")

    def _write_sz(self, font_size):
        # Write the <sz> element.
        attributes = [("val", font_size)]

        self._xml_empty_tag("sz", attributes)

    def _write_color(self):
        # Write the <color> element.
        attributes = [("indexed", 81)]

        self._xml_empty_tag("color", attributes)

    def _write_r_font(self, font_name):
        # Write the <rFont> element.
        attributes = [("val", font_name)]

        self._xml_empty_tag("rFont", attributes)

    def _write_family(self, font_family):
        # Write the <family> element.
        attributes = [("val", font_family)]

        self._xml_empty_tag("family", attributes)

```

---

### File: `tmp\xlsxwriter_sdist\XlsxWriter-3.2.0\xlsxwriter\contenttypes.py`

```python
###############################################################################
#
# ContentTypes - A class for writing the Excel XLSX ContentTypes file.
#
# SPDX-License-Identifier: BSD-2-Clause
# Copyright 2013-2024, John McNamara, jmcnamara@cpan.org
#

import copy
from . import xmlwriter

# Long namespace strings used in the class.
app_package = "application/vnd.openxmlformats-package."
app_document = "application/vnd.openxmlformats-officedocument."

defaults = [
    ["rels", app_package + "relationships+xml"],
    ["xml", "application/xml"],
]

overrides = [
    ["/docProps/app.xml", app_document + "extended-properties+xml"],
    ["/docProps/core.xml", app_package + "core-properties+xml"],
    ["/xl/styles.xml", app_document + "spreadsheetml.styles+xml"],
    ["/xl/theme/theme1.xml", app_document + "theme+xml"],
    ["/xl/workbook.xml", app_document + "spreadsheetml.sheet.main+xml"],
]


class ContentTypes(xmlwriter.XMLwriter):
    """
    A class for writing the Excel XLSX ContentTypes file.


    """

    ###########################################################################
    #
    # Public API.
    #
    ###########################################################################

    def __init__(self):
        """
        Constructor.

        """

        super(ContentTypes, self).__init__()

        # Copy the defaults in case we need to change them.
        self.defaults = copy.deepcopy(defaults)
        self.overrides = copy.deepcopy(overrides)

    ###########################################################################
    #
    # Private API.
    #
    ###########################################################################

    def _assemble_xml_file(self):
        # Assemble and write the XML file.

        # Write the XML declaration.
        self._xml_declaration()

        self._write_types()
        self._write_defaults()
        self._write_overrides()

        self._xml_end_tag("Types")

        # Close the file.
        self._xml_close()

    def _add_default(self, default):
        # Add elements to the ContentTypes defaults.
        self.defaults.append(default)

    def _add_override(self, override):
        # Add elements to the ContentTypes overrides.
        self.overrides.append(override)

    def _add_worksheet_name(self, worksheet_name):
        # Add the name of a worksheet to the ContentTypes overrides.
        worksheet_name = "/xl/worksheets/" + worksheet_name + ".xml"

        self._add_override(
            (worksheet_name, app_document + "spreadsheetml.worksheet+xml")
        )

    def _add_chartsheet_name(self, chartsheet_name):
        # Add the name of a chartsheet to the ContentTypes overrides.
        chartsheet_name = "/xl/chartsheets/" + chartsheet_name + ".xml"

        self._add_override(
            (chartsheet_name, app_document + "spreadsheetml.chartsheet+xml")
        )

    def _add_chart_name(self, chart_name):
        # Add the name of a chart to the ContentTypes overrides.
        chart_name = "/xl/charts/" + chart_name + ".xml"

        self._add_override((chart_name, app_document + "drawingml.chart+xml"))

    def _add_drawing_name(self, drawing_name):
        # Add the name of a drawing to the ContentTypes overrides.
        drawing_name = "/xl/drawings/" + drawing_name + ".xml"

        self._add_override((drawing_name, app_document + "drawing+xml"))

    def _add_vml_name(self):
        # Add the name of a VML drawing to the ContentTypes defaults.
        self._add_default(("vml", app_document + "vmlDrawing"))

    def _add_comment_name(self, comment_name):
        # Add the name of a comment to the ContentTypes overrides.
        comment_name = "/xl/" + comment_name + ".xml"

        self._add_override((comment_name, app_document + "spreadsheetml.comments+xml"))

    def _add_shared_strings(self):
        # Add the sharedStrings link to the ContentTypes overrides.
        self._add_override(
            ("/xl/sharedStrings.xml", app_document + "spreadsheetml.sharedStrings+xml")
        )

    def _add_calc_chain(self):
        # Add the calcChain link to the ContentTypes overrides.
        self._add_override(
            ("/xl/calcChain.xml", app_document + "spreadsheetml.calcChain+xml")
        )

    def _add_image_types(self, image_types):
        # Add the image default types.
        for image_type in image_types:
            extension = image_type

            if image_type in ("wmf", "emf"):
                image_type = "x-" + image_type

            self._add_default((extension, "image/" + image_type))

    def _add_table_name(self, table_name):
        # Add the name of a table to the ContentTypes overrides.
        table_name = "/xl/tables/" + table_name + ".xml"

        self._add_override((table_name, app_document + "spreadsheetml.table+xml"))

    def _add_vba_project(self):
        # Add a vbaProject to the ContentTypes defaults.

        # Change the workbook.xml content-type from xlsx to xlsm.
        for i, override in enumerate(self.overrides):
            if override[0] == "/xl/workbook.xml":
                xlsm = "application/vnd.ms-excel.sheet.macroEnabled.main+xml"
                self.overrides[i][1] = xlsm

        self._add_default(("bin", "application/vnd.ms-office.vbaProject"))

    def _add_vba_project_signature(self):
        # Add a vbaProjectSignature to the ContentTypes overrides.
        self._add_override(
            (
                "/xl/vbaProjectSignature.bin",
                "application/vnd.ms-office.vbaProjectSignature",
            )
        )

    def _add_custom_properties(self):
        # Add the custom properties to the ContentTypes overrides.
        self._add_override(
            ("/docProps/custom.xml", app_document + "custom-properties+xml")
        )

    def _add_metadata(self):
        # Add the metadata file to the ContentTypes overrides.
        self._add_override(
            ("/xl/metadata.xml", app_document + "spreadsheetml.sheetMetadata+xml")
        )

    def _add_rich_value(self):
        # Add the richValue files to the ContentTypes overrides.
        self._add_override(
            (
                "/xl/richData/rdRichValueTypes.xml",
                "application/vnd.ms-excel.rdrichvaluetypes+xml",
            )
        )

        self._add_override(
            ("/xl/richData/rdrichvalue.xml", "application/vnd.ms-excel.rdrichvalue+xml")
        )

        self._add_override(
            (
                "/xl/richData/rdrichvaluestructure.xml",
                "application/vnd.ms-excel.rdrichvaluestructure+xml",
            )
        )

        self._add_override(
            (
                "/xl/richData/richValueRel.xml",
                "application/vnd.ms-excel.richvaluerel+xml",
            )
        )

    ###########################################################################
    #
    # XML methods.
    #
    ###########################################################################

    def _write_defaults(self):
        # Write out all of the <Default> types.

        for extension, content_type in self.defaults:
            self._xml_empty_tag(
                "Default", [("Extension", extension), ("ContentType", content_type)]
            )

    def _write_overrides(self):
        # Write out all of the <Override> types.
        for part_name, content_type in self.overrides:
            self._xml_empty_tag(
                "Override", [("PartName", part_name), ("ContentType", content_type)]
            )

    def _write_types(self):
        # Write the <Types> element.
        xmlns = "http://schemas.openxmlformats.org/package/2006/content-types"

        attributes = [
            (
                "xmlns",
                xmlns,
            )
        ]
        self._xml_start_tag("Types", attributes)

    def _write_default(self, extension, content_type):
        # Write the <Default> element.
        attributes = [
            ("Extension", extension),
            ("ContentType", content_type),
        ]

        self._xml_empty_tag("Default", attributes)

    def _write_override(self, part_name, content_type):
        # Write the <Override> element.
        attributes = [
            ("PartName", part_name),
            ("ContentType", content_type),
        ]

        self._xml_empty_tag("Override", attributes)

```

---

### File: `tmp\xlsxwriter_sdist\XlsxWriter-3.2.0\xlsxwriter\core.py`

```python
###############################################################################
#
# Core - A class for writing the Excel XLSX Worksheet file.
#
# SPDX-License-Identifier: BSD-2-Clause
# Copyright 2013-2024, John McNamara, jmcnamara@cpan.org
#

# Standard packages.
from datetime import datetime, timezone

# Package imports.
from . import xmlwriter


class Core(xmlwriter.XMLwriter):
    """
    A class for writing the Excel XLSX Core file.


    """

    ###########################################################################
    #
    # Public API.
    #
    ###########################################################################

    def __init__(self):
        """
        Constructor.

        """

        super(Core, self).__init__()

        self.properties = {}

    ###########################################################################
    #
    # Private API.
    #
    ###########################################################################

    def _assemble_xml_file(self):
        # Assemble and write the XML file.

        # Write the XML declaration.
        self._xml_declaration()

        self._write_cp_core_properties()
        self._write_dc_title()
        self._write_dc_subject()
        self._write_dc_creator()
        self._write_cp_keywords()
        self._write_dc_description()
        self._write_cp_last_modified_by()
        self._write_dcterms_created()
        self._write_dcterms_modified()
        self._write_cp_category()
        self._write_cp_content_status()

        self._xml_end_tag("cp:coreProperties")

        # Close the file.
        self._xml_close()

    def _set_properties(self, properties):
        # Set the document properties.
        self.properties = properties

    def _datetime_to_iso8601_date(self, date):
        # Convert to a ISO 8601 style "2010-01-01T00:00:00Z" date.
        if not date:
            date = datetime.now(timezone.utc)

        return date.strftime("%Y-%m-%dT%H:%M:%SZ")

    ###########################################################################
    #
    # XML methods.
    #
    ###########################################################################

    def _write_cp_core_properties(self):
        # Write the <cp:coreProperties> element.

        xmlns_cp = (
            "http://schemas.openxmlformats.org/package/2006/"
            + "metadata/core-properties"
        )
        xmlns_dc = "http://purl.org/dc/elements/1.1/"
        xmlns_dcterms = "http://purl.org/dc/terms/"
        xmlns_dcmitype = "http://purl.org/dc/dcmitype/"
        xmlns_xsi = "http://www.w3.org/2001/XMLSchema-instance"

        attributes = [
            ("xmlns:cp", xmlns_cp),
            ("xmlns:dc", xmlns_dc),
            ("xmlns:dcterms", xmlns_dcterms),
            ("xmlns:dcmitype", xmlns_dcmitype),
            ("xmlns:xsi", xmlns_xsi),
        ]

        self._xml_start_tag("cp:coreProperties", attributes)

    def _write_dc_creator(self):
        # Write the <dc:creator> element.
        data = self.properties.get("author", "")

        self._xml_data_element("dc:creator", data)

    def _write_cp_last_modified_by(self):
        # Write the <cp:lastModifiedBy> element.
        data = self.properties.get("author", "")

        self._xml_data_element("cp:lastModifiedBy", data)

    def _write_dcterms_created(self):
        # Write the <dcterms:created> element.
        date = self.properties.get("created", datetime.now(timezone.utc))

        xsi_type = "dcterms:W3CDTF"

        date = self._datetime_to_iso8601_date(date)

        attributes = [
            (
                "xsi:type",
                xsi_type,
            )
        ]

        self._xml_data_element("dcterms:created", date, attributes)

    def _write_dcterms_modified(self):
        # Write the <dcterms:modified> element.
        date = self.properties.get("created", datetime.now(timezone.utc))

        xsi_type = "dcterms:W3CDTF"

        date = self._datetime_to_iso8601_date(date)

        attributes = [
            (
                "xsi:type",
                xsi_type,
            )
        ]

        self._xml_data_element("dcterms:modified", date, attributes)

    def _write_dc_title(self):
        # Write the <dc:title> element.
        if "title" in self.properties:
            data = self.properties["title"]
        else:
            return

        self._xml_data_element("dc:title", data)

    def _write_dc_subject(self):
        # Write the <dc:subject> element.
        if "subject" in self.properties:
            data = self.properties["subject"]
        else:
            return

        self._xml_data_element("dc:subject", data)

    def _write_cp_keywords(self):
        # Write the <cp:keywords> element.
        if "keywords" in self.properties:
            data = self.properties["keywords"]
        else:
            return

        self._xml_data_element("cp:keywords", data)

    def _write_dc_description(self):
        # Write the <dc:description> element.
        if "comments" in self.properties:
            data = self.properties["comments"]
        else:
            return

        self._xml_data_element("dc:description", data)

    def _write_cp_category(self):
        # Write the <cp:category> element.
        if "category" in self.properties:
            data = self.properties["category"]
        else:
            return

        self._xml_data_element("cp:category", data)

    def _write_cp_content_status(self):
        # Write the <cp:contentStatus> element.
        if "status" in self.properties:
            data = self.properties["status"]
        else:
            return

        self._xml_data_element("cp:contentStatus", data)

```

---

### File: `tmp\xlsxwriter_sdist\XlsxWriter-3.2.0\xlsxwriter\custom.py`

```python
###############################################################################
#
# Custom - A class for writing the Excel XLSX Custom Property file.
#
# SPDX-License-Identifier: BSD-2-Clause
# Copyright 2013-2024, John McNamara, jmcnamara@cpan.org
#

# Package imports.
from . import xmlwriter


class Custom(xmlwriter.XMLwriter):
    """
    A class for writing the Excel XLSX Custom Workbook Property file.


    """

    ###########################################################################
    #
    # Public API.
    #
    ###########################################################################

    def __init__(self):
        """
        Constructor.

        """

        super(Custom, self).__init__()

        self.properties = []
        self.pid = 1

    def _set_properties(self, properties):
        # Set the document properties.
        self.properties = properties

    ###########################################################################
    #
    # Private API.
    #
    ###########################################################################

    def _assemble_xml_file(self):
        # Assemble and write the XML file.

        # Write the XML declaration.
        self._xml_declaration()

        self._write_properties()

        self._xml_end_tag("Properties")

        # Close the file.
        self._xml_close()

    ###########################################################################
    #
    # XML methods.
    #
    ###########################################################################

    def _write_properties(self):
        # Write the <Properties> element.
        schema = "http://schemas.openxmlformats.org/officeDocument/2006/"
        xmlns = schema + "custom-properties"
        xmlns_vt = schema + "docPropsVTypes"

        attributes = [
            ("xmlns", xmlns),
            ("xmlns:vt", xmlns_vt),
        ]

        self._xml_start_tag("Properties", attributes)

        for custom_property in self.properties:
            # Write the property element.
            self._write_property(custom_property)

    def _write_property(self, custom_property):
        # Write the <property> element.

        fmtid = "{D5CDD505-2E9C-101B-9397-08002B2CF9AE}"

        name, value, property_type = custom_property
        self.pid += 1

        attributes = [
            ("fmtid", fmtid),
            ("pid", self.pid),
            ("name", name),
        ]

        self._xml_start_tag("property", attributes)

        if property_type == "number_int":
            # Write the vt:i4 element.
            self._write_vt_i4(value)
        elif property_type == "number":
            # Write the vt:r8 element.
            self._write_vt_r8(value)
        elif property_type == "date":
            # Write the vt:filetime element.
            self._write_vt_filetime(value)
        elif property_type == "bool":
            # Write the vt:bool element.
            self._write_vt_bool(value)
        else:
            # Write the vt:lpwstr element.
            self._write_vt_lpwstr(value)

        self._xml_end_tag("property")

    def _write_vt_lpwstr(self, value):
        # Write the <vt:lpwstr> element.
        self._xml_data_element("vt:lpwstr", value)

    def _write_vt_filetime(self, value):
        # Write the <vt:filetime> element.
        self._xml_data_element("vt:filetime", value)

    def _write_vt_i4(self, value):
        # Write the <vt:i4> element.
        self._xml_data_element("vt:i4", value)

    def _write_vt_r8(self, value):
        # Write the <vt:r8> element.
        self._xml_data_element("vt:r8", value)

    def _write_vt_bool(self, value):
        # Write the <vt:bool> element.

        if value:
            value = "true"
        else:
            value = "false"

        self._xml_data_element("vt:bool", value)

```

---

### File: `tmp\xlsxwriter_sdist\XlsxWriter-3.2.0\xlsxwriter\drawing.py`

```python
###############################################################################
#
# Drawing - A class for writing the Excel XLSX Drawing file.
#
# SPDX-License-Identifier: BSD-2-Clause
# Copyright 2013-2024, John McNamara, jmcnamara@cpan.org
#

from . import xmlwriter
from .shape import Shape
from .utility import get_rgb_color


class Drawing(xmlwriter.XMLwriter):
    """
    A class for writing the Excel XLSX Drawing file.


    """

    ###########################################################################
    #
    # Public API.
    #
    ###########################################################################

    def __init__(self):
        """
        Constructor.

        """

        super(Drawing, self).__init__()

        self.drawings = []
        self.embedded = 0
        self.orientation = 0

    ###########################################################################
    #
    # Private API.
    #
    ###########################################################################

    def _assemble_xml_file(self):
        # Assemble and write the XML file.

        # Write the XML declaration.
        self._xml_declaration()

        # Write the xdr:wsDr element.
        self._write_drawing_workspace()

        if self.embedded:
            index = 0
            for drawing_properties in self.drawings:
                # Write the xdr:twoCellAnchor element.
                index += 1
                self._write_two_cell_anchor(index, drawing_properties)

        else:
            # Write the xdr:absoluteAnchor element.
            self._write_absolute_anchor(1)

        self._xml_end_tag("xdr:wsDr")

        # Close the file.
        self._xml_close()

    def _add_drawing_object(self):
        # Add a chart, image or shape sub object to the drawing.

        drawing_object = {
            "anchor_type": None,
            "dimensions": [],
            "width": 0,
            "height": 0,
            "shape": None,
            "anchor": None,
            "rel_index": 0,
            "url_rel_index": 0,
            "tip": None,
            "name": None,
            "description": None,
            "decorative": False,
        }

        self.drawings.append(drawing_object)

        return drawing_object

    ###########################################################################
    #
    # XML methods.
    #
    ###########################################################################

    def _write_drawing_workspace(self):
        # Write the <xdr:wsDr> element.
        schema = "http://schemas.openxmlformats.org/drawingml/"
        xmlns_xdr = schema + "2006/spreadsheetDrawing"
        xmlns_a = schema + "2006/main"

        attributes = [
            ("xmlns:xdr", xmlns_xdr),
            ("xmlns:a", xmlns_a),
        ]

        self._xml_start_tag("xdr:wsDr", attributes)

    def _write_two_cell_anchor(self, index, drawing_properties):
        # Write the <xdr:twoCellAnchor> element.
        anchor_type = drawing_properties["type"]
        dimensions = drawing_properties["dimensions"]
        col_from = dimensions[0]
        row_from = dimensions[1]
        col_from_offset = dimensions[2]
        row_from_offset = dimensions[3]
        col_to = dimensions[4]
        row_to = dimensions[5]
        col_to_offset = dimensions[6]
        row_to_offset = dimensions[7]
        col_absolute = dimensions[8]
        row_absolute = dimensions[9]
        width = drawing_properties["width"]
        height = drawing_properties["height"]
        shape = drawing_properties["shape"]
        anchor = drawing_properties["anchor"]
        rel_index = drawing_properties["rel_index"]
        url_rel_index = drawing_properties["url_rel_index"]
        tip = drawing_properties["tip"]
        name = drawing_properties["name"]
        description = drawing_properties["description"]
        decorative = drawing_properties["decorative"]

        attributes = []

        # Add attribute for positioning.
        if anchor == 2:
            attributes.append(("editAs", "oneCell"))
        elif anchor == 3:
            attributes.append(("editAs", "absolute"))

        # Add editAs attribute for shapes.
        if shape and shape.edit_as:
            attributes.append(("editAs", shape.edit_as))

        self._xml_start_tag("xdr:twoCellAnchor", attributes)

        # Write the xdr:from element.
        self._write_from(col_from, row_from, col_from_offset, row_from_offset)

        # Write the xdr:from element.
        self._write_to(col_to, row_to, col_to_offset, row_to_offset)

        if anchor_type == 1:
            # Graphic frame.
            # Write the xdr:graphicFrame element for charts.
            self._write_graphic_frame(index, rel_index, name, description, decorative)
        elif anchor_type == 2:
            # Write the xdr:pic element.
            self._write_pic(
                index,
                rel_index,
                col_absolute,
                row_absolute,
                width,
                height,
                shape,
                description,
                url_rel_index,
                tip,
                decorative,
            )
        else:
            # Write the xdr:sp element for shapes.
            self._write_sp(
                index,
                col_absolute,
                row_absolute,
                width,
                height,
                shape,
                description,
                url_rel_index,
                tip,
                decorative,
            )

        # Write the xdr:clientData element.
        self._write_client_data()

        self._xml_end_tag("xdr:twoCellAnchor")

    def _write_absolute_anchor(self, frame_index):
        self._xml_start_tag("xdr:absoluteAnchor")
        # Write the <xdr:absoluteAnchor> element.

        # Different coordinates for horizontal (= 0) and vertical (= 1).
        if self.orientation == 0:
            # Write the xdr:pos element.
            self._write_pos(0, 0)

            # Write the xdr:ext element.
            self._write_xdr_ext(9308969, 6078325)

        else:
            # Write the xdr:pos element.
            self._write_pos(0, -47625)

            # Write the xdr:ext element.
            self._write_xdr_ext(6162675, 6124575)

        # Write the xdr:graphicFrame element.
        self._write_graphic_frame(frame_index, frame_index)

        # Write the xdr:clientData element.
        self._write_client_data()

        self._xml_end_tag("xdr:absoluteAnchor")

    def _write_from(self, col, row, col_offset, row_offset):
        # Write the <xdr:from> element.
        self._xml_start_tag("xdr:from")

        # Write the xdr:col element.
        self._write_col(col)

        # Write the xdr:colOff element.
        self._write_col_off(col_offset)

        # Write the xdr:row element.
        self._write_row(row)

        # Write the xdr:rowOff element.
        self._write_row_off(row_offset)

        self._xml_end_tag("xdr:from")

    def _write_to(self, col, row, col_offset, row_offset):
        # Write the <xdr:to> element.
        self._xml_start_tag("xdr:to")

        # Write the xdr:col element.
        self._write_col(col)

        # Write the xdr:colOff element.
        self._write_col_off(col_offset)

        # Write the xdr:row element.
        self._write_row(row)

        # Write the xdr:rowOff element.
        self._write_row_off(row_offset)

        self._xml_end_tag("xdr:to")

    def _write_col(self, data):
        # Write the <xdr:col> element.
        self._xml_data_element("xdr:col", data)

    def _write_col_off(self, data):
        # Write the <xdr:colOff> element.
        self._xml_data_element("xdr:colOff", data)

    def _write_row(self, data):
        # Write the <xdr:row> element.
        self._xml_data_element("xdr:row", data)

    def _write_row_off(self, data):
        # Write the <xdr:rowOff> element.
        self._xml_data_element("xdr:rowOff", data)

    def _write_pos(self, x, y):
        # Write the <xdr:pos> element.

        attributes = [("x", x), ("y", y)]

        self._xml_empty_tag("xdr:pos", attributes)

    def _write_xdr_ext(self, cx, cy):
        # Write the <xdr:ext> element.

        attributes = [("cx", cx), ("cy", cy)]

        self._xml_empty_tag("xdr:ext", attributes)

    def _write_graphic_frame(
        self, index, rel_index, name=None, description=None, decorative=None
    ):
        # Write the <xdr:graphicFrame> element.
        attributes = [("macro", "")]

        self._xml_start_tag("xdr:graphicFrame", attributes)

        # Write the xdr:nvGraphicFramePr element.
        self._write_nv_graphic_frame_pr(index, name, description, decorative)

        # Write the xdr:xfrm element.
        self._write_xfrm()

        # Write the a:graphic element.
        self._write_atag_graphic(rel_index)

        self._xml_end_tag("xdr:graphicFrame")

    def _write_nv_graphic_frame_pr(self, index, name, description, decorative):
        # Write the <xdr:nvGraphicFramePr> element.

        if not name:
            name = "Chart " + str(index)

        self._xml_start_tag("xdr:nvGraphicFramePr")

        # Write the xdr:cNvPr element.
        self._write_c_nv_pr(index + 1, name, description, None, None, decorative)

        # Write the xdr:cNvGraphicFramePr element.
        self._write_c_nv_graphic_frame_pr()

        self._xml_end_tag("xdr:nvGraphicFramePr")

    def _write_c_nv_pr(self, index, name, description, url_rel_index, tip, decorative):
        # Write the <xdr:cNvPr> element.
        attributes = [("id", index), ("name", name)]

        # Add description attribute for images.
        if description and not decorative:
            attributes.append(("descr", description))

        if url_rel_index or decorative:
            self._xml_start_tag("xdr:cNvPr", attributes)

            if url_rel_index:
                self._write_a_hlink_click(url_rel_index, tip)

            if decorative:
                self._write_decorative()

            self._xml_end_tag("xdr:cNvPr")
        else:
            self._xml_empty_tag("xdr:cNvPr", attributes)

    def _write_decorative(self):
        self._xml_start_tag("a:extLst")

        self._write_uri_ext("{FF2B5EF4-FFF2-40B4-BE49-F238E27FC236}")
        self._write_a16_creation_id()
        self._xml_end_tag("a:ext")

        self._write_uri_ext("{C183D7F6-B498-43B3-948B-1728B52AA6E4}")
        self._write_adec_decorative()
        self._xml_end_tag("a:ext")

        self._xml_end_tag("a:extLst")

    def _write_uri_ext(self, uri):
        # Write the <a:ext> element.
        attributes = [("uri", uri)]

        self._xml_start_tag("a:ext", attributes)

    def _write_adec_decorative(self):
        # Write the <adec:decorative> element.
        xmlns = "http://schemas.microsoft.com/office/drawing/2017/decorative"
        val = "1"

        attributes = [
            ("xmlns:adec", xmlns),
            ("val", val),
        ]

        self._xml_empty_tag("adec:decorative", attributes)

    def _write_a16_creation_id(self):
        # Write the <a16:creationId> element.

        xmlns_a_16 = "http://schemas.microsoft.com/office/drawing/2014/main"
        creation_id = "{00000000-0008-0000-0000-000002000000}"

        attributes = [
            ("xmlns:a16", xmlns_a_16),
            ("id", creation_id),
        ]

        self._xml_empty_tag("a16:creationId", attributes)

    def _write_a_hlink_click(self, rel_index, tip):
        # Write the <a:hlinkClick> element.
        schema = "http://schemas.openxmlformats.org/officeDocument/"
        xmlns_r = schema + "2006/relationships"

        attributes = [
            ("xmlns:r", xmlns_r),
            ("r:id", "rId" + str(rel_index)),
        ]

        if tip:
            attributes.append(("tooltip", tip))

        self._xml_empty_tag("a:hlinkClick", attributes)

    def _write_c_nv_graphic_frame_pr(self):
        # Write the <xdr:cNvGraphicFramePr> element.
        if self.embedded:
            self._xml_empty_tag("xdr:cNvGraphicFramePr")
        else:
            self._xml_start_tag("xdr:cNvGraphicFramePr")

            # Write the a:graphicFrameLocks element.
            self._write_a_graphic_frame_locks()

            self._xml_end_tag("xdr:cNvGraphicFramePr")

    def _write_a_graphic_frame_locks(self):
        # Write the <a:graphicFrameLocks> element.
        attributes = [("noGrp", 1)]

        self._xml_empty_tag("a:graphicFrameLocks", attributes)

    def _write_xfrm(self):
        # Write the <xdr:xfrm> element.
        self._xml_start_tag("xdr:xfrm")

        # Write the xfrmOffset element.
        self._write_xfrm_offset()

        # Write the xfrmOffset element.
        self._write_xfrm_extension()

        self._xml_end_tag("xdr:xfrm")

    def _write_xfrm_offset(self):
        # Write the <a:off> xfrm sub-element.

        attributes = [
            ("x", 0),
            ("y", 0),
        ]

        self._xml_empty_tag("a:off", attributes)

    def _write_xfrm_extension(self):
        # Write the <a:ext> xfrm sub-element.

        attributes = [
            ("cx", 0),
            ("cy", 0),
        ]

        self._xml_empty_tag("a:ext", attributes)

    def _write_atag_graphic(self, index):
        # Write the <a:graphic> element.
        self._xml_start_tag("a:graphic")

        # Write the a:graphicData element.
        self._write_atag_graphic_data(index)

        self._xml_end_tag("a:graphic")

    def _write_atag_graphic_data(self, index):
        # Write the <a:graphicData> element.
        uri = "http://schemas.openxmlformats.org/drawingml/2006/chart"

        attributes = [
            (
                "uri",
                uri,
            )
        ]

        self._xml_start_tag("a:graphicData", attributes)

        # Write the c:chart element.
        self._write_c_chart("rId" + str(index))

        self._xml_end_tag("a:graphicData")

    def _write_c_chart(self, r_id):
        # Write the <c:chart> element.

        schema = "http://schemas.openxmlformats.org/"
        xmlns_c = schema + "drawingml/2006/chart"
        xmlns_r = schema + "officeDocument/2006/relationships"

        attributes = [
            ("xmlns:c", xmlns_c),
            ("xmlns:r", xmlns_r),
            ("r:id", r_id),
        ]

        self._xml_empty_tag("c:chart", attributes)

    def _write_client_data(self):
        # Write the <xdr:clientData> element.
        self._xml_empty_tag("xdr:clientData")

    def _write_sp(
        self,
        index,
        col_absolute,
        row_absolute,
        width,
        height,
        shape,
        description,
        url_rel_index,
        tip,
        decorative,
    ):
        # Write the <xdr:sp> element.

        if shape and shape.connect:
            attributes = [("macro", "")]
            self._xml_start_tag("xdr:cxnSp", attributes)

            # Write the xdr:nvCxnSpPr element.
            self._write_nv_cxn_sp_pr(index, shape)

            # Write the xdr:spPr element.
            self._write_xdr_sp_pr(
                index, col_absolute, row_absolute, width, height, shape
            )

            self._xml_end_tag("xdr:cxnSp")
        else:
            # Add attribute for shapes.
            attributes = [("macro", ""), ("textlink", shape.textlink)]

            self._xml_start_tag("xdr:sp", attributes)

            # Write the xdr:nvSpPr element.
            self._write_nv_sp_pr(
                index, shape, url_rel_index, tip, description, decorative
            )

            # Write the xdr:spPr element.
            self._write_xdr_sp_pr(
                index, col_absolute, row_absolute, width, height, shape
            )

            # Write the xdr:style element.
            self._write_style()

            # Write the xdr:txBody element.
            if shape.text is not None:
                self._write_tx_body(col_absolute, row_absolute, width, height, shape)

            self._xml_end_tag("xdr:sp")

    def _write_nv_cxn_sp_pr(self, index, shape):
        # Write the <xdr:nvCxnSpPr> element.
        self._xml_start_tag("xdr:nvCxnSpPr")

        name = shape.name + " " + str(index)
        if name is not None:
            self._write_c_nv_pr(index, name, None, None, None, None)

        self._xml_start_tag("xdr:cNvCxnSpPr")

        attributes = [("noChangeShapeType", "1")]
        self._xml_empty_tag("a:cxnSpLocks", attributes)

        if shape.start:
            attributes = [("id", shape.start), ("idx", shape.start_index)]
            self._xml_empty_tag("a:stCxn", attributes)

        if shape.end:
            attributes = [("id", shape.end), ("idx", shape.end_index)]
            self._xml_empty_tag("a:endCxn", attributes)

        self._xml_end_tag("xdr:cNvCxnSpPr")
        self._xml_end_tag("xdr:nvCxnSpPr")

    def _write_nv_sp_pr(
        self, index, shape, url_rel_index, tip, description, decorative
    ):
        # Write the <xdr:NvSpPr> element.
        attributes = []

        self._xml_start_tag("xdr:nvSpPr")

        name = shape.name + " " + str(index)

        self._write_c_nv_pr(
            index + 1, name, description, url_rel_index, tip, decorative
        )

        if shape.name == "TextBox":
            attributes = [("txBox", 1)]

        self._xml_empty_tag("xdr:cNvSpPr", attributes)

        self._xml_end_tag("xdr:nvSpPr")

    def _write_pic(
        self,
        index,
        rel_index,
        col_absolute,
        row_absolute,
        width,
        height,
        shape,
        description,
        url_rel_index,
        tip,
        decorative,
    ):
        # Write the <xdr:pic> element.
        self._xml_start_tag("xdr:pic")

        # Write the xdr:nvPicPr element.
        self._write_nv_pic_pr(
            index, rel_index, description, url_rel_index, tip, decorative
        )
        # Write the xdr:blipFill element.
        self._write_blip_fill(rel_index)

        # Write the xdr:spPr element.
        self._write_sp_pr(col_absolute, row_absolute, width, height, shape)

        self._xml_end_tag("xdr:pic")

    def _write_nv_pic_pr(
        self, index, rel_index, description, url_rel_index, tip, decorative
    ):
        # Write the <xdr:nvPicPr> element.
        self._xml_start_tag("xdr:nvPicPr")

        # Write the xdr:cNvPr element.
        self._write_c_nv_pr(
            index + 1,
            "Picture " + str(index),
            description,
            url_rel_index,
            tip,
            decorative,
        )

        # Write the xdr:cNvPicPr element.
        self._write_c_nv_pic_pr()

        self._xml_end_tag("xdr:nvPicPr")

    def _write_c_nv_pic_pr(self):
        # Write the <xdr:cNvPicPr> element.
        self._xml_start_tag("xdr:cNvPicPr")

        # Write the a:picLocks element.
        self._write_a_pic_locks()

        self._xml_end_tag("xdr:cNvPicPr")

    def _write_a_pic_locks(self):
        # Write the <a:picLocks> element.
        attributes = [("noChangeAspect", 1)]

        self._xml_empty_tag("a:picLocks", attributes)

    def _write_blip_fill(self, index):
        # Write the <xdr:blipFill> element.
        self._xml_start_tag("xdr:blipFill")

        # Write the a:blip element.
        self._write_a_blip(index)

        # Write the a:stretch element.
        self._write_a_stretch()

        self._xml_end_tag("xdr:blipFill")

    def _write_a_blip(self, index):
        # Write the <a:blip> element.
        schema = "http://schemas.openxmlformats.org/officeDocument/"
        xmlns_r = schema + "2006/relationships"
        r_embed = "rId" + str(index)

        attributes = [("xmlns:r", xmlns_r), ("r:embed", r_embed)]

        self._xml_empty_tag("a:blip", attributes)

    def _write_a_stretch(self):
        # Write the <a:stretch> element.
        self._xml_start_tag("a:stretch")

        # Write the a:fillRect element.
        self._write_a_fill_rect()

        self._xml_end_tag("a:stretch")

    def _write_a_fill_rect(self):
        # Write the <a:fillRect> element.
        self._xml_empty_tag("a:fillRect")

    def _write_sp_pr(self, col_absolute, row_absolute, width, height, shape=None):
        # Write the <xdr:spPr> element, for charts.

        self._xml_start_tag("xdr:spPr")

        # Write the a:xfrm element.
        self._write_a_xfrm(col_absolute, row_absolute, width, height)

        # Write the a:prstGeom element.
        self._write_a_prst_geom(shape)

        self._xml_end_tag("xdr:spPr")

    def _write_xdr_sp_pr(self, index, col_absolute, row_absolute, width, height, shape):
        # Write the <xdr:spPr> element for shapes.
        self._xml_start_tag("xdr:spPr")

        # Write the a:xfrm element.
        self._write_a_xfrm(col_absolute, row_absolute, width, height, shape)

        # Write the a:prstGeom element.
        self._write_a_prst_geom(shape)

        if shape.fill:
            if not shape.fill["defined"]:
                # Write the a:solidFill element.
                self._write_a_solid_fill_scheme("lt1")
            elif "none" in shape.fill:
                # Write the a:noFill element.
                self._xml_empty_tag("a:noFill")
            elif "color" in shape.fill:
                # Write the a:solidFill element.
                self._write_a_solid_fill(get_rgb_color(shape.fill["color"]))

        if shape.gradient:
            # Write the a:gradFill element.
            self._write_a_grad_fill(shape.gradient)

        # Write the a:ln element.
        self._write_a_ln(shape.line)

        self._xml_end_tag("xdr:spPr")

    def _write_a_xfrm(self, col_absolute, row_absolute, width, height, shape=None):
        # Write the <a:xfrm> element.
        attributes = []

        if shape:
            if shape.rotation:
                rotation = shape.rotation
                rotation *= 60000
                attributes.append(("rot", rotation))

            if shape.flip_h:
                attributes.append(("flipH", 1))
            if shape.flip_v:
                attributes.append(("flipV", 1))

        self._xml_start_tag("a:xfrm", attributes)

        # Write the a:off element.
        self._write_a_off(col_absolute, row_absolute)

        # Write the a:ext element.
        self._write_a_ext(width, height)

        self._xml_end_tag("a:xfrm")

    def _write_a_off(self, x, y):
        # Write the <a:off> element.
        attributes = [
            ("x", x),
            ("y", y),
        ]

        self._xml_empty_tag("a:off", attributes)

    def _write_a_ext(self, cx, cy):
        # Write the <a:ext> element.
        attributes = [
            ("cx", cx),
            ("cy", cy),
        ]

        self._xml_empty_tag("a:ext", attributes)

    def _write_a_prst_geom(self, shape=None):
        # Write the <a:prstGeom> element.
        attributes = [("prst", "rect")]

        self._xml_start_tag("a:prstGeom", attributes)

        # Write the a:avLst element.
        self._write_a_av_lst(shape)

        self._xml_end_tag("a:prstGeom")

    def _write_a_av_lst(self, shape=None):
        # Write the <a:avLst> element.
        adjustments = []

        if shape and shape.adjustments:
            adjustments = shape.adjustments

        if adjustments:
            self._xml_start_tag("a:avLst")

            i = 0
            for adj in adjustments:
                i += 1
                # Only connectors have multiple adjustments.
                if shape.connect:
                    suffix = i
                else:
                    suffix = ""

                # Scale Adjustments: 100,000 = 100%.
                adj_int = str(int(adj * 1000))

                attributes = [("name", "adj" + suffix), ("fmla", "val" + adj_int)]

                self._xml_empty_tag("a:gd", attributes)

            self._xml_end_tag("a:avLst")
        else:
            self._xml_empty_tag("a:avLst")

    def _write_a_solid_fill(self, rgb):
        # Write the <a:solidFill> element.
        if rgb is None:
            rgb = "FFFFFF"

        self._xml_start_tag("a:solidFill")

        # Write the a:srgbClr element.
        self._write_a_srgb_clr(rgb)

        self._xml_end_tag("a:solidFill")

    def _write_a_solid_fill_scheme(self, color, shade=None):
        attributes = [("val", color)]

        self._xml_start_tag("a:solidFill")

        if shade:
            self._xml_start_tag("a:schemeClr", attributes)
            self._write_a_shade(shade)
            self._xml_end_tag("a:schemeClr")
        else:
            self._xml_empty_tag("a:schemeClr", attributes)

        self._xml_end_tag("a:solidFill")

    def _write_a_ln(self, line):
        # Write the <a:ln> element.
        width = line.get("width", 0.75)

        # Round width to nearest 0.25, like Excel.
        width = int((width + 0.125) * 4) / 4.0

        # Convert to internal units.
        width = int(0.5 + (12700 * width))

        attributes = [("w", width), ("cmpd", "sng")]

        self._xml_start_tag("a:ln", attributes)

        if "none" in line:
            # Write the a:noFill element.
            self._xml_empty_tag("a:noFill")

        elif "color" in line:
            # Write the a:solidFill element.
            self._write_a_solid_fill(get_rgb_color(line["color"]))

        else:
            # Write the a:solidFill element.
            self._write_a_solid_fill_scheme("lt1", "50000")

        # Write the line/dash type.
        line_type = line.get("dash_type")
        if line_type:
            # Write the a:prstDash element.
            self._write_a_prst_dash(line_type)

        self._xml_end_tag("a:ln")

    def _write_tx_body(self, col_absolute, row_absolute, width, height, shape):
        # Write the <xdr:txBody> element.
        attributes = []

        if shape.text_rotation != 0:
            if shape.text_rotation == 90:
                attributes.append(("vert", "vert270"))
            if shape.text_rotation == -90:
                attributes.append(("vert", "vert"))
            if shape.text_rotation == 270:
                attributes.append(("vert", "wordArtVert"))
            if shape.text_rotation == 271:
                attributes.append(("vert", "eaVert"))

        attributes.append(("wrap", "square"))
        attributes.append(("rtlCol", "0"))

        if not shape.align["defined"]:
            attributes.append(("anchor", "t"))
        else:
            if "vertical" in shape.align:
                align = shape.align["vertical"]
                if align == "top":
                    attributes.append(("anchor", "t"))
                elif align == "middle":
                    attributes.append(("anchor", "ctr"))
                elif align == "bottom":
                    attributes.append(("anchor", "b"))
            else:
                attributes.append(("anchor", "t"))

            if "horizontal" in shape.align:
                align = shape.align["horizontal"]
                if align == "center":
                    attributes.append(("anchorCtr", "1"))
            else:
                attributes.append(("anchorCtr", "0"))

        self._xml_start_tag("xdr:txBody")
        self._xml_empty_tag("a:bodyPr", attributes)
        self._xml_empty_tag("a:lstStyle")

        lines = shape.text.split("\n")

        # Set the font attributes.
        font = shape.font
        style_attrs = Shape._get_font_style_attributes(font)
        latin_attrs = Shape._get_font_latin_attributes(font)
        style_attrs.insert(0, ("lang", font["lang"]))

        if shape.textlink != "":
            attributes = [
                ("id", "{B8ADDEFE-BF52-4FD4-8C5D-6B85EF6FF707}"),
                ("type", "TxLink"),
            ]

            self._xml_start_tag("a:p")
            self._xml_start_tag("a:fld", attributes)

            self._write_font_run(font, style_attrs, latin_attrs, "a:rPr")

            self._xml_data_element("a:t", shape.text)
            self._xml_end_tag("a:fld")

            self._write_font_run(font, style_attrs, latin_attrs, "a:endParaRPr")

            self._xml_end_tag("a:p")
        else:
            for line in lines:
                self._xml_start_tag("a:p")

                if line == "":
                    self._write_font_run(font, style_attrs, latin_attrs, "a:endParaRPr")
                    self._xml_end_tag("a:p")
                    continue
                elif "text" in shape.align:
                    if shape.align["text"] == "left":
                        self._xml_empty_tag("a:pPr", [("algn", "l")])
                    if shape.align["text"] == "center":
                        self._xml_empty_tag("a:pPr", [("algn", "ctr")])
                    if shape.align["text"] == "right":
                        self._xml_empty_tag("a:pPr", [("algn", "r")])

                self._xml_start_tag("a:r")

                self._write_font_run(font, style_attrs, latin_attrs, "a:rPr")

                self._xml_data_element("a:t", line)

                self._xml_end_tag("a:r")
                self._xml_end_tag("a:p")

        self._xml_end_tag("xdr:txBody")

    def _write_font_run(self, font, style_attrs, latin_attrs, run_type):
        # Write a:rPr or a:endParaRPr.
        if font.get("color") is not None:
            has_color = True
        else:
            has_color = False

        if latin_attrs or has_color:
            self._xml_start_tag(run_type, style_attrs)

            if has_color:
                self._write_a_solid_fill(get_rgb_color(font["color"]))

            if latin_attrs:
                self._write_a_latin(latin_attrs)
                self._write_a_cs(latin_attrs)

            self._xml_end_tag(run_type)
        else:
            self._xml_empty_tag(run_type, style_attrs)

    def _write_style(self):
        # Write the <xdr:style> element.
        self._xml_start_tag("xdr:style")

        # Write the a:lnRef element.
        self._write_a_ln_ref()

        # Write the a:fillRef element.
        self._write_a_fill_ref()

        # Write the a:effectRef element.
        self._write_a_effect_ref()

        # Write the a:fontRef element.
        self._write_a_font_ref()

        self._xml_end_tag("xdr:style")

    def _write_a_ln_ref(self):
        # Write the <a:lnRef> element.
        attributes = [("idx", "0")]

        self._xml_start_tag("a:lnRef", attributes)

        # Write the a:scrgbClr element.
        self._write_a_scrgb_clr()

        self._xml_end_tag("a:lnRef")

    def _write_a_fill_ref(self):
        # Write the <a:fillRef> element.
        attributes = [("idx", "0")]

        self._xml_start_tag("a:fillRef", attributes)

        # Write the a:scrgbClr element.
        self._write_a_scrgb_clr()

        self._xml_end_tag("a:fillRef")

    def _write_a_effect_ref(self):
        # Write the <a:effectRef> element.
        attributes = [("idx", "0")]

        self._xml_start_tag("a:effectRef", attributes)

        # Write the a:scrgbClr element.
        self._write_a_scrgb_clr()

        self._xml_end_tag("a:effectRef")

    def _write_a_scrgb_clr(self):
        # Write the <a:scrgbClr> element.

        attributes = [
            ("r", "0"),
            ("g", "0"),
            ("b", "0"),
        ]

        self._xml_empty_tag("a:scrgbClr", attributes)

    def _write_a_font_ref(self):
        # Write the <a:fontRef> element.
        attributes = [("idx", "minor")]

        self._xml_start_tag("a:fontRef", attributes)

        # Write the a:schemeClr element.
        self._write_a_scheme_clr("dk1")

        self._xml_end_tag("a:fontRef")

    def _write_a_scheme_clr(self, val):
        # Write the <a:schemeClr> element.
        attributes = [("val", val)]

        self._xml_empty_tag("a:schemeClr", attributes)

    def _write_a_shade(self, shade):
        # Write the <a:shade> element.
        attributes = [("val", shade)]

        self._xml_empty_tag("a:shade", attributes)

    def _write_a_prst_dash(self, val):
        # Write the <a:prstDash> element.

        attributes = [("val", val)]

        self._xml_empty_tag("a:prstDash", attributes)

    def _write_a_grad_fill(self, gradient):
        # Write the <a:gradFill> element.

        attributes = [("flip", "none"), ("rotWithShape", "1")]

        if gradient["type"] == "linear":
            attributes = []

        self._xml_start_tag("a:gradFill", attributes)

        # Write the a:gsLst element.
        self._write_a_gs_lst(gradient)

        if gradient["type"] == "linear":
            # Write the a:lin element.
            self._write_a_lin(gradient["angle"])
        else:
            # Write the a:path element.
            self._write_a_path(gradient["type"])

            # Write the a:tileRect element.
            self._write_a_tile_rect(gradient["type"])

        self._xml_end_tag("a:gradFill")

    def _write_a_gs_lst(self, gradient):
        # Write the <a:gsLst> element.
        positions = gradient["positions"]
        colors = gradient["colors"]

        self._xml_start_tag("a:gsLst")

        for i in range(len(colors)):
            pos = int(positions[i] * 1000)
            attributes = [("pos", pos)]
            self._xml_start_tag("a:gs", attributes)

            # Write the a:srgbClr element.
            color = get_rgb_color(colors[i])
            self._write_a_srgb_clr(color)

            self._xml_end_tag("a:gs")

        self._xml_end_tag("a:gsLst")

    def _write_a_lin(self, angle):
        # Write the <a:lin> element.

        angle = int(60000 * angle)

        attributes = [
            ("ang", angle),
            ("scaled", "0"),
        ]

        self._xml_empty_tag("a:lin", attributes)

    def _write_a_path(self, gradient_type):
        # Write the <a:path> element.

        attributes = [("path", gradient_type)]

        self._xml_start_tag("a:path", attributes)

        # Write the a:fillToRect element.
        self._write_a_fill_to_rect(gradient_type)

        self._xml_end_tag("a:path")

    def _write_a_fill_to_rect(self, gradient_type):
        # Write the <a:fillToRect> element.

        if gradient_type == "shape":
            attributes = [
                ("l", "50000"),
                ("t", "50000"),
                ("r", "50000"),
                ("b", "50000"),
            ]
        else:
            attributes = [
                ("l", "100000"),
                ("t", "100000"),
            ]

        self._xml_empty_tag("a:fillToRect", attributes)

    def _write_a_tile_rect(self, gradient_type):
        # Write the <a:tileRect> element.

        if gradient_type == "shape":
            attributes = []
        else:
            attributes = [
                ("r", "-100000"),
                ("b", "-100000"),
            ]

        self._xml_empty_tag("a:tileRect", attributes)

    def _write_a_srgb_clr(self, val):
        # Write the <a:srgbClr> element.

        attributes = [("val", val)]

        self._xml_empty_tag("a:srgbClr", attributes)

    def _write_a_latin(self, attributes):
        # Write the <a:latin> element.
        self._xml_empty_tag("a:latin", attributes)

    def _write_a_cs(self, attributes):
        # Write the <a:latin> element.
        self._xml_empty_tag("a:cs", attributes)

```

---

### File: `tmp\xlsxwriter_sdist\XlsxWriter-3.2.0\xlsxwriter\exceptions.py`

```python
###############################################################################
#
# Exceptions - A class for XlsxWriter exceptions.
#
# SPDX-License-Identifier: BSD-2-Clause
# Copyright 2013-2024, John McNamara, jmcnamara@cpan.org
#


class XlsxWriterException(Exception):
    """Base exception for XlsxWriter."""


class XlsxInputError(XlsxWriterException):
    """Base exception for all input data related errors."""


class XlsxFileError(XlsxWriterException):
    """Base exception for all file related errors."""


class EmptyChartSeries(XlsxInputError):
    """Chart must contain at least one data series."""


class DuplicateTableName(XlsxInputError):
    """Worksheet table name already exists."""


class InvalidWorksheetName(XlsxInputError):
    """Worksheet name is too long or contains restricted characters."""


class DuplicateWorksheetName(XlsxInputError):
    """Worksheet name already exists."""


class OverlappingRange(XlsxInputError):
    """Worksheet merge range or table overlaps previous range."""


class UndefinedImageSize(XlsxFileError):
    """No size data found in image file."""


class UnsupportedImageFormat(XlsxFileError):
    """Unsupported image file format."""


class FileCreateError(XlsxFileError):
    """IO error when creating xlsx file."""


class FileSizeError(XlsxFileError):
    """Filesize would require ZIP64 extensions. Use workbook.use_zip64()."""

```

---

### File: `tmp\xlsxwriter_sdist\XlsxWriter-3.2.0\xlsxwriter\format.py`

```python
###############################################################################
#
# Format - A class for writing the Excel XLSX Worksheet file.
#
# SPDX-License-Identifier: BSD-2-Clause
# Copyright 2013-2024, John McNamara, jmcnamara@cpan.org
#

# Package imports.
from . import xmlwriter
from warnings import warn


class Format(xmlwriter.XMLwriter):
    """
    A class for writing the Excel XLSX Format file.


    """

    ###########################################################################
    #
    # Public API.
    #
    ###########################################################################

    def __init__(self, properties=None, xf_indices=None, dxf_indices=None):
        """
        Constructor.

        """
        if properties is None:
            properties = {}

        super(Format, self).__init__()

        self.xf_format_indices = xf_indices
        self.dxf_format_indices = dxf_indices
        self.xf_index = None
        self.dxf_index = None

        self.num_format = "General"
        self.num_format_index = 0
        self.font_index = 0
        self.has_font = 0
        self.has_dxf_font = 0

        self.bold = 0
        self.underline = 0
        self.italic = 0
        self.font_name = "Calibri"
        self.font_size = 11
        self.font_color = 0x0
        self.font_strikeout = 0
        self.font_outline = 0
        self.font_shadow = 0
        self.font_script = 0
        self.font_family = 2
        self.font_charset = 0
        self.font_scheme = "minor"
        self.font_condense = 0
        self.font_extend = 0
        self.theme = 0
        self.hyperlink = False
        self.xf_id = 0

        self.hidden = 0
        self.locked = 1

        self.text_h_align = 0
        self.text_wrap = 0
        self.text_v_align = 0
        self.text_justlast = 0
        self.rotation = 0

        self.fg_color = 0
        self.bg_color = 0
        self.pattern = 0
        self.has_fill = 0
        self.has_dxf_fill = 0
        self.fill_index = 0
        self.fill_count = 0

        self.border_index = 0
        self.has_border = 0
        self.has_dxf_border = 0
        self.border_count = 0

        self.bottom = 0
        self.bottom_color = 0
        self.diag_border = 0
        self.diag_color = 0
        self.diag_type = 0
        self.left = 0
        self.left_color = 0
        self.right = 0
        self.right_color = 0
        self.top = 0
        self.top_color = 0

        self.indent = 0
        self.shrink = 0
        self.merge_range = 0
        self.reading_order = 0
        self.just_distrib = 0
        self.color_indexed = 0
        self.font_only = 0

        self.quote_prefix = False

        # Convert properties in the constructor to method calls.
        for key, value in properties.items():
            getattr(self, "set_" + key)(value)

        self._format_key = None

    ###########################################################################
    #
    # Format properties.
    #
    ###########################################################################

    def set_font_name(self, font_name):
        """
        Set the Format font_name property such as 'Time New Roman'. The
        default Excel font is 'Calibri'.

        Args:
            font_name: String with the font name. No default.

        Returns:
            Nothing.

        """
        self.font_name = font_name

    def set_font_size(self, font_size=11):
        """
        Set the Format font_size property. The default Excel font size is 11.

        Args:
            font_size: Int with font size. No default.

        Returns:
            Nothing.

        """
        self.font_size = font_size

    def set_font_color(self, font_color):
        """
        Set the Format font_color property. The Excel default is black.

        Args:
            font_color: String with the font color. No default.

        Returns:
            Nothing.

        """
        self.font_color = self._get_color(font_color)

    def set_bold(self, bold=True):
        """
        Set the Format bold property.

        Args:
            bold: Default is True, turns property on.

        Returns:
            Nothing.

        """
        self.bold = bold

    def set_italic(self, italic=True):
        """
        Set the Format italic property.

        Args:
            italic: Default is True, turns property on.

        Returns:
            Nothing.

        """
        self.italic = italic

    def set_underline(self, underline=1):
        """
        Set the Format underline property.

        Args:
            underline: Default is 1, single underline.

        Returns:
            Nothing.

        """
        self.underline = underline

    def set_font_strikeout(self, font_strikeout=True):
        """
        Set the Format font_strikeout property.

        Args:
            font_strikeout: Default is True, turns property on.

        Returns:
            Nothing.

        """
        self.font_strikeout = font_strikeout

    def set_font_script(self, font_script=1):
        """
        Set the Format font_script property.

        Args:
            font_script: Default is 1, superscript.

        Returns:
            Nothing.

        """
        self.font_script = font_script

    def set_font_outline(self, font_outline=True):
        """
        Set the Format font_outline property.

        Args:
            font_outline: Default is True, turns property on.

        Returns:
            Nothing.

        """
        self.font_outline = font_outline

    def set_font_shadow(self, font_shadow=True):
        """
        Set the Format font_shadow property.

        Args:
            font_shadow: Default is True, turns property on.

        Returns:
            Nothing.

        """
        self.font_shadow = font_shadow

    def set_num_format(self, num_format):
        """
        Set the Format num_format property such as '#,##0'.

        Args:
            num_format: String representing the number format. No default.

        Returns:
            Nothing.

        """
        self.num_format = num_format

    def set_locked(self, locked=True):
        """
        Set the Format locked property.

        Args:
            locked: Default is True, turns property on.

        Returns:
            Nothing.

        """
        self.locked = locked

    def set_hidden(self, hidden=True):
        """
        Set the Format hidden property.

        Args:
            hidden: Default is True, turns property on.

        Returns:
            Nothing.

        """
        self.hidden = hidden

    def set_align(self, alignment):
        """
        Set the Format cell alignment.

        Args:
            alignment: String representing alignment. No default.

        Returns:
            Nothing.
        """
        alignment = alignment.lower()

        # Set horizontal alignment properties.
        if alignment == "left":
            self.set_text_h_align(1)
        if alignment == "centre":
            self.set_text_h_align(2)
        if alignment == "center":
            self.set_text_h_align(2)
        if alignment == "right":
            self.set_text_h_align(3)
        if alignment == "fill":
            self.set_text_h_align(4)
        if alignment == "justify":
            self.set_text_h_align(5)
        if alignment == "center_across":
            self.set_text_h_align(6)
        if alignment == "centre_across":
            self.set_text_h_align(6)
        if alignment == "distributed":
            self.set_text_h_align(7)
        if alignment == "justify_distributed":
            self.set_text_h_align(7)

        if alignment == "justify_distributed":
            self.just_distrib = 1

        # Set vertical alignment properties.
        if alignment == "top":
            self.set_text_v_align(1)
        if alignment == "vcentre":
            self.set_text_v_align(2)
        if alignment == "vcenter":
            self.set_text_v_align(2)
        if alignment == "bottom":
            self.set_text_v_align(3)
        if alignment == "vjustify":
            self.set_text_v_align(4)
        if alignment == "vdistributed":
            self.set_text_v_align(5)

    def set_center_across(self, align_type=None):
        """
        Set the Format center_across property.

        Returns:
            Nothing.

        """
        self.set_text_h_align(6)

    def set_text_wrap(self, text_wrap=True):
        """
        Set the Format text_wrap property.

        Args:
            text_wrap: Default is True, turns property on.

        Returns:
            Nothing.

        """
        self.text_wrap = text_wrap

    def set_rotation(self, rotation):
        """
        Set the Format rotation property.

        Args:
            rotation: Rotation angle. No default.

        Returns:
            Nothing.

        """
        rotation = int(rotation)

        # Map user angle to Excel angle.
        if rotation == 270:
            rotation = 255
        elif -90 <= rotation <= 90:
            if rotation < 0:
                rotation = -rotation + 90
        else:
            warn("Rotation rotation outside range: -90 <= angle <= 90")
            return

        self.rotation = rotation

    def set_indent(self, indent=1):
        """
        Set the Format indent property.

        Args:
            indent: Default is 1, first indentation level.

        Returns:
            Nothing.

        """
        self.indent = indent

    def set_shrink(self, shrink=True):
        """
        Set the Format shrink property.

        Args:
            shrink: Default is True, turns property on.

        Returns:
            Nothing.

        """
        self.shrink = shrink

    def set_text_justlast(self, text_justlast=True):
        """
        Set the Format text_justlast property.

        Args:
            text_justlast: Default is True, turns property on.

        Returns:
            Nothing.

        """
        self.text_justlast = text_justlast

    def set_pattern(self, pattern=1):
        """
        Set the Format pattern property.

        Args:
            pattern: Default is 1, solid fill.

        Returns:
            Nothing.

        """
        self.pattern = pattern

    def set_bg_color(self, bg_color):
        """
        Set the Format bg_color property.

        Args:
            bg_color: Background color. No default.

        Returns:
            Nothing.

        """
        self.bg_color = self._get_color(bg_color)

    def set_fg_color(self, fg_color):
        """
        Set the Format fg_color property.

        Args:
            fg_color: Foreground color. No default.

        Returns:
            Nothing.

        """
        self.fg_color = self._get_color(fg_color)

    # set_border(style) Set cells borders to the same style
    def set_border(self, style=1):
        """
        Set the Format bottom property.

        Args:
            bottom: Default is 1, border type 1.

        Returns:
            Nothing.

        """
        self.set_bottom(style)
        self.set_top(style)
        self.set_left(style)
        self.set_right(style)

    # set_border_color(color) Set cells border to the same color
    def set_border_color(self, color):
        """
        Set the Format bottom property.

        Args:
            color: Color string. No default.

        Returns:
            Nothing.

        """
        self.set_bottom_color(color)
        self.set_top_color(color)
        self.set_left_color(color)
        self.set_right_color(color)

    def set_bottom(self, bottom=1):
        """
        Set the Format bottom property.

        Args:
            bottom: Default is 1, border type 1.

        Returns:
            Nothing.

        """
        self.bottom = bottom

    def set_bottom_color(self, bottom_color):
        """
        Set the Format bottom_color property.

        Args:
            bottom_color: Color string. No default.

        Returns:
            Nothing.

        """
        self.bottom_color = self._get_color(bottom_color)

    def set_diag_type(self, diag_type=1):
        """
        Set the Format diag_type property.

        Args:
            diag_type: Default is 1, border type 1.

        Returns:
            Nothing.

        """
        self.diag_type = diag_type

    def set_left(self, left=1):
        """
        Set the Format left property.

        Args:
            left: Default is 1, border type 1.

        Returns:
            Nothing.

        """
        self.left = left

    def set_left_color(self, left_color):
        """
        Set the Format left_color property.

        Args:
            left_color: Color string. No default.

        Returns:
            Nothing.

        """
        self.left_color = self._get_color(left_color)

    def set_right(self, right=1):
        """
        Set the Format right property.

        Args:
            right: Default is 1, border type 1.

        Returns:
            Nothing.

        """
        self.right = right

    def set_right_color(self, right_color):
        """
        Set the Format right_color property.

        Args:
            right_color: Color string. No default.

        Returns:
            Nothing.

        """
        self.right_color = self._get_color(right_color)

    def set_top(self, top=1):
        """
        Set the Format top property.

        Args:
            top: Default is 1, border type 1.

        Returns:
            Nothing.

        """
        self.top = top

    def set_top_color(self, top_color):
        """
        Set the Format top_color property.

        Args:
            top_color: Color string. No default.

        Returns:
            Nothing.

        """
        self.top_color = self._get_color(top_color)

    def set_diag_color(self, diag_color):
        """
        Set the Format diag_color property.

        Args:
            diag_color: Color string. No default.

        Returns:
            Nothing.

        """
        self.diag_color = self._get_color(diag_color)

    def set_diag_border(self, diag_border=1):
        """
        Set the Format diag_border property.

        Args:
            diag_border: Default is 1, border type 1.

        Returns:
            Nothing.

        """
        self.diag_border = diag_border

    def set_quote_prefix(self, quote_prefix=True):
        """
        Set the Format quote prefix property.

        Args:
            quote_prefix: Default is True, turns property on.

        Returns:
            Nothing.

        """
        self.quote_prefix = quote_prefix

    ###########################################################################
    #
    # Internal Format properties. These aren't documented since they are
    # either only used internally or else are unlikely to be set by the user.
    #
    ###########################################################################

    def set_has_font(self, has_font=True):
        # Set the has_font property.
        self.has_font = has_font

    def set_has_fill(self, has_fill=True):
        # Set the has_fill property.
        self.has_fill = has_fill

    def set_font_index(self, font_index):
        # Set the font_index property.
        self.font_index = font_index

    def set_xf_index(self, xf_index):
        # Set the xf_index property.
        self.xf_index = xf_index

    def set_dxf_index(self, dxf_index):
        # Set the xf_index property.
        self.dxf_index = dxf_index

    def set_num_format_index(self, num_format_index):
        # Set the num_format_index property.
        self.num_format_index = num_format_index

    def set_text_h_align(self, text_h_align):
        # Set the text_h_align property.
        self.text_h_align = text_h_align

    def set_text_v_align(self, text_v_align):
        # Set the text_v_align property.
        self.text_v_align = text_v_align

    def set_reading_order(self, direction=0):
        # Set the reading_order property.
        self.reading_order = direction

    def set_valign(self, align):
        # Set vertical cell alignment. This is required by the constructor
        # properties dict to differentiate between the vertical and horizontal
        # properties.
        self.set_align(align)

    def set_font_family(self, font_family):
        # Set the Format font_family property.
        self.font_family = font_family

    def set_font_charset(self, font_charset):
        # Set the Format font_charset property.
        self.font_charset = font_charset

    def set_font_scheme(self, font_scheme):
        # Set the Format font_scheme property.
        self.font_scheme = font_scheme

    def set_font_condense(self, font_condense):
        # Set the Format font_condense property.
        self.font_condense = font_condense

    def set_font_extend(self, font_extend):
        # Set the Format font_extend property.
        self.font_extend = font_extend

    def set_theme(self, theme):
        # Set the Format theme property.
        self.theme = theme

    def set_hyperlink(self, hyperlink=True):
        # Set the properties for the hyperlink style. This isn't
        # currently public. To be fixed when styles are supported.
        self.xf_id = 1
        self.set_underline(1)
        self.set_theme(10)
        self.hyperlink = hyperlink

    def set_color_indexed(self, color_index):
        # Used in the cell comment format.
        self.color_indexed = color_index

    def set_font_only(self, font_only=True):
        # Used in the cell comment format.
        self.font_only = font_only

    # Compatibility methods.
    def set_font(self, font_name):
        #  For compatibility with Excel::Writer::XLSX.
        self.font_name = font_name

    def set_size(self, font_size):
        #  For compatibility with Excel::Writer::XLSX.
        self.font_size = font_size

    def set_color(self, font_color):
        #  For compatibility with Excel::Writer::XLSX.
        self.font_color = self._get_color(font_color)

    ###########################################################################
    #
    # Private API.
    #
    ###########################################################################

    def _get_align_properties(self):
        # Return properties for an Style xf <alignment> sub-element.
        changed = 0
        align = []

        # Check if any alignment options in the format have been changed.
        if (
            self.text_h_align
            or self.text_v_align
            or self.indent
            or self.rotation
            or self.text_wrap
            or self.shrink
            or self.reading_order
        ):
            changed = 1
        else:
            return changed, align

        # Indent is only allowed for some alignment properties. If it is
        # defined for any other alignment or no alignment has been set then
        # default to left alignment.
        if (
            self.indent
            and self.text_h_align != 1
            and self.text_h_align != 3
            and self.text_h_align != 7
            and self.text_v_align != 1
            and self.text_v_align != 3
            and self.text_v_align != 5
        ):
            self.text_h_align = 1

        # Check for properties that are mutually exclusive.
        if self.text_wrap:
            self.shrink = 0
        if self.text_h_align == 4:
            self.shrink = 0
        if self.text_h_align == 5:
            self.shrink = 0
        if self.text_h_align == 7:
            self.shrink = 0
        if self.text_h_align != 7:
            self.just_distrib = 0
        if self.indent:
            self.just_distrib = 0

        continuous = "centerContinuous"

        if self.text_h_align == 1:
            align.append(("horizontal", "left"))
        if self.text_h_align == 2:
            align.append(("horizontal", "center"))
        if self.text_h_align == 3:
            align.append(("horizontal", "right"))
        if self.text_h_align == 4:
            align.append(("horizontal", "fill"))
        if self.text_h_align == 5:
            align.append(("horizontal", "justify"))
        if self.text_h_align == 6:
            align.append(("horizontal", continuous))
        if self.text_h_align == 7:
            align.append(("horizontal", "distributed"))

        if self.just_distrib:
            align.append(("justifyLastLine", 1))

        # Property 'vertical' => 'bottom' is a default. It sets applyAlignment
        # without an alignment sub-element.
        if self.text_v_align == 1:
            align.append(("vertical", "top"))
        if self.text_v_align == 2:
            align.append(("vertical", "center"))
        if self.text_v_align == 4:
            align.append(("vertical", "justify"))
        if self.text_v_align == 5:
            align.append(("vertical", "distributed"))

        if self.rotation:
            align.append(("textRotation", self.rotation))
        if self.indent:
            align.append(("indent", self.indent))

        if self.text_wrap:
            align.append(("wrapText", 1))
        if self.shrink:
            align.append(("shrinkToFit", 1))

        if self.reading_order == 1:
            align.append(("readingOrder", 1))
        if self.reading_order == 2:
            align.append(("readingOrder", 2))

        return changed, align

    def _get_protection_properties(self):
        # Return properties for an Excel XML <Protection> element.
        attribs = []

        if not self.locked:
            attribs.append(("locked", 0))
        if self.hidden:
            attribs.append(("hidden", 1))

        return attribs

    def _get_format_key(self):
        # Returns a unique hash key for a format. Used by Workbook.
        if self._format_key is None:
            self._format_key = ":".join(
                str(x)
                for x in (
                    self._get_font_key(),
                    self._get_border_key(),
                    self._get_fill_key(),
                    self._get_alignment_key(),
                    self.num_format,
                    self.locked,
                    self.quote_prefix,
                    self.hidden,
                )
            )

        return self._format_key

    def _get_font_key(self):
        # Returns a unique hash key for a font. Used by Workbook.
        key = ":".join(
            str(x)
            for x in (
                self.bold,
                self.font_color,
                self.font_charset,
                self.font_family,
                self.font_outline,
                self.font_script,
                self.font_shadow,
                self.font_strikeout,
                self.font_name,
                self.italic,
                self.font_size,
                self.underline,
                self.theme,
            )
        )

        return key

    def _get_border_key(self):
        # Returns a unique hash key for a border style. Used by Workbook.
        key = ":".join(
            str(x)
            for x in (
                self.bottom,
                self.bottom_color,
                self.diag_border,
                self.diag_color,
                self.diag_type,
                self.left,
                self.left_color,
                self.right,
                self.right_color,
                self.top,
                self.top_color,
            )
        )

        return key

    def _get_fill_key(self):
        # Returns a unique hash key for a fill style. Used by Workbook.
        key = ":".join(str(x) for x in (self.pattern, self.bg_color, self.fg_color))

        return key

    def _get_alignment_key(self):
        # Returns a unique hash key for alignment formats.

        key = ":".join(
            str(x)
            for x in (
                self.text_h_align,
                self.text_v_align,
                self.indent,
                self.rotation,
                self.text_wrap,
                self.shrink,
                self.reading_order,
            )
        )

        return key

    def _get_xf_index(self):
        # Returns the XF index number used by Excel to identify a format.
        if self.xf_index is not None:
            # Format already has an index number so return it.
            return self.xf_index
        else:
            # Format doesn't have an index number so assign one.
            key = self._get_format_key()

            if key in self.xf_format_indices:
                # Format matches existing format with an index.
                return self.xf_format_indices[key]
            else:
                # New format requiring an index. Note. +1 since Excel
                # has an implicit "General" format at index 0.
                index = 1 + len(self.xf_format_indices)
                self.xf_format_indices[key] = index
                self.xf_index = index
                return index

    def _get_dxf_index(self):
        # Returns the DXF index number used by Excel to identify a format.
        if self.dxf_index is not None:
            # Format already has an index number so return it.
            return self.dxf_index
        else:
            # Format doesn't have an index number so assign one.
            key = self._get_format_key()

            if key in self.dxf_format_indices:
                # Format matches existing format with an index.
                return self.dxf_format_indices[key]
            else:
                # New format requiring an index.
                index = len(self.dxf_format_indices)
                self.dxf_format_indices[key] = index
                self.dxf_index = index
                return index

    def _get_color(self, color):
        # Used in conjunction with the set_xxx_color methods to convert a
        # color name into an RGB formatted string. These colors are for
        # backward compatibility with older versions of Excel.
        named_colors = {
            "black": "#000000",
            "blue": "#0000FF",
            "brown": "#800000",
            "cyan": "#00FFFF",
            "gray": "#808080",
            "green": "#008000",
            "lime": "#00FF00",
            "magenta": "#FF00FF",
            "navy": "#000080",
            "orange": "#FF6600",
            "pink": "#FF00FF",
            "purple": "#800080",
            "red": "#FF0000",
            "silver": "#C0C0C0",
            "white": "#FFFFFF",
            "yellow": "#FFFF00",
            "automatic": "Automatic",
        }

        if color in named_colors:
            color = named_colors[color]

        return color

    ###########################################################################
    #
    # XML methods.
    #
    ###########################################################################

```

---

### File: `tmp\xlsxwriter_sdist\XlsxWriter-3.2.0\xlsxwriter\metadata.py`

```python
###############################################################################
#
# Metadata - A class for writing the Excel XLSX Metadata file.
#
# SPDX-License-Identifier: BSD-2-Clause
# Copyright 2013-2024, John McNamara, jmcnamara@cpan.org
#

from . import xmlwriter


class Metadata(xmlwriter.XMLwriter):
    """
    A class for writing the Excel XLSX Metadata file.


    """

    ###########################################################################
    #
    # Public API.
    #
    ###########################################################################

    def __init__(self):
        """
        Constructor.

        """

        super(Metadata, self).__init__()
        self.has_dynamic_functions = False
        self.has_embedded_images = False
        self.num_embedded_images = 0

    ###########################################################################
    #
    # Private API.
    #
    ###########################################################################

    def _assemble_xml_file(self):
        # Assemble and write the XML file.

        if self.num_embedded_images > 0:
            self.has_embedded_images = True

        # Write the XML declaration.
        self._xml_declaration()

        # Write the metadata element.
        self._write_metadata()

        # Write the metadataTypes element.
        self._write_metadata_types()

        # Write the futureMetadata elements.
        if self.has_dynamic_functions:
            self._write_cell_future_metadata()
        if self.has_embedded_images:
            self._write_value_future_metadata()

        # Write the cellMetadata element.
        if self.has_dynamic_functions:
            self._write_cell_metadata()
        if self.has_embedded_images:
            self._write_value_metadata()

        self._xml_end_tag("metadata")

        # Close the file.
        self._xml_close()

    ###########################################################################
    #
    # XML methods.
    #
    ###########################################################################

    def _write_metadata(self):
        # Write the <metadata> element.
        xmlns = "http://schemas.openxmlformats.org/spreadsheetml/2006/main"
        schema = "http://schemas.microsoft.com/office/spreadsheetml"

        attributes = [("xmlns", xmlns)]

        if self.has_embedded_images:
            attributes.append(("xmlns:xlrd", schema + "/2017/richdata"))

        if self.has_dynamic_functions:
            attributes.append(("xmlns:xda", schema + "/2017/dynamicarray"))

        self._xml_start_tag("metadata", attributes)

    def _write_metadata_types(self):
        # Write the <metadataTypes> element.
        count = 0

        if self.has_dynamic_functions:
            count += 1
        if self.has_embedded_images:
            count += 1

        attributes = [("count", count)]

        self._xml_start_tag("metadataTypes", attributes)

        # Write the metadataType element.
        if self.has_dynamic_functions:
            self._write_cell_metadata_type()
        if self.has_embedded_images:
            self._write_value_metadata_type()

        self._xml_end_tag("metadataTypes")

    def _write_cell_metadata_type(self):
        # Write the <metadataType> element.
        attributes = [
            ("name", "XLDAPR"),
            ("minSupportedVersion", 120000),
            ("copy", 1),
            ("pasteAll", 1),
            ("pasteValues", 1),
            ("merge", 1),
            ("splitFirst", 1),
            ("rowColShift", 1),
            ("clearFormats", 1),
            ("clearComments", 1),
            ("assign", 1),
            ("coerce", 1),
            ("cellMeta", 1),
        ]

        self._xml_empty_tag("metadataType", attributes)

    def _write_value_metadata_type(self):
        # Write the <metadataType> element.
        attributes = [
            ("name", "XLRICHVALUE"),
            ("minSupportedVersion", 120000),
            ("copy", 1),
            ("pasteAll", 1),
            ("pasteValues", 1),
            ("merge", 1),
            ("splitFirst", 1),
            ("rowColShift", 1),
            ("clearFormats", 1),
            ("clearComments", 1),
            ("assign", 1),
            ("coerce", 1),
        ]

        self._xml_empty_tag("metadataType", attributes)

    def _write_cell_future_metadata(self):
        # Write the <futureMetadata> element.
        attributes = [
            ("name", "XLDAPR"),
            ("count", 1),
        ]

        self._xml_start_tag("futureMetadata", attributes)
        self._xml_start_tag("bk")
        self._xml_start_tag("extLst")
        self._write_cell_ext()
        self._xml_end_tag("extLst")
        self._xml_end_tag("bk")
        self._xml_end_tag("futureMetadata")

    def _write_value_future_metadata(self):
        # Write the <futureMetadata> element.
        attributes = [
            ("name", "XLRICHVALUE"),
            ("count", self.num_embedded_images),
        ]

        self._xml_start_tag("futureMetadata", attributes)

        for index in range(self.num_embedded_images):
            self._xml_start_tag("bk")
            self._xml_start_tag("extLst")
            self._write_value_ext(index)
            self._xml_end_tag("extLst")
            self._xml_end_tag("bk")

        self._xml_end_tag("futureMetadata")

    def _write_cell_ext(self):
        # Write the <ext> element.
        attributes = [("uri", "{bdbb8cdc-fa1e-496e-a857-3c3f30c029c3}")]

        self._xml_start_tag("ext", attributes)

        # Write the xda:dynamicArrayProperties element.
        self._write_xda_dynamic_array_properties()

        self._xml_end_tag("ext")

    def _write_xda_dynamic_array_properties(self):
        # Write the <xda:dynamicArrayProperties> element.
        attributes = [
            ("fDynamic", 1),
            ("fCollapsed", 0),
        ]

        self._xml_empty_tag("xda:dynamicArrayProperties", attributes)

    def _write_value_ext(self, index):
        # Write the <ext> element.
        attributes = [("uri", "{3e2802c4-a4d2-4d8b-9148-e3be6c30e623}")]

        self._xml_start_tag("ext", attributes)

        # Write the xlrd:rvb element.
        self._write_xlrd_rvb(index)

        self._xml_end_tag("ext")

    def _write_xlrd_rvb(self, index):
        # Write the <xlrd:rvb> element.
        attributes = [("i", index)]

        self._xml_empty_tag("xlrd:rvb", attributes)

    def _write_cell_metadata(self):
        # Write the <cellMetadata> element.
        attributes = [("count", 1)]

        self._xml_start_tag("cellMetadata", attributes)
        self._xml_start_tag("bk")

        # Write the rc element.
        self._write_rc(1, 0)

        self._xml_end_tag("bk")
        self._xml_end_tag("cellMetadata")

    def _write_value_metadata(self):
        # Write the <valueMetadata> element.
        count = self.num_embedded_images
        type = 1

        if self.has_dynamic_functions:
            type = 2

        attributes = [("count", count)]

        self._xml_start_tag("valueMetadata", attributes)

        # Write the rc elements.
        for index in range(self.num_embedded_images):
            self._xml_start_tag("bk")
            self._write_rc(type, index)
            self._xml_end_tag("bk")

        self._xml_end_tag("valueMetadata")

    def _write_rc(self, type, index):
        # Write the <rc> element.
        attributes = [
            ("t", type),
            ("v", index),
        ]

        self._xml_empty_tag("rc", attributes)

```

---

### File: `tmp\xlsxwriter_sdist\XlsxWriter-3.2.0\xlsxwriter\packager.py`

```python
###############################################################################
#
# Packager - A class for writing the Excel XLSX Worksheet file.
#
# SPDX-License-Identifier: BSD-2-Clause
# Copyright 2013-2024, John McNamara, jmcnamara@cpan.org
#

# Standard packages.
import os
import stat
import tempfile
from shutil import copy

from io import StringIO
from io import BytesIO

# Package imports.
from .app import App
from .contenttypes import ContentTypes
from .core import Core
from .custom import Custom
from .metadata import Metadata
from .relationships import Relationships
from .sharedstrings import SharedStrings
from .rich_value import RichValue
from .rich_value_types import RichValueTypes
from .rich_value_rel import RichValueRel
from .rich_value_structure import RichValueStructure
from .styles import Styles
from .theme import Theme
from .vml import Vml
from .table import Table
from .comments import Comments
from .exceptions import EmptyChartSeries


class Packager(object):
    """
    A class for writing the Excel XLSX Packager file.

    This module is used in conjunction with XlsxWriter to create an
    Excel XLSX container file.

    From Wikipedia: The Open Packaging Conventions (OPC) is a
    container-file technology initially created by Microsoft to store
    a combination of XML and non-XML files that together form a single
    entity such as an Open XML Paper Specification (OpenXPS)
    document. http://en.wikipedia.org/wiki/Open_Packaging_Conventions.

    At its simplest an Excel XLSX file contains the following elements::

         ____ [Content_Types].xml
        |
        |____ docProps
        | |____ app.xml
        | |____ core.xml
        |
        |____ xl
        | |____ workbook.xml
        | |____ worksheets
        | | |____ sheet1.xml
        | |
        | |____ styles.xml
        | |
        | |____ theme
        | | |____ theme1.xml
        | |
        | |_____rels
        |   |____ workbook.xml.rels
        |
        |_____rels
          |____ .rels

    The Packager class coordinates the classes that represent the
    elements of the package and writes them into the XLSX file.

    """

    ###########################################################################
    #
    # Public API.
    #
    ###########################################################################

    def __init__(self):
        """
        Constructor.

        """

        super(Packager, self).__init__()

        self.tmpdir = ""
        self.in_memory = False
        self.workbook = None
        self.worksheet_count = 0
        self.chartsheet_count = 0
        self.chart_count = 0
        self.drawing_count = 0
        self.table_count = 0
        self.num_vml_files = 0
        self.num_comment_files = 0
        self.named_ranges = []
        self.filenames = []

    ###########################################################################
    #
    # Private API.
    #
    ###########################################################################

    def _set_tmpdir(self, tmpdir):
        # Set an optional user defined temp directory.
        self.tmpdir = tmpdir

    def _set_in_memory(self, in_memory):
        # Set the optional 'in_memory' mode.
        self.in_memory = in_memory

    def _add_workbook(self, workbook):
        # Add the Excel::Writer::XLSX::Workbook object to the package.
        self.workbook = workbook
        self.chart_count = len(workbook.charts)
        self.drawing_count = len(workbook.drawings)
        self.num_vml_files = workbook.num_vml_files
        self.num_comment_files = workbook.num_comment_files
        self.named_ranges = workbook.named_ranges

        for worksheet in self.workbook.worksheets():
            if worksheet.is_chartsheet:
                self.chartsheet_count += 1
            else:
                self.worksheet_count += 1

    def _create_package(self):
        # Write the xml files that make up the XLSX OPC package.
        self._write_content_types_file()
        self._write_root_rels_file()
        self._write_workbook_rels_file()
        self._write_worksheet_files()
        self._write_chartsheet_files()
        self._write_workbook_file()
        self._write_chart_files()
        self._write_drawing_files()
        self._write_vml_files()
        self._write_comment_files()
        self._write_table_files()
        self._write_shared_strings_file()
        self._write_styles_file()
        self._write_custom_file()
        self._write_theme_file()
        self._write_worksheet_rels_files()
        self._write_chartsheet_rels_files()
        self._write_drawing_rels_files()
        self._write_rich_value_rels_files()
        self._add_image_files()
        self._add_vba_project()
        self._add_vba_project_signature()
        self._write_vba_project_rels_file()
        self._write_core_file()
        self._write_app_file()
        self._write_metadata_file()
        self._write_rich_value_files()

        return self.filenames

    def _filename(self, xml_filename):
        # Create a temp filename to write the XML data to and store the Excel
        # filename to use as the name in the Zip container.
        if self.in_memory:
            os_filename = StringIO()
        else:
            (fd, os_filename) = tempfile.mkstemp(dir=self.tmpdir)
            os.close(fd)

        self.filenames.append((os_filename, xml_filename, False))

        return os_filename

    def _write_workbook_file(self):
        # Write the workbook.xml file.
        workbook = self.workbook

        workbook._set_xml_writer(self._filename("xl/workbook.xml"))
        workbook._assemble_xml_file()

    def _write_worksheet_files(self):
        # Write the worksheet files.
        index = 1
        for worksheet in self.workbook.worksheets():
            if worksheet.is_chartsheet:
                continue

            if worksheet.constant_memory:
                worksheet._opt_reopen()
                worksheet._write_single_row()

            worksheet._set_xml_writer(
                self._filename("xl/worksheets/sheet" + str(index) + ".xml")
            )
            worksheet._assemble_xml_file()
            index += 1

    def _write_chartsheet_files(self):
        # Write the chartsheet files.
        index = 1
        for worksheet in self.workbook.worksheets():
            if not worksheet.is_chartsheet:
                continue

            worksheet._set_xml_writer(
                self._filename("xl/chartsheets/sheet" + str(index) + ".xml")
            )
            worksheet._assemble_xml_file()
            index += 1

    def _write_chart_files(self):
        # Write the chart files.
        if not self.workbook.charts:
            return

        index = 1
        for chart in self.workbook.charts:
            # Check that the chart has at least one data series.
            if not chart.series:
                raise EmptyChartSeries(
                    "Chart%d must contain at least one "
                    "data series. See chart.add_series()." % index
                )

            chart._set_xml_writer(
                self._filename("xl/charts/chart" + str(index) + ".xml")
            )
            chart._assemble_xml_file()
            index += 1

    def _write_drawing_files(self):
        # Write the drawing files.
        if not self.drawing_count:
            return

        index = 1
        for drawing in self.workbook.drawings:
            drawing._set_xml_writer(
                self._filename("xl/drawings/drawing" + str(index) + ".xml")
            )
            drawing._assemble_xml_file()
            index += 1

    def _write_vml_files(self):
        # Write the comment VML files.
        index = 1
        for worksheet in self.workbook.worksheets():
            if not worksheet.has_vml and not worksheet.has_header_vml:
                continue
            if worksheet.has_vml:
                vml = Vml()
                vml._set_xml_writer(
                    self._filename("xl/drawings/vmlDrawing" + str(index) + ".vml")
                )
                vml._assemble_xml_file(
                    worksheet.vml_data_id,
                    worksheet.vml_shape_id,
                    worksheet.comments_list,
                    worksheet.buttons_list,
                )
                index += 1

            if worksheet.has_header_vml:
                vml = Vml()

                vml._set_xml_writer(
                    self._filename("xl/drawings/vmlDrawing" + str(index) + ".vml")
                )
                vml._assemble_xml_file(
                    worksheet.vml_header_id,
                    worksheet.vml_header_id * 1024,
                    None,
                    None,
                    worksheet.header_images_list,
                )

                self._write_vml_drawing_rels_file(worksheet, index)
                index += 1

    def _write_comment_files(self):
        # Write the comment files.
        index = 1
        for worksheet in self.workbook.worksheets():
            if not worksheet.has_comments:
                continue

            comment = Comments()
            comment._set_xml_writer(self._filename("xl/comments" + str(index) + ".xml"))
            comment._assemble_xml_file(worksheet.comments_list)
            index += 1

    def _write_shared_strings_file(self):
        # Write the sharedStrings.xml file.
        sst = SharedStrings()
        sst.string_table = self.workbook.str_table

        if not self.workbook.str_table.count:
            return

        sst._set_xml_writer(self._filename("xl/sharedStrings.xml"))
        sst._assemble_xml_file()

    def _write_app_file(self):
        # Write the app.xml file.
        properties = self.workbook.doc_properties
        app = App()

        # Add the Worksheet parts.
        worksheet_count = 0
        for worksheet in self.workbook.worksheets():
            if worksheet.is_chartsheet:
                continue

            # Don't write/count veryHidden sheets.
            if worksheet.hidden != 2:
                app._add_part_name(worksheet.name)
                worksheet_count += 1

        # Add the Worksheet heading pairs.
        app._add_heading_pair(["Worksheets", worksheet_count])

        # Add the Chartsheet parts.
        for worksheet in self.workbook.worksheets():
            if not worksheet.is_chartsheet:
                continue
            app._add_part_name(worksheet.name)

        # Add the Chartsheet heading pairs.
        app._add_heading_pair(["Charts", self.chartsheet_count])

        # Add the Named Range heading pairs.
        if self.named_ranges:
            app._add_heading_pair(["Named Ranges", len(self.named_ranges)])

        # Add the Named Ranges parts.
        for named_range in self.named_ranges:
            app._add_part_name(named_range)

        app._set_properties(properties)
        app.doc_security = self.workbook.read_only

        app._set_xml_writer(self._filename("docProps/app.xml"))
        app._assemble_xml_file()

    def _write_core_file(self):
        # Write the core.xml file.
        properties = self.workbook.doc_properties
        core = Core()

        core._set_properties(properties)
        core._set_xml_writer(self._filename("docProps/core.xml"))
        core._assemble_xml_file()

    def _write_metadata_file(self):
        # Write the metadata.xml file.
        if not self.workbook.has_metadata:
            return

        metadata = Metadata()
        metadata.has_dynamic_functions = self.workbook.has_dynamic_functions
        metadata.num_embedded_images = len(self.workbook.embedded_images.images)

        metadata._set_xml_writer(self._filename("xl/metadata.xml"))
        metadata._assemble_xml_file()

    def _write_rich_value_files(self):

        if not self.workbook.embedded_images.has_images():
            return

        self._write_rich_value()
        self._write_rich_value_types()
        self._write_rich_value_structure()
        self._write_rich_value_rel()

    def _write_rich_value(self):
        # Write the rdrichvalue.xml file.
        filename = self._filename("xl/richData/rdrichvalue.xml")
        xml_file = RichValue()
        xml_file.embedded_images = self.workbook.embedded_images.images
        xml_file._set_xml_writer(filename)
        xml_file._assemble_xml_file()

    def _write_rich_value_types(self):
        # Write the rdRichValueTypes.xml file.
        filename = self._filename("xl/richData/rdRichValueTypes.xml")
        xml_file = RichValueTypes()
        xml_file._set_xml_writer(filename)
        xml_file._assemble_xml_file()

    def _write_rich_value_structure(self):
        # Write the rdrichvaluestructure.xml file.
        filename = self._filename("xl/richData/rdrichvaluestructure.xml")
        xml_file = RichValueStructure()
        xml_file.has_embedded_descriptions = self.workbook.has_embedded_descriptions
        xml_file._set_xml_writer(filename)
        xml_file._assemble_xml_file()

    def _write_rich_value_rel(self):
        # Write the richValueRel.xml file.
        filename = self._filename("xl/richData/richValueRel.xml")
        xml_file = RichValueRel()
        xml_file.num_embedded_images = len(self.workbook.embedded_images.images)
        xml_file._set_xml_writer(filename)
        xml_file._assemble_xml_file()

    def _write_custom_file(self):
        # Write the custom.xml file.
        properties = self.workbook.custom_properties
        custom = Custom()

        if not len(properties):
            return

        custom._set_properties(properties)
        custom._set_xml_writer(self._filename("docProps/custom.xml"))
        custom._assemble_xml_file()

    def _write_content_types_file(self):
        # Write the ContentTypes.xml file.
        content = ContentTypes()
        content._add_image_types(self.workbook.image_types)

        self._get_table_count()

        worksheet_index = 1
        chartsheet_index = 1
        for worksheet in self.workbook.worksheets():
            if worksheet.is_chartsheet:
                content._add_chartsheet_name("sheet" + str(chartsheet_index))
                chartsheet_index += 1
            else:
                content._add_worksheet_name("sheet" + str(worksheet_index))
                worksheet_index += 1

        for i in range(1, self.chart_count + 1):
            content._add_chart_name("chart" + str(i))

        for i in range(1, self.drawing_count + 1):
            content._add_drawing_name("drawing" + str(i))

        if self.num_vml_files:
            content._add_vml_name()

        for i in range(1, self.table_count + 1):
            content._add_table_name("table" + str(i))

        for i in range(1, self.num_comment_files + 1):
            content._add_comment_name("comments" + str(i))

        # Add the sharedString rel if there is string data in the workbook.
        if self.workbook.str_table.count:
            content._add_shared_strings()

        # Add vbaProject (and optionally vbaProjectSignature) if present.
        if self.workbook.vba_project:
            content._add_vba_project()
            if self.workbook.vba_project_signature:
                content._add_vba_project_signature()

        # Add the custom properties if present.
        if self.workbook.custom_properties:
            content._add_custom_properties()

        # Add the metadata file if present.
        if self.workbook.has_metadata:
            content._add_metadata()

        # Add the RichValue file if present.
        if self.workbook.embedded_images.has_images():
            content._add_rich_value()

        content._set_xml_writer(self._filename("[Content_Types].xml"))
        content._assemble_xml_file()

    def _write_styles_file(self):
        # Write the style xml file.
        xf_formats = self.workbook.xf_formats
        palette = self.workbook.palette
        font_count = self.workbook.font_count
        num_formats = self.workbook.num_formats
        border_count = self.workbook.border_count
        fill_count = self.workbook.fill_count
        custom_colors = self.workbook.custom_colors
        dxf_formats = self.workbook.dxf_formats
        has_comments = self.workbook.has_comments

        styles = Styles()
        styles._set_style_properties(
            [
                xf_formats,
                palette,
                font_count,
                num_formats,
                border_count,
                fill_count,
                custom_colors,
                dxf_formats,
                has_comments,
            ]
        )

        styles._set_xml_writer(self._filename("xl/styles.xml"))
        styles._assemble_xml_file()

    def _write_theme_file(self):
        # Write the theme xml file.
        theme = Theme()

        theme._set_xml_writer(self._filename("xl/theme/theme1.xml"))
        theme._assemble_xml_file()

    def _write_table_files(self):
        # Write the table files.
        index = 1
        for worksheet in self.workbook.worksheets():
            table_props = worksheet.tables

            if not table_props:
                continue

            for table_props in table_props:
                table = Table()
                table._set_xml_writer(
                    self._filename("xl/tables/table" + str(index) + ".xml")
                )
                table._set_properties(table_props)
                table._assemble_xml_file()
                index += 1

    def _get_table_count(self):
        # Count the table files. Required for the [Content_Types] file.
        for worksheet in self.workbook.worksheets():
            for _ in worksheet.tables:
                self.table_count += 1

    def _write_root_rels_file(self):
        # Write the _rels/.rels xml file.
        rels = Relationships()

        rels._add_document_relationship("/officeDocument", "xl/workbook.xml")

        rels._add_package_relationship("/metadata/core-properties", "docProps/core.xml")

        rels._add_document_relationship("/extended-properties", "docProps/app.xml")

        if self.workbook.custom_properties:
            rels._add_document_relationship("/custom-properties", "docProps/custom.xml")

        rels._set_xml_writer(self._filename("_rels/.rels"))

        rels._assemble_xml_file()

    def _write_workbook_rels_file(self):
        # Write the _rels/.rels xml file.
        rels = Relationships()

        worksheet_index = 1
        chartsheet_index = 1

        for worksheet in self.workbook.worksheets():
            if worksheet.is_chartsheet:
                rels._add_document_relationship(
                    "/chartsheet", "chartsheets/sheet" + str(chartsheet_index) + ".xml"
                )
                chartsheet_index += 1
            else:
                rels._add_document_relationship(
                    "/worksheet", "worksheets/sheet" + str(worksheet_index) + ".xml"
                )
                worksheet_index += 1

        rels._add_document_relationship("/theme", "theme/theme1.xml")
        rels._add_document_relationship("/styles", "styles.xml")

        # Add the sharedString rel if there is string data in the workbook.
        if self.workbook.str_table.count:
            rels._add_document_relationship("/sharedStrings", "sharedStrings.xml")

        # Add vbaProject if present.
        if self.workbook.vba_project:
            rels._add_ms_package_relationship("/vbaProject", "vbaProject.bin")

        # Add the metadata file if required.
        if self.workbook.has_metadata:
            rels._add_document_relationship("/sheetMetadata", "metadata.xml")

        # Add the RichValue files if present.
        if self.workbook.embedded_images.has_images():
            rels._add_rich_value_relationship()

        rels._set_xml_writer(self._filename("xl/_rels/workbook.xml.rels"))
        rels._assemble_xml_file()

    def _write_worksheet_rels_files(self):
        # Write data such as hyperlinks or drawings.
        index = 0
        for worksheet in self.workbook.worksheets():
            if worksheet.is_chartsheet:
                continue

            index += 1

            external_links = (
                worksheet.external_hyper_links
                + worksheet.external_drawing_links
                + worksheet.external_vml_links
                + worksheet.external_background_links
                + worksheet.external_table_links
                + worksheet.external_comment_links
            )

            if not external_links:
                continue

            # Create the worksheet .rels dirs.
            rels = Relationships()

            for link_data in external_links:
                rels._add_document_relationship(*link_data)

            # Create .rels file such as /xl/worksheets/_rels/sheet1.xml.rels.
            rels._set_xml_writer(
                self._filename("xl/worksheets/_rels/sheet" + str(index) + ".xml.rels")
            )
            rels._assemble_xml_file()

    def _write_chartsheet_rels_files(self):
        # Write the chartsheet .rels files for links to drawing files.
        index = 0
        for worksheet in self.workbook.worksheets():
            if not worksheet.is_chartsheet:
                continue

            index += 1

            external_links = (
                worksheet.external_drawing_links + worksheet.external_vml_links
            )

            if not external_links:
                continue

            # Create the chartsheet .rels xlsx_dir.
            rels = Relationships()

            for link_data in external_links:
                rels._add_document_relationship(*link_data)

            # Create .rels file such as /xl/chartsheets/_rels/sheet1.xml.rels.
            rels._set_xml_writer(
                self._filename("xl/chartsheets/_rels/sheet" + str(index) + ".xml.rels")
            )
            rels._assemble_xml_file()

    def _write_drawing_rels_files(self):
        # Write the drawing .rels files for worksheets with charts or drawings.
        index = 0
        for worksheet in self.workbook.worksheets():
            if worksheet.drawing:
                index += 1

            if not worksheet.drawing_links:
                continue

            # Create the drawing .rels xlsx_dir.
            rels = Relationships()

            for drawing_data in worksheet.drawing_links:
                rels._add_document_relationship(*drawing_data)

            # Create .rels file such as /xl/drawings/_rels/sheet1.xml.rels.
            rels._set_xml_writer(
                self._filename("xl/drawings/_rels/drawing" + str(index) + ".xml.rels")
            )
            rels._assemble_xml_file()

    def _write_vml_drawing_rels_file(self, worksheet, index):
        # Write the vmlDdrawing .rels files for worksheets with images in
        # headers or footers.

        # Create the drawing .rels dir.
        rels = Relationships()

        for drawing_data in worksheet.vml_drawing_links:
            rels._add_document_relationship(*drawing_data)

        # Create .rels file such as /xl/drawings/_rels/vmlDrawing1.vml.rels.
        rels._set_xml_writer(
            self._filename("xl/drawings/_rels/vmlDrawing" + str(index) + ".vml.rels")
        )
        rels._assemble_xml_file()

    def _write_vba_project_rels_file(self):
        # Write the vbaProject.rels xml file if signed macros exist.
        vba_project_signature = self.workbook.vba_project_signature

        if not vba_project_signature:
            return

        # Create the vbaProject .rels dir.
        rels = Relationships()

        rels._add_ms_package_relationship(
            "/vbaProjectSignature", "vbaProjectSignature.bin"
        )

        rels._set_xml_writer(self._filename("xl/_rels/vbaProject.bin.rels"))
        rels._assemble_xml_file()

    def _write_rich_value_rels_files(self):
        # Write the richValueRel.xml.rels for embedded images.
        if not self.workbook.embedded_images.has_images():
            return

        # Create the worksheet .rels dirs.
        rels = Relationships()

        index = 1
        for image_data in self.workbook.embedded_images.images:
            file_type = image_data[1]
            image_file = f"../media/image{index}.{file_type}"
            rels._add_document_relationship("/image", image_file)
            index += 1

        # Create .rels file such as /xl/worksheets/_rels/sheet1.xml.rels.
        rels._set_xml_writer(self._filename("/xl/richData/_rels/richValueRel.xml.rels"))

        rels._assemble_xml_file()

    def _add_image_files(self):
        # Write the /xl/media/image?.xml files.
        workbook = self.workbook
        index = 1

        images = workbook.embedded_images.images + workbook.images

        for image in images:
            filename = image[0]
            ext = "." + image[1]
            image_data = image[2]

            xml_image_name = "xl/media/image" + str(index) + ext

            if not self.in_memory:
                # In file mode we just write or copy the image file.
                os_filename = self._filename(xml_image_name)

                if image_data:
                    # The data is in a byte stream. Write it to the target.
                    os_file = open(os_filename, mode="wb")
                    os_file.write(image_data.getvalue())
                    os_file.close()
                else:
                    copy(filename, os_filename)

                    # Allow copies of Windows read-only images to be deleted.
                    try:
                        os.chmod(
                            os_filename, os.stat(os_filename).st_mode | stat.S_IWRITE
                        )
                    except OSError:
                        pass
            else:
                # For in-memory mode we read the image into a stream.
                if image_data:
                    # The data is already in a byte stream.
                    os_filename = image_data
                else:
                    image_file = open(filename, mode="rb")
                    image_data = image_file.read()
                    os_filename = BytesIO(image_data)
                    image_file.close()

                self.filenames.append((os_filename, xml_image_name, True))

            index += 1

    def _add_vba_project_signature(self):
        # Copy in a vbaProjectSignature.bin file.
        vba_project_signature = self.workbook.vba_project_signature
        vba_project_signature_is_stream = self.workbook.vba_project_signature_is_stream

        if not vba_project_signature:
            return

        xml_vba_signature_name = "xl/vbaProjectSignature.bin"

        if not self.in_memory:
            # In file mode we just write or copy the VBA project signature file.
            os_filename = self._filename(xml_vba_signature_name)

            if vba_project_signature_is_stream:
                # The data is in a byte stream. Write it to the target.
                os_file = open(os_filename, mode="wb")
                os_file.write(vba_project_signature.getvalue())
                os_file.close()
            else:
                copy(vba_project_signature, os_filename)

        else:
            # For in-memory mode we read the vba into a stream.
            if vba_project_signature_is_stream:
                # The data is already in a byte stream.
                os_filename = vba_project_signature
            else:
                vba_file = open(vba_project_signature, mode="rb")
                vba_data = vba_file.read()
                os_filename = BytesIO(vba_data)
                vba_file.close()

            self.filenames.append((os_filename, xml_vba_signature_name, True))

    def _add_vba_project(self):
        # Copy in a vbaProject.bin file.
        vba_project = self.workbook.vba_project
        vba_project_is_stream = self.workbook.vba_project_is_stream

        if not vba_project:
            return

        xml_vba_name = "xl/vbaProject.bin"

        if not self.in_memory:
            # In file mode we just write or copy the VBA file.
            os_filename = self._filename(xml_vba_name)

            if vba_project_is_stream:
                # The data is in a byte stream. Write it to the target.
                os_file = open(os_filename, mode="wb")
                os_file.write(vba_project.getvalue())
                os_file.close()
            else:
                copy(vba_project, os_filename)

        else:
            # For in-memory mode we read the vba into a stream.
            if vba_project_is_stream:
                # The data is already in a byte stream.
                os_filename = vba_project
            else:
                vba_file = open(vba_project, mode="rb")
                vba_data = vba_file.read()
                os_filename = BytesIO(vba_data)
                vba_file.close()

            self.filenames.append((os_filename, xml_vba_name, True))

```

---

### File: `tmp\xlsxwriter_sdist\XlsxWriter-3.2.0\xlsxwriter\relationships.py`

```python
###############################################################################
#
# Relationships - A class for writing the Excel XLSX Worksheet file.
#
# SPDX-License-Identifier: BSD-2-Clause
# Copyright 2013-2024, John McNamara, jmcnamara@cpan.org
#

# Package imports.
from . import xmlwriter

# Long namespace strings used in the class.
schema_root = "http://schemas.openxmlformats.org"
package_schema = schema_root + "/package/2006/relationships"
document_schema = schema_root + "/officeDocument/2006/relationships"


class Relationships(xmlwriter.XMLwriter):
    """
    A class for writing the Excel XLSX Relationships file.


    """

    ###########################################################################
    #
    # Public API.
    #
    ###########################################################################

    def __init__(self):
        """
        Constructor.

        """

        super(Relationships, self).__init__()

        self.relationships = []
        self.id = 1

    ###########################################################################
    #
    # Private API.
    #
    ###########################################################################

    def _assemble_xml_file(self):
        # Assemble and write the XML file.

        # Write the XML declaration.
        self._xml_declaration()

        self._write_relationships()

        # Close the file.
        self._xml_close()

    def _add_document_relationship(self, rel_type, target, target_mode=None):
        # Add container relationship to XLSX .rels xml files.
        rel_type = document_schema + rel_type

        self.relationships.append((rel_type, target, target_mode))

    def _add_package_relationship(self, rel_type, target):
        # Add container relationship to XLSX .rels xml files.
        rel_type = package_schema + rel_type

        self.relationships.append((rel_type, target, None))

    def _add_ms_package_relationship(self, rel_type, target):
        # Add container relationship to XLSX .rels xml files. Uses MS schema.
        schema = "http://schemas.microsoft.com/office/2006/relationships"
        rel_type = schema + rel_type

        self.relationships.append((rel_type, target, None))

    def _add_rich_value_relationship(self):
        # Add RichValue relationship to XLSX .rels xml files.
        schema = "http://schemas.microsoft.com/office/2022/10/relationships/"
        rel_type = schema + "richValueRel"
        target = "richData/richValueRel.xml"
        self.relationships.append((rel_type, target, None))

        schema = "http://schemas.microsoft.com/office/2017/06/relationships/"
        rel_type = schema + "rdRichValue"
        target = "richData/rdrichvalue.xml"
        self.relationships.append((rel_type, target, None))

        schema = "http://schemas.microsoft.com/office/2017/06/relationships/"
        rel_type = schema + "rdRichValueStructure"
        target = "richData/rdrichvaluestructure.xml"
        self.relationships.append((rel_type, target, None))

        schema = "http://schemas.microsoft.com/office/2017/06/relationships/"
        rel_type = schema + "rdRichValueTypes"
        target = "richData/rdRichValueTypes.xml"
        self.relationships.append((rel_type, target, None))

    ###########################################################################
    #
    # XML methods.
    #
    ###########################################################################

    def _write_relationships(self):
        # Write the <Relationships> element.
        attributes = [
            (
                "xmlns",
                package_schema,
            )
        ]

        self._xml_start_tag("Relationships", attributes)

        for relationship in self.relationships:
            self._write_relationship(relationship)

        self._xml_end_tag("Relationships")

    def _write_relationship(self, relationship):
        # Write the <Relationship> element.
        rel_type, target, target_mode = relationship

        attributes = [
            ("Id", "rId" + str(self.id)),
            ("Type", rel_type),
            ("Target", target),
        ]

        self.id += 1

        if target_mode:
            attributes.append(("TargetMode", target_mode))

        self._xml_empty_tag("Relationship", attributes)

```

---

### File: `tmp\xlsxwriter_sdist\XlsxWriter-3.2.0\xlsxwriter\rich_value.py`

```python
###############################################################################
#
# RichValue - A class for writing the Excel XLSX rdrichvalue.xml file.
#
# SPDX-License-Identifier: BSD-2-Clause
# Copyright 2013-2024, John McNamara, jmcnamara@cpan.org
#

# Package imports.
from . import xmlwriter


class RichValue(xmlwriter.XMLwriter):
    """
    A class for writing the Excel XLSX rdrichvalue.xml file.


    """

    ###########################################################################
    #
    # Public API.
    #
    ###########################################################################

    def __init__(self):
        """
        Constructor.

        """

        super(RichValue, self).__init__()
        self.embedded_images = []

    ###########################################################################
    #
    # Private API.
    #
    ###########################################################################

    def _assemble_xml_file(self):
        # Assemble and write the XML file.

        # Write the XML declaration.
        self._xml_declaration()

        # Write the rvData element.
        self._write_rv_data()

        self._xml_end_tag("rvData")

        # Close the file.
        self._xml_close()

    ###########################################################################
    #
    # XML methods.
    #
    ###########################################################################
    def _write_rv_data(self):
        # Write the <rvData> element.
        xmlns = "http://schemas.microsoft.com/office/spreadsheetml/2017/richdata"

        attributes = [
            ("xmlns", xmlns),
            ("count", len(self.embedded_images)),
        ]

        self._xml_start_tag("rvData", attributes)

        for index, image_data in enumerate(self.embedded_images):
            # Write the rv element.
            self._write_rv(index, image_data[3], image_data[4])

    def _write_rv(self, index, description, decorative):
        # Write the <rv> element.
        attributes = [("s", 0)]
        value = 5

        if decorative:
            value = 6

        self._xml_start_tag("rv", attributes)

        # Write the v elements.
        self._write_v(index)
        self._write_v(value)

        if description:
            self._write_v(description)

        self._xml_end_tag("rv")

    def _write_v(self, data):
        # Write the <v> element.
        self._xml_data_element("v", data)

```

---

### File: `tmp\xlsxwriter_sdist\XlsxWriter-3.2.0\xlsxwriter\rich_value_rel.py`

```python
###############################################################################
#
# RichValueRel - A class for writing the Excel XLSX richValueRel.xml file.
#
# SPDX-License-Identifier: BSD-2-Clause
# Copyright 2013-2024, John McNamara, jmcnamara@cpan.org
#

# Package imports.
from . import xmlwriter


class RichValueRel(xmlwriter.XMLwriter):
    """
    A class for writing the Excel XLSX richValueRel.xml file.


    """

    ###########################################################################
    #
    # Public API.
    #
    ###########################################################################

    def __init__(self):
        """
        Constructor.

        """

        super(RichValueRel, self).__init__()
        self.num_embedded_images = 0

    ###########################################################################
    #
    # Private API.
    #
    ###########################################################################

    def _assemble_xml_file(self):
        # Assemble and write the XML file.

        # Write the XML declaration.
        self._xml_declaration()

        # Write the richValueRels element.
        self._write_rich_value_rels()

        self._xml_end_tag("richValueRels")

        # Close the file.
        self._xml_close()

    ###########################################################################
    #
    # XML methods.
    #
    ###########################################################################
    def _write_rich_value_rels(self):
        # Write the <richValueRels> element.
        xmlns = "http://schemas.microsoft.com/office/spreadsheetml/2022/richvaluerel"
        xmlns_r = "http://schemas.openxmlformats.org/officeDocument/2006/relationships"

        attributes = [
            ("xmlns", xmlns),
            ("xmlns:r", xmlns_r),
        ]

        self._xml_start_tag("richValueRels", attributes)

        # Write the rel elements.
        for index in range(self.num_embedded_images):
            self._write_rel(index + 1)

    def _write_rel(self, index):
        # Write the <rel> element.
        r_id = f"rId{index}"
        attributes = [("r:id", r_id)]

        self._xml_empty_tag("rel", attributes)

```

---

### File: `tmp\xlsxwriter_sdist\XlsxWriter-3.2.0\xlsxwriter\rich_value_structure.py`

```python
###############################################################################
#
# RichValueStructure - A class for writing the Excel XLSX rdrichvaluestructure.xml file.
#
# SPDX-License-Identifier: BSD-2-Clause
# Copyright 2013-2024, John McNamara, jmcnamara@cpan.org
#

# Package imports.
from . import xmlwriter


class RichValueStructure(xmlwriter.XMLwriter):
    """
    A class for writing the Excel XLSX rdrichvaluestructure.xml file.


    """

    ###########################################################################
    #
    # Public API.
    #
    ###########################################################################

    def __init__(self):
        """
        Constructor.

        """

        super(RichValueStructure, self).__init__()
        self.has_embedded_descriptions = False

    ###########################################################################
    #
    # Private API.
    #
    ###########################################################################

    def _assemble_xml_file(self):
        # Assemble and write the XML file.

        # Write the XML declaration.
        self._xml_declaration()

        # Write the rvStructures element.
        self._write_rv_structures()

        self._xml_end_tag("rvStructures")

        # Close the file.
        self._xml_close()

    ###########################################################################
    #
    # XML methods.
    #
    ###########################################################################
    def _write_rv_structures(self):
        # Write the <rvStructures> element.
        xmlns = "http://schemas.microsoft.com/office/spreadsheetml/2017/richdata"
        count = "1"

        attributes = [
            ("xmlns", xmlns),
            ("count", count),
        ]

        self._xml_start_tag("rvStructures", attributes)

        # Write the s element.
        self._write_s()

    def _write_s(self):
        # Write the <s> element.
        t = "_localImage"
        attributes = [("t", t)]

        self._xml_start_tag("s", attributes)

        # Write the k elements.
        self._write_k("_rvRel:LocalImageIdentifier", "i")
        self._write_k("CalcOrigin", "i")

        if self.has_embedded_descriptions:
            self._write_k("Text", "s")

        self._xml_end_tag("s")

    def _write_k(self, name, type):
        # Write the <k> element.
        attributes = [
            ("n", name),
            ("t", type),
        ]

        self._xml_empty_tag("k", attributes)

```

---

### File: `tmp\xlsxwriter_sdist\XlsxWriter-3.2.0\xlsxwriter\rich_value_types.py`

```python
###############################################################################
#
# RichValueTypes - A class for writing the Excel XLSX rdRichValueTypes.xml file.
#
# SPDX-License-Identifier: BSD-2-Clause
# Copyright 2013-2024, John McNamara, jmcnamara@cpan.org
#

# Package imports.
from . import xmlwriter


class RichValueTypes(xmlwriter.XMLwriter):
    """
    A class for writing the Excel XLSX rdRichValueTypes.xml file.


    """

    ###########################################################################
    #
    # Public API.
    #
    ###########################################################################

    def __init__(self):
        """
        Constructor.

        """

        super(RichValueTypes, self).__init__()

    ###########################################################################
    #
    # Private API.
    #
    ###########################################################################

    def _assemble_xml_file(self):
        # Assemble and write the XML file.

        # Write the XML declaration.
        self._xml_declaration()

        # Write the rvTypesInfo element.
        self._write_rv_types_info()

        # Write the global element.
        self._write_global()

        self._xml_end_tag("rvTypesInfo")

        # Close the file.
        self._xml_close()

    ###########################################################################
    #
    # XML methods.
    #
    ###########################################################################

    def _write_rv_types_info(self):
        # Write the <rvTypesInfo> element.
        xmlns = "http://schemas.microsoft.com/office/spreadsheetml/2017/richdata2"
        xmlns_x = "http://schemas.openxmlformats.org/spreadsheetml/2006/main"
        xmlns_mc = "http://schemas.openxmlformats.org/markup-compatibility/2006"
        mc_ignorable = "x"

        attributes = [
            ("xmlns", xmlns),
            ("xmlns:mc", xmlns_mc),
            ("mc:Ignorable", mc_ignorable),
            ("xmlns:x", xmlns_x),
        ]

        self._xml_start_tag("rvTypesInfo", attributes)

    def _write_global(self):
        # Write the <global> element.
        key_flags = [
            ["_Self", ["ExcludeFromFile", "ExcludeFromCalcComparison"]],
            ["_DisplayString", ["ExcludeFromCalcComparison"]],
            ["_Flags", ["ExcludeFromCalcComparison"]],
            ["_Format", ["ExcludeFromCalcComparison"]],
            ["_SubLabel", ["ExcludeFromCalcComparison"]],
            ["_Attribution", ["ExcludeFromCalcComparison"]],
            ["_Icon", ["ExcludeFromCalcComparison"]],
            ["_Display", ["ExcludeFromCalcComparison"]],
            ["_CanonicalPropertyNames", ["ExcludeFromCalcComparison"]],
            ["_ClassificationId", ["ExcludeFromCalcComparison"]],
        ]

        self._xml_start_tag("global")
        self._xml_start_tag("keyFlags")

        for key_flag in key_flags:
            # Write the key element.
            self._write_key(key_flag)

        self._xml_end_tag("keyFlags")
        self._xml_end_tag("global")

    def _write_key(self, key_flag):
        # Write the <key> element.
        name = key_flag[0]
        attributes = [("name", name)]

        self._xml_start_tag("key", attributes)

        # Write the flag element.
        for name in key_flag[1]:
            self._write_flag(name)

        self._xml_end_tag("key")

    def _write_flag(self, name):
        # Write the <flag> element.
        attributes = [
            ("name", name),
            ("value", "1"),
        ]

        self._xml_empty_tag("flag", attributes)

```

---

### File: `tmp\xlsxwriter_sdist\XlsxWriter-3.2.0\xlsxwriter\shape.py`

```python
###############################################################################
#
# Shape - A class for to represent Excel XLSX shape objects.
#
# SPDX-License-Identifier: BSD-2-Clause
# Copyright 2013-2024, John McNamara, jmcnamara@cpan.org
#
import copy
from warnings import warn


class Shape(object):
    """
    A class for to represent Excel XLSX shape objects.


    """

    ###########################################################################
    #
    # Public API.
    #
    ###########################################################################

    def __init__(self, shape_type, name, options):
        """
        Constructor.

        """
        super(Shape, self).__init__()
        self.name = name
        self.shape_type = shape_type
        self.connect = 0
        self.drawing = 0
        self.edit_as = ""
        self.id = 0
        self.text = ""
        self.textlink = ""
        self.stencil = 1
        self.element = -1
        self.start = None
        self.start_index = None
        self.end = None
        self.end_index = None
        self.adjustments = []
        self.start_side = ""
        self.end_side = ""
        self.flip_h = 0
        self.flip_v = 0
        self.rotation = 0
        self.text_rotation = 0
        self.textbox = False

        self.align = None
        self.fill = None
        self.font = None
        self.format = None
        self.line = None
        self.url_rel_index = None
        self.tip = None

        self._set_options(options)

    ###########################################################################
    #
    # Private API.
    #
    ###########################################################################

    def _set_options(self, options):
        self.align = self._get_align_properties(options.get("align"))
        self.fill = self._get_fill_properties(options.get("fill"))
        self.font = self._get_font_properties(options.get("font"))
        self.gradient = self._get_gradient_properties(options.get("gradient"))
        self.line = self._get_line_properties(options.get("line"))

        self.text_rotation = options.get("text_rotation", 0)

        self.textlink = options.get("textlink", "")
        if self.textlink.startswith("="):
            self.textlink = self.textlink.lstrip("=")

        if options.get("border"):
            self.line = self._get_line_properties(options["border"])

        # Gradient fill overrides solid fill.
        if self.gradient:
            self.fill = None

    ###########################################################################
    #
    # Static methods for processing chart/shape style properties.
    #
    ###########################################################################

    @staticmethod
    def _get_line_properties(line):
        # Convert user line properties to the structure required internally.

        if not line:
            return {"defined": False}

        # Copy the user defined properties since they will be modified.
        line = copy.deepcopy(line)

        dash_types = {
            "solid": "solid",
            "round_dot": "sysDot",
            "square_dot": "sysDash",
            "dash": "dash",
            "dash_dot": "dashDot",
            "long_dash": "lgDash",
            "long_dash_dot": "lgDashDot",
            "long_dash_dot_dot": "lgDashDotDot",
            "dot": "dot",
            "system_dash_dot": "sysDashDot",
            "system_dash_dot_dot": "sysDashDotDot",
        }

        # Check the dash type.
        dash_type = line.get("dash_type")

        if dash_type is not None:
            if dash_type in dash_types:
                line["dash_type"] = dash_types[dash_type]
            else:
                warn("Unknown dash type '%s'" % dash_type)
                return

        line["defined"] = True

        return line

    @staticmethod
    def _get_fill_properties(fill):
        # Convert user fill properties to the structure required internally.

        if not fill:
            return {"defined": False}

        # Copy the user defined properties since they will be modified.
        fill = copy.deepcopy(fill)

        fill["defined"] = True

        return fill

    @staticmethod
    def _get_pattern_properties(pattern):
        # Convert user defined pattern to the structure required internally.

        if not pattern:
            return

        # Copy the user defined properties since they will be modified.
        pattern = copy.deepcopy(pattern)

        if not pattern.get("pattern"):
            warn("Pattern must include 'pattern'")
            return

        if not pattern.get("fg_color"):
            warn("Pattern must include 'fg_color'")
            return

        types = {
            "percent_5": "pct5",
            "percent_10": "pct10",
            "percent_20": "pct20",
            "percent_25": "pct25",
            "percent_30": "pct30",
            "percent_40": "pct40",
            "percent_50": "pct50",
            "percent_60": "pct60",
            "percent_70": "pct70",
            "percent_75": "pct75",
            "percent_80": "pct80",
            "percent_90": "pct90",
            "light_downward_diagonal": "ltDnDiag",
            "light_upward_diagonal": "ltUpDiag",
            "dark_downward_diagonal": "dkDnDiag",
            "dark_upward_diagonal": "dkUpDiag",
            "wide_downward_diagonal": "wdDnDiag",
            "wide_upward_diagonal": "wdUpDiag",
            "light_vertical": "ltVert",
            "light_horizontal": "ltHorz",
            "narrow_vertical": "narVert",
            "narrow_horizontal": "narHorz",
            "dark_vertical": "dkVert",
            "dark_horizontal": "dkHorz",
            "dashed_downward_diagonal": "dashDnDiag",
            "dashed_upward_diagonal": "dashUpDiag",
            "dashed_horizontal": "dashHorz",
            "dashed_vertical": "dashVert",
            "small_confetti": "smConfetti",
            "large_confetti": "lgConfetti",
            "zigzag": "zigZag",
            "wave": "wave",
            "diagonal_brick": "diagBrick",
            "horizontal_brick": "horzBrick",
            "weave": "weave",
            "plaid": "plaid",
            "divot": "divot",
            "dotted_grid": "dotGrid",
            "dotted_diamond": "dotDmnd",
            "shingle": "shingle",
            "trellis": "trellis",
            "sphere": "sphere",
            "small_grid": "smGrid",
            "large_grid": "lgGrid",
            "small_check": "smCheck",
            "large_check": "lgCheck",
            "outlined_diamond": "openDmnd",
            "solid_diamond": "solidDmnd",
        }

        # Check for valid types.
        if pattern["pattern"] not in types:
            warn("unknown pattern type '%s'" % pattern["pattern"])
            return
        else:
            pattern["pattern"] = types[pattern["pattern"]]

        # Specify a default background color.
        pattern["bg_color"] = pattern.get("bg_color", "#FFFFFF")

        return pattern

    @staticmethod
    def _get_gradient_properties(gradient):
        # Convert user defined gradient to the structure required internally.

        if not gradient:
            return

        # Copy the user defined properties since they will be modified.
        gradient = copy.deepcopy(gradient)

        types = {
            "linear": "linear",
            "radial": "circle",
            "rectangular": "rect",
            "path": "shape",
        }

        # Check the colors array exists and is valid.
        if "colors" not in gradient or not isinstance(gradient["colors"], list):
            warn("Gradient must include colors list")
            return

        # Check the colors array has the required number of entries.
        if not 2 <= len(gradient["colors"]) <= 10:
            warn("Gradient colors list must at least 2 values and not more than 10")
            return

        if "positions" in gradient:
            # Check the positions array has the right number of entries.
            if len(gradient["positions"]) != len(gradient["colors"]):
                warn("Gradient positions not equal to number of colors")
                return

            # Check the positions are in the correct range.
            for pos in gradient["positions"]:
                if not 0 <= pos <= 100:
                    warn("Gradient position must be in the range 0 <= position <= 100")
                    return
        else:
            # Use the default gradient positions.
            if len(gradient["colors"]) == 2:
                gradient["positions"] = [0, 100]

            elif len(gradient["colors"]) == 3:
                gradient["positions"] = [0, 50, 100]

            elif len(gradient["colors"]) == 4:
                gradient["positions"] = [0, 33, 66, 100]

            else:
                warn("Must specify gradient positions")
                return

        angle = gradient.get("angle")
        if angle:
            if not 0 <= angle < 360:
                warn("Gradient angle must be in the range 0 <= angle < 360")
                return
        else:
            gradient["angle"] = 90

        # Check for valid types.
        gradient_type = gradient.get("type")

        if gradient_type is not None:
            if gradient_type in types:
                gradient["type"] = types[gradient_type]
            else:
                warn("Unknown gradient type '%s" % gradient_type)
                return
        else:
            gradient["type"] = "linear"

        return gradient

    @staticmethod
    def _get_font_properties(options):
        # Convert user defined font values into private dict values.
        if options is None:
            options = {}

        font = {
            "name": options.get("name"),
            "color": options.get("color"),
            "size": options.get("size", 11),
            "bold": options.get("bold"),
            "italic": options.get("italic"),
            "underline": options.get("underline"),
            "pitch_family": options.get("pitch_family"),
            "charset": options.get("charset"),
            "baseline": options.get("baseline", -1),
            "lang": options.get("lang", "en-US"),
        }

        # Convert font size units.
        if font["size"]:
            font["size"] = int(font["size"] * 100)

        return font

    @staticmethod
    def _get_font_style_attributes(font):
        # _get_font_style_attributes.
        attributes = []

        if not font:
            return attributes

        if font.get("size"):
            attributes.append(("sz", font["size"]))

        if font.get("bold") is not None:
            attributes.append(("b", 0 + font["bold"]))

        if font.get("italic") is not None:
            attributes.append(("i", 0 + font["italic"]))

        if font.get("underline") is not None:
            attributes.append(("u", "sng"))

        if font.get("baseline") != -1:
            attributes.append(("baseline", font["baseline"]))

        return attributes

    @staticmethod
    def _get_font_latin_attributes(font):
        # _get_font_latin_attributes.
        attributes = []

        if not font:
            return attributes

        if font["name"] is not None:
            attributes.append(("typeface", font["name"]))

        if font["pitch_family"] is not None:
            attributes.append(("pitchFamily", font["pitch_family"]))

        if font["charset"] is not None:
            attributes.append(("charset", font["charset"]))

        return attributes

    @staticmethod
    def _get_align_properties(align):
        # Convert user defined align to the structure required internally.
        if not align:
            return {"defined": False}

        # Copy the user defined properties since they will be modified.
        align = copy.deepcopy(align)

        if "vertical" in align:
            align_type = align["vertical"]

            align_types = {
                "top": "top",
                "middle": "middle",
                "bottom": "bottom",
            }

            if align_type in align_types:
                align["vertical"] = align_types[align_type]
            else:
                warn("Unknown alignment type '%s'" % align_type)
                return {"defined": False}

        if "horizontal" in align:
            align_type = align["horizontal"]

            align_types = {
                "left": "left",
                "center": "center",
                "right": "right",
            }

            if align_type in align_types:
                align["horizontal"] = align_types[align_type]
            else:
                warn("Unknown alignment type '%s'" % align_type)
                return {"defined": False}

        align["defined"] = True

        return align

```

---

### File: `tmp\xlsxwriter_sdist\XlsxWriter-3.2.0\xlsxwriter\sharedstrings.py`

```python
###############################################################################
#
# SharedStrings - A class for writing the Excel XLSX sharedStrings file.
#
# SPDX-License-Identifier: BSD-2-Clause
# Copyright 2013-2024, John McNamara, jmcnamara@cpan.org
#

# Package imports.
from . import xmlwriter
from .utility import preserve_whitespace


class SharedStrings(xmlwriter.XMLwriter):
    """
    A class for writing the Excel XLSX sharedStrings file.

    """

    ###########################################################################
    #
    # Public API.
    #
    ###########################################################################

    def __init__(self):
        """
        Constructor.

        """

        super(SharedStrings, self).__init__()

        self.string_table = None

    ###########################################################################
    #
    # Private API.
    #
    ###########################################################################

    def _assemble_xml_file(self):
        # Assemble and write the XML file.

        # Write the XML declaration.
        self._xml_declaration()

        # Write the sst element.
        self._write_sst()

        # Write the sst strings.
        self._write_sst_strings()

        # Close the sst tag.
        self._xml_end_tag("sst")

        # Close the file.
        self._xml_close()

    ###########################################################################
    #
    # XML methods.
    #
    ###########################################################################

    def _write_sst(self):
        # Write the <sst> element.
        xmlns = "http://schemas.openxmlformats.org/spreadsheetml/2006/main"

        attributes = [
            ("xmlns", xmlns),
            ("count", self.string_table.count),
            ("uniqueCount", self.string_table.unique_count),
        ]

        self._xml_start_tag("sst", attributes)

    def _write_sst_strings(self):
        # Write the sst string elements.

        for string in self.string_table.string_array:
            self._write_si(string)

    def _write_si(self, string):
        # Write the <si> element.
        attributes = []

        # Convert control character to a _xHHHH_ escape.
        string = self._escape_control_characters(string)

        # Add attribute to preserve leading or trailing whitespace.
        if preserve_whitespace(string):
            attributes.append(("xml:space", "preserve"))

        # Write any rich strings without further tags.
        if string.startswith("<r>") and string.endswith("</r>"):
            self._xml_rich_si_element(string)
        else:
            self._xml_si_element(string, attributes)


# A metadata class to store Excel strings between worksheets.
class SharedStringTable(object):
    """
    A class to track Excel shared strings between worksheets.

    """

    def __init__(self):
        self.count = 0
        self.unique_count = 0
        self.string_table = {}
        self.string_array = []

    def _get_shared_string_index(self, string):
        """ " Get the index of the string in the Shared String table."""
        if string not in self.string_table:
            # String isn't already stored in the table so add it.
            index = self.unique_count
            self.string_table[string] = index
            self.count += 1
            self.unique_count += 1
            return index
        else:
            # String exists in the table.
            index = self.string_table[string]
            self.count += 1
            return index

    def _get_shared_string(self, index):
        """ " Get a shared string from the index."""
        return self.string_array[index]

    def _sort_string_data(self):
        """ " Sort the shared string data and convert from dict to list."""
        self.string_array = sorted(self.string_table, key=self.string_table.__getitem__)
        self.string_table = {}

```

---

### File: `tmp\xlsxwriter_sdist\XlsxWriter-3.2.0\xlsxwriter\styles.py`

```python
###############################################################################
#
# Styles - A class for writing the Excel XLSX Worksheet file.
#
# SPDX-License-Identifier: BSD-2-Clause
# Copyright 2013-2024, John McNamara, jmcnamara@cpan.org
#

# Package imports.
from . import xmlwriter


class Styles(xmlwriter.XMLwriter):
    """
    A class for writing the Excel XLSX Styles file.


    """

    ###########################################################################
    #
    # Public API.
    #
    ###########################################################################

    def __init__(self):
        """
        Constructor.

        """

        super(Styles, self).__init__()

        self.xf_formats = []
        self.palette = []
        self.font_count = 0
        self.num_formats = []
        self.border_count = 0
        self.fill_count = 0
        self.custom_colors = []
        self.dxf_formats = []
        self.has_hyperlink = False
        self.hyperlink_font_id = 0
        self.has_comments = False

    ###########################################################################
    #
    # Private API.
    #
    ###########################################################################

    def _assemble_xml_file(self):
        # Assemble and write the XML file.

        # Write the XML declaration.
        self._xml_declaration()

        # Add the style sheet.
        self._write_style_sheet()

        # Write the number formats.
        self._write_num_fmts()

        # Write the fonts.
        self._write_fonts()

        # Write the fills.
        self._write_fills()

        # Write the borders element.
        self._write_borders()

        # Write the cellStyleXfs element.
        self._write_cell_style_xfs()

        # Write the cellXfs element.
        self._write_cell_xfs()

        # Write the cellStyles element.
        self._write_cell_styles()

        # Write the dxfs element.
        self._write_dxfs()

        # Write the tableStyles element.
        self._write_table_styles()

        # Write the colors element.
        self._write_colors()

        # Close the style sheet tag.
        self._xml_end_tag("styleSheet")

        # Close the file.
        self._xml_close()

    def _set_style_properties(self, properties):
        # Pass in the Format objects and other properties used in the styles.

        self.xf_formats = properties[0]
        self.palette = properties[1]
        self.font_count = properties[2]
        self.num_formats = properties[3]
        self.border_count = properties[4]
        self.fill_count = properties[5]
        self.custom_colors = properties[6]
        self.dxf_formats = properties[7]
        self.has_comments = properties[8]

    def _get_palette_color(self, color):
        # Special handling for automatic color.
        if color == "Automatic":
            return color

        # Convert the RGB color.
        if color[0] == "#":
            color = color[1:]

        return "FF" + color.upper()

    ###########################################################################
    #
    # XML methods.
    #
    ###########################################################################

    def _write_style_sheet(self):
        # Write the <styleSheet> element.
        xmlns = "http://schemas.openxmlformats.org/spreadsheetml/2006/main"

        attributes = [("xmlns", xmlns)]
        self._xml_start_tag("styleSheet", attributes)

    def _write_num_fmts(self):
        # Write the <numFmts> element.
        if not self.num_formats:
            return

        attributes = [("count", len(self.num_formats))]
        self._xml_start_tag("numFmts", attributes)

        # Write the numFmts elements.
        for index, num_format in enumerate(self.num_formats, 164):
            self._write_num_fmt(index, num_format)

        self._xml_end_tag("numFmts")

    def _write_num_fmt(self, num_fmt_id, format_code):
        # Write the <numFmt> element.
        format_codes = {
            0: "General",
            1: "0",
            2: "0.00",
            3: "#,##0",
            4: "#,##0.00",
            5: "($#,##0_);($#,##0)",
            6: "($#,##0_);[Red]($#,##0)",
            7: "($#,##0.00_);($#,##0.00)",
            8: "($#,##0.00_);[Red]($#,##0.00)",
            9: "0%",
            10: "0.00%",
            11: "0.00E+00",
            12: "# ?/?",
            13: "# ??/??",
            14: "m/d/yy",
            15: "d-mmm-yy",
            16: "d-mmm",
            17: "mmm-yy",
            18: "h:mm AM/PM",
            19: "h:mm:ss AM/PM",
            20: "h:mm",
            21: "h:mm:ss",
            22: "m/d/yy h:mm",
            37: "(#,##0_);(#,##0)",
            38: "(#,##0_);[Red](#,##0)",
            39: "(#,##0.00_);(#,##0.00)",
            40: "(#,##0.00_);[Red](#,##0.00)",
            41: '_(* #,##0_);_(* (#,##0);_(* "-"_);_(_)',
            42: '_($* #,##0_);_($* (#,##0);_($* "-"_);_(_)',
            43: '_(* #,##0.00_);_(* (#,##0.00);_(* "-"??_);_(_)',
            44: '_($* #,##0.00_);_($* (#,##0.00);_($* "-"??_);_(_)',
            45: "mm:ss",
            46: "[h]:mm:ss",
            47: "mm:ss.0",
            48: "##0.0E+0",
            49: "@",
        }

        # Set the format code for built-in number formats.
        if num_fmt_id < 164:
            if num_fmt_id in format_codes:
                format_code = format_codes[num_fmt_id]
            else:
                format_code = "General"

        attributes = [
            ("numFmtId", num_fmt_id),
            ("formatCode", format_code),
        ]

        self._xml_empty_tag("numFmt", attributes)

    def _write_fonts(self):
        # Write the <fonts> element.
        if self.has_comments:
            # Add extra font for comments.
            attributes = [("count", self.font_count + 1)]
        else:
            attributes = [("count", self.font_count)]

        self._xml_start_tag("fonts", attributes)

        # Write the font elements for xf_format objects that have them.
        for xf_format in self.xf_formats:
            if xf_format.has_font:
                self._write_font(xf_format)

        if self.has_comments:
            self._write_comment_font()

        self._xml_end_tag("fonts")

    def _write_font(self, xf_format, is_dxf_format=False):
        # Write the <font> element.
        self._xml_start_tag("font")

        # The condense and extend elements are mainly used in dxf formats.
        if xf_format.font_condense:
            self._write_condense()

        if xf_format.font_extend:
            self._write_extend()

        if xf_format.bold:
            self._xml_empty_tag("b")

        if xf_format.italic:
            self._xml_empty_tag("i")

        if xf_format.font_strikeout:
            self._xml_empty_tag("strike")

        if xf_format.font_outline:
            self._xml_empty_tag("outline")

        if xf_format.font_shadow:
            self._xml_empty_tag("shadow")

        # Handle the underline variants.
        if xf_format.underline:
            self._write_underline(xf_format.underline)

        if xf_format.font_script == 1:
            self._write_vert_align("superscript")

        if xf_format.font_script == 2:
            self._write_vert_align("subscript")

        if not is_dxf_format:
            self._xml_empty_tag("sz", [("val", xf_format.font_size)])

        if xf_format.theme == -1:
            # Ignore for excel2003_style.
            pass
        elif xf_format.theme:
            self._write_color("theme", xf_format.theme)
        elif xf_format.color_indexed:
            self._write_color("indexed", xf_format.color_indexed)
        elif xf_format.font_color:
            color = self._get_palette_color(xf_format.font_color)
            if color != "Automatic":
                self._write_color("rgb", color)
        elif not is_dxf_format:
            self._write_color("theme", 1)

        if not is_dxf_format:
            self._xml_empty_tag("name", [("val", xf_format.font_name)])

            if xf_format.font_family:
                self._xml_empty_tag("family", [("val", xf_format.font_family)])

            if xf_format.font_charset:
                self._xml_empty_tag("charset", [("val", xf_format.font_charset)])

            if xf_format.font_name == "Calibri" and not xf_format.hyperlink:
                self._xml_empty_tag("scheme", [("val", xf_format.font_scheme)])

            if xf_format.hyperlink:
                self.has_hyperlink = True
                if self.hyperlink_font_id == 0:
                    self.hyperlink_font_id = xf_format.font_index

        self._xml_end_tag("font")

    def _write_comment_font(self):
        # Write the <font> element for comments.
        self._xml_start_tag("font")

        self._xml_empty_tag("sz", [("val", 8)])
        self._write_color("indexed", 81)
        self._xml_empty_tag("name", [("val", "Tahoma")])
        self._xml_empty_tag("family", [("val", 2)])

        self._xml_end_tag("font")

    def _write_underline(self, underline):
        # Write the underline font element.

        if underline == 2:
            attributes = [("val", "double")]
        elif underline == 33:
            attributes = [("val", "singleAccounting")]
        elif underline == 34:
            attributes = [("val", "doubleAccounting")]
        else:
            # Default to single underline.
            attributes = []

        self._xml_empty_tag("u", attributes)

    def _write_vert_align(self, val):
        # Write the <vertAlign> font sub-element.
        attributes = [("val", val)]

        self._xml_empty_tag("vertAlign", attributes)

    def _write_color(self, name, value):
        # Write the <color> element.
        attributes = [(name, value)]

        self._xml_empty_tag("color", attributes)

    def _write_fills(self):
        # Write the <fills> element.
        attributes = [("count", self.fill_count)]

        self._xml_start_tag("fills", attributes)

        # Write the default fill element.
        self._write_default_fill("none")
        self._write_default_fill("gray125")

        # Write the fill elements for xf_format objects that have them.
        for xf_format in self.xf_formats:
            if xf_format.has_fill:
                self._write_fill(xf_format)

        self._xml_end_tag("fills")

    def _write_default_fill(self, pattern_type):
        # Write the <fill> element for the default fills.
        self._xml_start_tag("fill")
        self._xml_empty_tag("patternFill", [("patternType", pattern_type)])
        self._xml_end_tag("fill")

    def _write_fill(self, xf_format, is_dxf_format=False):
        # Write the <fill> element.
        pattern = xf_format.pattern
        bg_color = xf_format.bg_color
        fg_color = xf_format.fg_color

        # Colors for dxf formats are handled differently from normal formats
        # since the normal xf_format reverses the meaning of BG and FG for
        # solid fills.
        if is_dxf_format:
            bg_color = xf_format.dxf_bg_color
            fg_color = xf_format.dxf_fg_color

        patterns = (
            "none",
            "solid",
            "mediumGray",
            "darkGray",
            "lightGray",
            "darkHorizontal",
            "darkVertical",
            "darkDown",
            "darkUp",
            "darkGrid",
            "darkTrellis",
            "lightHorizontal",
            "lightVertical",
            "lightDown",
            "lightUp",
            "lightGrid",
            "lightTrellis",
            "gray125",
            "gray0625",
        )

        # Special handling for pattern only case.
        if not fg_color and not bg_color and patterns[pattern]:
            self._write_default_fill(patterns[pattern])
            return

        self._xml_start_tag("fill")

        # The "none" pattern is handled differently for dxf formats.
        if is_dxf_format and pattern <= 1:
            self._xml_start_tag("patternFill")
        else:
            self._xml_start_tag("patternFill", [("patternType", patterns[pattern])])

        if fg_color:
            fg_color = self._get_palette_color(fg_color)
            if fg_color != "Automatic":
                self._xml_empty_tag("fgColor", [("rgb", fg_color)])

        if bg_color:
            bg_color = self._get_palette_color(bg_color)
            if bg_color != "Automatic":
                self._xml_empty_tag("bgColor", [("rgb", bg_color)])
        else:
            if not is_dxf_format and pattern <= 1:
                self._xml_empty_tag("bgColor", [("indexed", 64)])

        self._xml_end_tag("patternFill")
        self._xml_end_tag("fill")

    def _write_borders(self):
        # Write the <borders> element.
        attributes = [("count", self.border_count)]

        self._xml_start_tag("borders", attributes)

        # Write the border elements for xf_format objects that have them.
        for xf_format in self.xf_formats:
            if xf_format.has_border:
                self._write_border(xf_format)

        self._xml_end_tag("borders")

    def _write_border(self, xf_format, is_dxf_format=False):
        # Write the <border> element.
        attributes = []

        # Diagonal borders add attributes to the <border> element.
        if xf_format.diag_type == 1:
            attributes.append(("diagonalUp", 1))
        elif xf_format.diag_type == 2:
            attributes.append(("diagonalDown", 1))
        elif xf_format.diag_type == 3:
            attributes.append(("diagonalUp", 1))
            attributes.append(("diagonalDown", 1))

        # Ensure that a default diag border is set if the diag type is set.
        if xf_format.diag_type and not xf_format.diag_border:
            xf_format.diag_border = 1

        # Write the start border tag.
        self._xml_start_tag("border", attributes)

        # Write the <border> sub elements.
        self._write_sub_border("left", xf_format.left, xf_format.left_color)

        self._write_sub_border("right", xf_format.right, xf_format.right_color)

        self._write_sub_border("top", xf_format.top, xf_format.top_color)

        self._write_sub_border("bottom", xf_format.bottom, xf_format.bottom_color)

        # Condition DXF formats don't allow diagonal borders.
        if not is_dxf_format:
            self._write_sub_border(
                "diagonal", xf_format.diag_border, xf_format.diag_color
            )

        if is_dxf_format:
            self._write_sub_border("vertical", None, None)
            self._write_sub_border("horizontal", None, None)

        self._xml_end_tag("border")

    def _write_sub_border(self, border_type, style, color):
        # Write the <border> sub elements such as <right>, <top>, etc.
        attributes = []

        if not style:
            self._xml_empty_tag(border_type)
            return

        border_styles = (
            "none",
            "thin",
            "medium",
            "dashed",
            "dotted",
            "thick",
            "double",
            "hair",
            "mediumDashed",
            "dashDot",
            "mediumDashDot",
            "dashDotDot",
            "mediumDashDotDot",
            "slantDashDot",
        )

        attributes.append(("style", border_styles[style]))

        self._xml_start_tag(border_type, attributes)

        if color and color != "Automatic":
            color = self._get_palette_color(color)
            self._xml_empty_tag("color", [("rgb", color)])
        else:
            self._xml_empty_tag("color", [("auto", 1)])

        self._xml_end_tag(border_type)

    def _write_cell_style_xfs(self):
        # Write the <cellStyleXfs> element.
        count = 1

        if self.has_hyperlink:
            count = 2

        attributes = [("count", count)]

        self._xml_start_tag("cellStyleXfs", attributes)
        self._write_style_xf()

        if self.has_hyperlink:
            self._write_style_xf(True, self.hyperlink_font_id)

        self._xml_end_tag("cellStyleXfs")

    def _write_cell_xfs(self):
        # Write the <cellXfs> element.
        formats = self.xf_formats

        # Workaround for when the last xf_format is used for the comment font
        # and shouldn't be used for cellXfs.
        last_format = formats[-1]
        if last_format.font_only:
            formats.pop()

        attributes = [("count", len(formats))]
        self._xml_start_tag("cellXfs", attributes)

        # Write the xf elements.
        for xf_format in formats:
            self._write_xf(xf_format)

        self._xml_end_tag("cellXfs")

    def _write_style_xf(self, has_hyperlink=False, font_id=0):
        # Write the style <xf> element.
        num_fmt_id = 0
        fill_id = 0
        border_id = 0

        attributes = [
            ("numFmtId", num_fmt_id),
            ("fontId", font_id),
            ("fillId", fill_id),
            ("borderId", border_id),
        ]

        if has_hyperlink:
            attributes.append(("applyNumberFormat", 0))
            attributes.append(("applyFill", 0))
            attributes.append(("applyBorder", 0))
            attributes.append(("applyAlignment", 0))
            attributes.append(("applyProtection", 0))

            self._xml_start_tag("xf", attributes)
            self._xml_empty_tag("alignment", [("vertical", "top")])
            self._xml_empty_tag("protection", [("locked", 0)])
            self._xml_end_tag("xf")

        else:
            self._xml_empty_tag("xf", attributes)

    def _write_xf(self, xf_format):
        # Write the <xf> element.
        num_fmt_id = xf_format.num_format_index
        font_id = xf_format.font_index
        fill_id = xf_format.fill_index
        border_id = xf_format.border_index
        xf_id = xf_format.xf_id
        has_align = 0
        has_protect = 0

        attributes = [
            ("numFmtId", num_fmt_id),
            ("fontId", font_id),
            ("fillId", fill_id),
            ("borderId", border_id),
            ("xfId", xf_id),
        ]

        if xf_format.quote_prefix:
            attributes.append(("quotePrefix", 1))

        if xf_format.num_format_index > 0:
            attributes.append(("applyNumberFormat", 1))

        # Add applyFont attribute if XF format uses a font element.
        if xf_format.font_index > 0 and not xf_format.hyperlink:
            attributes.append(("applyFont", 1))

        # Add applyFill attribute if XF format uses a fill element.
        if xf_format.fill_index > 0:
            attributes.append(("applyFill", 1))

        # Add applyBorder attribute if XF format uses a border element.
        if xf_format.border_index > 0:
            attributes.append(("applyBorder", 1))

        # Check if XF format has alignment properties set.
        (apply_align, align) = xf_format._get_align_properties()

        # Check if an alignment sub-element should be written.
        if apply_align and align:
            has_align = 1

        # We can also have applyAlignment without a sub-element.
        if apply_align or xf_format.hyperlink:
            attributes.append(("applyAlignment", 1))

        # Check for cell protection properties.
        protection = xf_format._get_protection_properties()

        if protection or xf_format.hyperlink:
            attributes.append(("applyProtection", 1))

            if not xf_format.hyperlink:
                has_protect = 1

        # Write XF with sub-elements if required.
        if has_align or has_protect:
            self._xml_start_tag("xf", attributes)
            if has_align:
                self._xml_empty_tag("alignment", align)
            if has_protect:
                self._xml_empty_tag("protection", protection)
            self._xml_end_tag("xf")
        else:
            self._xml_empty_tag("xf", attributes)

    def _write_cell_styles(self):
        # Write the <cellStyles> element.
        count = 1

        if self.has_hyperlink:
            count = 2

        attributes = [("count", count)]

        self._xml_start_tag("cellStyles", attributes)

        if self.has_hyperlink:
            self._write_cell_style("Hyperlink", 1, 8)

        self._write_cell_style()

        self._xml_end_tag("cellStyles")

    def _write_cell_style(self, name="Normal", xf_id=0, builtin_id=0):
        # Write the <cellStyle> element.
        attributes = [
            ("name", name),
            ("xfId", xf_id),
            ("builtinId", builtin_id),
        ]

        self._xml_empty_tag("cellStyle", attributes)

    def _write_dxfs(self):
        # Write the <dxfs> element.
        formats = self.dxf_formats
        count = len(formats)

        attributes = [("count", len(formats))]

        if count:
            self._xml_start_tag("dxfs", attributes)

            # Write the font elements for xf_format objects that have them.
            for xf_format in self.dxf_formats:
                self._xml_start_tag("dxf")
                if xf_format.has_dxf_font:
                    self._write_font(xf_format, True)

                if xf_format.num_format_index:
                    self._write_num_fmt(
                        xf_format.num_format_index, xf_format.num_format
                    )

                if xf_format.has_dxf_fill:
                    self._write_fill(xf_format, True)
                if xf_format.has_dxf_border:
                    self._write_border(xf_format, True)
                self._xml_end_tag("dxf")

            self._xml_end_tag("dxfs")
        else:
            self._xml_empty_tag("dxfs", attributes)

    def _write_table_styles(self):
        # Write the <tableStyles> element.
        count = 0
        default_table_style = "TableStyleMedium9"
        default_pivot_style = "PivotStyleLight16"

        attributes = [
            ("count", count),
            ("defaultTableStyle", default_table_style),
            ("defaultPivotStyle", default_pivot_style),
        ]

        self._xml_empty_tag("tableStyles", attributes)

    def _write_colors(self):
        # Write the <colors> element.
        custom_colors = self.custom_colors

        if not custom_colors:
            return

        self._xml_start_tag("colors")
        self._write_mru_colors(custom_colors)
        self._xml_end_tag("colors")

    def _write_mru_colors(self, custom_colors):
        # Write the <mruColors> element for the most recently used colors.

        # Write the custom custom_colors in reverse order.
        custom_colors.reverse()

        # Limit the mruColors to the last 10.
        if len(custom_colors) > 10:
            custom_colors = custom_colors[0:10]

        self._xml_start_tag("mruColors")

        # Write the custom custom_colors in reverse order.
        for color in custom_colors:
            self._write_color("rgb", color)

        self._xml_end_tag("mruColors")

    def _write_condense(self):
        # Write the <condense> element.
        attributes = [("val", 0)]

        self._xml_empty_tag("condense", attributes)

    def _write_extend(self):
        # Write the <extend> element.
        attributes = [("val", 0)]

        self._xml_empty_tag("extend", attributes)

```

---

### File: `tmp\xlsxwriter_sdist\XlsxWriter-3.2.0\xlsxwriter\table.py`

```python
###############################################################################
#
# Table - A class for writing the Excel XLSX Worksheet file.
#
# SPDX-License-Identifier: BSD-2-Clause
# Copyright 2013-2024, John McNamara, jmcnamara@cpan.org
#

from . import xmlwriter


class Table(xmlwriter.XMLwriter):
    """
    A class for writing the Excel XLSX Table file.


    """

    ###########################################################################
    #
    # Public API.
    #
    ###########################################################################

    def __init__(self):
        """
        Constructor.

        """

        super(Table, self).__init__()

        self.properties = {}

    ###########################################################################
    #
    # Private API.
    #
    ###########################################################################

    def _assemble_xml_file(self):
        # Assemble and write the XML file.

        # Write the XML declaration.
        self._xml_declaration()

        # Write the table element.
        self._write_table()

        # Write the autoFilter element.
        self._write_auto_filter()

        # Write the tableColumns element.
        self._write_table_columns()

        # Write the tableStyleInfo element.
        self._write_table_style_info()

        # Close the table tag.
        self._xml_end_tag("table")

        # Close the file.
        self._xml_close()

    def _set_properties(self, properties):
        # Set the document properties.
        self.properties = properties

    ###########################################################################
    #
    # XML methods.
    #
    ###########################################################################

    def _write_table(self):
        # Write the <table> element.
        schema = "http://schemas.openxmlformats.org/"
        xmlns = schema + "spreadsheetml/2006/main"
        table_id = self.properties["id"]
        name = self.properties["name"]
        display_name = self.properties["name"]
        ref = self.properties["range"]
        totals_row_shown = self.properties["totals_row_shown"]
        header_row_count = self.properties["header_row_count"]

        attributes = [
            ("xmlns", xmlns),
            ("id", table_id),
            ("name", name),
            ("displayName", display_name),
            ("ref", ref),
        ]

        if not header_row_count:
            attributes.append(("headerRowCount", 0))

        if totals_row_shown:
            attributes.append(("totalsRowCount", 1))
        else:
            attributes.append(("totalsRowShown", 0))

        self._xml_start_tag("table", attributes)

    def _write_auto_filter(self):
        # Write the <autoFilter> element.
        autofilter = self.properties.get("autofilter", 0)

        if not autofilter:
            return

        attributes = [
            (
                "ref",
                autofilter,
            )
        ]

        self._xml_empty_tag("autoFilter", attributes)

    def _write_table_columns(self):
        # Write the <tableColumns> element.
        columns = self.properties["columns"]

        count = len(columns)

        attributes = [("count", count)]

        self._xml_start_tag("tableColumns", attributes)

        for col_data in columns:
            # Write the tableColumn element.
            self._write_table_column(col_data)

        self._xml_end_tag("tableColumns")

    def _write_table_column(self, col_data):
        # Write the <tableColumn> element.
        attributes = [
            ("id", col_data["id"]),
            ("name", col_data["name"]),
        ]

        if col_data.get("total_string"):
            attributes.append(("totalsRowLabel", col_data["total_string"]))
        elif col_data.get("total_function"):
            attributes.append(("totalsRowFunction", col_data["total_function"]))

        if "format" in col_data and col_data["format"] is not None:
            attributes.append(("dataDxfId", col_data["format"]))

        if col_data.get("formula") or col_data.get("custom_total"):
            self._xml_start_tag("tableColumn", attributes)

            if col_data.get("formula"):
                # Write the calculatedColumnFormula element.
                self._write_calculated_column_formula(col_data["formula"])

            if col_data.get("custom_total"):
                # Write the totalsRowFormula element.
                self._write_totals_row_formula(col_data.get("custom_total"))

            self._xml_end_tag("tableColumn")
        else:
            self._xml_empty_tag("tableColumn", attributes)

    def _write_table_style_info(self):
        # Write the <tableStyleInfo> element.
        props = self.properties
        attributes = []

        name = props["style"]
        show_first_column = 0 + props["show_first_col"]
        show_last_column = 0 + props["show_last_col"]
        show_row_stripes = 0 + props["show_row_stripes"]
        show_column_stripes = 0 + props["show_col_stripes"]

        if name is not None and name != "" and name != "None":
            attributes.append(("name", name))

        attributes.append(("showFirstColumn", show_first_column))
        attributes.append(("showLastColumn", show_last_column))
        attributes.append(("showRowStripes", show_row_stripes))
        attributes.append(("showColumnStripes", show_column_stripes))

        self._xml_empty_tag("tableStyleInfo", attributes)

    def _write_calculated_column_formula(self, formula):
        # Write the <calculatedColumnFormula> element.
        self._xml_data_element("calculatedColumnFormula", formula)

    def _write_totals_row_formula(self, formula):
        # Write the <totalsRowFormula> element.
        self._xml_data_element("totalsRowFormula", formula)

```

---

### File: `tmp\xlsxwriter_sdist\XlsxWriter-3.2.0\xlsxwriter\theme.py`

```python
###############################################################################
#
# Theme - A class for writing the Excel XLSX Worksheet file.
#
# SPDX-License-Identifier: BSD-2-Clause
# Copyright 2013-2024, John McNamara, jmcnamara@cpan.org
#

from io import StringIO


class Theme(object):
    """
    A class for writing the Excel XLSX Theme file.


    """

    ###########################################################################
    #
    # Public API.
    #
    ###########################################################################

    def __init__(self):
        """
        Constructor.

        """
        super(Theme, self).__init__()
        self.fh = None
        self.internal_fh = False

    ###########################################################################
    #
    # Private API.
    #
    ###########################################################################

    def _assemble_xml_file(self):
        # Assemble and write the XML file.
        self._write_theme_file()
        if self.internal_fh:
            self.fh.close()

    def _set_xml_writer(self, filename):
        # Set the XML writer filehandle for the object.
        if isinstance(filename, StringIO):
            self.internal_fh = False
            self.fh = filename
        else:
            self.internal_fh = True
            self.fh = open(filename, mode="w", encoding="utf-8")

    ###########################################################################
    #
    # XML methods.
    #
    ###########################################################################

    def _write_theme_file(self):
        # Write a default theme.xml file.

        default_theme = """<?xml version="1.0" encoding="UTF-8" standalone="yes"?>\n<a:theme xmlns:a="http://schemas.openxmlformats.org/drawingml/2006/main" name="Office Theme"><a:themeElements><a:clrScheme name="Office"><a:dk1><a:sysClr val="windowText" lastClr="000000"/></a:dk1><a:lt1><a:sysClr val="window" lastClr="FFFFFF"/></a:lt1><a:dk2><a:srgbClr val="1F497D"/></a:dk2><a:lt2><a:srgbClr val="EEECE1"/></a:lt2><a:accent1><a:srgbClr val="4F81BD"/></a:accent1><a:accent2><a:srgbClr val="C0504D"/></a:accent2><a:accent3><a:srgbClr val="9BBB59"/></a:accent3><a:accent4><a:srgbClr val="8064A2"/></a:accent4><a:accent5><a:srgbClr val="4BACC6"/></a:accent5><a:accent6><a:srgbClr val="F79646"/></a:accent6><a:hlink><a:srgbClr val="0000FF"/></a:hlink><a:folHlink><a:srgbClr val="800080"/></a:folHlink></a:clrScheme><a:fontScheme name="Office"><a:majorFont><a:latin typeface="Cambria"/><a:ea typeface=""/><a:cs typeface=""/><a:font script="Jpan" typeface="\uff2d\uff33 \uff30\u30b4\u30b7\u30c3\u30af"/><a:font script="Hang" typeface="\ub9d1\uc740 \uace0\ub515"/><a:font script="Hans" typeface="\u5b8b\u4f53"/><a:font script="Hant" typeface="\u65b0\u7d30\u660e\u9ad4"/><a:font script="Arab" typeface="Times New Roman"/><a:font script="Hebr" typeface="Times New Roman"/><a:font script="Thai" typeface="Tahoma"/><a:font script="Ethi" typeface="Nyala"/><a:font script="Beng" typeface="Vrinda"/><a:font script="Gujr" typeface="Shruti"/><a:font script="Khmr" typeface="MoolBoran"/><a:font script="Knda" typeface="Tunga"/><a:font script="Guru" typeface="Raavi"/><a:font script="Cans" typeface="Euphemia"/><a:font script="Cher" typeface="Plantagenet Cherokee"/><a:font script="Yiii" typeface="Microsoft Yi Baiti"/><a:font script="Tibt" typeface="Microsoft Himalaya"/><a:font script="Thaa" typeface="MV Boli"/><a:font script="Deva" typeface="Mangal"/><a:font script="Telu" typeface="Gautami"/><a:font script="Taml" typeface="Latha"/><a:font script="Syrc" typeface="Estrangelo Edessa"/><a:font script="Orya" typeface="Kalinga"/><a:font script="Mlym" typeface="Kartika"/><a:font script="Laoo" typeface="DokChampa"/><a:font script="Sinh" typeface="Iskoola Pota"/><a:font script="Mong" typeface="Mongolian Baiti"/><a:font script="Viet" typeface="Times New Roman"/><a:font script="Uigh" typeface="Microsoft Uighur"/></a:majorFont><a:minorFont><a:latin typeface="Calibri"/><a:ea typeface=""/><a:cs typeface=""/><a:font script="Jpan" typeface="\uff2d\uff33 \uff30\u30b4\u30b7\u30c3\u30af"/><a:font script="Hang" typeface="\ub9d1\uc740 \uace0\ub515"/><a:font script="Hans" typeface="\u5b8b\u4f53"/><a:font script="Hant" typeface="\u65b0\u7d30\u660e\u9ad4"/><a:font script="Arab" typeface="Arial"/><a:font script="Hebr" typeface="Arial"/><a:font script="Thai" typeface="Tahoma"/><a:font script="Ethi" typeface="Nyala"/><a:font script="Beng" typeface="Vrinda"/><a:font script="Gujr" typeface="Shruti"/><a:font script="Khmr" typeface="DaunPenh"/><a:font script="Knda" typeface="Tunga"/><a:font script="Guru" typeface="Raavi"/><a:font script="Cans" typeface="Euphemia"/><a:font script="Cher" typeface="Plantagenet Cherokee"/><a:font script="Yiii" typeface="Microsoft Yi Baiti"/><a:font script="Tibt" typeface="Microsoft Himalaya"/><a:font script="Thaa" typeface="MV Boli"/><a:font script="Deva" typeface="Mangal"/><a:font script="Telu" typeface="Gautami"/><a:font script="Taml" typeface="Latha"/><a:font script="Syrc" typeface="Estrangelo Edessa"/><a:font script="Orya" typeface="Kalinga"/><a:font script="Mlym" typeface="Kartika"/><a:font script="Laoo" typeface="DokChampa"/><a:font script="Sinh" typeface="Iskoola Pota"/><a:font script="Mong" typeface="Mongolian Baiti"/><a:font script="Viet" typeface="Arial"/><a:font script="Uigh" typeface="Microsoft Uighur"/></a:minorFont></a:fontScheme><a:fmtScheme name="Office"><a:fillStyleLst><a:solidFill><a:schemeClr val="phClr"/></a:solidFill><a:gradFill rotWithShape="1"><a:gsLst><a:gs pos="0"><a:schemeClr val="phClr"><a:tint val="50000"/><a:satMod val="300000"/></a:schemeClr></a:gs><a:gs pos="35000"><a:schemeClr val="phClr"><a:tint val="37000"/><a:satMod val="300000"/></a:schemeClr></a:gs><a:gs pos="100000"><a:schemeClr val="phClr"><a:tint val="15000"/><a:satMod val="350000"/></a:schemeClr></a:gs></a:gsLst><a:lin ang="16200000" scaled="1"/></a:gradFill><a:gradFill rotWithShape="1"><a:gsLst><a:gs pos="0"><a:schemeClr val="phClr"><a:shade val="51000"/><a:satMod val="130000"/></a:schemeClr></a:gs><a:gs pos="80000"><a:schemeClr val="phClr"><a:shade val="93000"/><a:satMod val="130000"/></a:schemeClr></a:gs><a:gs pos="100000"><a:schemeClr val="phClr"><a:shade val="94000"/><a:satMod val="135000"/></a:schemeClr></a:gs></a:gsLst><a:lin ang="16200000" scaled="0"/></a:gradFill></a:fillStyleLst><a:lnStyleLst><a:ln w="9525" cap="flat" cmpd="sng" algn="ctr"><a:solidFill><a:schemeClr val="phClr"><a:shade val="95000"/><a:satMod val="105000"/></a:schemeClr></a:solidFill><a:prstDash val="solid"/></a:ln><a:ln w="25400" cap="flat" cmpd="sng" algn="ctr"><a:solidFill><a:schemeClr val="phClr"/></a:solidFill><a:prstDash val="solid"/></a:ln><a:ln w="38100" cap="flat" cmpd="sng" algn="ctr"><a:solidFill><a:schemeClr val="phClr"/></a:solidFill><a:prstDash val="solid"/></a:ln></a:lnStyleLst><a:effectStyleLst><a:effectStyle><a:effectLst><a:outerShdw blurRad="40000" dist="20000" dir="5400000" rotWithShape="0"><a:srgbClr val="000000"><a:alpha val="38000"/></a:srgbClr></a:outerShdw></a:effectLst></a:effectStyle><a:effectStyle><a:effectLst><a:outerShdw blurRad="40000" dist="23000" dir="5400000" rotWithShape="0"><a:srgbClr val="000000"><a:alpha val="35000"/></a:srgbClr></a:outerShdw></a:effectLst></a:effectStyle><a:effectStyle><a:effectLst><a:outerShdw blurRad="40000" dist="23000" dir="5400000" rotWithShape="0"><a:srgbClr val="000000"><a:alpha val="35000"/></a:srgbClr></a:outerShdw></a:effectLst><a:scene3d><a:camera prst="orthographicFront"><a:rot lat="0" lon="0" rev="0"/></a:camera><a:lightRig rig="threePt" dir="t"><a:rot lat="0" lon="0" rev="1200000"/></a:lightRig></a:scene3d><a:sp3d><a:bevelT w="63500" h="25400"/></a:sp3d></a:effectStyle></a:effectStyleLst><a:bgFillStyleLst><a:solidFill><a:schemeClr val="phClr"/></a:solidFill><a:gradFill rotWithShape="1"><a:gsLst><a:gs pos="0"><a:schemeClr val="phClr"><a:tint val="40000"/><a:satMod val="350000"/></a:schemeClr></a:gs><a:gs pos="40000"><a:schemeClr val="phClr"><a:tint val="45000"/><a:shade val="99000"/><a:satMod val="350000"/></a:schemeClr></a:gs><a:gs pos="100000"><a:schemeClr val="phClr"><a:shade val="20000"/><a:satMod val="255000"/></a:schemeClr></a:gs></a:gsLst><a:path path="circle"><a:fillToRect l="50000" t="-80000" r="50000" b="180000"/></a:path></a:gradFill><a:gradFill rotWithShape="1"><a:gsLst><a:gs pos="0"><a:schemeClr val="phClr"><a:tint val="80000"/><a:satMod val="300000"/></a:schemeClr></a:gs><a:gs pos="100000"><a:schemeClr val="phClr"><a:shade val="30000"/><a:satMod val="200000"/></a:schemeClr></a:gs></a:gsLst><a:path path="circle"><a:fillToRect l="50000" t="50000" r="50000" b="50000"/></a:path></a:gradFill></a:bgFillStyleLst></a:fmtScheme></a:themeElements><a:objectDefaults/><a:extraClrSchemeLst/></a:theme>"""  # noqa

        self.fh.write(default_theme)

```

---

### File: `tmp\xlsxwriter_sdist\XlsxWriter-3.2.0\xlsxwriter\utility.py`

```python
###############################################################################
#
# Worksheet - A class for writing Excel Worksheets.
#
# SPDX-License-Identifier: BSD-2-Clause
# Copyright 2013-2024, John McNamara, jmcnamara@cpan.org
#
import datetime
import hashlib
import os
import re
from struct import unpack
from warnings import warn
from .exceptions import UndefinedImageSize
from .exceptions import UnsupportedImageFormat

COL_NAMES = {}

CHAR_WIDTHS = {
    " ": 3,
    "!": 5,
    '"': 6,
    "#": 7,
    "$": 7,
    "%": 11,
    "&": 10,
    "'": 3,
    "(": 5,
    ")": 5,
    "*": 7,
    "+": 7,
    ",": 4,
    "-": 5,
    ".": 4,
    "/": 6,
    "0": 7,
    "1": 7,
    "2": 7,
    "3": 7,
    "4": 7,
    "5": 7,
    "6": 7,
    "7": 7,
    "8": 7,
    "9": 7,
    ":": 4,
    ";": 4,
    "<": 7,
    "=": 7,
    ">": 7,
    "?": 7,
    "@": 13,
    "A": 9,
    "B": 8,
    "C": 8,
    "D": 9,
    "E": 7,
    "F": 7,
    "G": 9,
    "H": 9,
    "I": 4,
    "J": 5,
    "K": 8,
    "L": 6,
    "M": 12,
    "N": 10,
    "O": 10,
    "P": 8,
    "Q": 10,
    "R": 8,
    "S": 7,
    "T": 7,
    "U": 9,
    "V": 9,
    "W": 13,
    "X": 8,
    "Y": 7,
    "Z": 7,
    "[": 5,
    "\\": 6,
    "]": 5,
    "^": 7,
    "_": 7,
    "`": 4,
    "a": 7,
    "b": 8,
    "c": 6,
    "d": 8,
    "e": 8,
    "f": 5,
    "g": 7,
    "h": 8,
    "i": 4,
    "j": 4,
    "k": 7,
    "l": 4,
    "m": 12,
    "n": 8,
    "o": 8,
    "p": 8,
    "q": 8,
    "r": 5,
    "s": 6,
    "t": 5,
    "u": 8,
    "v": 7,
    "w": 11,
    "x": 7,
    "y": 7,
    "z": 6,
    "{": 5,
    "|": 7,
    "}": 5,
    "~": 7,
}

# Compile performance critical regular expressions.
re_leading = re.compile(r"^\s")
re_trailing = re.compile(r"\s$")
re_range_parts = re.compile(r"(\$?)([A-Z]{1,3})(\$?)(\d+)")


def xl_rowcol_to_cell(row, col, row_abs=False, col_abs=False):
    """
    Convert a zero indexed row and column cell reference to a A1 style string.

    Args:
       row:     The cell row.    Int.
       col:     The cell column. Int.
       row_abs: Optional flag to make the row absolute.    Bool.
       col_abs: Optional flag to make the column absolute. Bool.

    Returns:
        A1 style string.

    """
    if row < 0:
        warn("Row number %d must be >= 0" % row)
        return None

    if col < 0:
        warn("Col number %d must be >= 0" % col)
        return None

    row += 1  # Change to 1-index.
    row_abs = "$" if row_abs else ""

    col_str = xl_col_to_name(col, col_abs)

    return col_str + row_abs + str(row)


def xl_rowcol_to_cell_fast(row, col):
    """
    Optimized version of the xl_rowcol_to_cell function. Only used internally.

    Args:
       row: The cell row.    Int.
       col: The cell column. Int.

    Returns:
        A1 style string.

    """
    if col in COL_NAMES:
        col_str = COL_NAMES[col]
    else:
        col_str = xl_col_to_name(col)
        COL_NAMES[col] = col_str

    return col_str + str(row + 1)


def xl_col_to_name(col, col_abs=False):
    """
    Convert a zero indexed column cell reference to a string.

    Args:
       col:     The cell column. Int.
       col_abs: Optional flag to make the column absolute. Bool.

    Returns:
        Column style string.

    """
    col_num = col
    if col_num < 0:
        warn("Col number %d must be >= 0" % col_num)
        return None

    col_num += 1  # Change to 1-index.
    col_str = ""
    col_abs = "$" if col_abs else ""

    while col_num:
        # Set remainder from 1 .. 26
        remainder = col_num % 26

        if remainder == 0:
            remainder = 26

        # Convert the remainder to a character.
        col_letter = chr(ord("A") + remainder - 1)

        # Accumulate the column letters, right to left.
        col_str = col_letter + col_str

        # Get the next order of magnitude.
        col_num = int((col_num - 1) / 26)

    return col_abs + col_str


def xl_cell_to_rowcol(cell_str):
    """
    Convert a cell reference in A1 notation to a zero indexed row and column.

    Args:
       cell_str:  A1 style string.

    Returns:
        row, col: Zero indexed cell row and column indices.

    """
    if not cell_str:
        return 0, 0

    match = re_range_parts.match(cell_str)
    col_str = match.group(2)
    row_str = match.group(4)

    # Convert base26 column string to number.
    expn = 0
    col = 0
    for char in reversed(col_str):
        col += (ord(char) - ord("A") + 1) * (26**expn)
        expn += 1

    # Convert 1-index to zero-index
    row = int(row_str) - 1
    col -= 1

    return row, col


def xl_cell_to_rowcol_abs(cell_str):
    """
    Convert an absolute cell reference in A1 notation to a zero indexed
    row and column, with True/False values for absolute rows or columns.

    Args:
       cell_str: A1 style string.

    Returns:
        row, col, row_abs, col_abs:  Zero indexed cell row and column indices.

    """
    if not cell_str:
        return 0, 0, False, False

    match = re_range_parts.match(cell_str)

    col_abs = match.group(1)
    col_str = match.group(2)
    row_abs = match.group(3)
    row_str = match.group(4)

    if col_abs:
        col_abs = True
    else:
        col_abs = False

    if row_abs:
        row_abs = True
    else:
        row_abs = False

    # Convert base26 column string to number.
    expn = 0
    col = 0
    for char in reversed(col_str):
        col += (ord(char) - ord("A") + 1) * (26**expn)
        expn += 1

    # Convert 1-index to zero-index
    row = int(row_str) - 1
    col -= 1

    return row, col, row_abs, col_abs


def xl_range(first_row, first_col, last_row, last_col):
    """
    Convert zero indexed row and col cell references to a A1:B1 range string.

    Args:
       first_row: The first cell row.    Int.
       first_col: The first cell column. Int.
       last_row:  The last cell row.     Int.
       last_col:  The last cell column.  Int.

    Returns:
        A1:B1 style range string.

    """
    range1 = xl_rowcol_to_cell(first_row, first_col)
    range2 = xl_rowcol_to_cell(last_row, last_col)

    if range1 is None or range2 is None:
        warn("Row and column numbers must be >= 0")
        return None

    if range1 == range2:
        return range1
    else:
        return range1 + ":" + range2


def xl_range_abs(first_row, first_col, last_row, last_col):
    """
    Convert zero indexed row and col cell references to a $A$1:$B$1 absolute
    range string.

    Args:
       first_row: The first cell row.    Int.
       first_col: The first cell column. Int.
       last_row:  The last cell row.     Int.
       last_col:  The last cell column.  Int.

    Returns:
        $A$1:$B$1 style range string.

    """
    range1 = xl_rowcol_to_cell(first_row, first_col, True, True)
    range2 = xl_rowcol_to_cell(last_row, last_col, True, True)

    if range1 is None or range2 is None:
        warn("Row and column numbers must be >= 0")
        return None

    if range1 == range2:
        return range1
    else:
        return range1 + ":" + range2


def xl_range_formula(sheetname, first_row, first_col, last_row, last_col):
    """
    Convert worksheet name and zero indexed row and col cell references to
    a Sheet1!A1:B1 range formula string.

    Args:
       sheetname: The worksheet name.    String.
       first_row: The first cell row.    Int.
       first_col: The first cell column. Int.
       last_row:  The last cell row.     Int.
       last_col:  The last cell column.  Int.

    Returns:
        A1:B1 style range string.

    """
    cell_range = xl_range_abs(first_row, first_col, last_row, last_col)
    sheetname = quote_sheetname(sheetname)

    return sheetname + "!" + cell_range


def quote_sheetname(sheetname):
    """
    Convert a worksheet name to a quoted  name if it contains spaces or
    special characters.

    Args:
       sheetname: The worksheet name. String.

    Returns:
        A quoted worksheet string.

    """

    if not sheetname.isalnum() and not sheetname.startswith("'"):
        # Double quote any single quotes.
        sheetname = sheetname.replace("'", "''")

        # Single quote the sheet name.
        sheetname = "'%s'" % sheetname

    return sheetname


def xl_pixel_width(string):
    """
    Get the pixel width of a string based on individual character widths taken
    from Excel. UTF8 characters, and other unhandled characters, are given a
    default width of 8.

    Args:
       string: The string to calculate the width for. String.

    Returns:
        The string width in pixels. Note, Excel adds an additional 7 pixels of
        padding in the cell.

    """
    length = 0
    for char in string:
        length += CHAR_WIDTHS.get(char, 8)

    return length


def xl_color(color):
    # Used in conjunction with the XlsxWriter *color() methods to convert
    # a color name into an RGB formatted string. These colors are for
    # backward compatibility with older versions of Excel.
    named_colors = {
        "black": "#000000",
        "blue": "#0000FF",
        "brown": "#800000",
        "cyan": "#00FFFF",
        "gray": "#808080",
        "green": "#008000",
        "lime": "#00FF00",
        "magenta": "#FF00FF",
        "navy": "#000080",
        "orange": "#FF6600",
        "pink": "#FF00FF",
        "purple": "#800080",
        "red": "#FF0000",
        "silver": "#C0C0C0",
        "white": "#FFFFFF",
        "yellow": "#FFFF00",
    }

    if color in named_colors:
        color = named_colors[color]

    if not re.match("#[0-9a-fA-F]{6}", color):
        warn("Color '%s' isn't a valid Excel color" % color)

    # Convert the RGB color to the Excel ARGB format.
    return "FF" + color.lstrip("#").upper()


def get_rgb_color(color):
    # Convert the user specified color to an RGB color.
    rgb_color = xl_color(color)

    # Remove leading FF from RGB color for charts.
    rgb_color = re.sub(r"^FF", "", rgb_color)

    return rgb_color


def get_sparkline_style(style_id):
    styles = [
        {
            "series": {"theme": "4", "tint": "-0.499984740745262"},
            "negative": {"theme": "5"},
            "markers": {"theme": "4", "tint": "-0.499984740745262"},
            "first": {"theme": "4", "tint": "0.39997558519241921"},
            "last": {"theme": "4", "tint": "0.39997558519241921"},
            "high": {"theme": "4"},
            "low": {"theme": "4"},
        },  # 0
        {
            "series": {"theme": "4", "tint": "-0.499984740745262"},
            "negative": {"theme": "5"},
            "markers": {"theme": "4", "tint": "-0.499984740745262"},
            "first": {"theme": "4", "tint": "0.39997558519241921"},
            "last": {"theme": "4", "tint": "0.39997558519241921"},
            "high": {"theme": "4"},
            "low": {"theme": "4"},
        },  # 1
        {
            "series": {"theme": "5", "tint": "-0.499984740745262"},
            "negative": {"theme": "6"},
            "markers": {"theme": "5", "tint": "-0.499984740745262"},
            "first": {"theme": "5", "tint": "0.39997558519241921"},
            "last": {"theme": "5", "tint": "0.39997558519241921"},
            "high": {"theme": "5"},
            "low": {"theme": "5"},
        },  # 2
        {
            "series": {"theme": "6", "tint": "-0.499984740745262"},
            "negative": {"theme": "7"},
            "markers": {"theme": "6", "tint": "-0.499984740745262"},
            "first": {"theme": "6", "tint": "0.39997558519241921"},
            "last": {"theme": "6", "tint": "0.39997558519241921"},
            "high": {"theme": "6"},
            "low": {"theme": "6"},
        },  # 3
        {
            "series": {"theme": "7", "tint": "-0.499984740745262"},
            "negative": {"theme": "8"},
            "markers": {"theme": "7", "tint": "-0.499984740745262"},
            "first": {"theme": "7", "tint": "0.39997558519241921"},
            "last": {"theme": "7", "tint": "0.39997558519241921"},
            "high": {"theme": "7"},
            "low": {"theme": "7"},
        },  # 4
        {
            "series": {"theme": "8", "tint": "-0.499984740745262"},
            "negative": {"theme": "9"},
            "markers": {"theme": "8", "tint": "-0.499984740745262"},
            "first": {"theme": "8", "tint": "0.39997558519241921"},
            "last": {"theme": "8", "tint": "0.39997558519241921"},
            "high": {"theme": "8"},
            "low": {"theme": "8"},
        },  # 5
        {
            "series": {"theme": "9", "tint": "-0.499984740745262"},
            "negative": {"theme": "4"},
            "markers": {"theme": "9", "tint": "-0.499984740745262"},
            "first": {"theme": "9", "tint": "0.39997558519241921"},
            "last": {"theme": "9", "tint": "0.39997558519241921"},
            "high": {"theme": "9"},
            "low": {"theme": "9"},
        },  # 6
        {
            "series": {"theme": "4", "tint": "-0.249977111117893"},
            "negative": {"theme": "5"},
            "markers": {"theme": "5", "tint": "-0.249977111117893"},
            "first": {"theme": "5", "tint": "-0.249977111117893"},
            "last": {"theme": "5", "tint": "-0.249977111117893"},
            "high": {"theme": "5", "tint": "-0.249977111117893"},
            "low": {"theme": "5", "tint": "-0.249977111117893"},
        },  # 7
        {
            "series": {"theme": "5", "tint": "-0.249977111117893"},
            "negative": {"theme": "6"},
            "markers": {"theme": "6", "tint": "-0.249977111117893"},
            "first": {"theme": "6", "tint": "-0.249977111117893"},
            "last": {"theme": "6", "tint": "-0.249977111117893"},
            "high": {"theme": "6", "tint": "-0.249977111117893"},
            "low": {"theme": "6", "tint": "-0.249977111117893"},
        },  # 8
        {
            "series": {"theme": "6", "tint": "-0.249977111117893"},
            "negative": {"theme": "7"},
            "markers": {"theme": "7", "tint": "-0.249977111117893"},
            "first": {"theme": "7", "tint": "-0.249977111117893"},
            "last": {"theme": "7", "tint": "-0.249977111117893"},
            "high": {"theme": "7", "tint": "-0.249977111117893"},
            "low": {"theme": "7", "tint": "-0.249977111117893"},
        },  # 9
        {
            "series": {"theme": "7", "tint": "-0.249977111117893"},
            "negative": {"theme": "8"},
            "markers": {"theme": "8", "tint": "-0.249977111117893"},
            "first": {"theme": "8", "tint": "-0.249977111117893"},
            "last": {"theme": "8", "tint": "-0.249977111117893"},
            "high": {"theme": "8", "tint": "-0.249977111117893"},
            "low": {"theme": "8", "tint": "-0.249977111117893"},
        },  # 10
        {
            "series": {"theme": "8", "tint": "-0.249977111117893"},
            "negative": {"theme": "9"},
            "markers": {"theme": "9", "tint": "-0.249977111117893"},
            "first": {"theme": "9", "tint": "-0.249977111117893"},
            "last": {"theme": "9", "tint": "-0.249977111117893"},
            "high": {"theme": "9", "tint": "-0.249977111117893"},
            "low": {"theme": "9", "tint": "-0.249977111117893"},
        },  # 11
        {
            "series": {"theme": "9", "tint": "-0.249977111117893"},
            "negative": {"theme": "4"},
            "markers": {"theme": "4", "tint": "-0.249977111117893"},
            "first": {"theme": "4", "tint": "-0.249977111117893"},
            "last": {"theme": "4", "tint": "-0.249977111117893"},
            "high": {"theme": "4", "tint": "-0.249977111117893"},
            "low": {"theme": "4", "tint": "-0.249977111117893"},
        },  # 12
        {
            "series": {"theme": "4"},
            "negative": {"theme": "5"},
            "markers": {"theme": "4", "tint": "-0.249977111117893"},
            "first": {"theme": "4", "tint": "-0.249977111117893"},
            "last": {"theme": "4", "tint": "-0.249977111117893"},
            "high": {"theme": "4", "tint": "-0.249977111117893"},
            "low": {"theme": "4", "tint": "-0.249977111117893"},
        },  # 13
        {
            "series": {"theme": "5"},
            "negative": {"theme": "6"},
            "markers": {"theme": "5", "tint": "-0.249977111117893"},
            "first": {"theme": "5", "tint": "-0.249977111117893"},
            "last": {"theme": "5", "tint": "-0.249977111117893"},
            "high": {"theme": "5", "tint": "-0.249977111117893"},
            "low": {"theme": "5", "tint": "-0.249977111117893"},
        },  # 14
        {
            "series": {"theme": "6"},
            "negative": {"theme": "7"},
            "markers": {"theme": "6", "tint": "-0.249977111117893"},
            "first": {"theme": "6", "tint": "-0.249977111117893"},
            "last": {"theme": "6", "tint": "-0.249977111117893"},
            "high": {"theme": "6", "tint": "-0.249977111117893"},
            "low": {"theme": "6", "tint": "-0.249977111117893"},
        },  # 15
        {
            "series": {"theme": "7"},
            "negative": {"theme": "8"},
            "markers": {"theme": "7", "tint": "-0.249977111117893"},
            "first": {"theme": "7", "tint": "-0.249977111117893"},
            "last": {"theme": "7", "tint": "-0.249977111117893"},
            "high": {"theme": "7", "tint": "-0.249977111117893"},
            "low": {"theme": "7", "tint": "-0.249977111117893"},
        },  # 16
        {
            "series": {"theme": "8"},
            "negative": {"theme": "9"},
            "markers": {"theme": "8", "tint": "-0.249977111117893"},
            "first": {"theme": "8", "tint": "-0.249977111117893"},
            "last": {"theme": "8", "tint": "-0.249977111117893"},
            "high": {"theme": "8", "tint": "-0.249977111117893"},
            "low": {"theme": "8", "tint": "-0.249977111117893"},
        },  # 17
        {
            "series": {"theme": "9"},
            "negative": {"theme": "4"},
            "markers": {"theme": "9", "tint": "-0.249977111117893"},
            "first": {"theme": "9", "tint": "-0.249977111117893"},
            "last": {"theme": "9", "tint": "-0.249977111117893"},
            "high": {"theme": "9", "tint": "-0.249977111117893"},
            "low": {"theme": "9", "tint": "-0.249977111117893"},
        },  # 18
        {
            "series": {"theme": "4", "tint": "0.39997558519241921"},
            "negative": {"theme": "0", "tint": "-0.499984740745262"},
            "markers": {"theme": "4", "tint": "0.79998168889431442"},
            "first": {"theme": "4", "tint": "-0.249977111117893"},
            "last": {"theme": "4", "tint": "-0.249977111117893"},
            "high": {"theme": "4", "tint": "-0.499984740745262"},
            "low": {"theme": "4", "tint": "-0.499984740745262"},
        },  # 19
        {
            "series": {"theme": "5", "tint": "0.39997558519241921"},
            "negative": {"theme": "0", "tint": "-0.499984740745262"},
            "markers": {"theme": "5", "tint": "0.79998168889431442"},
            "first": {"theme": "5", "tint": "-0.249977111117893"},
            "last": {"theme": "5", "tint": "-0.249977111117893"},
            "high": {"theme": "5", "tint": "-0.499984740745262"},
            "low": {"theme": "5", "tint": "-0.499984740745262"},
        },  # 20
        {
            "series": {"theme": "6", "tint": "0.39997558519241921"},
            "negative": {"theme": "0", "tint": "-0.499984740745262"},
            "markers": {"theme": "6", "tint": "0.79998168889431442"},
            "first": {"theme": "6", "tint": "-0.249977111117893"},
            "last": {"theme": "6", "tint": "-0.249977111117893"},
            "high": {"theme": "6", "tint": "-0.499984740745262"},
            "low": {"theme": "6", "tint": "-0.499984740745262"},
        },  # 21
        {
            "series": {"theme": "7", "tint": "0.39997558519241921"},
            "negative": {"theme": "0", "tint": "-0.499984740745262"},
            "markers": {"theme": "7", "tint": "0.79998168889431442"},
            "first": {"theme": "7", "tint": "-0.249977111117893"},
            "last": {"theme": "7", "tint": "-0.249977111117893"},
            "high": {"theme": "7", "tint": "-0.499984740745262"},
            "low": {"theme": "7", "tint": "-0.499984740745262"},
        },  # 22
        {
            "series": {"theme": "8", "tint": "0.39997558519241921"},
            "negative": {"theme": "0", "tint": "-0.499984740745262"},
            "markers": {"theme": "8", "tint": "0.79998168889431442"},
            "first": {"theme": "8", "tint": "-0.249977111117893"},
            "last": {"theme": "8", "tint": "-0.249977111117893"},
            "high": {"theme": "8", "tint": "-0.499984740745262"},
            "low": {"theme": "8", "tint": "-0.499984740745262"},
        },  # 23
        {
            "series": {"theme": "9", "tint": "0.39997558519241921"},
            "negative": {"theme": "0", "tint": "-0.499984740745262"},
            "markers": {"theme": "9", "tint": "0.79998168889431442"},
            "first": {"theme": "9", "tint": "-0.249977111117893"},
            "last": {"theme": "9", "tint": "-0.249977111117893"},
            "high": {"theme": "9", "tint": "-0.499984740745262"},
            "low": {"theme": "9", "tint": "-0.499984740745262"},
        },  # 24
        {
            "series": {"theme": "1", "tint": "0.499984740745262"},
            "negative": {"theme": "1", "tint": "0.249977111117893"},
            "markers": {"theme": "1", "tint": "0.249977111117893"},
            "first": {"theme": "1", "tint": "0.249977111117893"},
            "last": {"theme": "1", "tint": "0.249977111117893"},
            "high": {"theme": "1", "tint": "0.249977111117893"},
            "low": {"theme": "1", "tint": "0.249977111117893"},
        },  # 25
        {
            "series": {"theme": "1", "tint": "0.34998626667073579"},
            "negative": {"theme": "0", "tint": "-0.249977111117893"},
            "markers": {"theme": "0", "tint": "-0.249977111117893"},
            "first": {"theme": "0", "tint": "-0.249977111117893"},
            "last": {"theme": "0", "tint": "-0.249977111117893"},
            "high": {"theme": "0", "tint": "-0.249977111117893"},
            "low": {"theme": "0", "tint": "-0.249977111117893"},
        },  # 26
        {
            "series": {"rgb": "FF323232"},
            "negative": {"rgb": "FFD00000"},
            "markers": {"rgb": "FFD00000"},
            "first": {"rgb": "FFD00000"},
            "last": {"rgb": "FFD00000"},
            "high": {"rgb": "FFD00000"},
            "low": {"rgb": "FFD00000"},
        },  # 27
        {
            "series": {"rgb": "FF000000"},
            "negative": {"rgb": "FF0070C0"},
            "markers": {"rgb": "FF0070C0"},
            "first": {"rgb": "FF0070C0"},
            "last": {"rgb": "FF0070C0"},
            "high": {"rgb": "FF0070C0"},
            "low": {"rgb": "FF0070C0"},
        },  # 28
        {
            "series": {"rgb": "FF376092"},
            "negative": {"rgb": "FFD00000"},
            "markers": {"rgb": "FFD00000"},
            "first": {"rgb": "FFD00000"},
            "last": {"rgb": "FFD00000"},
            "high": {"rgb": "FFD00000"},
            "low": {"rgb": "FFD00000"},
        },  # 29
        {
            "series": {"rgb": "FF0070C0"},
            "negative": {"rgb": "FF000000"},
            "markers": {"rgb": "FF000000"},
            "first": {"rgb": "FF000000"},
            "last": {"rgb": "FF000000"},
            "high": {"rgb": "FF000000"},
            "low": {"rgb": "FF000000"},
        },  # 30
        {
            "series": {"rgb": "FF5F5F5F"},
            "negative": {"rgb": "FFFFB620"},
            "markers": {"rgb": "FFD70077"},
            "first": {"rgb": "FF5687C2"},
            "last": {"rgb": "FF359CEB"},
            "high": {"rgb": "FF56BE79"},
            "low": {"rgb": "FFFF5055"},
        },  # 31
        {
            "series": {"rgb": "FF5687C2"},
            "negative": {"rgb": "FFFFB620"},
            "markers": {"rgb": "FFD70077"},
            "first": {"rgb": "FF777777"},
            "last": {"rgb": "FF359CEB"},
            "high": {"rgb": "FF56BE79"},
            "low": {"rgb": "FFFF5055"},
        },  # 32
        {
            "series": {"rgb": "FFC6EFCE"},
            "negative": {"rgb": "FFFFC7CE"},
            "markers": {"rgb": "FF8CADD6"},
            "first": {"rgb": "FFFFDC47"},
            "last": {"rgb": "FFFFEB9C"},
            "high": {"rgb": "FF60D276"},
            "low": {"rgb": "FFFF5367"},
        },  # 33
        {
            "series": {"rgb": "FF00B050"},
            "negative": {"rgb": "FFFF0000"},
            "markers": {"rgb": "FF0070C0"},
            "first": {"rgb": "FFFFC000"},
            "last": {"rgb": "FFFFC000"},
            "high": {"rgb": "FF00B050"},
            "low": {"rgb": "FFFF0000"},
        },  # 34
        {
            "series": {"theme": "3"},
            "negative": {"theme": "9"},
            "markers": {"theme": "8"},
            "first": {"theme": "4"},
            "last": {"theme": "5"},
            "high": {"theme": "6"},
            "low": {"theme": "7"},
        },  # 35
        {
            "series": {"theme": "1"},
            "negative": {"theme": "9"},
            "markers": {"theme": "8"},
            "first": {"theme": "4"},
            "last": {"theme": "5"},
            "high": {"theme": "6"},
            "low": {"theme": "7"},
        },  # 36
    ]

    return styles[style_id]


def supported_datetime(dt):
    # Determine is an argument is a supported datetime object.
    return isinstance(
        dt, (datetime.datetime, datetime.date, datetime.time, datetime.timedelta)
    )


def remove_datetime_timezone(dt_obj, remove_timezone):
    # Excel doesn't support timezones in datetimes/times so we remove the
    # tzinfo from the object if the user has specified that option in the
    # constructor.
    if remove_timezone:
        dt_obj = dt_obj.replace(tzinfo=None)
    else:
        if dt_obj.tzinfo:
            raise TypeError(
                "Excel doesn't support timezones in datetimes. "
                "Set the tzinfo in the datetime/time object to None or "
                "use the 'remove_timezone' Workbook() option"
            )

    return dt_obj


def datetime_to_excel_datetime(dt_obj, date_1904, remove_timezone):
    # Convert a datetime object to an Excel serial date and time. The integer
    # part of the number stores the number of days since the epoch and the
    # fractional part stores the percentage of the day.
    date_type = dt_obj
    is_timedelta = False

    if date_1904:
        # Excel for Mac date epoch.
        epoch = datetime.datetime(1904, 1, 1)
    else:
        # Default Excel epoch.
        epoch = datetime.datetime(1899, 12, 31)

    # We handle datetime .datetime, .date and .time objects but convert
    # them to datetime.datetime objects and process them in the same way.
    if isinstance(dt_obj, datetime.datetime):
        dt_obj = remove_datetime_timezone(dt_obj, remove_timezone)
        delta = dt_obj - epoch
    elif isinstance(dt_obj, datetime.date):
        dt_obj = datetime.datetime.fromordinal(dt_obj.toordinal())
        delta = dt_obj - epoch
    elif isinstance(dt_obj, datetime.time):
        dt_obj = datetime.datetime.combine(epoch, dt_obj)
        dt_obj = remove_datetime_timezone(dt_obj, remove_timezone)
        delta = dt_obj - epoch
    elif isinstance(dt_obj, datetime.timedelta):
        is_timedelta = True
        delta = dt_obj
    else:
        raise TypeError("Unknown or unsupported datetime type")

    # Convert a Python datetime.datetime value to an Excel date number.
    excel_time = delta.days + (
        float(delta.seconds) + float(delta.microseconds) / 1e6
    ) / (60 * 60 * 24)

    # The following is a workaround for the fact that in Excel a time only
    # value is represented as 1899-12-31+time whereas in datetime.datetime()
    # it is 1900-1-1+time so we need to subtract the 1 day difference.
    if isinstance(date_type, datetime.datetime) and dt_obj.isocalendar() == (
        1900,
        1,
        1,
    ):
        excel_time -= 1

    # Account for Excel erroneously treating 1900 as a leap year.
    if not date_1904 and not is_timedelta and excel_time > 59:
        excel_time += 1

    return excel_time


def preserve_whitespace(string):
    # Check if a string has leading or trailing whitespace that requires a
    # "preserve" attribute.
    if re_leading.search(string) or re_trailing.search(string):
        return True
    else:
        return False


def get_image_properties(filename, image_data):
    # Extract dimension information from the image file.
    height = 0
    width = 0
    x_dpi = 96
    y_dpi = 96

    if not image_data:
        # Open the image file and read in the data.
        fh = open(filename, "rb")
        data = fh.read()
    else:
        # Read the image data from the user supplied byte stream.
        data = image_data.getvalue()

    digest = hashlib.sha256(data).hexdigest()

    # Get the image filename without the path.
    image_name = os.path.basename(filename)

    # Look for some common image file markers.
    marker1 = unpack("3s", data[1:4])[0]
    marker2 = unpack(">H", data[:2])[0]
    marker3 = unpack("2s", data[:2])[0]
    marker4 = unpack("<L", data[:4])[0]
    marker5 = (unpack("4s", data[40:44]))[0]
    marker6 = unpack("4s", data[:4])[0]

    png_marker = b"PNG"
    bmp_marker = b"BM"
    emf_marker = b" EMF"
    gif_marker = b"GIF8"

    if marker1 == png_marker:
        (image_type, width, height, x_dpi, y_dpi) = _process_png(data)

    elif marker2 == 0xFFD8:
        (image_type, width, height, x_dpi, y_dpi) = _process_jpg(data)

    elif marker3 == bmp_marker:
        (image_type, width, height) = _process_bmp(data)

    elif marker4 == 0x9AC6CDD7:
        (image_type, width, height, x_dpi, y_dpi) = _process_wmf(data)

    elif marker4 == 1 and marker5 == emf_marker:
        (image_type, width, height, x_dpi, y_dpi) = _process_emf(data)

    elif marker6 == gif_marker:
        (image_type, width, height, x_dpi, y_dpi) = _process_gif(data)

    else:
        raise UnsupportedImageFormat(
            "%s: Unknown or unsupported image file format." % filename
        )

    # Check that we found the required data.
    if not height or not width:
        raise UndefinedImageSize("%s: no size data found in image file." % filename)

    if not image_data:
        fh.close()

    # Set a default dpi for images with 0 dpi.
    if x_dpi == 0:
        x_dpi = 96
    if y_dpi == 0:
        y_dpi = 96

    return image_type, width, height, image_name, x_dpi, y_dpi, digest


def _process_png(data):
    # Extract width and height information from a PNG file.
    offset = 8
    data_length = len(data)
    end_marker = False
    width = 0
    height = 0
    x_dpi = 96
    y_dpi = 96

    # Search through the image data to read the height and width in the
    # IHDR element. Also read the DPI in the pHYs element.
    while not end_marker and offset < data_length:
        length = unpack(">I", data[offset + 0 : offset + 4])[0]
        marker = unpack("4s", data[offset + 4 : offset + 8])[0]

        # Read the image dimensions.
        if marker == b"IHDR":
            width = unpack(">I", data[offset + 8 : offset + 12])[0]
            height = unpack(">I", data[offset + 12 : offset + 16])[0]

        # Read the image DPI.
        if marker == b"pHYs":
            x_density = unpack(">I", data[offset + 8 : offset + 12])[0]
            y_density = unpack(">I", data[offset + 12 : offset + 16])[0]
            units = unpack("b", data[offset + 16 : offset + 17])[0]

            if units == 1:
                x_dpi = x_density * 0.0254
                y_dpi = y_density * 0.0254

        if marker == b"IEND":
            end_marker = True
            continue

        offset = offset + length + 12

    return "png", width, height, x_dpi, y_dpi


def _process_jpg(data):
    # Extract width and height information from a JPEG file.
    offset = 2
    data_length = len(data)
    end_marker = False
    width = 0
    height = 0
    x_dpi = 96
    y_dpi = 96

    # Search through the image data to read the JPEG markers.
    while not end_marker and offset < data_length:
        marker = unpack(">H", data[offset + 0 : offset + 2])[0]
        length = unpack(">H", data[offset + 2 : offset + 4])[0]

        # Read the height and width in the 0xFFCn elements (except C4, C8
        # and CC which aren't SOF markers).
        if (
            (marker & 0xFFF0) == 0xFFC0
            and marker != 0xFFC4
            and marker != 0xFFC8
            and marker != 0xFFCC
        ):
            height = unpack(">H", data[offset + 5 : offset + 7])[0]
            width = unpack(">H", data[offset + 7 : offset + 9])[0]

        # Read the DPI in the 0xFFE0 element.
        if marker == 0xFFE0:
            units = unpack("b", data[offset + 11 : offset + 12])[0]
            x_density = unpack(">H", data[offset + 12 : offset + 14])[0]
            y_density = unpack(">H", data[offset + 14 : offset + 16])[0]

            if units == 1:
                x_dpi = x_density
                y_dpi = y_density

            if units == 2:
                x_dpi = x_density * 2.54
                y_dpi = y_density * 2.54

            # Workaround for incorrect dpi.
            if x_dpi == 1:
                x_dpi = 96
            if y_dpi == 1:
                y_dpi = 96

        if marker == 0xFFDA:
            end_marker = True
            continue

        offset = offset + length + 2

    return "jpeg", width, height, x_dpi, y_dpi


def _process_gif(data):
    # Extract width and height information from a GIF file.
    x_dpi = 96
    y_dpi = 96

    width = unpack("<h", data[6:8])[0]
    height = unpack("<h", data[8:10])[0]

    return "gif", width, height, x_dpi, y_dpi


def _process_bmp(data):
    # Extract width and height information from a BMP file.
    width = unpack("<L", data[18:22])[0]
    height = unpack("<L", data[22:26])[0]
    return "bmp", width, height


def _process_wmf(data):
    # Extract width and height information from a WMF file.
    x_dpi = 96
    y_dpi = 96

    # Read the bounding box, measured in logical units.
    x1 = unpack("<h", data[6:8])[0]
    y1 = unpack("<h", data[8:10])[0]
    x2 = unpack("<h", data[10:12])[0]
    y2 = unpack("<h", data[12:14])[0]

    # Read the number of logical units per inch. Used to scale the image.
    inch = unpack("<H", data[14:16])[0]

    # Convert to rendered height and width.
    width = float((x2 - x1) * x_dpi) / inch
    height = float((y2 - y1) * y_dpi) / inch

    return "wmf", width, height, x_dpi, y_dpi


def _process_emf(data):
    # Extract width and height information from a EMF file.

    # Read the bounding box, measured in logical units.
    bound_x1 = unpack("<l", data[8:12])[0]
    bound_y1 = unpack("<l", data[12:16])[0]
    bound_x2 = unpack("<l", data[16:20])[0]
    bound_y2 = unpack("<l", data[20:24])[0]

    # Convert the bounds to width and height.
    width = bound_x2 - bound_x1
    height = bound_y2 - bound_y1

    # Read the rectangular frame in units of 0.01mm.
    frame_x1 = unpack("<l", data[24:28])[0]
    frame_y1 = unpack("<l", data[28:32])[0]
    frame_x2 = unpack("<l", data[32:36])[0]
    frame_y2 = unpack("<l", data[36:40])[0]

    # Convert the frame bounds to mm width and height.
    width_mm = 0.01 * (frame_x2 - frame_x1)
    height_mm = 0.01 * (frame_y2 - frame_y1)

    # Get the dpi based on the logical size.
    x_dpi = width * 25.4 / width_mm
    y_dpi = height * 25.4 / height_mm

    # This is to match Excel's calculation. It is probably to account for
    # the fact that the bounding box is inclusive-inclusive. Or a bug.
    width += 1
    height += 1

    return "emf", width, height, x_dpi, y_dpi

```

---

### File: `tmp\xlsxwriter_sdist\XlsxWriter-3.2.0\xlsxwriter\vml.py`

```python
###############################################################################
#
# Vml - A class for writing the Excel XLSX Vml file.
#
# SPDX-License-Identifier: BSD-2-Clause
# Copyright 2013-2024, John McNamara, jmcnamara@cpan.org
#

# Package imports.
from . import xmlwriter


class Vml(xmlwriter.XMLwriter):
    """
    A class for writing the Excel XLSX Vml file.


    """

    ###########################################################################
    #
    # Public API.
    #
    ###########################################################################

    def __init__(self):
        """
        Constructor.

        """

        super(Vml, self).__init__()

    ###########################################################################
    #
    # Private API.
    #
    ###########################################################################
    def _assemble_xml_file(
        self,
        data_id,
        vml_shape_id,
        comments_data=None,
        buttons_data=None,
        header_images_data=None,
    ):
        # Assemble and write the XML file.
        z_index = 1

        self._write_xml_namespace()

        # Write the o:shapelayout element.
        self._write_shapelayout(data_id)

        if buttons_data:
            # Write the v:shapetype element.
            self._write_button_shapetype()

            for button in buttons_data:
                # Write the v:shape element.
                vml_shape_id += 1
                self._write_button_shape(vml_shape_id, z_index, button)
                z_index += 1

        if comments_data:
            # Write the v:shapetype element.
            self._write_comment_shapetype()

            for comment in comments_data:
                # Write the v:shape element.
                vml_shape_id += 1
                self._write_comment_shape(vml_shape_id, z_index, comment)
                z_index += 1

        if header_images_data:
            # Write the v:shapetype element.
            self._write_image_shapetype()

            index = 1
            for image in header_images_data:
                # Write the v:shape element.
                vml_shape_id += 1
                self._write_image_shape(vml_shape_id, index, image)
                index += 1

        self._xml_end_tag("xml")

        # Close the XML writer filehandle.
        self._xml_close()

    def _pixels_to_points(self, vertices):
        # Convert comment vertices from pixels to points.

        left, top, width, height = vertices[8:12]

        # Scale to pixels.
        left *= 0.75
        top *= 0.75
        width *= 0.75
        height *= 0.75

        return left, top, width, height

    ###########################################################################
    #
    # XML methods.
    #
    ###########################################################################
    def _write_xml_namespace(self):
        # Write the <xml> element. This is the root element of VML.
        schema = "urn:schemas-microsoft-com:"
        xmlns = schema + "vml"
        xmlns_o = schema + "office:office"
        xmlns_x = schema + "office:excel"

        attributes = [
            ("xmlns:v", xmlns),
            ("xmlns:o", xmlns_o),
            ("xmlns:x", xmlns_x),
        ]

        self._xml_start_tag("xml", attributes)

    def _write_shapelayout(self, data_id):
        # Write the <o:shapelayout> element.
        attributes = [("v:ext", "edit")]

        self._xml_start_tag("o:shapelayout", attributes)

        # Write the o:idmap element.
        self._write_idmap(data_id)

        self._xml_end_tag("o:shapelayout")

    def _write_idmap(self, data_id):
        # Write the <o:idmap> element.
        attributes = [
            ("v:ext", "edit"),
            ("data", data_id),
        ]

        self._xml_empty_tag("o:idmap", attributes)

    def _write_comment_shapetype(self):
        # Write the <v:shapetype> element.
        shape_id = "_x0000_t202"
        coordsize = "21600,21600"
        spt = 202
        path = "m,l,21600r21600,l21600,xe"

        attributes = [
            ("id", shape_id),
            ("coordsize", coordsize),
            ("o:spt", spt),
            ("path", path),
        ]

        self._xml_start_tag("v:shapetype", attributes)

        # Write the v:stroke element.
        self._write_stroke()

        # Write the v:path element.
        self._write_comment_path("t", "rect")

        self._xml_end_tag("v:shapetype")

    def _write_button_shapetype(self):
        # Write the <v:shapetype> element.
        shape_id = "_x0000_t201"
        coordsize = "21600,21600"
        spt = 201
        path = "m,l,21600r21600,l21600,xe"

        attributes = [
            ("id", shape_id),
            ("coordsize", coordsize),
            ("o:spt", spt),
            ("path", path),
        ]

        self._xml_start_tag("v:shapetype", attributes)

        # Write the v:stroke element.
        self._write_stroke()

        # Write the v:path element.
        self._write_button_path()

        # Write the o:lock element.
        self._write_shapetype_lock()

        self._xml_end_tag("v:shapetype")

    def _write_image_shapetype(self):
        # Write the <v:shapetype> element.
        shape_id = "_x0000_t75"
        coordsize = "21600,21600"
        spt = 75
        o_preferrelative = "t"
        path = "m@4@5l@4@11@9@11@9@5xe"
        filled = "f"
        stroked = "f"

        attributes = [
            ("id", shape_id),
            ("coordsize", coordsize),
            ("o:spt", spt),
            ("o:preferrelative", o_preferrelative),
            ("path", path),
            ("filled", filled),
            ("stroked", stroked),
        ]

        self._xml_start_tag("v:shapetype", attributes)

        # Write the v:stroke element.
        self._write_stroke()

        # Write the v:formulas element.
        self._write_formulas()

        # Write the v:path element.
        self._write_image_path()

        # Write the o:lock element.
        self._write_aspect_ratio_lock()

        self._xml_end_tag("v:shapetype")

    def _write_stroke(self):
        # Write the <v:stroke> element.
        joinstyle = "miter"

        attributes = [("joinstyle", joinstyle)]

        self._xml_empty_tag("v:stroke", attributes)

    def _write_comment_path(self, gradientshapeok, connecttype):
        # Write the <v:path> element.
        attributes = []

        if gradientshapeok:
            attributes.append(("gradientshapeok", "t"))

        attributes.append(("o:connecttype", connecttype))

        self._xml_empty_tag("v:path", attributes)

    def _write_button_path(self):
        # Write the <v:path> element.
        shadowok = "f"
        extrusionok = "f"
        strokeok = "f"
        fillok = "f"
        connecttype = "rect"

        attributes = [
            ("shadowok", shadowok),
            ("o:extrusionok", extrusionok),
            ("strokeok", strokeok),
            ("fillok", fillok),
            ("o:connecttype", connecttype),
        ]

        self._xml_empty_tag("v:path", attributes)

    def _write_image_path(self):
        # Write the <v:path> element.
        extrusionok = "f"
        gradientshapeok = "t"
        connecttype = "rect"

        attributes = [
            ("o:extrusionok", extrusionok),
            ("gradientshapeok", gradientshapeok),
            ("o:connecttype", connecttype),
        ]

        self._xml_empty_tag("v:path", attributes)

    def _write_shapetype_lock(self):
        # Write the <o:lock> element.
        ext = "edit"
        shapetype = "t"

        attributes = [
            ("v:ext", ext),
            ("shapetype", shapetype),
        ]

        self._xml_empty_tag("o:lock", attributes)

    def _write_rotation_lock(self):
        # Write the <o:lock> element.
        ext = "edit"
        rotation = "t"

        attributes = [
            ("v:ext", ext),
            ("rotation", rotation),
        ]

        self._xml_empty_tag("o:lock", attributes)

    def _write_aspect_ratio_lock(self):
        # Write the <o:lock> element.
        ext = "edit"
        aspectratio = "t"

        attributes = [
            ("v:ext", ext),
            ("aspectratio", aspectratio),
        ]

        self._xml_empty_tag("o:lock", attributes)

    def _write_comment_shape(self, shape_id, z_index, comment):
        # Write the <v:shape> element.
        shape_type = "#_x0000_t202"
        insetmode = "auto"
        visibility = "hidden"

        # Set the shape index.
        shape_id = "_x0000_s" + str(shape_id)

        # Get the comment parameters
        row = comment[0]
        col = comment[1]
        visible = comment[4]
        fillcolor = comment[5]
        vertices = comment[9]

        (left, top, width, height) = self._pixels_to_points(vertices)

        # Set the visibility.
        if visible:
            visibility = "visible"

        style = (
            "position:absolute;"
            "margin-left:%.15gpt;"
            "margin-top:%.15gpt;"
            "width:%.15gpt;"
            "height:%.15gpt;"
            "z-index:%d;"
            "visibility:%s" % (left, top, width, height, z_index, visibility)
        )

        attributes = [
            ("id", shape_id),
            ("type", shape_type),
            ("style", style),
            ("fillcolor", fillcolor),
            ("o:insetmode", insetmode),
        ]

        self._xml_start_tag("v:shape", attributes)

        # Write the v:fill element.
        self._write_comment_fill()

        # Write the v:shadow element.
        self._write_shadow()

        # Write the v:path element.
        self._write_comment_path(None, "none")

        # Write the v:textbox element.
        self._write_comment_textbox()

        # Write the x:ClientData element.
        self._write_comment_client_data(row, col, visible, vertices)

        self._xml_end_tag("v:shape")

    def _write_button_shape(self, shape_id, z_index, button):
        # Write the <v:shape> element.
        shape_type = "#_x0000_t201"

        # Set the shape index.
        shape_id = "_x0000_s" + str(shape_id)

        # Get the button parameters.
        # row = button["_row"]
        # col = button["_col"]
        vertices = button["vertices"]

        (left, top, width, height) = self._pixels_to_points(vertices)

        style = (
            "position:absolute;"
            "margin-left:%.15gpt;"
            "margin-top:%.15gpt;"
            "width:%.15gpt;"
            "height:%.15gpt;"
            "z-index:%d;"
            "mso-wrap-style:tight" % (left, top, width, height, z_index)
        )

        attributes = [
            ("id", shape_id),
            ("type", shape_type),
        ]

        if button.get("description"):
            attributes.append(("alt", button["description"]))

        attributes.append(("style", style))
        attributes.append(("o:button", "t"))
        attributes.append(("fillcolor", "buttonFace [67]"))
        attributes.append(("strokecolor", "windowText [64]"))
        attributes.append(("o:insetmode", "auto"))

        self._xml_start_tag("v:shape", attributes)

        # Write the v:fill element.
        self._write_button_fill()

        # Write the o:lock element.
        self._write_rotation_lock()

        # Write the v:textbox element.
        self._write_button_textbox(button["font"])

        # Write the x:ClientData element.
        self._write_button_client_data(button)

        self._xml_end_tag("v:shape")

    def _write_image_shape(self, shape_id, z_index, image_data):
        # Write the <v:shape> element.
        shape_type = "#_x0000_t75"

        # Set the shape index.
        shape_id = "_x0000_s" + str(shape_id)

        # Get the image parameters
        width = image_data[0]
        height = image_data[1]
        name = image_data[2]
        position = image_data[3]
        x_dpi = image_data[4]
        y_dpi = image_data[5]
        ref_id = image_data[6]

        # Scale the height/width by the resolution, relative to 72dpi.
        width = width * 72.0 / x_dpi
        height = height * 72.0 / y_dpi

        # Excel uses a rounding based around 72 and 96 dpi.
        width = 72.0 / 96 * int(width * 96.0 / 72 + 0.25)
        height = 72.0 / 96 * int(height * 96.0 / 72 + 0.25)

        style = (
            "position:absolute;"
            "margin-left:0;"
            "margin-top:0;"
            "width:%.15gpt;"
            "height:%.15gpt;"
            "z-index:%d" % (width, height, z_index)
        )

        attributes = [
            ("id", position),
            ("o:spid", shape_id),
            ("type", shape_type),
            ("style", style),
        ]

        self._xml_start_tag("v:shape", attributes)

        # Write the v:imagedata element.
        self._write_imagedata(ref_id, name)

        # Write the o:lock element.
        self._write_rotation_lock()

        self._xml_end_tag("v:shape")

    def _write_comment_fill(self):
        # Write the <v:fill> element.
        color_2 = "#ffffe1"

        attributes = [("color2", color_2)]

        self._xml_empty_tag("v:fill", attributes)

    def _write_button_fill(self):
        # Write the <v:fill> element.
        color_2 = "buttonFace [67]"
        detectmouseclick = "t"

        attributes = [
            ("color2", color_2),
            ("o:detectmouseclick", detectmouseclick),
        ]

        self._xml_empty_tag("v:fill", attributes)

    def _write_shadow(self):
        # Write the <v:shadow> element.
        on = "t"
        color = "black"
        obscured = "t"

        attributes = [
            ("on", on),
            ("color", color),
            ("obscured", obscured),
        ]

        self._xml_empty_tag("v:shadow", attributes)

    def _write_comment_textbox(self):
        # Write the <v:textbox> element.
        style = "mso-direction-alt:auto"

        attributes = [("style", style)]

        self._xml_start_tag("v:textbox", attributes)

        # Write the div element.
        self._write_div("left")

        self._xml_end_tag("v:textbox")

    def _write_button_textbox(self, font):
        # Write the <v:textbox> element.
        style = "mso-direction-alt:auto"

        attributes = [("style", style), ("o:singleclick", "f")]

        self._xml_start_tag("v:textbox", attributes)

        # Write the div element.
        self._write_div("center", font)

        self._xml_end_tag("v:textbox")

    def _write_div(self, align, font=None):
        # Write the <div> element.

        style = "text-align:" + align

        attributes = [("style", style)]

        self._xml_start_tag("div", attributes)

        if font:
            # Write the font element.
            self._write_font(font)

        self._xml_end_tag("div")

    def _write_font(self, font):
        # Write the <font> element.
        caption = font["caption"]
        face = "Calibri"
        size = 220
        color = "#000000"

        attributes = [
            ("face", face),
            ("size", size),
            ("color", color),
        ]

        self._xml_data_element("font", caption, attributes)

    def _write_comment_client_data(self, row, col, visible, vertices):
        # Write the <x:ClientData> element.
        object_type = "Note"

        attributes = [("ObjectType", object_type)]

        self._xml_start_tag("x:ClientData", attributes)

        # Write the x:MoveWithCells element.
        self._write_move_with_cells()

        # Write the x:SizeWithCells element.
        self._write_size_with_cells()

        # Write the x:Anchor element.
        self._write_anchor(vertices)

        # Write the x:AutoFill element.
        self._write_auto_fill()

        # Write the x:Row element.
        self._write_row(row)

        # Write the x:Column element.
        self._write_column(col)

        # Write the x:Visible element.
        if visible:
            self._write_visible()

        self._xml_end_tag("x:ClientData")

    def _write_button_client_data(self, button):
        # Write the <x:ClientData> element.
        macro = button["macro"]
        vertices = button["vertices"]

        object_type = "Button"

        attributes = [("ObjectType", object_type)]

        self._xml_start_tag("x:ClientData", attributes)

        # Write the x:Anchor element.
        self._write_anchor(vertices)

        # Write the x:PrintObject element.
        self._write_print_object()

        # Write the x:AutoFill element.
        self._write_auto_fill()

        # Write the x:FmlaMacro element.
        self._write_fmla_macro(macro)

        # Write the x:TextHAlign element.
        self._write_text_halign()

        # Write the x:TextVAlign element.
        self._write_text_valign()

        self._xml_end_tag("x:ClientData")

    def _write_move_with_cells(self):
        # Write the <x:MoveWithCells> element.
        self._xml_empty_tag("x:MoveWithCells")

    def _write_size_with_cells(self):
        # Write the <x:SizeWithCells> element.
        self._xml_empty_tag("x:SizeWithCells")

    def _write_visible(self):
        # Write the <x:Visible> element.
        self._xml_empty_tag("x:Visible")

    def _write_anchor(self, vertices):
        # Write the <x:Anchor> element.
        (col_start, row_start, x1, y1, col_end, row_end, x2, y2) = vertices[:8]

        strings = [col_start, x1, row_start, y1, col_end, x2, row_end, y2]
        strings = [str(i) for i in strings]

        data = ", ".join(strings)

        self._xml_data_element("x:Anchor", data)

    def _write_auto_fill(self):
        # Write the <x:AutoFill> element.
        data = "False"

        self._xml_data_element("x:AutoFill", data)

    def _write_row(self, data):
        # Write the <x:Row> element.
        self._xml_data_element("x:Row", data)

    def _write_column(self, data):
        # Write the <x:Column> element.
        self._xml_data_element("x:Column", data)

    def _write_print_object(self):
        # Write the <x:PrintObject> element.
        self._xml_data_element("x:PrintObject", "False")

    def _write_text_halign(self):
        # Write the <x:TextHAlign> element.
        self._xml_data_element("x:TextHAlign", "Center")

    def _write_text_valign(self):
        # Write the <x:TextVAlign> element.
        self._xml_data_element("x:TextVAlign", "Center")

    def _write_fmla_macro(self, data):
        # Write the <x:FmlaMacro> element.
        self._xml_data_element("x:FmlaMacro", data)

    def _write_imagedata(self, ref_id, o_title):
        # Write the <v:imagedata> element.
        attributes = [
            ("o:relid", "rId" + str(ref_id)),
            ("o:title", o_title),
        ]

        self._xml_empty_tag("v:imagedata", attributes)

    def _write_formulas(self):
        # Write the <v:formulas> element.
        self._xml_start_tag("v:formulas")

        # Write the v:f elements.
        self._write_formula("if lineDrawn pixelLineWidth 0")
        self._write_formula("sum @0 1 0")
        self._write_formula("sum 0 0 @1")
        self._write_formula("prod @2 1 2")
        self._write_formula("prod @3 21600 pixelWidth")
        self._write_formula("prod @3 21600 pixelHeight")
        self._write_formula("sum @0 0 1")
        self._write_formula("prod @6 1 2")
        self._write_formula("prod @7 21600 pixelWidth")
        self._write_formula("sum @8 21600 0")
        self._write_formula("prod @7 21600 pixelHeight")
        self._write_formula("sum @10 21600 0")

        self._xml_end_tag("v:formulas")

    def _write_formula(self, eqn):
        # Write the <v:f> element.
        attributes = [("eqn", eqn)]

        self._xml_empty_tag("v:f", attributes)

```

---

### File: `tmp\xlsxwriter_sdist\XlsxWriter-3.2.0\xlsxwriter\workbook.py`

```python
###############################################################################
#
# Workbook - A class for writing the Excel XLSX Workbook file.
#
# SPDX-License-Identifier: BSD-2-Clause
# Copyright 2013-2024, John McNamara, jmcnamara@cpan.org
#

# Standard packages.
import operator
import os
import re
import time
from datetime import datetime, timezone
from decimal import Decimal
from fractions import Fraction
from warnings import warn
from zipfile import ZipFile, ZipInfo, ZIP_DEFLATED, LargeZipFile


# Package imports.
from . import xmlwriter
from .worksheet import Worksheet
from .chartsheet import Chartsheet
from .sharedstrings import SharedStringTable
from .format import Format
from .packager import Packager
from .utility import xl_cell_to_rowcol
from .chart_area import ChartArea
from .chart_bar import ChartBar
from .chart_column import ChartColumn
from .chart_doughnut import ChartDoughnut
from .chart_line import ChartLine
from .chart_pie import ChartPie
from .chart_radar import ChartRadar
from .chart_scatter import ChartScatter
from .chart_stock import ChartStock
from .exceptions import InvalidWorksheetName
from .exceptions import DuplicateWorksheetName
from .exceptions import FileCreateError
from .exceptions import FileSizeError
from .utility import get_image_properties


class Workbook(xmlwriter.XMLwriter):
    """
    A class for writing the Excel XLSX Workbook file.


    """

    ###########################################################################
    #
    # Public API.
    #
    ###########################################################################
    chartsheet_class = Chartsheet
    worksheet_class = Worksheet

    def __init__(self, filename=None, options=None):
        """
        Constructor.

        """
        if options is None:
            options = {}

        super(Workbook, self).__init__()

        self.filename = filename

        self.tmpdir = options.get("tmpdir", None)
        self.date_1904 = options.get("date_1904", False)
        self.strings_to_numbers = options.get("strings_to_numbers", False)
        self.strings_to_formulas = options.get("strings_to_formulas", True)
        self.strings_to_urls = options.get("strings_to_urls", True)
        self.nan_inf_to_errors = options.get("nan_inf_to_errors", False)
        self.default_date_format = options.get("default_date_format", None)
        self.constant_memory = options.get("constant_memory", False)
        self.in_memory = options.get("in_memory", False)
        self.excel2003_style = options.get("excel2003_style", False)
        self.remove_timezone = options.get("remove_timezone", False)
        self.use_future_functions = options.get("use_future_functions", False)
        self.default_format_properties = options.get("default_format_properties", {})

        self.max_url_length = options.get("max_url_length", 2079)
        if self.max_url_length < 255:
            self.max_url_length = 2079

        if options.get("use_zip64"):
            self.allow_zip64 = True
        else:
            self.allow_zip64 = False

        self.worksheet_meta = WorksheetMeta()
        self.selected = 0
        self.fileclosed = 0
        self.filehandle = None
        self.internal_fh = 0
        self.sheet_name = "Sheet"
        self.chart_name = "Chart"
        self.sheetname_count = 0
        self.chartname_count = 0
        self.worksheets_objs = []
        self.charts = []
        self.drawings = []
        self.sheetnames = {}
        self.formats = []
        self.xf_formats = []
        self.xf_format_indices = {}
        self.dxf_formats = []
        self.dxf_format_indices = {}
        self.palette = []
        self.font_count = 0
        self.num_formats = []
        self.defined_names = []
        self.named_ranges = []
        self.custom_colors = []
        self.doc_properties = {}
        self.custom_properties = []
        self.createtime = datetime.now(timezone.utc)
        self.num_vml_files = 0
        self.num_comment_files = 0
        self.x_window = 240
        self.y_window = 15
        self.window_width = 16095
        self.window_height = 9660
        self.tab_ratio = 600
        self.str_table = SharedStringTable()
        self.vba_project = None
        self.vba_project_is_stream = False
        self.vba_project_signature = None
        self.vba_project_signature_is_stream = False
        self.vba_codename = None
        self.image_types = {}
        self.images = []
        self.border_count = 0
        self.fill_count = 0
        self.drawing_count = 0
        self.calc_mode = "auto"
        self.calc_on_load = True
        self.calc_id = 124519
        self.has_comments = False
        self.read_only = 0
        self.has_metadata = False
        self.has_embedded_images = False
        self.has_dynamic_functions = False
        self.has_embedded_descriptions = False
        self.embedded_images = EmbeddedImages()

        # We can't do 'constant_memory' mode while doing 'in_memory' mode.
        if self.in_memory:
            self.constant_memory = False

        # Add the default cell format.
        if self.excel2003_style:
            self.add_format({"xf_index": 0, "font_family": 0})
        else:
            self.add_format({"xf_index": 0})

        # Add a default URL format.
        self.default_url_format = self.add_format({"hyperlink": True})

        # Add the default date format.
        if self.default_date_format is not None:
            self.default_date_format = self.add_format(
                {"num_format": self.default_date_format}
            )

    def __enter__(self):
        """Return self object to use with "with" statement."""
        return self

    def __exit__(self, type, value, traceback):
        """Close workbook when exiting "with" statement."""
        self.close()

    def add_worksheet(self, name=None, worksheet_class=None):
        """
        Add a new worksheet to the Excel workbook.

        Args:
            name: The worksheet name. Defaults to 'Sheet1', etc.

        Returns:
            Reference to a worksheet object.

        """
        if worksheet_class is None:
            worksheet_class = self.worksheet_class

        return self._add_sheet(name, worksheet_class=worksheet_class)

    def add_chartsheet(self, name=None, chartsheet_class=None):
        """
        Add a new chartsheet to the Excel workbook.

        Args:
            name: The chartsheet name. Defaults to 'Sheet1', etc.

        Returns:
            Reference to a chartsheet object.

        """
        if chartsheet_class is None:
            chartsheet_class = self.chartsheet_class

        return self._add_sheet(name, worksheet_class=chartsheet_class)

    def add_format(self, properties=None):
        """
        Add a new Format to the Excel Workbook.

        Args:
            properties: The format properties.

        Returns:
            Reference to a Format object.

        """
        format_properties = self.default_format_properties.copy()

        if self.excel2003_style:
            format_properties = {"font_name": "Arial", "font_size": 10, "theme": 1 * -1}

        if properties:
            format_properties.update(properties)

        xf_format = Format(
            format_properties, self.xf_format_indices, self.dxf_format_indices
        )

        # Store the format reference.
        self.formats.append(xf_format)

        return xf_format

    def add_chart(self, options):
        """
        Create a chart object.

        Args:
            options: The chart type and subtype options.

        Returns:
            Reference to a Chart object.

        """

        # Type must be specified so we can create the required chart instance.
        chart_type = options.get("type")
        if chart_type is None:
            warn("Chart type must be defined in add_chart()")
            return

        if chart_type == "area":
            chart = ChartArea(options)
        elif chart_type == "bar":
            chart = ChartBar(options)
        elif chart_type == "column":
            chart = ChartColumn(options)
        elif chart_type == "doughnut":
            chart = ChartDoughnut(options)
        elif chart_type == "line":
            chart = ChartLine(options)
        elif chart_type == "pie":
            chart = ChartPie(options)
        elif chart_type == "radar":
            chart = ChartRadar(options)
        elif chart_type == "scatter":
            chart = ChartScatter(options)
        elif chart_type == "stock":
            chart = ChartStock(options)
        else:
            warn("Unknown chart type '%s' in add_chart()" % chart_type)
            return

        # Set the embedded chart name if present.
        if "name" in options:
            chart.chart_name = options["name"]

        chart.embedded = True
        chart.date_1904 = self.date_1904
        chart.remove_timezone = self.remove_timezone

        self.charts.append(chart)

        return chart

    def add_vba_project(self, vba_project, is_stream=False):
        """
        Add a vbaProject binary to the Excel workbook.

        Args:
            vba_project: The vbaProject binary file name.
            is_stream:   vba_project is an in memory byte stream.

        Returns:
            Nothing.

        """
        if not is_stream and not os.path.exists(vba_project):
            warn("VBA project binary file '%s' not found." % vba_project)
            return -1

        if self.vba_codename is None:
            self.vba_codename = "ThisWorkbook"

        self.vba_project = vba_project
        self.vba_project_is_stream = is_stream

    def add_signed_vba_project(
        self, vba_project, signature, project_is_stream=False, signature_is_stream=False
    ):
        """
        Add a vbaProject binary and a vbaProjectSignature binary to the
        Excel workbook.

        Args:
            vba_project:           The vbaProject binary file name.
            signature:             The vbaProjectSignature binary file name.
            project_is_stream:     vba_project is an in memory byte stream.
            signature_is_stream:   signature is an in memory byte stream.

        Returns:
            Nothing.

        """
        if self.add_vba_project(vba_project, project_is_stream) == -1:
            return -1

        if not signature_is_stream and not os.path.exists(signature):
            warn("VBA project signature binary file '%s' not found." % signature)
            return -1

        self.vba_project_signature = signature
        self.vba_project_signature_is_stream = signature_is_stream

    def close(self):
        """
        Call finalization code and close file.

        Args:
            None.

        Returns:
            Nothing.

        """
        if not self.fileclosed:
            try:
                self._store_workbook()
            except IOError as e:
                raise FileCreateError(e)
            except LargeZipFile:
                raise FileSizeError(
                    "Filesize would require ZIP64 extensions. "
                    "Use workbook.use_zip64()."
                )

            self.fileclosed = True

            # Ensure all constant_memory temp files are closed.
            if self.constant_memory:
                for worksheet in self.worksheets():
                    worksheet._opt_close()

        else:
            warn("Calling close() on already closed file.")

    def set_size(self, width, height):
        """
        Set the size of a workbook window.

        Args:
            width:  Width  of the window in pixels.
            height: Height of the window in pixels.

        Returns:
            Nothing.

        """
        # Convert the width/height to twips at 96 dpi.
        if width:
            self.window_width = int(width * 1440 / 96)
        else:
            self.window_width = 16095

        if height:
            self.window_height = int(height * 1440 / 96)
        else:
            self.window_height = 9660

    def set_tab_ratio(self, tab_ratio=None):
        """
        Set the ratio between worksheet tabs and the horizontal slider.

        Args:
            tab_ratio: The tab ratio, 0 <= tab_ratio <= 100

        Returns:
            Nothing.

        """
        if tab_ratio is None:
            return

        if tab_ratio < 0 or tab_ratio > 100:
            warn("Tab ratio '%d' outside: 0 <= tab_ratio <= 100" % tab_ratio)
        else:
            self.tab_ratio = int(tab_ratio * 10)

    def set_properties(self, properties):
        """
        Set the document properties such as Title, Author etc.

        Args:
            properties: Dictionary of document properties.

        Returns:
            Nothing.

        """
        self.doc_properties = properties

    def set_custom_property(self, name, value, property_type=None):
        """
        Set a custom document property.

        Args:
            name:          The name of the custom property.
            value:         The value of the custom property.
            property_type: The type of the custom property. Optional.

        Returns:
            Nothing.

        """
        if name is None or value is None:
            warn(
                "The name and value parameters must be non-None in "
                "set_custom_property()"
            )
            return -1

        if property_type is None:
            # Determine the property type from the Python type.
            if isinstance(value, bool):
                property_type = "bool"
            elif isinstance(value, datetime):
                property_type = "date"
            elif isinstance(value, int):
                property_type = "number_int"
            elif isinstance(value, (float, int, Decimal, Fraction)):
                property_type = "number"
            else:
                property_type = "text"

        if property_type == "date":
            value = value.strftime("%Y-%m-%dT%H:%M:%SZ")

        if property_type == "text" and len(value) > 255:
            warn(
                "Length of 'value' parameter exceeds Excel's limit of 255 "
                "characters in set_custom_property(): '%s'" % value
            )

        if len(name) > 255:
            warn(
                "Length of 'name' parameter exceeds Excel's limit of 255 "
                "characters in set_custom_property(): '%s'" % name
            )

        self.custom_properties.append((name, value, property_type))

    def set_calc_mode(self, mode, calc_id=None):
        """
        Set the Excel calculation mode for the workbook.

        Args:
            mode: String containing one of:
                * manual
                * auto_except_tables
                * auto

        Returns:
            Nothing.

        """
        self.calc_mode = mode

        if mode == "manual":
            self.calc_on_load = False
        elif mode == "auto_except_tables":
            self.calc_mode = "autoNoTable"

        # Leave undocumented for now. Rarely required.
        if calc_id:
            self.calc_id = calc_id

    def define_name(self, name, formula):
        # Create a defined name in Excel. We handle global/workbook level
        # names and local/worksheet names.
        """
        Create a defined name in the workbook.

        Args:
            name:    The defined name.
            formula: The cell or range that the defined name refers to.

        Returns:
            Nothing.

        """
        sheet_index = None
        sheetname = ""

        # Remove the = sign from the formula if it exists.
        if formula.startswith("="):
            formula = formula.lstrip("=")

        # Local defined names are formatted like "Sheet1!name".
        sheet_parts = re.compile(r"^([^!]+)!([^!]+)$")
        match = sheet_parts.match(name)

        if match:
            sheetname = match.group(1)
            name = match.group(2)
            sheet_index = self._get_sheet_index(sheetname)

            # Warn if the sheet index wasn't found.
            if sheet_index is None:
                warn("Unknown sheet name '%s' in defined_name()" % sheetname)
                return -1
        else:
            # Use -1 to indicate global names.
            sheet_index = -1

        # Warn if the defined name contains invalid chars as defined by Excel.
        if not re.match(r"^[\w\\][\w\\.]*$", name, re.UNICODE) or re.match(
            r"^\d", name
        ):
            warn("Invalid Excel characters in defined_name(): '%s'" % name)
            return -1

        # Warn if the defined name looks like a cell name.
        if re.match(r"^[a-zA-Z][a-zA-Z]?[a-dA-D]?\d+$", name):
            warn("Name looks like a cell name in defined_name(): '%s'" % name)
            return -1

        # Warn if the name looks like a R1C1 cell reference.
        if re.match(r"^[rcRC]$", name) or re.match(r"^[rcRC]\d+[rcRC]\d+$", name):
            warn("Invalid name '%s' like a RC cell ref in defined_name()" % name)
            return -1

        self.defined_names.append([name, sheet_index, formula, False])

    def worksheets(self):
        """
        Return a list of the worksheet objects in the workbook.

        Args:
            None.

        Returns:
            A list of worksheet objects.

        """
        return self.worksheets_objs

    def get_worksheet_by_name(self, name):
        """
        Return a worksheet object in the workbook using the sheetname.

        Args:
            name: The name of the worksheet.

        Returns:
            A worksheet object or None.

        """
        return self.sheetnames.get(name)

    def get_default_url_format(self):
        """
        Get the default url format used when a user defined format isn't
        specified with write_url(). The format is the hyperlink style defined
        by Excel for the default theme.

        Args:
            None.

        Returns:
            A format object.

        """
        return self.default_url_format

    def use_zip64(self):
        """
        Allow ZIP64 extensions when writing xlsx file zip container.

        Args:
            None.

        Returns:
            Nothing.

        """
        self.allow_zip64 = True

    def set_vba_name(self, name=None):
        """
        Set the VBA name for the workbook. By default the workbook is referred
        to as ThisWorkbook in VBA.

        Args:
            name: The VBA name for the workbook.

        Returns:
            Nothing.

        """
        if name is not None:
            self.vba_codename = name
        else:
            self.vba_codename = "ThisWorkbook"

    def read_only_recommended(self):
        """
        Set the Excel "Read-only recommended" option when saving a file.

        Args:
            None.

        Returns:
            Nothing.

        """
        self.read_only = 2

    ###########################################################################
    #
    # Private API.
    #
    ###########################################################################

    def _assemble_xml_file(self):
        # Assemble and write the XML file.

        # Prepare format object for passing to Style.pm.
        self._prepare_format_properties()

        # Write the XML declaration.
        self._xml_declaration()

        # Write the workbook element.
        self._write_workbook()

        # Write the fileVersion element.
        self._write_file_version()

        # Write the fileSharing element.
        self._write_file_sharing()

        # Write the workbookPr element.
        self._write_workbook_pr()

        # Write the bookViews element.
        self._write_book_views()

        # Write the sheets element.
        self._write_sheets()

        # Write the workbook defined names.
        self._write_defined_names()

        # Write the calcPr element.
        self._write_calc_pr()

        # Close the workbook tag.
        self._xml_end_tag("workbook")

        # Close the file.
        self._xml_close()

    def _store_workbook(self):
        # Create the xlsx/zip file.
        try:
            xlsx_file = ZipFile(
                self.filename,
                "w",
                compression=ZIP_DEFLATED,
                allowZip64=self.allow_zip64,
            )
        except IOError as e:
            raise e

        # Assemble worksheets into a workbook.
        packager = self._get_packager()

        # Add a default worksheet if non have been added.
        if not self.worksheets():
            self.add_worksheet()

        # Ensure that at least one worksheet has been selected.
        if self.worksheet_meta.activesheet == 0:
            self.worksheets_objs[0].selected = 1
            self.worksheets_objs[0].hidden = 0

        # Set the active sheet.
        for sheet in self.worksheets():
            if sheet.index == self.worksheet_meta.activesheet:
                sheet.active = 1

        # Set the sheet vba_codename the workbook has a vbaProject binary.
        if self.vba_project:
            for sheet in self.worksheets():
                if sheet.vba_codename is None:
                    sheet.set_vba_name()

        # Convert the SST strings data structure.
        self._prepare_sst_string_data()

        # Prepare the worksheet VML elements such as comments and buttons.
        self._prepare_vml()

        # Set the defined names for the worksheets such as Print Titles.
        self._prepare_defined_names()

        # Prepare the drawings, charts and images.
        self._prepare_drawings()

        # Add cached data to charts.
        self._add_chart_data()

        # Prepare the worksheet tables.
        self._prepare_tables()

        # Prepare the metadata file links.
        self._prepare_metadata()

        # Package the workbook.
        packager._add_workbook(self)
        packager._set_tmpdir(self.tmpdir)
        packager._set_in_memory(self.in_memory)
        xml_files = packager._create_package()

        # Free up the Packager object.
        packager = None

        # Add XML sub-files to the Zip file with their Excel filename.
        for file_id, file_data in enumerate(xml_files):
            os_filename, xml_filename, is_binary = file_data

            if self.in_memory:
                # Set sub-file timestamp to Excel's timestamp of 1/1/1980.
                zipinfo = ZipInfo(xml_filename, (1980, 1, 1, 0, 0, 0))

                # Copy compression type from parent ZipFile.
                zipinfo.compress_type = xlsx_file.compression

                if is_binary:
                    xlsx_file.writestr(zipinfo, os_filename.getvalue())
                else:
                    xlsx_file.writestr(zipinfo, os_filename.getvalue().encode("utf-8"))
            else:
                # The sub-files are tempfiles on disk, i.e, not in memory.

                # Set sub-file timestamp to 31/1/1980 due to portability
                # issues setting it to Excel's timestamp of 1/1/1980.
                timestamp = time.mktime((1980, 1, 31, 0, 0, 0, 0, 0, -1))
                os.utime(os_filename, (timestamp, timestamp))

                try:
                    xlsx_file.write(os_filename, xml_filename)
                    os.remove(os_filename)
                except LargeZipFile as e:
                    # Close open temp files on zipfile.LargeZipFile exception.
                    for i in range(file_id, len(xml_files) - 1):
                        os.remove(xml_files[i][0])
                    raise e

        xlsx_file.close()

    def _add_sheet(self, name, worksheet_class=None):
        # Utility for shared code in add_worksheet() and add_chartsheet().

        if worksheet_class:
            worksheet = worksheet_class()
        else:
            worksheet = self.worksheet_class()

        sheet_index = len(self.worksheets_objs)
        name = self._check_sheetname(name, isinstance(worksheet, Chartsheet))

        # Initialization data to pass to the worksheet.
        init_data = {
            "name": name,
            "index": sheet_index,
            "str_table": self.str_table,
            "worksheet_meta": self.worksheet_meta,
            "constant_memory": self.constant_memory,
            "tmpdir": self.tmpdir,
            "date_1904": self.date_1904,
            "strings_to_numbers": self.strings_to_numbers,
            "strings_to_formulas": self.strings_to_formulas,
            "strings_to_urls": self.strings_to_urls,
            "nan_inf_to_errors": self.nan_inf_to_errors,
            "default_date_format": self.default_date_format,
            "default_url_format": self.default_url_format,
            "excel2003_style": self.excel2003_style,
            "remove_timezone": self.remove_timezone,
            "max_url_length": self.max_url_length,
            "use_future_functions": self.use_future_functions,
            "embedded_images": self.embedded_images,
        }

        worksheet._initialize(init_data)

        self.worksheets_objs.append(worksheet)
        self.sheetnames[name] = worksheet

        return worksheet

    def _check_sheetname(self, sheetname, is_chartsheet=False):
        # Check for valid worksheet names. We check the length, if it contains
        # any invalid chars and if the sheetname is unique in the workbook.
        invalid_char = re.compile(r"[\[\]:*?/\\]")

        # Increment the Sheet/Chart number used for default sheet names below.
        if is_chartsheet:
            self.chartname_count += 1
        else:
            self.sheetname_count += 1

        # Supply default Sheet/Chart sheetname if none has been defined.
        if sheetname is None or sheetname == "":
            if is_chartsheet:
                sheetname = self.chart_name + str(self.chartname_count)
            else:
                sheetname = self.sheet_name + str(self.sheetname_count)

        # Check that sheet sheetname is <= 31. Excel limit.
        if len(sheetname) > 31:
            raise InvalidWorksheetName(
                "Excel worksheet name '%s' must be <= 31 chars." % sheetname
            )

        # Check that sheetname doesn't contain any invalid characters.
        if invalid_char.search(sheetname):
            raise InvalidWorksheetName(
                "Invalid Excel character '[]:*?/\\' in sheetname '%s'." % sheetname
            )

        # Check that sheetname doesn't start or end with an apostrophe.
        if sheetname.startswith("'") or sheetname.endswith("'"):
            raise InvalidWorksheetName(
                'Sheet name cannot start or end with an apostrophe "%s".' % sheetname
            )

        # Check that the worksheet name doesn't already exist since this is a
        # fatal Excel error. The check must be case insensitive like Excel.
        for worksheet in self.worksheets():
            if sheetname.lower() == worksheet.name.lower():
                raise DuplicateWorksheetName(
                    "Sheetname '%s', with case ignored, is already in use." % sheetname
                )

        return sheetname

    def _prepare_format_properties(self):
        # Prepare all Format properties prior to passing them to styles.py.

        # Separate format objects into XF and DXF formats.
        self._prepare_formats()

        # Set the font index for the format objects.
        self._prepare_fonts()

        # Set the number format index for the format objects.
        self._prepare_num_formats()

        # Set the border index for the format objects.
        self._prepare_borders()

        # Set the fill index for the format objects.
        self._prepare_fills()

    def _prepare_formats(self):
        # Iterate through the XF Format objects and separate them into
        # XF and DXF formats. The XF and DF formats then need to be sorted
        # back into index order rather than creation order.
        xf_formats = []
        dxf_formats = []

        # Sort into XF and DXF formats.
        for xf_format in self.formats:
            if xf_format.xf_index is not None:
                xf_formats.append(xf_format)

            if xf_format.dxf_index is not None:
                dxf_formats.append(xf_format)

        # Pre-extend the format lists.
        self.xf_formats = [None] * len(xf_formats)
        self.dxf_formats = [None] * len(dxf_formats)

        # Rearrange formats into index order.
        for xf_format in xf_formats:
            index = xf_format.xf_index
            self.xf_formats[index] = xf_format

        for dxf_format in dxf_formats:
            index = dxf_format.dxf_index
            self.dxf_formats[index] = dxf_format

    def _set_default_xf_indices(self):
        # Set the default index for each format. Only used for testing.

        formats = list(self.formats)

        # Delete the default url format.
        del formats[1]

        # Skip the default date format if set.
        if self.default_date_format is not None:
            del formats[1]

        # Set the remaining formats.
        for xf_format in formats:
            xf_format._get_xf_index()

    def _prepare_fonts(self):
        # Iterate through the XF Format objects and give them an index to
        # non-default font elements.
        fonts = {}
        index = 0

        for xf_format in self.xf_formats:
            key = xf_format._get_font_key()
            if key in fonts:
                # Font has already been used.
                xf_format.font_index = fonts[key]
                xf_format.has_font = 0
            else:
                # This is a new font.
                fonts[key] = index
                xf_format.font_index = index
                xf_format.has_font = 1
                index += 1

        self.font_count = index

        # For DXF formats we only need to check if the properties have changed.
        for xf_format in self.dxf_formats:
            # The only font properties that can change for a DXF format are:
            # color, bold, italic, underline and strikethrough.
            if (
                xf_format.font_color
                or xf_format.bold
                or xf_format.italic
                or xf_format.underline
                or xf_format.font_strikeout
            ):
                xf_format.has_dxf_font = 1

    def _prepare_num_formats(self):
        # User defined records in Excel start from index 0xA4.
        unique_num_formats = {}
        num_formats = []
        index = 164

        for xf_format in self.xf_formats + self.dxf_formats:
            num_format = xf_format.num_format

            # Check if num_format is an index to a built-in number format.
            if not isinstance(num_format, str):
                num_format = int(num_format)

                # Number format '0' is indexed as 1 in Excel.
                if num_format == 0:
                    num_format = 1

                xf_format.num_format_index = num_format
                continue
            elif num_format == "0":
                # Number format '0' is indexed as 1 in Excel.
                xf_format.num_format_index = 1
                continue
            elif num_format == "General":
                # The 'General' format has an number format index of 0.
                xf_format.num_format_index = 0
                continue

            if num_format in unique_num_formats:
                # Number xf_format has already been used.
                xf_format.num_format_index = unique_num_formats[num_format]
            else:
                # Add a new number xf_format.
                unique_num_formats[num_format] = index
                xf_format.num_format_index = index
                index += 1

                # Only increase font count for XF formats (not DXF formats).
                if xf_format.xf_index:
                    num_formats.append(num_format)

        self.num_formats = num_formats

    def _prepare_borders(self):
        # Iterate through the XF Format objects and give them an index to
        # non-default border elements.
        borders = {}
        index = 0

        for xf_format in self.xf_formats:
            key = xf_format._get_border_key()

            if key in borders:
                # Border has already been used.
                xf_format.border_index = borders[key]
                xf_format.has_border = 0
            else:
                # This is a new border.
                borders[key] = index
                xf_format.border_index = index
                xf_format.has_border = 1
                index += 1

        self.border_count = index

        # For DXF formats we only need to check if the properties have changed.
        has_border = re.compile(r"[^0:]")

        for xf_format in self.dxf_formats:
            key = xf_format._get_border_key()

            if has_border.search(key):
                xf_format.has_dxf_border = 1

    def _prepare_fills(self):
        # Iterate through the XF Format objects and give them an index to
        # non-default fill elements.
        # The user defined fill properties start from 2 since there are 2
        # default fills: patternType="none" and patternType="gray125".
        fills = {}
        index = 2  # Start from 2. See above.

        # Add the default fills.
        fills["0:0:0"] = 0
        fills["17:0:0"] = 1

        # Store the DXF colors separately since them may be reversed below.
        for xf_format in self.dxf_formats:
            if xf_format.pattern or xf_format.bg_color or xf_format.fg_color:
                xf_format.has_dxf_fill = 1
                xf_format.dxf_bg_color = xf_format.bg_color
                xf_format.dxf_fg_color = xf_format.fg_color

        for xf_format in self.xf_formats:
            # The following logical statements jointly take care of special
            # cases in relation to cell colors and patterns:
            # 1. For a solid fill (_pattern == 1) Excel reverses the role of
            # foreground and background colors, and
            # 2. If the user specifies a foreground or background color
            # without a pattern they probably wanted a solid fill, so we fill
            # in the defaults.
            if (
                xf_format.pattern == 1
                and xf_format.bg_color != 0
                and xf_format.fg_color != 0
            ):
                tmp = xf_format.fg_color
                xf_format.fg_color = xf_format.bg_color
                xf_format.bg_color = tmp

            if (
                xf_format.pattern <= 1
                and xf_format.bg_color != 0
                and xf_format.fg_color == 0
            ):
                xf_format.fg_color = xf_format.bg_color
                xf_format.bg_color = 0
                xf_format.pattern = 1

            if (
                xf_format.pattern <= 1
                and xf_format.bg_color == 0
                and xf_format.fg_color != 0
            ):
                xf_format.pattern = 1

            key = xf_format._get_fill_key()

            if key in fills:
                # Fill has already been used.
                xf_format.fill_index = fills[key]
                xf_format.has_fill = 0
            else:
                # This is a new fill.
                fills[key] = index
                xf_format.fill_index = index
                xf_format.has_fill = 1
                index += 1

        self.fill_count = index

    def _prepare_defined_names(self):
        # Iterate through the worksheets and store any defined names in
        # addition to any user defined names. Stores the defined names
        # for the Workbook.xml and the named ranges for App.xml.
        defined_names = self.defined_names

        for sheet in self.worksheets():
            # Check for Print Area settings.
            if sheet.autofilter_area:
                hidden = 1
                sheet_range = sheet.autofilter_area
                # Store the defined names.
                defined_names.append(
                    ["_xlnm._FilterDatabase", sheet.index, sheet_range, hidden]
                )

            # Check for Print Area settings.
            if sheet.print_area_range:
                hidden = 0
                sheet_range = sheet.print_area_range
                # Store the defined names.
                defined_names.append(
                    ["_xlnm.Print_Area", sheet.index, sheet_range, hidden]
                )

            # Check for repeat rows/cols referred to as Print Titles.
            if sheet.repeat_col_range or sheet.repeat_row_range:
                hidden = 0
                sheet_range = ""
                if sheet.repeat_col_range and sheet.repeat_row_range:
                    sheet_range = sheet.repeat_col_range + "," + sheet.repeat_row_range
                else:
                    sheet_range = sheet.repeat_col_range + sheet.repeat_row_range
                # Store the defined names.
                defined_names.append(
                    ["_xlnm.Print_Titles", sheet.index, sheet_range, hidden]
                )

        defined_names = self._sort_defined_names(defined_names)
        self.defined_names = defined_names
        self.named_ranges = self._extract_named_ranges(defined_names)

    def _sort_defined_names(self, names):
        # Sort the list of list of internal and user defined names in
        # the same order as used by Excel.

        # Add a normalize name string to each list for sorting.
        for name_list in names:
            (defined_name, _, sheet_name, _) = name_list

            # Normalize the defined name by removing any leading '_xmln.'
            # from internal names and lowercasing the string.
            defined_name = defined_name.replace("_xlnm.", "").lower()

            # Normalize the sheetname by removing the leading quote and
            # lowercasing the string.
            sheet_name = sheet_name.lstrip("'").lower()

            name_list.append(defined_name + "::" + sheet_name)

        # Sort based on the normalized key.
        names.sort(key=operator.itemgetter(4))

        # Remove the extra key used for sorting.
        for name_list in names:
            name_list.pop()

        return names

    def _prepare_drawings(self):
        # Iterate through the worksheets and set up chart and image drawings.
        chart_ref_id = 0
        ref_id = 0
        drawing_id = 0
        image_ids = {}
        header_image_ids = {}
        background_ids = {}

        # Store the image types for any embedded images.
        for image_data in self.embedded_images.images:
            image_type = image_data[1]
            self.image_types[image_type] = True
            if image_data[3]:
                self.has_embedded_descriptions = True

        image_ref_id = len(self.embedded_images.images)

        for sheet in self.worksheets():
            chart_count = len(sheet.charts)
            image_count = len(sheet.images)
            shape_count = len(sheet.shapes)

            header_image_count = len(sheet.header_images)
            footer_image_count = len(sheet.footer_images)
            has_background = sheet.background_image
            has_drawing = False

            if not (
                chart_count
                or image_count
                or shape_count
                or header_image_count
                or footer_image_count
                or has_background
            ):
                continue

            # Don't increase the drawing_id header/footer images.
            if chart_count or image_count or shape_count:
                drawing_id += 1
                has_drawing = True

            # Prepare the background images.
            if sheet.background_image:
                if sheet.background_bytes:
                    filename = ""
                    image_data = sheet.background_image
                else:
                    filename = sheet.background_image
                    image_data = None

                (
                    image_type,
                    _,
                    _,
                    _,
                    _,
                    _,
                    digest,
                ) = get_image_properties(filename, image_data)

                self.image_types[image_type] = True

                if digest in background_ids:
                    ref_id = background_ids[digest]
                else:
                    image_ref_id += 1
                    ref_id = image_ref_id
                    background_ids[digest] = image_ref_id
                    self.images.append([filename, image_type, image_data])

                sheet._prepare_background(ref_id, image_type)

            # Prepare the worksheet images.
            for index in range(image_count):
                filename = sheet.images[index][2]
                image_data = sheet.images[index][10]
                (
                    image_type,
                    width,
                    height,
                    name,
                    x_dpi,
                    y_dpi,
                    digest,
                ) = get_image_properties(filename, image_data)

                self.image_types[image_type] = True

                if digest in image_ids:
                    ref_id = image_ids[digest]
                else:
                    image_ref_id += 1
                    ref_id = image_ref_id
                    image_ids[digest] = image_ref_id
                    self.images.append([filename, image_type, image_data])

                sheet._prepare_image(
                    index,
                    ref_id,
                    drawing_id,
                    width,
                    height,
                    name,
                    image_type,
                    x_dpi,
                    y_dpi,
                    digest,
                )

            # Prepare the worksheet charts.
            for index in range(chart_count):
                chart_ref_id += 1
                sheet._prepare_chart(index, chart_ref_id, drawing_id)

            # Prepare the worksheet shapes.
            for index in range(shape_count):
                sheet._prepare_shape(index, drawing_id)

            # Prepare the header images.
            for index in range(header_image_count):
                filename = sheet.header_images[index][0]
                image_data = sheet.header_images[index][1]
                position = sheet.header_images[index][2]

                (
                    image_type,
                    width,
                    height,
                    name,
                    x_dpi,
                    y_dpi,
                    digest,
                ) = get_image_properties(filename, image_data)

                self.image_types[image_type] = True

                if digest in header_image_ids:
                    ref_id = header_image_ids[digest]
                else:
                    image_ref_id += 1
                    ref_id = image_ref_id
                    header_image_ids[digest] = image_ref_id
                    self.images.append([filename, image_type, image_data])

                sheet._prepare_header_image(
                    ref_id,
                    width,
                    height,
                    name,
                    image_type,
                    position,
                    x_dpi,
                    y_dpi,
                    digest,
                )

            # Prepare the footer images.
            for index in range(footer_image_count):
                filename = sheet.footer_images[index][0]
                image_data = sheet.footer_images[index][1]
                position = sheet.footer_images[index][2]

                (
                    image_type,
                    width,
                    height,
                    name,
                    x_dpi,
                    y_dpi,
                    digest,
                ) = get_image_properties(filename, image_data)

                self.image_types[image_type] = True

                if digest in header_image_ids:
                    ref_id = header_image_ids[digest]
                else:
                    image_ref_id += 1
                    ref_id = image_ref_id
                    header_image_ids[digest] = image_ref_id
                    self.images.append([filename, image_type, image_data])

                sheet._prepare_header_image(
                    ref_id,
                    width,
                    height,
                    name,
                    image_type,
                    position,
                    x_dpi,
                    y_dpi,
                    digest,
                )

            if has_drawing:
                drawing = sheet.drawing
                self.drawings.append(drawing)

        # Remove charts that were created but not inserted into worksheets.
        for chart in self.charts[:]:
            if chart.id == -1:
                self.charts.remove(chart)

        # Sort the workbook charts references into the order that the were
        # written to the worksheets above.
        self.charts = sorted(self.charts, key=lambda chart: chart.id)

        self.drawing_count = drawing_id

    def _extract_named_ranges(self, defined_names):
        # Extract the named ranges from the sorted list of defined names.
        # These are used in the App.xml file.
        named_ranges = []

        for defined_name in defined_names:
            name = defined_name[0]
            index = defined_name[1]
            sheet_range = defined_name[2]

            # Skip autoFilter ranges.
            if name == "_xlnm._FilterDatabase":
                continue

            # We are only interested in defined names with ranges.
            if "!" in sheet_range:
                sheet_name, _ = sheet_range.split("!", 1)

                # Match Print_Area and Print_Titles xlnm types.
                if name.startswith("_xlnm."):
                    xlnm_type = name.replace("_xlnm.", "")
                    name = sheet_name + "!" + xlnm_type
                elif index != -1:
                    name = sheet_name + "!" + name

                named_ranges.append(name)

        return named_ranges

    def _get_sheet_index(self, sheetname):
        # Convert a sheet name to its index. Return None otherwise.
        sheetname = sheetname.strip("'")

        if sheetname in self.sheetnames:
            return self.sheetnames[sheetname].index
        else:
            return None

    def _prepare_vml(self):
        # Iterate through the worksheets and set up the VML objects.
        comment_id = 0
        vml_drawing_id = 0
        vml_data_id = 1
        vml_header_id = 0
        vml_shape_id = 1024
        vml_files = 0
        comment_files = 0

        for sheet in self.worksheets():
            if not sheet.has_vml and not sheet.has_header_vml:
                continue

            vml_files += 1

            if sheet.has_vml:
                if sheet.has_comments:
                    comment_files += 1
                    comment_id += 1
                    self.has_comments = True

                vml_drawing_id += 1

                count = sheet._prepare_vml_objects(
                    vml_data_id, vml_shape_id, vml_drawing_id, comment_id
                )

                # Each VML should start with a shape id incremented by 1024.
                vml_data_id += 1 * int((1024 + count) / 1024)
                vml_shape_id += 1024 * int((1024 + count) / 1024)

            if sheet.has_header_vml:
                vml_header_id += 1
                vml_drawing_id += 1
                sheet._prepare_header_vml_objects(vml_header_id, vml_drawing_id)

            self.num_vml_files = vml_files
            self.num_comment_files = comment_files

    def _prepare_tables(self):
        # Set the table ids for the worksheet tables.
        table_id = 0
        seen = {}

        for sheet in self.worksheets():
            table_count = len(sheet.tables)

            if not table_count:
                continue

            sheet._prepare_tables(table_id + 1, seen)
            table_id += table_count

    def _prepare_metadata(self):
        # Set the metadata rel link.
        self.has_embedded_images = self.embedded_images.has_images()
        self.has_metadata = self.has_embedded_images

        for sheet in self.worksheets():
            if sheet.has_dynamic_arrays:
                self.has_metadata = True
                self.has_dynamic_functions = True

    def _add_chart_data(self):
        # Add "cached" data to charts to provide the numCache and strCache
        # data for series and title/axis ranges.
        worksheets = {}
        seen_ranges = {}
        charts = []

        # Map worksheet names to worksheet objects.
        for worksheet in self.worksheets():
            worksheets[worksheet.name] = worksheet

        # Build a list of the worksheet charts including any combined charts.
        for chart in self.charts:
            charts.append(chart)
            if chart.combined:
                charts.append(chart.combined)

        for chart in charts:
            for c_range in chart.formula_ids.keys():
                r_id = chart.formula_ids[c_range]

                # Skip if the series has user defined data.
                if chart.formula_data[r_id] is not None:
                    if c_range not in seen_ranges or seen_ranges[c_range] is None:
                        data = chart.formula_data[r_id]
                        seen_ranges[c_range] = data
                    continue

                # Check to see if the data is already cached locally.
                if c_range in seen_ranges:
                    chart.formula_data[r_id] = seen_ranges[c_range]
                    continue

                # Convert the range formula to a sheet name and cell range.
                (sheetname, cells) = self._get_chart_range(c_range)

                # Skip if we couldn't parse the formula.
                if sheetname is None:
                    continue

                # Handle non-contiguous ranges like:
                #     (Sheet1!$A$1:$A$2,Sheet1!$A$4:$A$5).
                # We don't try to parse them. We just return an empty list.
                if sheetname.startswith("("):
                    chart.formula_data[r_id] = []
                    seen_ranges[c_range] = []
                    continue

                # Warn if the name is unknown since it indicates a user error
                # in a chart series formula.
                if sheetname not in worksheets:
                    warn(
                        "Unknown worksheet reference '%s' in range "
                        "'%s' passed to add_series()" % (sheetname, c_range)
                    )
                    chart.formula_data[r_id] = []
                    seen_ranges[c_range] = []
                    continue

                # Find the worksheet object based on the sheet name.
                worksheet = worksheets[sheetname]

                # Get the data from the worksheet table.
                data = worksheet._get_range_data(*cells)

                # Add the data to the chart.
                chart.formula_data[r_id] = data

                # Store range data locally to avoid lookup if seen again.
                seen_ranges[c_range] = data

    def _get_chart_range(self, c_range):
        # Convert a range formula such as Sheet1!$B$1:$B$5 into a sheet name
        # and cell range such as ( 'Sheet1', 0, 1, 4, 1 ).

        # Split the range formula into sheetname and cells at the last '!'.
        pos = c_range.rfind("!")
        if pos > 0:
            sheetname = c_range[:pos]
            cells = c_range[pos + 1 :]
        else:
            return None, None

        # Split the cell range into 2 cells or else use single cell for both.
        if cells.find(":") > 0:
            (cell_1, cell_2) = cells.split(":", 1)
        else:
            (cell_1, cell_2) = (cells, cells)

        # Remove leading/trailing quotes and convert escaped quotes to single.
        sheetname = sheetname.strip("'")
        sheetname = sheetname.replace("''", "'")

        try:
            # Get the row, col values from the Excel ranges. We do this in a
            # try block for ranges that can't be parsed such as defined names.
            (row_start, col_start) = xl_cell_to_rowcol(cell_1)
            (row_end, col_end) = xl_cell_to_rowcol(cell_2)
        except AttributeError:
            return None, None

        # We only handle 1D ranges.
        if row_start != row_end and col_start != col_end:
            return None, None

        return sheetname, [row_start, col_start, row_end, col_end]

    def _prepare_sst_string_data(self):
        # Convert the SST string data from a dict to a list.
        self.str_table._sort_string_data()

    def _get_packager(self):
        # Get and instance of the Packager class to create the xlsx package.
        # This allows the default packager to be over-ridden.
        return Packager()

    ###########################################################################
    #
    # XML methods.
    #
    ###########################################################################

    def _write_workbook(self):
        # Write <workbook> element.

        schema = "http://schemas.openxmlformats.org"
        xmlns = schema + "/spreadsheetml/2006/main"
        xmlns_r = schema + "/officeDocument/2006/relationships"

        attributes = [
            ("xmlns", xmlns),
            ("xmlns:r", xmlns_r),
        ]

        self._xml_start_tag("workbook", attributes)

    def _write_file_version(self):
        # Write the <fileVersion> element.

        app_name = "xl"
        last_edited = 4
        lowest_edited = 4
        rup_build = 4505

        attributes = [
            ("appName", app_name),
            ("lastEdited", last_edited),
            ("lowestEdited", lowest_edited),
            ("rupBuild", rup_build),
        ]

        if self.vba_project:
            attributes.append(("codeName", "{37E998C4-C9E5-D4B9-71C8-EB1FF731991C}"))

        self._xml_empty_tag("fileVersion", attributes)

    def _write_file_sharing(self):
        # Write the <fileSharing> element.
        if self.read_only == 0:
            return

        attributes = [("readOnlyRecommended", 1)]

        self._xml_empty_tag("fileSharing", attributes)

    def _write_workbook_pr(self):
        # Write <workbookPr> element.
        default_theme_version = 124226
        attributes = []

        if self.vba_codename:
            attributes.append(("codeName", self.vba_codename))
        if self.date_1904:
            attributes.append(("date1904", 1))

        attributes.append(("defaultThemeVersion", default_theme_version))

        self._xml_empty_tag("workbookPr", attributes)

    def _write_book_views(self):
        # Write <bookViews> element.
        self._xml_start_tag("bookViews")
        self._write_workbook_view()
        self._xml_end_tag("bookViews")

    def _write_workbook_view(self):
        # Write <workbookView> element.
        attributes = [
            ("xWindow", self.x_window),
            ("yWindow", self.y_window),
            ("windowWidth", self.window_width),
            ("windowHeight", self.window_height),
        ]

        # Store the tabRatio attribute when it isn't the default.
        if self.tab_ratio != 600:
            attributes.append(("tabRatio", self.tab_ratio))

        # Store the firstSheet attribute when it isn't the default.
        if self.worksheet_meta.firstsheet > 0:
            firstsheet = self.worksheet_meta.firstsheet + 1
            attributes.append(("firstSheet", firstsheet))

        # Store the activeTab attribute when it isn't the first sheet.
        if self.worksheet_meta.activesheet > 0:
            attributes.append(("activeTab", self.worksheet_meta.activesheet))

        self._xml_empty_tag("workbookView", attributes)

    def _write_sheets(self):
        # Write <sheets> element.
        self._xml_start_tag("sheets")

        id_num = 1
        for worksheet in self.worksheets():
            self._write_sheet(worksheet.name, id_num, worksheet.hidden)
            id_num += 1

        self._xml_end_tag("sheets")

    def _write_sheet(self, name, sheet_id, hidden):
        # Write <sheet> element.
        attributes = [
            ("name", name),
            ("sheetId", sheet_id),
        ]

        if hidden == 1:
            attributes.append(("state", "hidden"))
        elif hidden == 2:
            attributes.append(("state", "veryHidden"))

        attributes.append(("r:id", "rId" + str(sheet_id)))

        self._xml_empty_tag("sheet", attributes)

    def _write_calc_pr(self):
        # Write the <calcPr> element.
        attributes = [("calcId", self.calc_id)]

        if self.calc_mode == "manual":
            attributes.append(("calcMode", self.calc_mode))
            attributes.append(("calcOnSave", "0"))
        elif self.calc_mode == "autoNoTable":
            attributes.append(("calcMode", self.calc_mode))

        if self.calc_on_load:
            attributes.append(("fullCalcOnLoad", "1"))

        self._xml_empty_tag("calcPr", attributes)

    def _write_defined_names(self):
        # Write the <definedNames> element.
        if not self.defined_names:
            return

        self._xml_start_tag("definedNames")

        for defined_name in self.defined_names:
            self._write_defined_name(defined_name)

        self._xml_end_tag("definedNames")

    def _write_defined_name(self, defined_name):
        # Write the <definedName> element.
        name = defined_name[0]
        sheet_id = defined_name[1]
        sheet_range = defined_name[2]
        hidden = defined_name[3]

        attributes = [("name", name)]

        if sheet_id != -1:
            attributes.append(("localSheetId", sheet_id))
        if hidden:
            attributes.append(("hidden", 1))

        self._xml_data_element("definedName", sheet_range, attributes)


# A metadata class to share data between worksheets.
class WorksheetMeta(object):
    """
    A class to track worksheets data such as the active sheet and the
    first sheet.

    """

    def __init__(self):
        self.activesheet = 0
        self.firstsheet = 0


# A helper class to share embedded images between worksheets.
class EmbeddedImages(object):
    """
    A class to track duplicate embedded images between worksheets.

    """

    def __init__(self):
        self.images = []
        self.image_indexes = {}

    def get_image_index(self, image, digest):
        image_index = self.image_indexes.get(digest)

        if image_index is None:
            self.images.append(image)
            image_index = len(self.images)
            self.image_indexes[digest] = image_index

        return image_index

    def has_images(self):
        return len(self.images) > 0

```

---

### File: `tmp\xlsxwriter_sdist\XlsxWriter-3.2.0\xlsxwriter\worksheet.py`

```python
###############################################################################
#
# Worksheet - A class for writing the Excel XLSX Worksheet file.
#
# SPDX-License-Identifier: BSD-2-Clause
# Copyright 2013-2024, John McNamara, jmcnamara@cpan.org
#

# Standard packages.
import datetime
import math
import os
import re
import tempfile

from collections import defaultdict
from collections import namedtuple
from decimal import Decimal
from fractions import Fraction
from functools import wraps
from io import StringIO
from math import isinf
from math import isnan
from warnings import warn

# Package imports.
from . import xmlwriter
from .format import Format
from .drawing import Drawing
from .shape import Shape
from .xmlwriter import XMLwriter
from .utility import xl_rowcol_to_cell
from .utility import xl_rowcol_to_cell_fast
from .utility import xl_cell_to_rowcol
from .utility import xl_col_to_name
from .utility import xl_range
from .utility import xl_color
from .utility import xl_pixel_width
from .utility import get_sparkline_style
from .utility import supported_datetime
from .utility import datetime_to_excel_datetime
from .utility import get_image_properties
from .utility import preserve_whitespace
from .utility import quote_sheetname
from .exceptions import DuplicateTableName
from .exceptions import OverlappingRange

re_dynamic_function = re.compile(
    r"""
    \bANCHORARRAY\(    |
    \bBYCOL\(          |
    \bBYROW\(          |
    \bCHOOSECOLS\(     |
    \bCHOOSEROWS\(     |
    \bDROP\(           |
    \bEXPAND\(         |
    \bFILTER\(         |
    \bHSTACK\(         |
    \bLAMBDA\(         |
    \bMAKEARRAY\(      |
    \bMAP\(            |
    \bRANDARRAY\(      |
    \bREDUCE\(         |
    \bSCAN\(           |
    \bSEQUENCE\(       |
    \bSINGLE\(         |
    \bSORT\(           |
    \bSORTBY\(         |
    \bSWITCH\(         |
    \bTAKE\(           |
    \bTEXTSPLIT\(      |
    \bTOCOL\(          |
    \bTOROW\(          |
    \bUNIQUE\(         |
    \bVSTACK\(         |
    \bWRAPCOLS\(       |
    \bWRAPROWS\(       |
    \bXLOOKUP\(""",
    re.VERBOSE,
)


###############################################################################
#
# Decorator functions.
#
###############################################################################
def convert_cell_args(method):
    """
    Decorator function to convert A1 notation in cell method calls
    to the default row/col notation.

    """

    @wraps(method)
    def cell_wrapper(self, *args, **kwargs):
        try:
            # First arg is an int, default to row/col notation.
            if args:
                first_arg = args[0]
                int(first_arg)
        except ValueError:
            # First arg isn't an int, convert to A1 notation.
            new_args = xl_cell_to_rowcol(first_arg)
            args = new_args + args[1:]

        return method(self, *args, **kwargs)

    return cell_wrapper


def convert_range_args(method):
    """
    Decorator function to convert A1 notation in range method calls
    to the default row/col notation.

    """

    @wraps(method)
    def cell_wrapper(self, *args, **kwargs):
        try:
            # First arg is an int, default to row/col notation.
            if args:
                int(args[0])
        except ValueError:
            # First arg isn't an int, convert to A1 notation.
            if ":" in args[0]:
                cell_1, cell_2 = args[0].split(":")
                row_1, col_1 = xl_cell_to_rowcol(cell_1)
                row_2, col_2 = xl_cell_to_rowcol(cell_2)
            else:
                row_1, col_1 = xl_cell_to_rowcol(args[0])
                row_2, col_2 = row_1, col_1

            new_args = [row_1, col_1, row_2, col_2]
            new_args.extend(args[1:])
            args = new_args

        return method(self, *args, **kwargs)

    return cell_wrapper


def convert_column_args(method):
    """
    Decorator function to convert A1 notation in columns method calls
    to the default row/col notation.

    """

    @wraps(method)
    def column_wrapper(self, *args, **kwargs):
        try:
            # First arg is an int, default to row/col notation.
            if args:
                int(args[0])
        except ValueError:
            # First arg isn't an int, convert to A1 notation.
            cell_1, cell_2 = [col + "1" for col in args[0].split(":")]
            _, col_1 = xl_cell_to_rowcol(cell_1)
            _, col_2 = xl_cell_to_rowcol(cell_2)
            new_args = [col_1, col_2]
            new_args.extend(args[1:])
            args = new_args

        return method(self, *args, **kwargs)

    return column_wrapper


###############################################################################
#
# Named tuples used for cell types.
#
###############################################################################
cell_string_tuple = namedtuple("String", "string, format")
cell_number_tuple = namedtuple("Number", "number, format")
cell_blank_tuple = namedtuple("Blank", "format")
cell_boolean_tuple = namedtuple("Boolean", "boolean, format")
cell_formula_tuple = namedtuple("Formula", "formula, format, value")
cell_datetime_tuple = namedtuple("Datetime", "number, format")
cell_arformula_tuple = namedtuple(
    "ArrayFormula", "formula, format, value, range, atype"
)
cell_rich_string_tuple = namedtuple("RichString", "string, format, raw_string")
cell_error_tuple = namedtuple("Error", "error, format, value")


###############################################################################
#
# Worksheet Class definition.
#
###############################################################################
class Worksheet(xmlwriter.XMLwriter):
    """
    A class for writing the Excel XLSX Worksheet file.

    """

    ###########################################################################
    #
    # Public API.
    #
    ###########################################################################

    def __init__(self):
        """
        Constructor.

        """

        super(Worksheet, self).__init__()

        self.name = None
        self.index = None
        self.str_table = None
        self.palette = None
        self.constant_memory = 0
        self.tmpdir = None
        self.is_chartsheet = False

        self.ext_sheets = []
        self.fileclosed = 0
        self.excel_version = 2007
        self.excel2003_style = False

        self.xls_rowmax = 1048576
        self.xls_colmax = 16384
        self.xls_strmax = 32767
        self.dim_rowmin = None
        self.dim_rowmax = None
        self.dim_colmin = None
        self.dim_colmax = None

        self.col_info = {}
        self.selections = []
        self.hidden = 0
        self.active = 0
        self.tab_color = 0
        self.top_left_cell = ""

        self.panes = []
        self.active_pane = 3
        self.selected = 0

        self.page_setup_changed = False
        self.paper_size = 0
        self.orientation = 1

        self.print_options_changed = False
        self.hcenter = False
        self.vcenter = False
        self.print_gridlines = False
        self.screen_gridlines = True
        self.print_headers = False
        self.row_col_headers = False

        self.header_footer_changed = False
        self.header = ""
        self.footer = ""
        self.header_footer_aligns = True
        self.header_footer_scales = True
        self.header_images = []
        self.footer_images = []
        self.header_images_list = []

        self.margin_left = 0.7
        self.margin_right = 0.7
        self.margin_top = 0.75
        self.margin_bottom = 0.75
        self.margin_header = 0.3
        self.margin_footer = 0.3

        self.repeat_row_range = ""
        self.repeat_col_range = ""
        self.print_area_range = ""

        self.page_order = 0
        self.black_white = 0
        self.draft_quality = 0
        self.print_comments = 0
        self.page_start = 0

        self.fit_page = 0
        self.fit_width = 0
        self.fit_height = 0

        self.hbreaks = []
        self.vbreaks = []

        self.protect_options = {}
        self.protected_ranges = []
        self.num_protected_ranges = 0
        self.set_cols = {}
        self.set_rows = defaultdict(dict)

        self.zoom = 100
        self.zoom_scale_normal = 1
        self.print_scale = 100
        self.is_right_to_left = 0
        self.show_zeros = 1
        self.leading_zeros = 0

        self.outline_row_level = 0
        self.outline_col_level = 0
        self.outline_style = 0
        self.outline_below = 1
        self.outline_right = 1
        self.outline_on = 1
        self.outline_changed = False

        self.original_row_height = 15
        self.default_row_height = 15
        self.default_row_pixels = 20
        self.default_col_width = 8.43
        self.default_col_pixels = 64
        self.default_date_pixels = 68
        self.default_row_zeroed = 0

        self.names = {}
        self.write_match = []
        self.table = defaultdict(dict)
        self.merge = []
        self.merged_cells = {}
        self.table_cells = {}
        self.row_spans = {}

        self.has_vml = False
        self.has_header_vml = False
        self.has_comments = False
        self.comments = defaultdict(dict)
        self.comments_list = []
        self.comments_author = ""
        self.comments_visible = 0
        self.vml_shape_id = 1024
        self.buttons_list = []
        self.vml_header_id = 0

        self.autofilter_area = ""
        self.autofilter_ref = None
        self.filter_range = []
        self.filter_on = 0
        self.filter_cols = {}
        self.filter_type = {}
        self.filter_cells = {}

        self.row_sizes = {}
        self.col_size_changed = False
        self.row_size_changed = False

        self.last_shape_id = 1
        self.rel_count = 0
        self.hlink_count = 0
        self.hlink_refs = []
        self.external_hyper_links = []
        self.external_drawing_links = []
        self.external_comment_links = []
        self.external_vml_links = []
        self.external_table_links = []
        self.external_background_links = []
        self.drawing_links = []
        self.vml_drawing_links = []
        self.charts = []
        self.images = []
        self.tables = []
        self.sparklines = []
        self.shapes = []
        self.shape_hash = {}
        self.drawing = 0
        self.drawing_rels = {}
        self.drawing_rels_id = 0
        self.vml_drawing_rels = {}
        self.vml_drawing_rels_id = 0
        self.background_image = None
        self.background_bytes = False

        self.rstring = ""
        self.previous_row = 0

        self.validations = []
        self.cond_formats = {}
        self.data_bars_2010 = []
        self.use_data_bars_2010 = False
        self.dxf_priority = 1
        self.page_view = 0

        self.vba_codename = None

        self.date_1904 = False
        self.hyperlinks = defaultdict(dict)

        self.strings_to_numbers = False
        self.strings_to_urls = True
        self.nan_inf_to_errors = False
        self.strings_to_formulas = True

        self.default_date_format = None
        self.default_url_format = None
        self.remove_timezone = False
        self.max_url_length = 2079

        self.row_data_filename = None
        self.row_data_fh = None
        self.worksheet_meta = None
        self.vml_data_id = None
        self.vml_shape_id = None

        self.row_data_filename = None
        self.row_data_fh = None
        self.row_data_fh_closed = False

        self.vertical_dpi = 0
        self.horizontal_dpi = 0

        self.write_handlers = {}

        self.ignored_errors = None

        self.has_dynamic_arrays = False
        self.use_future_functions = False
        self.ignore_write_string = False

    # Utility function for writing different types of strings.
    def _write_token_as_string(self, token, row, col, *args):
        # Map the data to the appropriate write_*() method.
        if token == "":
            return self._write_blank(row, col, *args)

        if self.strings_to_formulas and token.startswith("="):
            return self._write_formula(row, col, *args)

        if token.startswith("{=") and token.endswith("}"):
            return self._write_formula(row, col, *args)

        if (
            ":" in token
            and self.strings_to_urls
            and (
                re.match("(ftp|http)s?://", token)
                or re.match("mailto:", token)
                or re.match("(in|ex)ternal:", token)
            )
        ):
            return self._write_url(row, col, *args)

        if self.strings_to_numbers:
            try:
                f = float(token)
                if self.nan_inf_to_errors or (not isnan(f) and not isinf(f)):
                    return self._write_number(row, col, f, *args[1:])
            except ValueError:
                # Not a number, write as a string.
                pass

            return self._write_string(row, col, *args)

        else:
            # We have a plain string.
            return self._write_string(row, col, *args)

    @convert_cell_args
    def write(self, row, col, *args):
        """
        Write data to a worksheet cell by calling the appropriate write_*()
        method based on the type of data being passed.

        Args:
            row:   The cell row (zero indexed).
            col:   The cell column (zero indexed).
            *args: Args to pass to sub functions.

        Returns:
             0:    Success.
            -1:    Row or column is out of worksheet bounds.
            other: Return value of called method.

        """
        return self._write(row, col, *args)

    # Undecorated version of write().
    def _write(self, row, col, *args):
        # Check the number of args passed.
        if not args:
            raise TypeError("write() takes at least 4 arguments (3 given)")

        # The first arg should be the token for all write calls.
        token = args[0]

        # Avoid isinstance() for better performance.
        token_type = token.__class__

        # Check for any user defined type handlers with callback functions.
        if token_type in self.write_handlers:
            write_handler = self.write_handlers[token_type]
            function_return = write_handler(self, row, col, *args)

            # If the return value is None then the callback has returned
            # control to this function and we should continue as
            # normal. Otherwise we return the value to the caller and exit.
            if function_return is None:
                pass
            else:
                return function_return

        # Write None as a blank cell.
        if token is None:
            return self._write_blank(row, col, *args)

        # Check for standard Python types.
        if token_type is bool:
            return self._write_boolean(row, col, *args)

        if token_type in (float, int, Decimal, Fraction):
            return self._write_number(row, col, *args)

        if token_type is str:
            return self._write_token_as_string(token, row, col, *args)

        if token_type in (
            datetime.datetime,
            datetime.date,
            datetime.time,
            datetime.timedelta,
        ):
            return self._write_datetime(row, col, *args)

        # Resort to isinstance() for subclassed primitives.

        # Write number types.
        if isinstance(token, (float, int, Decimal, Fraction)):
            return self._write_number(row, col, *args)

        # Write string types.
        if isinstance(token, str):
            return self._write_token_as_string(token, row, col, *args)

        # Write boolean types.
        if isinstance(token, bool):
            return self._write_boolean(row, col, *args)

        # Write datetime objects.
        if supported_datetime(token):
            return self._write_datetime(row, col, *args)

        # We haven't matched a supported type. Try float.
        try:
            f = float(token)
            return self._write_number(row, col, f, *args[1:])
        except ValueError:
            pass
        except TypeError:
            raise TypeError("Unsupported type %s in write()" % type(token))

        # Finally try string.
        try:
            str(token)
            return self._write_string(row, col, *args)
        except ValueError:
            raise TypeError("Unsupported type %s in write()" % type(token))

    @convert_cell_args
    def write_string(self, row, col, string, cell_format=None):
        """
        Write a string to a worksheet cell.

        Args:
            row:    The cell row (zero indexed).
            col:    The cell column (zero indexed).
            string: Cell data. Str.
            format: An optional cell Format object.

        Returns:
            0:  Success.
            -1: Row or column is out of worksheet bounds.
            -2: String truncated to 32k characters.

        """
        return self._write_string(row, col, string, cell_format)

    # Undecorated version of write_string().
    def _write_string(self, row, col, string, cell_format=None):
        str_error = 0

        # Check that row and col are valid and store max and min values.
        if self._check_dimensions(row, col):
            return -1

        # Check that the string is < 32767 chars.
        if len(string) > self.xls_strmax:
            string = string[: self.xls_strmax]
            str_error = -2

        # Write a shared string or an in-line string in constant_memory mode.
        if not self.constant_memory:
            string_index = self.str_table._get_shared_string_index(string)
        else:
            string_index = string

        # Write previous row if in in-line string constant_memory mode.
        if self.constant_memory and row > self.previous_row:
            self._write_single_row(row)

        # Store the cell data in the worksheet data table.
        self.table[row][col] = cell_string_tuple(string_index, cell_format)

        return str_error

    @convert_cell_args
    def write_number(self, row, col, number, cell_format=None):
        """
        Write a number to a worksheet cell.

        Args:
            row:         The cell row (zero indexed).
            col:         The cell column (zero indexed).
            number:      Cell data. Int or float.
            cell_format: An optional cell Format object.

        Returns:
            0:  Success.
            -1: Row or column is out of worksheet bounds.

        """
        return self._write_number(row, col, number, cell_format)

    # Undecorated version of write_number().
    def _write_number(self, row, col, number, cell_format=None):
        if isnan(number) or isinf(number):
            if self.nan_inf_to_errors:
                if isnan(number):
                    return self._write_formula(row, col, "#NUM!", cell_format, "#NUM!")
                elif number == math.inf:
                    return self._write_formula(row, col, "1/0", cell_format, "#DIV/0!")
                elif number == -math.inf:
                    return self._write_formula(row, col, "-1/0", cell_format, "#DIV/0!")
            else:
                raise TypeError(
                    "NAN/INF not supported in write_number() "
                    "without 'nan_inf_to_errors' Workbook() option"
                )

        # Check that row and col are valid and store max and min values.
        if self._check_dimensions(row, col):
            return -1

        # Write previous row if in in-line string constant_memory mode.
        if self.constant_memory and row > self.previous_row:
            self._write_single_row(row)

        # Store the cell data in the worksheet data table.
        self.table[row][col] = cell_number_tuple(number, cell_format)

        return 0

    @convert_cell_args
    def write_blank(self, row, col, blank, cell_format=None):
        """
        Write a blank cell with formatting to a worksheet cell. The blank
        token is ignored and the format only is written to the cell.

        Args:
            row:         The cell row (zero indexed).
            col:         The cell column (zero indexed).
            blank:       Any value. It is ignored.
            cell_format: An optional cell Format object.

        Returns:
            0:  Success.
            -1: Row or column is out of worksheet bounds.

        """
        return self._write_blank(row, col, blank, cell_format)

    # Undecorated version of write_blank().
    def _write_blank(self, row, col, blank, cell_format=None):
        # Don't write a blank cell unless it has a format.
        if cell_format is None:
            return 0

        # Check that row and col are valid and store max and min values.
        if self._check_dimensions(row, col):
            return -1

        # Write previous row if in in-line string constant_memory mode.
        if self.constant_memory and row > self.previous_row:
            self._write_single_row(row)

        # Store the cell data in the worksheet data table.
        self.table[row][col] = cell_blank_tuple(cell_format)

        return 0

    @convert_cell_args
    def write_formula(self, row, col, formula, cell_format=None, value=0):
        """
        Write a formula to a worksheet cell.

        Args:
            row:         The cell row (zero indexed).
            col:         The cell column (zero indexed).
            formula:     Cell formula.
            cell_format: An optional cell Format object.
            value:       An optional value for the formula. Default is 0.

        Returns:
            0:  Success.
            -1: Row or column is out of worksheet bounds.
            -2: Formula can't be None or empty.

        """
        # Check that row and col are valid and store max and min values.
        return self._write_formula(row, col, formula, cell_format, value)

    # Undecorated version of write_formula().
    def _write_formula(self, row, col, formula, cell_format=None, value=0):
        if self._check_dimensions(row, col):
            return -1

        if formula is None or formula == "":
            warn("Formula can't be None or empty")
            return -1

        # Check for dynamic array functions.
        if re_dynamic_function.search(formula):
            return self.write_dynamic_array_formula(
                row, col, row, col, formula, cell_format, value
            )

        # Hand off array formulas.
        if formula.startswith("{") and formula.endswith("}"):
            return self._write_array_formula(
                row, col, row, col, formula, cell_format, value
            )

        # Modify the formula string, as needed.
        formula = self._prepare_formula(formula)

        # Write previous row if in in-line string constant_memory mode.
        if self.constant_memory and row > self.previous_row:
            self._write_single_row(row)

        # Store the cell data in the worksheet data table.
        self.table[row][col] = cell_formula_tuple(formula, cell_format, value)

        return 0

    @convert_range_args
    def write_array_formula(
        self,
        first_row,
        first_col,
        last_row,
        last_col,
        formula,
        cell_format=None,
        value=0,
    ):
        """
        Write a formula to a worksheet cell/range.

        Args:
            first_row:    The first row of the cell range. (zero indexed).
            first_col:    The first column of the cell range.
            last_row:     The last row of the cell range. (zero indexed).
            last_col:     The last column of the cell range.
            formula:      Cell formula.
            cell_format:  An optional cell Format object.
            value:        An optional value for the formula. Default is 0.

        Returns:
            0:  Success.
            -1: Row or column is out of worksheet bounds.

        """
        # Check for dynamic array functions.
        if re_dynamic_function.search(formula):
            return self.write_dynamic_array_formula(
                first_row, first_col, last_row, last_col, formula, cell_format, value
            )

        return self._write_array_formula(
            first_row,
            first_col,
            last_row,
            last_col,
            formula,
            cell_format,
            value,
            "static",
        )

    @convert_range_args
    def write_dynamic_array_formula(
        self,
        first_row,
        first_col,
        last_row,
        last_col,
        formula,
        cell_format=None,
        value=0,
    ):
        """
        Write a dynamic array formula to a worksheet cell/range.

        Args:
            first_row:    The first row of the cell range. (zero indexed).
            first_col:    The first column of the cell range.
            last_row:     The last row of the cell range. (zero indexed).
            last_col:     The last column of the cell range.
            formula:      Cell formula.
            cell_format:  An optional cell Format object.
            value:        An optional value for the formula. Default is 0.

        Returns:
            0:  Success.
            -1: Row or column is out of worksheet bounds.

        """
        error = self._write_array_formula(
            first_row,
            first_col,
            last_row,
            last_col,
            formula,
            cell_format,
            value,
            "dynamic",
        )

        if error == 0:
            self.has_dynamic_arrays = True

        return error

    # Utility method to strip equal sign and array braces from a formula and
    # also expand out future and dynamic array formulas.
    def _prepare_formula(self, formula, expand_future_functions=False):
        # Remove array formula braces and the leading =.
        if formula.startswith("{"):
            formula = formula[1:]
        if formula.startswith("="):
            formula = formula[1:]
        if formula.endswith("}"):
            formula = formula[:-1]

        # Check if formula is already expanded by the user.
        if "_xlfn." in formula:
            return formula

        # Expand dynamic formulas.
        formula = re.sub(r"\bANCHORARRAY\(", "_xlfn.ANCHORARRAY(", formula)
        formula = re.sub(r"\bBYCOL\(", "_xlfn.BYCOL(", formula)
        formula = re.sub(r"\bBYROW\(", "_xlfn.BYROW(", formula)
        formula = re.sub(r"\bCHOOSECOLS\(", "_xlfn.CHOOSECOLS(", formula)
        formula = re.sub(r"\bCHOOSEROWS\(", "_xlfn.CHOOSEROWS(", formula)
        formula = re.sub(r"\bDROP\(", "_xlfn.DROP(", formula)
        formula = re.sub(r"\bEXPAND\(", "_xlfn.EXPAND(", formula)
        formula = re.sub(r"\bFILTER\(", "_xlfn._xlws.FILTER(", formula)
        formula = re.sub(r"\bHSTACK\(", "_xlfn.HSTACK(", formula)
        formula = re.sub(r"\bLAMBDA\(", "_xlfn.LAMBDA(", formula)
        formula = re.sub(r"\bMAKEARRAY\(", "_xlfn.MAKEARRAY(", formula)
        formula = re.sub(r"\bMAP\(", "_xlfn.MAP(", formula)
        formula = re.sub(r"\bRANDARRAY\(", "_xlfn.RANDARRAY(", formula)
        formula = re.sub(r"\bREDUCE\(", "_xlfn.REDUCE(", formula)
        formula = re.sub(r"\bSCAN\(", "_xlfn.SCAN(", formula)
        formula = re.sub(r"\SINGLE\(", "_xlfn.SINGLE(", formula)
        formula = re.sub(r"\bSEQUENCE\(", "_xlfn.SEQUENCE(", formula)
        formula = re.sub(r"\bSORT\(", "_xlfn._xlws.SORT(", formula)
        formula = re.sub(r"\bSORTBY\(", "_xlfn.SORTBY(", formula)
        formula = re.sub(r"\bSWITCH\(", "_xlfn.SWITCH(", formula)
        formula = re.sub(r"\bTAKE\(", "_xlfn.TAKE(", formula)
        formula = re.sub(r"\bTEXTSPLIT\(", "_xlfn.TEXTSPLIT(", formula)
        formula = re.sub(r"\bTOCOL\(", "_xlfn.TOCOL(", formula)
        formula = re.sub(r"\bTOROW\(", "_xlfn.TOROW(", formula)
        formula = re.sub(r"\bUNIQUE\(", "_xlfn.UNIQUE(", formula)
        formula = re.sub(r"\bVSTACK\(", "_xlfn.VSTACK(", formula)
        formula = re.sub(r"\bWRAPCOLS\(", "_xlfn.WRAPCOLS(", formula)
        formula = re.sub(r"\bWRAPROWS\(", "_xlfn.WRAPROWS(", formula)
        formula = re.sub(r"\bXLOOKUP\(", "_xlfn.XLOOKUP(", formula)

        if not self.use_future_functions and not expand_future_functions:
            return formula

        formula = re.sub(r"\bACOTH\(", "_xlfn.ACOTH(", formula)
        formula = re.sub(r"\bACOT\(", "_xlfn.ACOT(", formula)
        formula = re.sub(r"\bAGGREGATE\(", "_xlfn.AGGREGATE(", formula)
        formula = re.sub(r"\bARABIC\(", "_xlfn.ARABIC(", formula)
        formula = re.sub(r"\bARRAYTOTEXT\(", "_xlfn.ARRAYTOTEXT(", formula)
        formula = re.sub(r"\bBASE\(", "_xlfn.BASE(", formula)
        formula = re.sub(r"\bBETA.DIST\(", "_xlfn.BETA.DIST(", formula)
        formula = re.sub(r"\bBETA.INV\(", "_xlfn.BETA.INV(", formula)
        formula = re.sub(r"\bBINOM.DIST.RANGE\(", "_xlfn.BINOM.DIST.RANGE(", formula)
        formula = re.sub(r"\bBINOM.DIST\(", "_xlfn.BINOM.DIST(", formula)
        formula = re.sub(r"\bBINOM.INV\(", "_xlfn.BINOM.INV(", formula)
        formula = re.sub(r"\bBITAND\(", "_xlfn.BITAND(", formula)
        formula = re.sub(r"\bBITLSHIFT\(", "_xlfn.BITLSHIFT(", formula)
        formula = re.sub(r"\bBITOR\(", "_xlfn.BITOR(", formula)
        formula = re.sub(r"\bBITRSHIFT\(", "_xlfn.BITRSHIFT(", formula)
        formula = re.sub(r"\bBITXOR\(", "_xlfn.BITXOR(", formula)
        formula = re.sub(r"\bCEILING.MATH\(", "_xlfn.CEILING.MATH(", formula)
        formula = re.sub(r"\bCEILING.PRECISE\(", "_xlfn.CEILING.PRECISE(", formula)
        formula = re.sub(r"\bCHISQ.DIST.RT\(", "_xlfn.CHISQ.DIST.RT(", formula)
        formula = re.sub(r"\bCHISQ.DIST\(", "_xlfn.CHISQ.DIST(", formula)
        formula = re.sub(r"\bCHISQ.INV.RT\(", "_xlfn.CHISQ.INV.RT(", formula)
        formula = re.sub(r"\bCHISQ.INV\(", "_xlfn.CHISQ.INV(", formula)
        formula = re.sub(r"\bCHISQ.TEST\(", "_xlfn.CHISQ.TEST(", formula)
        formula = re.sub(r"\bCOMBINA\(", "_xlfn.COMBINA(", formula)
        formula = re.sub(r"\bCONCAT\(", "_xlfn.CONCAT(", formula)
        formula = re.sub(r"\bCONFIDENCE.NORM\(", "_xlfn.CONFIDENCE.NORM(", formula)
        formula = re.sub(r"\bCONFIDENCE.T\(", "_xlfn.CONFIDENCE.T(", formula)
        formula = re.sub(r"\bCOTH\(", "_xlfn.COTH(", formula)
        formula = re.sub(r"\bCOT\(", "_xlfn.COT(", formula)
        formula = re.sub(r"\bCOVARIANCE.P\(", "_xlfn.COVARIANCE.P(", formula)
        formula = re.sub(r"\bCOVARIANCE.S\(", "_xlfn.COVARIANCE.S(", formula)
        formula = re.sub(r"\bCSCH\(", "_xlfn.CSCH(", formula)
        formula = re.sub(r"\bCSC\(", "_xlfn.CSC(", formula)
        formula = re.sub(r"\bDAYS\(", "_xlfn.DAYS(", formula)
        formula = re.sub(r"\bDECIMAL\(", "_xlfn.DECIMAL(", formula)
        formula = re.sub(r"\bERF.PRECISE\(", "_xlfn.ERF.PRECISE(", formula)
        formula = re.sub(r"\bERFC.PRECISE\(", "_xlfn.ERFC.PRECISE(", formula)
        formula = re.sub(r"\bEXPON.DIST\(", "_xlfn.EXPON.DIST(", formula)
        formula = re.sub(r"\bF.DIST.RT\(", "_xlfn.F.DIST.RT(", formula)
        formula = re.sub(r"\bF.DIST\(", "_xlfn.F.DIST(", formula)
        formula = re.sub(r"\bF.INV.RT\(", "_xlfn.F.INV.RT(", formula)
        formula = re.sub(r"\bF.INV\(", "_xlfn.F.INV(", formula)
        formula = re.sub(r"\bF.TEST\(", "_xlfn.F.TEST(", formula)
        formula = re.sub(r"\bFILTERXML\(", "_xlfn.FILTERXML(", formula)
        formula = re.sub(r"\bFLOOR.MATH\(", "_xlfn.FLOOR.MATH(", formula)
        formula = re.sub(r"\bFLOOR.PRECISE\(", "_xlfn.FLOOR.PRECISE(", formula)
        formula = re.sub(
            r"\bFORECAST.ETS.CONFINT\(", "_xlfn.FORECAST.ETS.CONFINT(", formula
        )
        formula = re.sub(
            r"\bFORECAST.ETS.SEASONALITY\(", "_xlfn.FORECAST.ETS.SEASONALITY(", formula
        )
        formula = re.sub(r"\bFORECAST.ETS.STAT\(", "_xlfn.FORECAST.ETS.STAT(", formula)
        formula = re.sub(r"\bFORECAST.ETS\(", "_xlfn.FORECAST.ETS(", formula)
        formula = re.sub(r"\bFORECAST.LINEAR\(", "_xlfn.FORECAST.LINEAR(", formula)
        formula = re.sub(r"\bFORMULATEXT\(", "_xlfn.FORMULATEXT(", formula)
        formula = re.sub(r"\bGAMMA.DIST\(", "_xlfn.GAMMA.DIST(", formula)
        formula = re.sub(r"\bGAMMA.INV\(", "_xlfn.GAMMA.INV(", formula)
        formula = re.sub(r"\bGAMMALN.PRECISE\(", "_xlfn.GAMMALN.PRECISE(", formula)
        formula = re.sub(r"\bGAMMA\(", "_xlfn.GAMMA(", formula)
        formula = re.sub(r"\bGAUSS\(", "_xlfn.GAUSS(", formula)
        formula = re.sub(r"\bHYPGEOM.DIST\(", "_xlfn.HYPGEOM.DIST(", formula)
        formula = re.sub(r"\bIFNA\(", "_xlfn.IFNA(", formula)
        formula = re.sub(r"\bIFS\(", "_xlfn.IFS(", formula)
        formula = re.sub(r"\bIMAGE\(", "_xlfn.IMAGE(", formula)
        formula = re.sub(r"\bIMCOSH\(", "_xlfn.IMCOSH(", formula)
        formula = re.sub(r"\bIMCOT\(", "_xlfn.IMCOT(", formula)
        formula = re.sub(r"\bIMCSCH\(", "_xlfn.IMCSCH(", formula)
        formula = re.sub(r"\bIMCSC\(", "_xlfn.IMCSC(", formula)
        formula = re.sub(r"\bIMSECH\(", "_xlfn.IMSECH(", formula)
        formula = re.sub(r"\bIMSEC\(", "_xlfn.IMSEC(", formula)
        formula = re.sub(r"\bIMSINH\(", "_xlfn.IMSINH(", formula)
        formula = re.sub(r"\bIMTAN\(", "_xlfn.IMTAN(", formula)
        formula = re.sub(r"\bISFORMULA\(", "_xlfn.ISFORMULA(", formula)
        formula = re.sub(r"\bISOMITTED\(", "_xlfn.ISOMITTED(", formula)
        formula = re.sub(r"\bISOWEEKNUM\(", "_xlfn.ISOWEEKNUM(", formula)
        formula = re.sub(r"\bLET\(", "_xlfn.LET(", formula)
        formula = re.sub(r"\bLOGNORM.DIST\(", "_xlfn.LOGNORM.DIST(", formula)
        formula = re.sub(r"\bLOGNORM.INV\(", "_xlfn.LOGNORM.INV(", formula)
        formula = re.sub(r"\bMAXIFS\(", "_xlfn.MAXIFS(", formula)
        formula = re.sub(r"\bMINIFS\(", "_xlfn.MINIFS(", formula)
        formula = re.sub(r"\bMODE.MULT\(", "_xlfn.MODE.MULT(", formula)
        formula = re.sub(r"\bMODE.SNGL\(", "_xlfn.MODE.SNGL(", formula)
        formula = re.sub(r"\bMUNIT\(", "_xlfn.MUNIT(", formula)
        formula = re.sub(r"\bNEGBINOM.DIST\(", "_xlfn.NEGBINOM.DIST(", formula)
        formula = re.sub(r"\bNORM.DIST\(", "_xlfn.NORM.DIST(", formula)
        formula = re.sub(r"\bNORM.INV\(", "_xlfn.NORM.INV(", formula)
        formula = re.sub(r"\bNORM.S.DIST\(", "_xlfn.NORM.S.DIST(", formula)
        formula = re.sub(r"\bNORM.S.INV\(", "_xlfn.NORM.S.INV(", formula)
        formula = re.sub(r"\bNUMBERVALUE\(", "_xlfn.NUMBERVALUE(", formula)
        formula = re.sub(r"\bPDURATION\(", "_xlfn.PDURATION(", formula)
        formula = re.sub(r"\bPERCENTILE.EXC\(", "_xlfn.PERCENTILE.EXC(", formula)
        formula = re.sub(r"\bPERCENTILE.INC\(", "_xlfn.PERCENTILE.INC(", formula)
        formula = re.sub(r"\bPERCENTRANK.EXC\(", "_xlfn.PERCENTRANK.EXC(", formula)
        formula = re.sub(r"\bPERCENTRANK.INC\(", "_xlfn.PERCENTRANK.INC(", formula)
        formula = re.sub(r"\bPERMUTATIONA\(", "_xlfn.PERMUTATIONA(", formula)
        formula = re.sub(r"\bPHI\(", "_xlfn.PHI(", formula)
        formula = re.sub(r"\bPOISSON.DIST\(", "_xlfn.POISSON.DIST(", formula)
        formula = re.sub(r"\bQUARTILE.EXC\(", "_xlfn.QUARTILE.EXC(", formula)
        formula = re.sub(r"\bQUARTILE.INC\(", "_xlfn.QUARTILE.INC(", formula)
        formula = re.sub(r"\bQUERYSTRING\(", "_xlfn.QUERYSTRING(", formula)
        formula = re.sub(r"\bRANK.AVG\(", "_xlfn.RANK.AVG(", formula)
        formula = re.sub(r"\bRANK.EQ\(", "_xlfn.RANK.EQ(", formula)
        formula = re.sub(r"\bRRI\(", "_xlfn.RRI(", formula)
        formula = re.sub(r"\bSECH\(", "_xlfn.SECH(", formula)
        formula = re.sub(r"\bSEC\(", "_xlfn.SEC(", formula)
        formula = re.sub(r"\bSHEETS\(", "_xlfn.SHEETS(", formula)
        formula = re.sub(r"\bSHEET\(", "_xlfn.SHEET(", formula)
        formula = re.sub(r"\bSKEW.P\(", "_xlfn.SKEW.P(", formula)
        formula = re.sub(r"\bSTDEV.P\(", "_xlfn.STDEV.P(", formula)
        formula = re.sub(r"\bSTDEV.S\(", "_xlfn.STDEV.S(", formula)
        formula = re.sub(r"\bT.DIST.2T\(", "_xlfn.T.DIST.2T(", formula)
        formula = re.sub(r"\bT.DIST.RT\(", "_xlfn.T.DIST.RT(", formula)
        formula = re.sub(r"\bT.DIST\(", "_xlfn.T.DIST(", formula)
        formula = re.sub(r"\bT.INV.2T\(", "_xlfn.T.INV.2T(", formula)
        formula = re.sub(r"\bT.INV\(", "_xlfn.T.INV(", formula)
        formula = re.sub(r"\bT.TEST\(", "_xlfn.T.TEST(", formula)
        formula = re.sub(r"\bTEXTAFTER\(", "_xlfn.TEXTAFTER(", formula)
        formula = re.sub(r"\bTEXTBEFORE\(", "_xlfn.TEXTBEFORE(", formula)
        formula = re.sub(r"\bTEXTJOIN\(", "_xlfn.TEXTJOIN(", formula)
        formula = re.sub(r"\bUNICHAR\(", "_xlfn.UNICHAR(", formula)
        formula = re.sub(r"\bUNICODE\(", "_xlfn.UNICODE(", formula)
        formula = re.sub(r"\bVALUETOTEXT\(", "_xlfn.VALUETOTEXT(", formula)
        formula = re.sub(r"\bVAR.P\(", "_xlfn.VAR.P(", formula)
        formula = re.sub(r"\bVAR.S\(", "_xlfn.VAR.S(", formula)
        formula = re.sub(r"\bWEBSERVICE\(", "_xlfn.WEBSERVICE(", formula)
        formula = re.sub(r"\bWEIBULL.DIST\(", "_xlfn.WEIBULL.DIST(", formula)
        formula = re.sub(r"\bXMATCH\(", "_xlfn.XMATCH(", formula)
        formula = re.sub(r"\bXOR\(", "_xlfn.XOR(", formula)
        formula = re.sub(r"\bZ.TEST\(", "_xlfn.Z.TEST(", formula)

        return formula

    # Undecorated version of write_array_formula() and
    # write_dynamic_array_formula().
    def _write_array_formula(
        self,
        first_row,
        first_col,
        last_row,
        last_col,
        formula,
        cell_format=None,
        value=0,
        atype="static",
    ):
        # Swap last row/col with first row/col as necessary.
        if first_row > last_row:
            first_row, last_row = last_row, first_row
        if first_col > last_col:
            first_col, last_col = last_col, first_col

        # Check that row and col are valid and store max and min values.
        if self._check_dimensions(first_row, first_col):
            return -1
        if self._check_dimensions(last_row, last_col):
            return -1

        # Define array range
        if first_row == last_row and first_col == last_col:
            cell_range = xl_rowcol_to_cell(first_row, first_col)
        else:
            cell_range = (
                xl_rowcol_to_cell(first_row, first_col)
                + ":"
                + xl_rowcol_to_cell(last_row, last_col)
            )

        # Modify the formula string, as needed.
        formula = self._prepare_formula(formula)

        # Write previous row if in in-line string constant_memory mode.
        if self.constant_memory and first_row > self.previous_row:
            self._write_single_row(first_row)

        # Store the cell data in the worksheet data table.
        self.table[first_row][first_col] = cell_arformula_tuple(
            formula, cell_format, value, cell_range, atype
        )

        # Pad out the rest of the area with formatted zeroes.
        if not self.constant_memory:
            for row in range(first_row, last_row + 1):
                for col in range(first_col, last_col + 1):
                    if row != first_row or col != first_col:
                        self._write_number(row, col, 0, cell_format)

        return 0

    @convert_cell_args
    def write_datetime(self, row, col, date, cell_format=None):
        """
        Write a date or time to a worksheet cell.

        Args:
            row:         The cell row (zero indexed).
            col:         The cell column (zero indexed).
            date:        Date and/or time as a datetime object.
            cell_format: A cell Format object.

        Returns:
            0:  Success.
            -1: Row or column is out of worksheet bounds.

        """
        return self._write_datetime(row, col, date, cell_format)

    # Undecorated version of write_datetime().
    def _write_datetime(self, row, col, date, cell_format=None):
        # Check that row and col are valid and store max and min values.
        if self._check_dimensions(row, col):
            return -1

        # Write previous row if in in-line string constant_memory mode.
        if self.constant_memory and row > self.previous_row:
            self._write_single_row(row)

        # Convert datetime to an Excel date.
        number = self._convert_date_time(date)

        # Add the default date format.
        if cell_format is None:
            cell_format = self.default_date_format

        # Store the cell data in the worksheet data table.
        self.table[row][col] = cell_datetime_tuple(number, cell_format)

        return 0

    @convert_cell_args
    def write_boolean(self, row, col, boolean, cell_format=None):
        """
        Write a boolean value to a worksheet cell.

        Args:
            row:         The cell row (zero indexed).
            col:         The cell column (zero indexed).
            boolean:     Cell data. bool type.
            cell_format: An optional cell Format object.

        Returns:
            0:  Success.
            -1: Row or column is out of worksheet bounds.

        """
        return self._write_boolean(row, col, boolean, cell_format)

    # Undecorated version of write_boolean().
    def _write_boolean(self, row, col, boolean, cell_format=None):
        # Check that row and col are valid and store max and min values.
        if self._check_dimensions(row, col):
            return -1

        # Write previous row if in in-line string constant_memory mode.
        if self.constant_memory and row > self.previous_row:
            self._write_single_row(row)

        if boolean:
            value = 1
        else:
            value = 0

        # Store the cell data in the worksheet data table.
        self.table[row][col] = cell_boolean_tuple(value, cell_format)

        return 0

    # Write a hyperlink. This is comprised of two elements: the displayed
    # string and the non-displayed link. The displayed string is the same as
    # the link unless an alternative string is specified. The display string
    # is written using the write_string() method. Therefore the max characters
    # string limit applies.
    #
    # The hyperlink can be to a http, ftp, mail, internal sheet, or external
    # directory urls.
    @convert_cell_args
    def write_url(self, row, col, url, cell_format=None, string=None, tip=None):
        """
        Write a hyperlink to a worksheet cell.

        Args:
            row:    The cell row (zero indexed).
            col:    The cell column (zero indexed).
            url:    Hyperlink url.
            format: An optional cell Format object.
            string: An optional display string for the hyperlink.
            tip:    An optional tooltip.
        Returns:
            0:  Success.
            -1: Row or column is out of worksheet bounds.
            -2: String longer than 32767 characters.
            -3: URL longer than Excel limit of 255 characters.
            -4: Exceeds Excel limit of 65,530 urls per worksheet.
        """
        return self._write_url(row, col, url, cell_format, string, tip)

    # Undecorated version of write_url().
    def _write_url(self, row, col, url, cell_format=None, string=None, tip=None):
        # Check that row and col are valid and store max and min values
        if self._check_dimensions(row, col):
            return -1

        # Set the displayed string to the URL unless defined by the user.
        if string is None:
            string = url

        # Default to external link type such as 'http://' or 'external:'.
        link_type = 1

        # Remove the URI scheme from internal links.
        if url.startswith("internal:"):
            url = url.replace("internal:", "")
            string = string.replace("internal:", "")
            link_type = 2

        # Remove the URI scheme from external links and change the directory
        # separator from Unix to Dos.
        external = False
        if url.startswith("external:"):
            url = url.replace("external:", "")
            url = url.replace("/", "\\")
            string = string.replace("external:", "")
            string = string.replace("/", "\\")
            external = True

        # Strip the mailto header.
        string = string.replace("mailto:", "")

        # Check that the string is < 32767 chars
        str_error = 0
        if len(string) > self.xls_strmax:
            warn(
                "Ignoring URL since it exceeds Excel's string limit of "
                "32767 characters"
            )
            return -2

        # Copy string for use in hyperlink elements.
        url_str = string

        # External links to URLs and to other Excel workbooks have slightly
        # different characteristics that we have to account for.
        if link_type == 1:
            # Split url into the link and optional anchor/location.
            if "#" in url:
                url, url_str = url.split("#", 1)
            else:
                url_str = None

            url = self._escape_url(url)

            if url_str is not None and not external:
                url_str = self._escape_url(url_str)

            # Add the file:/// URI to the url for Windows style "C:/" link and
            # Network shares.
            if re.match(r"\w:", url) or re.match(r"\\", url):
                url = "file:///" + url

            # Convert a .\dir\file.xlsx link to dir\file.xlsx.
            url = re.sub(r"^\.\\", "", url)

        # Excel limits the escaped URL and location/anchor to 255 characters.
        tmp_url_str = url_str or ""
        max_url = self.max_url_length
        if len(url) > max_url or len(tmp_url_str) > max_url:
            warn(
                "Ignoring URL '%s' with link or location/anchor > %d "
                "characters since it exceeds Excel's limit for URLS" % (url, max_url)
            )
            return -3

        # Check the limit of URLS per worksheet.
        self.hlink_count += 1

        if self.hlink_count > 65530:
            warn(
                "Ignoring URL '%s' since it exceeds Excel's limit of "
                "65,530 URLS per worksheet." % url
            )
            return -4

        # Add the default URL format.
        if cell_format is None:
            cell_format = self.default_url_format

        if not self.ignore_write_string:
            # Write previous row if in in-line string constant_memory mode.
            if self.constant_memory and row > self.previous_row:
                self._write_single_row(row)

            # Write the hyperlink string.
            self._write_string(row, col, string, cell_format)

        # Store the hyperlink data in a separate structure.
        self.hyperlinks[row][col] = {
            "link_type": link_type,
            "url": url,
            "str": url_str,
            "tip": tip,
        }

        return str_error

    @convert_cell_args
    def write_rich_string(self, row, col, *args):
        """
        Write a "rich" string with multiple formats to a worksheet cell.

        Args:
            row:          The cell row (zero indexed).
            col:          The cell column (zero indexed).
            string_parts: String and format pairs.
            cell_format:  Optional Format object.

        Returns:
            0:  Success.
            -1: Row or column is out of worksheet bounds.
            -2: String truncated to 32k characters.
            -3: 2 consecutive formats used.
            -4: Empty string used.
            -5: Insufficient parameters.

        """

        return self._write_rich_string(row, col, *args)

    # Undecorated version of write_rich_string().
    def _write_rich_string(self, row, col, *args):
        tokens = list(args)
        cell_format = None
        string_index = 0
        raw_string = ""

        # Check that row and col are valid and store max and min values
        if self._check_dimensions(row, col):
            return -1

        # If the last arg is a format we use it as the cell format.
        if isinstance(tokens[-1], Format):
            cell_format = tokens.pop()

        # Create a temp XMLWriter object and use it to write the rich string
        # XML to a string.
        fh = StringIO()
        self.rstring = XMLwriter()
        self.rstring._set_filehandle(fh)

        # Create a temp format with the default font for unformatted fragments.
        default = Format()

        # Convert list of format, string tokens to pairs of (format, string)
        # except for the first string fragment which doesn't require a default
        # formatting run. Use the default for strings without a leading format.
        fragments = []
        previous = "format"
        pos = 0

        if len(tokens) <= 2:
            warn(
                "You must specify more than 2 format/fragments for rich "
                "strings. Ignoring input in write_rich_string()."
            )
            return -5

        for token in tokens:
            if not isinstance(token, Format):
                # Token is a string.
                if previous != "format":
                    # If previous token wasn't a format add one before string.
                    fragments.append(default)
                    fragments.append(token)
                else:
                    # If previous token was a format just add the string.
                    fragments.append(token)

                if token == "":
                    warn(
                        "Excel doesn't allow empty strings in rich strings. "
                        "Ignoring input in write_rich_string()."
                    )
                    return -4

                # Keep track of unformatted string.
                raw_string += token
                previous = "string"
            else:
                # Can't allow 2 formats in a row.
                if previous == "format" and pos > 0:
                    warn(
                        "Excel doesn't allow 2 consecutive formats in rich "
                        "strings. Ignoring input in write_rich_string()."
                    )
                    return -3

                # Token is a format object. Add it to the fragment list.
                fragments.append(token)
                previous = "format"

            pos += 1

        # If the first token is a string start the <r> element.
        if not isinstance(fragments[0], Format):
            self.rstring._xml_start_tag("r")

        # Write the XML elements for the $format $string fragments.
        for token in fragments:
            if isinstance(token, Format):
                # Write the font run.
                self.rstring._xml_start_tag("r")
                self._write_font(token)
            else:
                # Write the string fragment part, with whitespace handling.
                attributes = []

                if preserve_whitespace(token):
                    attributes.append(("xml:space", "preserve"))

                self.rstring._xml_data_element("t", token, attributes)
                self.rstring._xml_end_tag("r")

        # Read the in-memory string.
        string = self.rstring.fh.getvalue()

        # Check that the string is < 32767 chars.
        if len(raw_string) > self.xls_strmax:
            warn(
                "String length must be less than or equal to Excel's limit "
                "of 32,767 characters in write_rich_string()."
            )
            return -2

        # Write a shared string or an in-line string in constant_memory mode.
        if not self.constant_memory:
            string_index = self.str_table._get_shared_string_index(string)
        else:
            string_index = string

        # Write previous row if in in-line string constant_memory mode.
        if self.constant_memory and row > self.previous_row:
            self._write_single_row(row)

        # Store the cell data in the worksheet data table.
        self.table[row][col] = cell_rich_string_tuple(
            string_index, cell_format, raw_string
        )

        return 0

    def add_write_handler(self, user_type, user_function):
        """
        Add a callback function to the write() method to handle user defined
        types.

        Args:
            user_type:      The user type() to match on.
            user_function:  The user defined function to write the type data.
        Returns:
            Nothing.

        """

        self.write_handlers[user_type] = user_function

    @convert_cell_args
    def write_row(self, row, col, data, cell_format=None):
        """
        Write a row of data starting from (row, col).

        Args:
            row:    The cell row (zero indexed).
            col:    The cell column (zero indexed).
            data:   A list of tokens to be written with write().
            format: An optional cell Format object.
        Returns:
            0:  Success.
            other: Return value of write() method.

        """
        for token in data:
            error = self._write(row, col, token, cell_format)
            if error:
                return error
            col += 1

        return 0

    @convert_cell_args
    def write_column(self, row, col, data, cell_format=None):
        """
        Write a column of data starting from (row, col).

        Args:
            row:    The cell row (zero indexed).
            col:    The cell column (zero indexed).
            data:   A list of tokens to be written with write().
            format: An optional cell Format object.
        Returns:
            0:  Success.
            other: Return value of write() method.

        """
        for token in data:
            error = self._write(row, col, token, cell_format)
            if error:
                return error
            row += 1

        return 0

    @convert_cell_args
    def insert_image(self, row, col, filename, options=None):
        """
        Insert an image with its top-left corner in a worksheet cell.

        Args:
            row:      The cell row (zero indexed).
            col:      The cell column (zero indexed).
            filename: Path and filename for in supported formats.
            options:  Position, scale, url and data stream of the image.

        Returns:
            0:  Success.
            -1: Row or column is out of worksheet bounds.

        """
        # Check insert (row, col) without storing.
        if self._check_dimensions(row, col, True, True):
            warn("Cannot insert image at (%d, %d)." % (row, col))
            return -1

        if options is None:
            options = {}

        x_offset = options.get("x_offset", 0)
        y_offset = options.get("y_offset", 0)
        x_scale = options.get("x_scale", 1)
        y_scale = options.get("y_scale", 1)
        url = options.get("url", None)
        tip = options.get("tip", None)
        anchor = options.get("object_position", 2)
        image_data = options.get("image_data", None)
        description = options.get("description", None)
        decorative = options.get("decorative", False)

        # For backward compatibility with older parameter name.
        anchor = options.get("positioning", anchor)

        if not image_data and not os.path.exists(filename):
            warn("Image file '%s' not found." % filename)
            return -1

        self.images.append(
            [
                row,
                col,
                filename,
                x_offset,
                y_offset,
                x_scale,
                y_scale,
                url,
                tip,
                anchor,
                image_data,
                description,
                decorative,
            ]
        )
        return 0

    @convert_cell_args
    def embed_image(self, row, col, filename, options=None):
        """
        Embed an image in a worksheet cell.

        Args:
            row:      The cell row (zero indexed).
            col:      The cell column (zero indexed).
            filename: Path and filename for in supported formats.
            options:  Url and data stream of the image.

        Returns:
            0:  Success.
            -1: Row or column is out of worksheet bounds.

        """
        # Check insert (row, col) without storing.
        if self._check_dimensions(row, col):
            warn("Cannot embed image at (%d, %d)." % (row, col))
            return -1

        if options is None:
            options = {}

        url = options.get("url", None)
        tip = options.get("tip", None)
        cell_format = options.get("cell_format", None)
        image_data = options.get("image_data", None)
        description = options.get("description", None)
        decorative = options.get("decorative", False)

        if not image_data and not os.path.exists(filename):
            warn("Image file '%s' not found." % filename)
            return -1

        if url:
            if cell_format is None:
                cell_format = self.default_url_format

            self.ignore_write_string = True
            self.write_url(row, col, url, cell_format, None, tip)
            self.ignore_write_string = False

        # Get the image properties, for the type and checksum.
        (
            image_type,
            _,
            _,
            _,
            _,
            _,
            digest,
        ) = get_image_properties(filename, image_data)

        image = [filename, image_type, image_data, description, decorative]
        image_index = self.embedded_images.get_image_index(image, digest)

        # Store the cell error and image index in the worksheet data table.
        self.table[row][col] = cell_error_tuple("#VALUE!", cell_format, image_index)

        return 0

    @convert_cell_args
    def insert_textbox(self, row, col, text, options=None):
        """
        Insert an textbox with its top-left corner in a worksheet cell.

        Args:
            row:      The cell row (zero indexed).
            col:      The cell column (zero indexed).
            text:     The text for the textbox.
            options:  Textbox options.

        Returns:
            0:  Success.
            -1: Row or column is out of worksheet bounds.

        """
        # Check insert (row, col) without storing.
        if self._check_dimensions(row, col, True, True):
            warn("Cannot insert textbox at (%d, %d)." % (row, col))
            return -1

        if text is None:
            text = ""

        if options is None:
            options = {}

        x_offset = options.get("x_offset", 0)
        y_offset = options.get("y_offset", 0)
        x_scale = options.get("x_scale", 1)
        y_scale = options.get("y_scale", 1)
        anchor = options.get("object_position", 1)
        description = options.get("description", None)
        decorative = options.get("decorative", False)

        self.shapes.append(
            [
                row,
                col,
                x_offset,
                y_offset,
                x_scale,
                y_scale,
                text,
                anchor,
                options,
                description,
                decorative,
            ]
        )
        return 0

    @convert_cell_args
    def insert_chart(self, row, col, chart, options=None):
        """
        Insert an chart with its top-left corner in a worksheet cell.

        Args:
            row:     The cell row (zero indexed).
            col:     The cell column (zero indexed).
            chart:   Chart object.
            options: Position and scale of the chart.

        Returns:
            0:  Success.
            -1: Row or column is out of worksheet bounds.

        """
        # Check insert (row, col) without storing.
        if self._check_dimensions(row, col, True, True):
            warn("Cannot insert chart at (%d, %d)." % (row, col))
            return -1

        if options is None:
            options = {}

        # Ensure a chart isn't inserted more than once.
        if chart.already_inserted or chart.combined and chart.combined.already_inserted:
            warn("Chart cannot be inserted in a worksheet more than once.")
            return
        else:
            chart.already_inserted = True

            if chart.combined:
                chart.combined.already_inserted = True

        x_offset = options.get("x_offset", 0)
        y_offset = options.get("y_offset", 0)
        x_scale = options.get("x_scale", 1)
        y_scale = options.get("y_scale", 1)
        anchor = options.get("object_position", 1)
        description = options.get("description", None)
        decorative = options.get("decorative", False)

        # Allow Chart to override the scale and offset.
        if chart.x_scale != 1:
            x_scale = chart.x_scale

        if chart.y_scale != 1:
            y_scale = chart.y_scale

        if chart.x_offset:
            x_offset = chart.x_offset

        if chart.y_offset:
            y_offset = chart.y_offset

        self.charts.append(
            [
                row,
                col,
                chart,
                x_offset,
                y_offset,
                x_scale,
                y_scale,
                anchor,
                description,
                decorative,
            ]
        )
        return 0

    @convert_cell_args
    def write_comment(self, row, col, comment, options=None):
        """
        Write a comment to a worksheet cell.

        Args:
            row:     The cell row (zero indexed).
            col:     The cell column (zero indexed).
            comment: Cell comment. Str.
            options: Comment formatting options.

        Returns:
            0:  Success.
            -1: Row or column is out of worksheet bounds.
            -2: String longer than 32k characters.

        """
        if options is None:
            options = {}

        # Check that row and col are valid and store max and min values
        if self._check_dimensions(row, col):
            return -1

        # Check that the comment string is < 32767 chars.
        if len(comment) > self.xls_strmax:
            return -2

        self.has_vml = 1
        self.has_comments = 1

        # Store the options of the cell comment, to process on file close.
        self.comments[row][col] = [row, col, comment, options]

        return 0

    def show_comments(self):
        """
        Make any comments in the worksheet visible.

        Args:
            None.

        Returns:
            Nothing.

        """
        self.comments_visible = 1

    def set_background(self, filename, is_byte_stream=False):
        """
        Set a background image for a worksheet.

        Args:
            filename:       Path and filename for in supported formats.
            is_byte_stream: File is a stream of bytes.
        Returns:
            Nothing.

        """

        if not is_byte_stream and not os.path.exists(filename):
            warn("Image file '%s' not found." % filename)
            return -1

        self.background_bytes = is_byte_stream
        self.background_image = filename

    def set_comments_author(self, author):
        """
        Set the default author of the cell comments.

        Args:
            author: Comment author name. String.

        Returns:
            Nothing.

        """
        self.comments_author = author

    def get_name(self):
        """
        Retrieve the worksheet name.

        Args:
            None.

        Returns:
            Nothing.

        """
        # There is no set_name() method. Name must be set in add_worksheet().
        return self.name

    def activate(self):
        """
        Set this worksheet as the active worksheet, i.e. the worksheet that is
        displayed when the workbook is opened. Also set it as selected.

        Note: An active worksheet cannot be hidden.

        Args:
            None.

        Returns:
            Nothing.

        """
        self.hidden = 0
        self.selected = 1
        self.worksheet_meta.activesheet = self.index

    def select(self):
        """
        Set current worksheet as a selected worksheet, i.e. the worksheet
        has its tab highlighted.

        Note: A selected worksheet cannot be hidden.

        Args:
            None.

        Returns:
            Nothing.

        """
        self.selected = 1
        self.hidden = 0

    def hide(self):
        """
        Hide the current worksheet.

        Args:
            None.

        Returns:
            Nothing.

        """
        self.hidden = 1

        # A hidden worksheet shouldn't be active or selected.
        self.selected = 0

    def very_hidden(self):
        """
        Hide the current worksheet. This can only be unhidden by VBA.

        Args:
            None.

        Returns:
            Nothing.

        """
        self.hidden = 2

        # A hidden worksheet shouldn't be active or selected.
        self.selected = 0

    def set_first_sheet(self):
        """
        Set current worksheet as the first visible sheet. This is necessary
        when there are a large number of worksheets and the activated
        worksheet is not visible on the screen.

        Note: A selected worksheet cannot be hidden.

        Args:
            None.

        Returns:
            Nothing.

        """
        self.hidden = 0  # Active worksheet can't be hidden.
        self.worksheet_meta.firstsheet = self.index

    @convert_column_args
    def set_column(
        self, first_col, last_col, width=None, cell_format=None, options=None
    ):
        """
        Set the width, and other properties of a single column or a
        range of columns.

        Args:
            first_col:   First column (zero-indexed).
            last_col:    Last column (zero-indexed). Can be same as first_col.
            width:       Column width. (optional).
            cell_format: Column cell_format. (optional).
            options:     Dict of options such as hidden and level.

        Returns:
            0:  Success.
            -1: Column number is out of worksheet bounds.

        """
        if options is None:
            options = {}

        # Ensure 2nd col is larger than first.
        if first_col > last_col:
            (first_col, last_col) = (last_col, first_col)

        # Don't modify the row dimensions when checking the columns.
        ignore_row = True

        # Set optional column values.
        hidden = options.get("hidden", False)
        collapsed = options.get("collapsed", False)
        level = options.get("level", 0)

        # Store the column dimension only in some conditions.
        if cell_format or (width and hidden):
            ignore_col = False
        else:
            ignore_col = True

        # Check that each column is valid and store the max and min values.
        if self._check_dimensions(0, last_col, ignore_row, ignore_col):
            return -1
        if self._check_dimensions(0, first_col, ignore_row, ignore_col):
            return -1

        # Set the limits for the outline levels (0 <= x <= 7).
        if level < 0:
            level = 0
        if level > 7:
            level = 7

        if level > self.outline_col_level:
            self.outline_col_level = level

        # Store the column data.
        for col in range(first_col, last_col + 1):
            self.col_info[col] = [width, cell_format, hidden, level, collapsed, False]

        # Store the column change to allow optimizations.
        self.col_size_changed = True

        return 0

    @convert_column_args
    def set_column_pixels(
        self, first_col, last_col, width=None, cell_format=None, options=None
    ):
        """
        Set the width, and other properties of a single column or a
        range of columns, where column width is in pixels.

        Args:
            first_col:   First column (zero-indexed).
            last_col:    Last column (zero-indexed). Can be same as first_col.
            width:       Column width in pixels. (optional).
            cell_format: Column cell_format. (optional).
            options:     Dict of options such as hidden and level.

        Returns:
            0:  Success.
            -1: Column number is out of worksheet bounds.

        """
        if width is not None:
            width = self._pixels_to_width(width)

        return self.set_column(first_col, last_col, width, cell_format, options)

    def autofit(self):
        """
        Simulate autofit based on the data, and datatypes in each column.

        Args:
            None.

        Returns:
            Nothing.

        """
        if self.constant_memory:
            warn("Autofit is not supported in constant_memory mode.")
            return

        # No data written to the target sheet; nothing to autofit
        if self.dim_rowmax is None:
            return

        # Store the max pixel width for each column.
        col_width_max = {}

        # Create a reverse lookup for the share strings table so we can convert
        # the string id back to the original string.
        strings = sorted(
            self.str_table.string_table, key=self.str_table.string_table.__getitem__
        )

        for row_num in range(self.dim_rowmin, self.dim_rowmax + 1):
            if not self.table.get(row_num):
                continue

            for col_num in range(self.dim_colmin, self.dim_colmax + 1):
                if col_num in self.table[row_num]:
                    cell = self.table[row_num][col_num]
                    cell_type = cell.__class__.__name__
                    length = 0

                    if cell_type in ("String", "RichString"):
                        # Handle strings and rich strings.
                        #
                        # For standard shared strings we do a reverse lookup
                        # from the shared string id to the actual string. For
                        # rich strings we use the unformatted string. We also
                        # split multi-line strings and handle each part
                        # separately.
                        if cell_type == "String":
                            string_id = cell.string
                            string = strings[string_id]
                        else:
                            string = cell.raw_string

                        if "\n" not in string:
                            # Single line string.
                            length = xl_pixel_width(string)
                        else:
                            # Handle multi-line strings.
                            for string in string.split("\n"):
                                seg_length = xl_pixel_width(string)
                                if seg_length > length:
                                    length = seg_length

                    elif cell_type == "Number":
                        # Handle numbers.
                        #
                        # We use a workaround/optimization for numbers since
                        # digits all have a pixel width of 7. This gives a
                        # slightly greater width for the decimal place and
                        # minus sign but only by a few pixels and
                        # over-estimation is okay.
                        length = 7 * len(str(cell.number))

                    elif cell_type == "Datetime":
                        # Handle dates.
                        #
                        # The following uses the default width for mm/dd/yyyy
                        # dates. It isn't feasible to parse the number format
                        # to get the actual string width for all format types.
                        length = self.default_date_pixels

                    elif cell_type == "Boolean":
                        # Handle boolean values.
                        #
                        # Use the Excel standard widths for TRUE and FALSE.
                        if cell.boolean:
                            length = 31
                        else:
                            length = 36

                    elif cell_type == "Formula" or cell_type == "ArrayFormula":
                        # Handle formulas.
                        #
                        # We only try to autofit a formula if it has a
                        # non-zero value.
                        if isinstance(cell.value, (float, int)):
                            if cell.value > 0:
                                length = 7 * len(str(cell.value))

                        elif isinstance(cell.value, str):
                            length = xl_pixel_width(cell.value)

                        elif isinstance(cell.value, bool):
                            if cell.value:
                                length = 31
                            else:
                                length = 36

                    # If the cell is in an autofilter header we add an
                    # additional 16 pixels for the dropdown arrow.
                    if self.filter_cells.get((row_num, col_num)) and length > 0:
                        length += 16

                    # Add the string length to the lookup table.
                    width_max = col_width_max.get(col_num, 0)
                    if length > width_max:
                        col_width_max[col_num] = length

        # Apply the width to the column.
        for col_num, pixel_width in col_width_max.items():
            # Convert the string pixel width to a character width using an
            # additional padding of 7 pixels, like Excel.
            width = self._pixels_to_width(pixel_width + 7)

            # The max column character width in Excel is 255.
            if width > 255.0:
                width = 255.0

            # Add the width to an existing col info structure or add a new one.
            if self.col_info.get(col_num):
                # We only update the width for an existing column if it is
                # greater than the user defined value. This allows the user
                # to pre-load a minimum col width.
                col_info = self.col_info.get(col_num)
                user_width = col_info[0]
                hidden = col_info[5]
                if user_width is not None and not hidden:
                    # Col info is user defined.
                    if width > user_width:
                        self.col_info[col_num][0] = width
                        self.col_info[col_num][5] = True
                else:
                    self.col_info[col_num][0] = width
                    self.col_info[col_num][5] = True
            else:
                self.col_info[col_num] = [width, None, False, 0, False, True]

    def set_row(self, row, height=None, cell_format=None, options=None):
        """
        Set the width, and other properties of a row.

        Args:
            row:         Row number (zero-indexed).
            height:      Row height. (optional).
            cell_format: Row cell_format. (optional).
            options:     Dict of options such as hidden, level and collapsed.

        Returns:
            0:  Success.
            -1: Row number is out of worksheet bounds.

        """
        if options is None:
            options = {}

        # Use minimum col in _check_dimensions().
        if self.dim_colmin is not None:
            min_col = self.dim_colmin
        else:
            min_col = 0

        # Check that row is valid.
        if self._check_dimensions(row, min_col):
            return -1

        if height is None:
            height = self.default_row_height

        # Set optional row values.
        hidden = options.get("hidden", False)
        collapsed = options.get("collapsed", False)
        level = options.get("level", 0)

        # If the height is 0 the row is hidden and the height is the default.
        if height == 0:
            hidden = 1
            height = self.default_row_height

        # Set the limits for the outline levels (0 <= x <= 7).
        if level < 0:
            level = 0
        if level > 7:
            level = 7

        if level > self.outline_row_level:
            self.outline_row_level = level

        # Store the row properties.
        self.set_rows[row] = [height, cell_format, hidden, level, collapsed]

        # Store the row change to allow optimizations.
        self.row_size_changed = True

        # Store the row sizes for use when calculating image vertices.
        self.row_sizes[row] = [height, hidden]

        return 0

    def set_row_pixels(self, row, height=None, cell_format=None, options=None):
        """
        Set the width (in pixels), and other properties of a row.

        Args:
            row:         Row number (zero-indexed).
            height:      Row height in pixels. (optional).
            cell_format: Row cell_format. (optional).
            options:     Dict of options such as hidden, level and collapsed.

        Returns:
            0:  Success.
            -1: Row number is out of worksheet bounds.

        """
        if height is not None:
            height = self._pixels_to_height(height)

        return self.set_row(row, height, cell_format, options)

    def set_default_row(self, height=None, hide_unused_rows=False):
        """
        Set the default row properties.

        Args:
            height:           Default height. Optional, defaults to 15.
            hide_unused_rows: Hide unused rows. Optional, defaults to False.

        Returns:
            Nothing.

        """
        if height is None:
            height = self.default_row_height

        if height != self.original_row_height:
            # Store the row change to allow optimizations.
            self.row_size_changed = True
            self.default_row_height = height

        if hide_unused_rows:
            self.default_row_zeroed = 1

    @convert_range_args
    def merge_range(
        self, first_row, first_col, last_row, last_col, data, cell_format=None
    ):
        """
        Merge a range of cells.

        Args:
            first_row:    The first row of the cell range. (zero indexed).
            first_col:    The first column of the cell range.
            last_row:     The last row of the cell range. (zero indexed).
            last_col:     The last column of the cell range.
            data:         Cell data.
            cell_format:  Cell Format object.

        Returns:
             0:    Success.
            -1:    Row or column is out of worksheet bounds.
            other: Return value of write().

        """
        # Merge a range of cells. The first cell should contain the data and
        # the others should be blank. All cells should have the same format.

        # Excel doesn't allow a single cell to be merged
        if first_row == last_row and first_col == last_col:
            warn("Can't merge single cell")
            return

        # Swap last row/col with first row/col as necessary
        if first_row > last_row:
            (first_row, last_row) = (last_row, first_row)
        if first_col > last_col:
            (first_col, last_col) = (last_col, first_col)

        # Check that row and col are valid and store max and min values.
        if self._check_dimensions(first_row, first_col):
            return -1
        if self._check_dimensions(last_row, last_col):
            return -1

        # Check if the merge range overlaps a previous merged or table range.
        # This is a critical file corruption error in Excel.
        cell_range = xl_range(first_row, first_col, last_row, last_col)
        for row in range(first_row, last_row + 1):
            for col in range(first_col, last_col + 1):
                if self.merged_cells.get((row, col)):
                    previous_range = self.merged_cells.get((row, col))
                    raise OverlappingRange(
                        "Merge range '%s' overlaps previous merge range '%s'."
                        % (cell_range, previous_range)
                    )
                elif self.table_cells.get((row, col)):
                    previous_range = self.table_cells.get((row, col))
                    raise OverlappingRange(
                        "Merge range '%s' overlaps previous table range '%s'."
                        % (cell_range, previous_range)
                    )
                else:
                    self.merged_cells[(row, col)] = cell_range

        # Store the merge range.
        self.merge.append([first_row, first_col, last_row, last_col])

        # Write the first cell
        self._write(first_row, first_col, data, cell_format)

        # Pad out the rest of the area with formatted blank cells.
        for row in range(first_row, last_row + 1):
            for col in range(first_col, last_col + 1):
                if row == first_row and col == first_col:
                    continue
                self._write_blank(row, col, "", cell_format)

        return 0

    @convert_range_args
    def autofilter(self, first_row, first_col, last_row, last_col):
        """
        Set the autofilter area in the worksheet.

        Args:
            first_row:    The first row of the cell range. (zero indexed).
            first_col:    The first column of the cell range.
            last_row:     The last row of the cell range. (zero indexed).
            last_col:     The last column of the cell range.

        Returns:
             Nothing.

        """
        # Reverse max and min values if necessary.
        if last_row < first_row:
            (first_row, last_row) = (last_row, first_row)
        if last_col < first_col:
            (first_col, last_col) = (last_col, first_col)

        # Build up the print area range "Sheet1!$A$1:$C$13".
        area = self._convert_name_area(first_row, first_col, last_row, last_col)
        ref = xl_range(first_row, first_col, last_row, last_col)

        self.autofilter_area = area
        self.autofilter_ref = ref
        self.filter_range = [first_col, last_col]

        # Store the filter cell positions for use in the autofit calculation.
        for col in range(first_col, last_col + 1):
            self.filter_cells[(first_row, col)] = True

    def filter_column(self, col, criteria):
        """
        Set the column filter criteria.

        Args:
            col:       Filter column (zero-indexed).
            criteria:  Filter criteria.

        Returns:
             Nothing.

        """
        if not self.autofilter_area:
            warn("Must call autofilter() before filter_column()")
            return

        # Check for a column reference in A1 notation and substitute.
        try:
            int(col)
        except ValueError:
            # Convert col ref to a cell ref and then to a col number.
            col_letter = col
            (_, col) = xl_cell_to_rowcol(col + "1")

            if col >= self.xls_colmax:
                warn("Invalid column '%s'" % col_letter)
                return

        (col_first, col_last) = self.filter_range

        # Reject column if it is outside filter range.
        if col < col_first or col > col_last:
            warn(
                "Column '%d' outside autofilter() column range (%d, %d)"
                % (col, col_first, col_last)
            )
            return

        tokens = self._extract_filter_tokens(criteria)

        if len(tokens) not in (3, 7):
            warn("Incorrect number of tokens in criteria '%s'" % criteria)

        tokens = self._parse_filter_expression(criteria, tokens)

        # Excel handles single or double custom filters as default filters.
        #  We need to check for them and handle them accordingly.
        if len(tokens) == 2 and tokens[0] == 2:
            # Single equality.
            self.filter_column_list(col, [tokens[1]])
        elif len(tokens) == 5 and tokens[0] == 2 and tokens[2] == 1 and tokens[3] == 2:
            # Double equality with "or" operator.
            self.filter_column_list(col, [tokens[1], tokens[4]])
        else:
            # Non default custom filter.
            self.filter_cols[col] = tokens
            self.filter_type[col] = 0

        self.filter_on = 1

    def filter_column_list(self, col, filters):
        """
        Set the column filter criteria in Excel 2007 list style.

        Args:
            col:      Filter column (zero-indexed).
            filters:  List of filter criteria to match.

        Returns:
             Nothing.

        """
        if not self.autofilter_area:
            warn("Must call autofilter() before filter_column()")
            return

        # Check for a column reference in A1 notation and substitute.
        try:
            int(col)
        except ValueError:
            # Convert col ref to a cell ref and then to a col number.
            col_letter = col
            (_, col) = xl_cell_to_rowcol(col + "1")

            if col >= self.xls_colmax:
                warn("Invalid column '%s'" % col_letter)
                return

        (col_first, col_last) = self.filter_range

        # Reject column if it is outside filter range.
        if col < col_first or col > col_last:
            warn(
                "Column '%d' outside autofilter() column range "
                "(%d,%d)" % (col, col_first, col_last)
            )
            return

        self.filter_cols[col] = filters
        self.filter_type[col] = 1
        self.filter_on = 1

    @convert_range_args
    def data_validation(self, first_row, first_col, last_row, last_col, options=None):
        """
        Add a data validation to a worksheet.

        Args:
            first_row:    The first row of the cell range. (zero indexed).
            first_col:    The first column of the cell range.
            last_row:     The last row of the cell range. (zero indexed).
            last_col:     The last column of the cell range.
            options:      Data validation options.

        Returns:
            0:  Success.
            -1: Row or column is out of worksheet bounds.
            -2: Incorrect parameter or option.
        """
        # Check that row and col are valid without storing the values.
        if self._check_dimensions(first_row, first_col, True, True):
            return -1
        if self._check_dimensions(last_row, last_col, True, True):
            return -1

        if options is None:
            options = {}
        else:
            # Copy the user defined options so they aren't modified.
            options = options.copy()

        # Valid input parameters.
        valid_parameters = {
            "validate",
            "criteria",
            "value",
            "source",
            "minimum",
            "maximum",
            "ignore_blank",
            "dropdown",
            "show_input",
            "input_title",
            "input_message",
            "show_error",
            "error_title",
            "error_message",
            "error_type",
            "other_cells",
            "multi_range",
        }

        # Check for valid input parameters.
        for param_key in options.keys():
            if param_key not in valid_parameters:
                warn("Unknown parameter '%s' in data_validation()" % param_key)
                return -2

        # Map alternative parameter names 'source' or 'minimum' to 'value'.
        if "source" in options:
            options["value"] = options["source"]
        if "minimum" in options:
            options["value"] = options["minimum"]

        # 'validate' is a required parameter.
        if "validate" not in options:
            warn("Parameter 'validate' is required in data_validation()")
            return -2

        # List of  valid validation types.
        valid_types = {
            "any": "none",
            "any value": "none",
            "whole number": "whole",
            "whole": "whole",
            "integer": "whole",
            "decimal": "decimal",
            "list": "list",
            "date": "date",
            "time": "time",
            "text length": "textLength",
            "length": "textLength",
            "custom": "custom",
        }

        # Check for valid validation types.
        if options["validate"] not in valid_types:
            warn(
                "Unknown validation type '%s' for parameter "
                "'validate' in data_validation()" % options["validate"]
            )
            return -2
        else:
            options["validate"] = valid_types[options["validate"]]

        # No action is required for validation type 'any' if there are no
        # input messages to display.
        if (
            options["validate"] == "none"
            and options.get("input_title") is None
            and options.get("input_message") is None
        ):
            return -2

        # The any, list and custom validations don't have a criteria so we use
        # a default of 'between'.
        if (
            options["validate"] == "none"
            or options["validate"] == "list"
            or options["validate"] == "custom"
        ):
            options["criteria"] = "between"
            options["maximum"] = None

        # 'criteria' is a required parameter.
        if "criteria" not in options:
            warn("Parameter 'criteria' is required in data_validation()")
            return -2

        # Valid criteria types.
        criteria_types = {
            "between": "between",
            "not between": "notBetween",
            "equal to": "equal",
            "=": "equal",
            "==": "equal",
            "not equal to": "notEqual",
            "!=": "notEqual",
            "<>": "notEqual",
            "greater than": "greaterThan",
            ">": "greaterThan",
            "less than": "lessThan",
            "<": "lessThan",
            "greater than or equal to": "greaterThanOrEqual",
            ">=": "greaterThanOrEqual",
            "less than or equal to": "lessThanOrEqual",
            "<=": "lessThanOrEqual",
        }

        # Check for valid criteria types.
        if options["criteria"] not in criteria_types:
            warn(
                "Unknown criteria type '%s' for parameter "
                "'criteria' in data_validation()" % options["criteria"]
            )
            return -2
        else:
            options["criteria"] = criteria_types[options["criteria"]]

        # 'Between' and 'Not between' criteria require 2 values.
        if options["criteria"] == "between" or options["criteria"] == "notBetween":
            if "maximum" not in options:
                warn(
                    "Parameter 'maximum' is required in data_validation() "
                    "when using 'between' or 'not between' criteria"
                )
                return -2
        else:
            options["maximum"] = None

        # Valid error dialog types.
        error_types = {
            "stop": 0,
            "warning": 1,
            "information": 2,
        }

        # Check for valid error dialog types.
        if "error_type" not in options:
            options["error_type"] = 0
        elif options["error_type"] not in error_types:
            warn(
                "Unknown criteria type '%s' for parameter 'error_type' "
                "in data_validation()" % options["error_type"]
            )
            return -2
        else:
            options["error_type"] = error_types[options["error_type"]]

        # Convert date/times value if required.
        if (
            options["validate"] in ("date", "time")
            and options["value"]
            and supported_datetime(options["value"])
        ):
            date_time = self._convert_date_time(options["value"])
            # Format date number to the same precision as Excel.
            options["value"] = "%.16g" % date_time

            if options["maximum"] and supported_datetime(options["maximum"]):
                date_time = self._convert_date_time(options["maximum"])
                options["maximum"] = "%.16g" % date_time

        # Check that the input title doesn't exceed the maximum length.
        if options.get("input_title") and len(options["input_title"]) > 32:
            warn(
                "Length of input title '%s' exceeds Excel's limit of 32"
                % options["input_title"]
            )
            return -2

        # Check that the error title doesn't exceed the maximum length.
        if options.get("error_title") and len(options["error_title"]) > 32:
            warn(
                "Length of error title '%s' exceeds Excel's limit of 32"
                % options["error_title"]
            )
            return -2

        # Check that the input message doesn't exceed the maximum length.
        if options.get("input_message") and len(options["input_message"]) > 255:
            warn(
                "Length of input message '%s' exceeds Excel's limit of 255"
                % options["input_message"]
            )
            return -2

        # Check that the error message doesn't exceed the maximum length.
        if options.get("error_message") and len(options["error_message"]) > 255:
            warn(
                "Length of error message '%s' exceeds Excel's limit of 255"
                % options["error_message"]
            )
            return -2

        # Check that the input list doesn't exceed the maximum length.
        if options["validate"] == "list" and isinstance(options["value"], list):
            formula = self._csv_join(*options["value"])
            if len(formula) > 255:
                warn(
                    "Length of list items '%s' exceeds Excel's limit of "
                    "255, use a formula range instead" % formula
                )
                return -2

        # Set some defaults if they haven't been defined by the user.
        if "ignore_blank" not in options:
            options["ignore_blank"] = 1
        if "dropdown" not in options:
            options["dropdown"] = 1
        if "show_input" not in options:
            options["show_input"] = 1
        if "show_error" not in options:
            options["show_error"] = 1

        # These are the cells to which the validation is applied.
        options["cells"] = [[first_row, first_col, last_row, last_col]]

        # A (for now) undocumented parameter to pass additional cell ranges.
        if "other_cells" in options:
            options["cells"].extend(options["other_cells"])

        # Override with user defined multiple range if provided.
        if "multi_range" in options:
            options["multi_range"] = options["multi_range"].replace("$", "")

        # Store the validation information until we close the worksheet.
        self.validations.append(options)

        return 0

    @convert_range_args
    def conditional_format(
        self, first_row, first_col, last_row, last_col, options=None
    ):
        """
        Add a conditional format to a worksheet.

        Args:
            first_row:    The first row of the cell range. (zero indexed).
            first_col:    The first column of the cell range.
            last_row:     The last row of the cell range. (zero indexed).
            last_col:     The last column of the cell range.
            options:      Conditional format options.

        Returns:
            0:  Success.
            -1: Row or column is out of worksheet bounds.
            -2: Incorrect parameter or option.
        """
        # Check that row and col are valid without storing the values.
        if self._check_dimensions(first_row, first_col, True, True):
            return -1
        if self._check_dimensions(last_row, last_col, True, True):
            return -1

        if options is None:
            options = {}
        else:
            # Copy the user defined options so they aren't modified.
            options = options.copy()

        # Valid input parameters.
        valid_parameter = {
            "type",
            "format",
            "criteria",
            "value",
            "minimum",
            "maximum",
            "stop_if_true",
            "min_type",
            "mid_type",
            "max_type",
            "min_value",
            "mid_value",
            "max_value",
            "min_color",
            "mid_color",
            "max_color",
            "min_length",
            "max_length",
            "multi_range",
            "bar_color",
            "bar_negative_color",
            "bar_negative_color_same",
            "bar_solid",
            "bar_border_color",
            "bar_negative_border_color",
            "bar_negative_border_color_same",
            "bar_no_border",
            "bar_direction",
            "bar_axis_position",
            "bar_axis_color",
            "bar_only",
            "data_bar_2010",
            "icon_style",
            "reverse_icons",
            "icons_only",
            "icons",
        }

        # Check for valid input parameters.
        for param_key in options.keys():
            if param_key not in valid_parameter:
                warn("Unknown parameter '%s' in conditional_format()" % param_key)
                return -2

        # 'type' is a required parameter.
        if "type" not in options:
            warn("Parameter 'type' is required in conditional_format()")
            return -2

        # Valid types.
        valid_type = {
            "cell": "cellIs",
            "date": "date",
            "time": "time",
            "average": "aboveAverage",
            "duplicate": "duplicateValues",
            "unique": "uniqueValues",
            "top": "top10",
            "bottom": "top10",
            "text": "text",
            "time_period": "timePeriod",
            "blanks": "containsBlanks",
            "no_blanks": "notContainsBlanks",
            "errors": "containsErrors",
            "no_errors": "notContainsErrors",
            "2_color_scale": "2_color_scale",
            "3_color_scale": "3_color_scale",
            "data_bar": "dataBar",
            "formula": "expression",
            "icon_set": "iconSet",
        }

        # Check for valid types.
        if options["type"] not in valid_type:
            warn(
                "Unknown value '%s' for parameter 'type' "
                "in conditional_format()" % options["type"]
            )
            return -2
        else:
            if options["type"] == "bottom":
                options["direction"] = "bottom"
            options["type"] = valid_type[options["type"]]

        # Valid criteria types.
        criteria_type = {
            "between": "between",
            "not between": "notBetween",
            "equal to": "equal",
            "=": "equal",
            "==": "equal",
            "not equal to": "notEqual",
            "!=": "notEqual",
            "<>": "notEqual",
            "greater than": "greaterThan",
            ">": "greaterThan",
            "less than": "lessThan",
            "<": "lessThan",
            "greater than or equal to": "greaterThanOrEqual",
            ">=": "greaterThanOrEqual",
            "less than or equal to": "lessThanOrEqual",
            "<=": "lessThanOrEqual",
            "containing": "containsText",
            "not containing": "notContains",
            "begins with": "beginsWith",
            "ends with": "endsWith",
            "yesterday": "yesterday",
            "today": "today",
            "last 7 days": "last7Days",
            "last week": "lastWeek",
            "this week": "thisWeek",
            "next week": "nextWeek",
            "last month": "lastMonth",
            "this month": "thisMonth",
            "next month": "nextMonth",
            # For legacy, but incorrect, support.
            "continue week": "nextWeek",
            "continue month": "nextMonth",
        }

        # Check for valid criteria types.
        if "criteria" in options and options["criteria"] in criteria_type:
            options["criteria"] = criteria_type[options["criteria"]]

        # Convert date/times value if required.
        if options["type"] in ("date", "time"):
            options["type"] = "cellIs"

            if "value" in options:
                if not supported_datetime(options["value"]):
                    warn("Conditional format 'value' must be a datetime object.")
                    return -2
                else:
                    date_time = self._convert_date_time(options["value"])
                    # Format date number to the same precision as Excel.
                    options["value"] = "%.16g" % date_time

            if "minimum" in options:
                if not supported_datetime(options["minimum"]):
                    warn("Conditional format 'minimum' must be a datetime object.")
                    return -2
                else:
                    date_time = self._convert_date_time(options["minimum"])
                    options["minimum"] = "%.16g" % date_time

            if "maximum" in options:
                if not supported_datetime(options["maximum"]):
                    warn("Conditional format 'maximum' must be a datetime object.")
                    return -2
                else:
                    date_time = self._convert_date_time(options["maximum"])
                    options["maximum"] = "%.16g" % date_time

        # Valid icon styles.
        valid_icons = {
            "3_arrows": "3Arrows",  # 1
            "3_flags": "3Flags",  # 2
            "3_traffic_lights_rimmed": "3TrafficLights2",  # 3
            "3_symbols_circled": "3Symbols",  # 4
            "4_arrows": "4Arrows",  # 5
            "4_red_to_black": "4RedToBlack",  # 6
            "4_traffic_lights": "4TrafficLights",  # 7
            "5_arrows_gray": "5ArrowsGray",  # 8
            "5_quarters": "5Quarters",  # 9
            "3_arrows_gray": "3ArrowsGray",  # 10
            "3_traffic_lights": "3TrafficLights",  # 11
            "3_signs": "3Signs",  # 12
            "3_symbols": "3Symbols2",  # 13
            "4_arrows_gray": "4ArrowsGray",  # 14
            "4_ratings": "4Rating",  # 15
            "5_arrows": "5Arrows",  # 16
            "5_ratings": "5Rating",
        }  # 17

        # Set the icon set properties.
        if options["type"] == "iconSet":
            # An icon_set must have an icon style.
            if not options.get("icon_style"):
                warn(
                    "The 'icon_style' parameter must be specified when "
                    "'type' == 'icon_set' in conditional_format()"
                )
                return -3

            # Check for valid icon styles.
            if options["icon_style"] not in valid_icons:
                warn(
                    "Unknown icon_style '%s' in conditional_format()"
                    % options["icon_style"]
                )
                return -2
            else:
                options["icon_style"] = valid_icons[options["icon_style"]]

            # Set the number of icons for the icon style.
            options["total_icons"] = 3
            if options["icon_style"].startswith("4"):
                options["total_icons"] = 4
            elif options["icon_style"].startswith("5"):
                options["total_icons"] = 5

            options["icons"] = self._set_icon_props(
                options.get("total_icons"), options.get("icons")
            )

        # Swap last row/col for first row/col as necessary
        if first_row > last_row:
            first_row, last_row = last_row, first_row

        if first_col > last_col:
            first_col, last_col = last_col, first_col

        # Set the formatting range.
        cell_range = xl_range(first_row, first_col, last_row, last_col)
        start_cell = xl_rowcol_to_cell(first_row, first_col)

        # Override with user defined multiple range if provided.
        if "multi_range" in options:
            cell_range = options["multi_range"]
            cell_range = cell_range.replace("$", "")

        # Get the dxf format index.
        if "format" in options and options["format"]:
            options["format"] = options["format"]._get_dxf_index()

        # Set the priority based on the order of adding.
        options["priority"] = self.dxf_priority
        self.dxf_priority += 1

        # Check for 2010 style data_bar parameters.
        if (
            self.use_data_bars_2010
            or options.get("data_bar_2010")
            or options.get("bar_solid")
            or options.get("bar_border_color")
            or options.get("bar_negative_color")
            or options.get("bar_negative_color_same")
            or options.get("bar_negative_border_color")
            or options.get("bar_negative_border_color_same")
            or options.get("bar_no_border")
            or options.get("bar_axis_position")
            or options.get("bar_axis_color")
            or options.get("bar_direction")
        ):
            options["is_data_bar_2010"] = True

        # Special handling of text criteria.
        if options["type"] == "text":
            if options["criteria"] == "containsText":
                options["type"] = "containsText"
                options["formula"] = 'NOT(ISERROR(SEARCH("%s",%s)))' % (
                    options["value"],
                    start_cell,
                )
            elif options["criteria"] == "notContains":
                options["type"] = "notContainsText"
                options["formula"] = 'ISERROR(SEARCH("%s",%s))' % (
                    options["value"],
                    start_cell,
                )
            elif options["criteria"] == "beginsWith":
                options["type"] = "beginsWith"
                options["formula"] = 'LEFT(%s,%d)="%s"' % (
                    start_cell,
                    len(options["value"]),
                    options["value"],
                )
            elif options["criteria"] == "endsWith":
                options["type"] = "endsWith"
                options["formula"] = 'RIGHT(%s,%d)="%s"' % (
                    start_cell,
                    len(options["value"]),
                    options["value"],
                )
            else:
                warn(
                    "Invalid text criteria '%s' "
                    "in conditional_format()" % options["criteria"]
                )

        # Special handling of time time_period criteria.
        if options["type"] == "timePeriod":
            if options["criteria"] == "yesterday":
                options["formula"] = "FLOOR(%s,1)=TODAY()-1" % start_cell

            elif options["criteria"] == "today":
                options["formula"] = "FLOOR(%s,1)=TODAY()" % start_cell

            elif options["criteria"] == "tomorrow":
                options["formula"] = "FLOOR(%s,1)=TODAY()+1" % start_cell

            # fmt: off
            elif options["criteria"] == "last7Days":
                options["formula"] = (
                    "AND(TODAY()-FLOOR(%s,1)<=6,FLOOR(%s,1)<=TODAY())"
                    % (start_cell, start_cell)
                )
            # fmt: on

            elif options["criteria"] == "lastWeek":
                options["formula"] = (
                    "AND(TODAY()-ROUNDDOWN(%s,0)>=(WEEKDAY(TODAY())),"
                    "TODAY()-ROUNDDOWN(%s,0)<(WEEKDAY(TODAY())+7))"
                    % (start_cell, start_cell)
                )

            elif options["criteria"] == "thisWeek":
                options["formula"] = (
                    "AND(TODAY()-ROUNDDOWN(%s,0)<=WEEKDAY(TODAY())-1,"
                    "ROUNDDOWN(%s,0)-TODAY()<=7-WEEKDAY(TODAY()))"
                    % (start_cell, start_cell)
                )

            elif options["criteria"] == "nextWeek":
                options["formula"] = (
                    "AND(ROUNDDOWN(%s,0)-TODAY()>(7-WEEKDAY(TODAY())),"
                    "ROUNDDOWN(%s,0)-TODAY()<(15-WEEKDAY(TODAY())))"
                    % (start_cell, start_cell)
                )

            elif options["criteria"] == "lastMonth":
                options["formula"] = (
                    "AND(MONTH(%s)=MONTH(TODAY())-1,OR(YEAR(%s)=YEAR("
                    "TODAY()),AND(MONTH(%s)=1,YEAR(A1)=YEAR(TODAY())-1)))"
                    % (start_cell, start_cell, start_cell)
                )

            # fmt: off
            elif options["criteria"] == "thisMonth":
                options["formula"] = (
                    "AND(MONTH(%s)=MONTH(TODAY()),YEAR(%s)=YEAR(TODAY()))"
                    % (start_cell, start_cell)
                )
            # fmt: on

            elif options["criteria"] == "nextMonth":
                options["formula"] = (
                    "AND(MONTH(%s)=MONTH(TODAY())+1,OR(YEAR(%s)=YEAR("
                    "TODAY()),AND(MONTH(%s)=12,YEAR(%s)=YEAR(TODAY())+1)))"
                    % (start_cell, start_cell, start_cell, start_cell)
                )

            else:
                warn(
                    "Invalid time_period criteria '%s' "
                    "in conditional_format()" % options["criteria"]
                )

        # Special handling of blanks/error types.
        if options["type"] == "containsBlanks":
            options["formula"] = "LEN(TRIM(%s))=0" % start_cell

        if options["type"] == "notContainsBlanks":
            options["formula"] = "LEN(TRIM(%s))>0" % start_cell

        if options["type"] == "containsErrors":
            options["formula"] = "ISERROR(%s)" % start_cell

        if options["type"] == "notContainsErrors":
            options["formula"] = "NOT(ISERROR(%s))" % start_cell

        # Special handling for 2 color scale.
        if options["type"] == "2_color_scale":
            options["type"] = "colorScale"

            # Color scales don't use any additional formatting.
            options["format"] = None

            # Turn off 3 color parameters.
            options["mid_type"] = None
            options["mid_color"] = None

            options.setdefault("min_type", "min")
            options.setdefault("max_type", "max")
            options.setdefault("min_value", 0)
            options.setdefault("max_value", 0)
            options.setdefault("min_color", "#FF7128")
            options.setdefault("max_color", "#FFEF9C")

            options["min_color"] = xl_color(options["min_color"])
            options["max_color"] = xl_color(options["max_color"])

        # Special handling for 3 color scale.
        if options["type"] == "3_color_scale":
            options["type"] = "colorScale"

            # Color scales don't use any additional formatting.
            options["format"] = None

            options.setdefault("min_type", "min")
            options.setdefault("mid_type", "percentile")
            options.setdefault("max_type", "max")
            options.setdefault("min_value", 0)
            options.setdefault("max_value", 0)
            options.setdefault("min_color", "#F8696B")
            options.setdefault("mid_color", "#FFEB84")
            options.setdefault("max_color", "#63BE7B")

            options["min_color"] = xl_color(options["min_color"])
            options["mid_color"] = xl_color(options["mid_color"])
            options["max_color"] = xl_color(options["max_color"])

            # Set a default mid value.
            if "mid_value" not in options:
                options["mid_value"] = 50

        # Special handling for data bar.
        if options["type"] == "dataBar":
            # Color scales don't use any additional formatting.
            options["format"] = None

            if not options.get("min_type"):
                options["min_type"] = "min"
                options["x14_min_type"] = "autoMin"
            else:
                options["x14_min_type"] = options["min_type"]

            if not options.get("max_type"):
                options["max_type"] = "max"
                options["x14_max_type"] = "autoMax"
            else:
                options["x14_max_type"] = options["max_type"]

            options.setdefault("min_value", 0)
            options.setdefault("max_value", 0)
            options.setdefault("bar_color", "#638EC6")
            options.setdefault("bar_border_color", options["bar_color"])
            options.setdefault("bar_only", False)
            options.setdefault("bar_no_border", False)
            options.setdefault("bar_solid", False)
            options.setdefault("bar_direction", "")
            options.setdefault("bar_negative_color", "#FF0000")
            options.setdefault("bar_negative_border_color", "#FF0000")
            options.setdefault("bar_negative_color_same", False)
            options.setdefault("bar_negative_border_color_same", False)
            options.setdefault("bar_axis_position", "")
            options.setdefault("bar_axis_color", "#000000")

            options["bar_color"] = xl_color(options["bar_color"])
            options["bar_border_color"] = xl_color(options["bar_border_color"])
            options["bar_axis_color"] = xl_color(options["bar_axis_color"])
            options["bar_negative_color"] = xl_color(options["bar_negative_color"])
            options["bar_negative_border_color"] = xl_color(
                options["bar_negative_border_color"]
            )

        # Adjust for 2010 style data_bar parameters.
        if options.get("is_data_bar_2010"):
            self.excel_version = 2010

            if options["min_type"] == "min" and options["min_value"] == 0:
                options["min_value"] = None

            if options["max_type"] == "max" and options["max_value"] == 0:
                options["max_value"] = None

            options["range"] = cell_range

        # Strip the leading = from formulas.
        try:
            options["min_value"] = options["min_value"].lstrip("=")
        except (KeyError, AttributeError):
            pass
        try:
            options["mid_value"] = options["mid_value"].lstrip("=")
        except (KeyError, AttributeError):
            pass
        try:
            options["max_value"] = options["max_value"].lstrip("=")
        except (KeyError, AttributeError):
            pass

        # Store the conditional format until we close the worksheet.
        if cell_range in self.cond_formats:
            self.cond_formats[cell_range].append(options)
        else:
            self.cond_formats[cell_range] = [options]

        return 0

    @convert_range_args
    def add_table(self, first_row, first_col, last_row, last_col, options=None):
        """
        Add an Excel table to a worksheet.

        Args:
            first_row:    The first row of the cell range. (zero indexed).
            first_col:    The first column of the cell range.
            last_row:     The last row of the cell range. (zero indexed).
            last_col:     The last column of the cell range.
            options:      Table format options. (Optional)

        Returns:
            0:  Success.
            -1: Row or column is out of worksheet bounds.
            -2: Incorrect parameter or option.
            -3: Not supported in constant_memory mode.
        """
        table = {}
        col_formats = {}

        if options is None:
            options = {}
        else:
            # Copy the user defined options so they aren't modified.
            options = options.copy()

        if self.constant_memory:
            warn("add_table() isn't supported in 'constant_memory' mode")
            return -3

        # Check that row and col are valid without storing the values.
        if self._check_dimensions(first_row, first_col, True, True):
            return -1
        if self._check_dimensions(last_row, last_col, True, True):
            return -1

        # Swap last row/col for first row/col as necessary.
        if first_row > last_row:
            (first_row, last_row) = (last_row, first_row)
        if first_col > last_col:
            (first_col, last_col) = (last_col, first_col)

        # Check if the table range overlaps a previous merged or table range.
        # This is a critical file corruption error in Excel.
        cell_range = xl_range(first_row, first_col, last_row, last_col)
        for row in range(first_row, last_row + 1):
            for col in range(first_col, last_col + 1):
                if self.table_cells.get((row, col)):
                    previous_range = self.table_cells.get((row, col))
                    raise OverlappingRange(
                        "Table range '%s' overlaps previous table range '%s'."
                        % (cell_range, previous_range)
                    )
                elif self.merged_cells.get((row, col)):
                    previous_range = self.merged_cells.get((row, col))
                    raise OverlappingRange(
                        "Table range '%s' overlaps previous merge range '%s'."
                        % (cell_range, previous_range)
                    )
                else:
                    self.table_cells[(row, col)] = cell_range

        # Valid input parameters.
        valid_parameter = {
            "autofilter",
            "banded_columns",
            "banded_rows",
            "columns",
            "data",
            "first_column",
            "header_row",
            "last_column",
            "name",
            "style",
            "total_row",
        }

        # Check for valid input parameters.
        for param_key in options.keys():
            if param_key not in valid_parameter:
                warn("Unknown parameter '%s' in add_table()" % param_key)
                return -2

        # Turn on Excel's defaults.
        options["banded_rows"] = options.get("banded_rows", True)
        options["header_row"] = options.get("header_row", True)
        options["autofilter"] = options.get("autofilter", True)

        # Check that there are enough rows.
        num_rows = last_row - first_row
        if options["header_row"]:
            num_rows -= 1

        if num_rows < 0:
            warn("Must have at least one data row in in add_table()")
            return -2

        # Set the table options.
        table["show_first_col"] = options.get("first_column", False)
        table["show_last_col"] = options.get("last_column", False)
        table["show_row_stripes"] = options.get("banded_rows", False)
        table["show_col_stripes"] = options.get("banded_columns", False)
        table["header_row_count"] = options.get("header_row", 0)
        table["totals_row_shown"] = options.get("total_row", False)

        # Set the table name.
        if "name" in options:
            name = options["name"]
            table["name"] = name

            if " " in name:
                warn("Name '%s' in add_table() cannot contain spaces" % name)
                return -2

            # Warn if the name contains invalid chars as defined by Excel.
            if not re.match(r"^[\w\\][\w\\.]*$", name, re.UNICODE) or re.match(
                r"^\d", name
            ):
                warn("Invalid Excel characters in add_table(): '%s'" % name)
                return -2

            # Warn if the name looks like a cell name.
            if re.match(r"^[a-zA-Z][a-zA-Z]?[a-dA-D]?\d+$", name):
                warn("Name looks like a cell name in add_table(): '%s'" % name)
                return -2

            # Warn if the name looks like a R1C1 cell reference.
            if re.match(r"^[rcRC]$", name) or re.match(r"^[rcRC]\d+[rcRC]\d+$", name):
                warn("Invalid name '%s' like a RC cell ref in add_table()" % name)
                return -2

        # Set the table style.
        if "style" in options:
            table["style"] = options["style"]

            if table["style"] is None:
                table["style"] = ""

            # Remove whitespace from style name.
            table["style"] = table["style"].replace(" ", "")
        else:
            table["style"] = "TableStyleMedium9"

        # Set the data range rows (without the header and footer).
        first_data_row = first_row
        last_data_row = last_row

        if options.get("header_row"):
            first_data_row += 1

        if options.get("total_row"):
            last_data_row -= 1

        # Set the table and autofilter ranges.
        table["range"] = xl_range(first_row, first_col, last_row, last_col)

        table["a_range"] = xl_range(first_row, first_col, last_data_row, last_col)

        # If the header row if off the default is to turn autofilter off.
        if not options["header_row"]:
            options["autofilter"] = 0

        # Set the autofilter range.
        if options["autofilter"]:
            table["autofilter"] = table["a_range"]

        # Add the table columns.
        col_id = 1
        table["columns"] = []
        seen_names = {}

        for col_num in range(first_col, last_col + 1):
            # Set up the default column data.
            col_data = {
                "id": col_id,
                "name": "Column" + str(col_id),
                "total_string": "",
                "total_function": "",
                "custom_total": "",
                "total_value": 0,
                "formula": "",
                "format": None,
                "name_format": None,
            }

            # Overwrite the defaults with any user defined values.
            if "columns" in options:
                # Check if there are user defined values for this column.
                if col_id <= len(options["columns"]):
                    user_data = options["columns"][col_id - 1]
                else:
                    user_data = None

                if user_data:
                    # Get the column format.
                    xformat = user_data.get("format", None)

                    # Map user defined values to internal values.
                    if user_data.get("header"):
                        col_data["name"] = user_data["header"]

                    # Excel requires unique case insensitive header names.
                    header_name = col_data["name"]
                    name = header_name.lower()
                    if name in seen_names:
                        warn("Duplicate header name in add_table(): '%s'" % name)
                        return -2
                    else:
                        seen_names[name] = True

                    col_data["name_format"] = user_data.get("header_format")

                    # Handle the column formula.
                    if "formula" in user_data and user_data["formula"]:
                        formula = user_data["formula"]

                        # Remove the formula '=' sign if it exists.
                        if formula.startswith("="):
                            formula = formula.lstrip("=")

                        # Convert Excel 2010 "@" ref to 2007 "#This Row".
                        formula = formula.replace("@", "[#This Row],")

                        # Escape any future functions.
                        formula = self._prepare_formula(formula, True)

                        col_data["formula"] = formula
                        # We write the formulas below after the table data.

                    # Handle the function for the total row.
                    if user_data.get("total_function"):
                        function = user_data["total_function"]
                        if function == "count_nums":
                            function = "countNums"
                        if function == "std_dev":
                            function = "stdDev"

                        subtotals = set(
                            [
                                "average",
                                "countNums",
                                "count",
                                "max",
                                "min",
                                "stdDev",
                                "sum",
                                "var",
                            ]
                        )

                        if function in subtotals:
                            formula = self._table_function_to_formula(
                                function, col_data["name"]
                            )
                        else:
                            formula = self._prepare_formula(function, True)
                            col_data["custom_total"] = formula
                            function = "custom"

                        col_data["total_function"] = function

                        value = user_data.get("total_value", 0)

                        self._write_formula(last_row, col_num, formula, xformat, value)

                    elif user_data.get("total_string"):
                        # Total label only (not a function).
                        total_string = user_data["total_string"]
                        col_data["total_string"] = total_string

                        self._write_string(
                            last_row, col_num, total_string, user_data.get("format")
                        )

                    # Get the dxf format index.
                    if xformat is not None:
                        col_data["format"] = xformat._get_dxf_index()

                    # Store the column format for writing the cell data.
                    # It doesn't matter if it is undefined.
                    col_formats[col_id - 1] = xformat

            # Store the column data.
            table["columns"].append(col_data)

            # Write the column headers to the worksheet.
            if options["header_row"]:
                self._write_string(
                    first_row, col_num, col_data["name"], col_data["name_format"]
                )

            col_id += 1

        # Write the cell data if supplied.
        if "data" in options:
            data = options["data"]

            i = 0  # For indexing the row data.
            for row in range(first_data_row, last_data_row + 1):
                j = 0  # For indexing the col data.
                for col in range(first_col, last_col + 1):
                    if i < len(data) and j < len(data[i]):
                        token = data[i][j]
                        if j in col_formats:
                            self._write(row, col, token, col_formats[j])
                        else:
                            self._write(row, col, token, None)
                    j += 1
                i += 1

        # Write any columns formulas after the user supplied table data to
        # overwrite it if required.
        for col_id, col_num in enumerate(range(first_col, last_col + 1)):
            column_data = table["columns"][col_id]
            if column_data and column_data["formula"]:
                formula_format = col_formats.get(col_id)
                formula = column_data["formula"]

                for row in range(first_data_row, last_data_row + 1):
                    self._write_formula(row, col_num, formula, formula_format)

        # Store the table data.
        self.tables.append(table)

        # Store the filter cell positions for use in the autofit calculation.
        if options["autofilter"]:
            for col in range(first_col, last_col + 1):
                self.filter_cells[(first_row, col)] = True

        return 0

    @convert_cell_args
    def add_sparkline(self, row, col, options=None):
        """
        Add sparklines to the worksheet.

        Args:
            row:     The cell row (zero indexed).
            col:     The cell column (zero indexed).
            options: Sparkline formatting options.

        Returns:
            0:  Success.
            -1: Row or column is out of worksheet bounds.
            -2: Incorrect parameter or option.

        """

        # Check that row and col are valid without storing the values.
        if self._check_dimensions(row, col, True, True):
            return -1

        sparkline = {"locations": [xl_rowcol_to_cell(row, col)]}

        if options is None:
            options = {}

        # Valid input parameters.
        valid_parameters = {
            "location",
            "range",
            "type",
            "high_point",
            "low_point",
            "negative_points",
            "first_point",
            "last_point",
            "markers",
            "style",
            "series_color",
            "negative_color",
            "markers_color",
            "first_color",
            "last_color",
            "high_color",
            "low_color",
            "max",
            "min",
            "axis",
            "reverse",
            "empty_cells",
            "show_hidden",
            "plot_hidden",
            "date_axis",
            "weight",
        }

        # Check for valid input parameters.
        for param_key in options.keys():
            if param_key not in valid_parameters:
                warn("Unknown parameter '%s' in add_sparkline()" % param_key)
                return -1

        # 'range' is a required parameter.
        if "range" not in options:
            warn("Parameter 'range' is required in add_sparkline()")
            return -2

        # Handle the sparkline type.
        spark_type = options.get("type", "line")

        if spark_type not in ("line", "column", "win_loss"):
            warn(
                "Parameter 'type' must be 'line', 'column' "
                "or 'win_loss' in add_sparkline()"
            )
            return -2

        if spark_type == "win_loss":
            spark_type = "stacked"
        sparkline["type"] = spark_type

        # We handle single location/range values or list of values.
        if "location" in options:
            if isinstance(options["location"], list):
                sparkline["locations"] = options["location"]
            else:
                sparkline["locations"] = [options["location"]]

        if isinstance(options["range"], list):
            sparkline["ranges"] = options["range"]
        else:
            sparkline["ranges"] = [options["range"]]

        range_count = len(sparkline["ranges"])
        location_count = len(sparkline["locations"])

        # The ranges and locations must match.
        if range_count != location_count:
            warn(
                "Must have the same number of location and range "
                "parameters in add_sparkline()"
            )
            return -2

        # Store the count.
        sparkline["count"] = len(sparkline["locations"])

        # Get the worksheet name for the range conversion below.
        sheetname = quote_sheetname(self.name)

        # Cleanup the input ranges.
        new_ranges = []
        for spark_range in sparkline["ranges"]:
            # Remove the absolute reference $ symbols.
            spark_range = spark_range.replace("$", "")

            # Remove the = from formula.
            spark_range = spark_range.lstrip("=")

            # Convert a simple range into a full Sheet1!A1:D1 range.
            if "!" not in spark_range:
                spark_range = sheetname + "!" + spark_range

            new_ranges.append(spark_range)

        sparkline["ranges"] = new_ranges

        # Cleanup the input locations.
        new_locations = []
        for location in sparkline["locations"]:
            location = location.replace("$", "")
            new_locations.append(location)

        sparkline["locations"] = new_locations

        # Map options.
        sparkline["high"] = options.get("high_point")
        sparkline["low"] = options.get("low_point")
        sparkline["negative"] = options.get("negative_points")
        sparkline["first"] = options.get("first_point")
        sparkline["last"] = options.get("last_point")
        sparkline["markers"] = options.get("markers")
        sparkline["min"] = options.get("min")
        sparkline["max"] = options.get("max")
        sparkline["axis"] = options.get("axis")
        sparkline["reverse"] = options.get("reverse")
        sparkline["hidden"] = options.get("show_hidden")
        sparkline["weight"] = options.get("weight")

        # Map empty cells options.
        empty = options.get("empty_cells", "")

        if empty == "zero":
            sparkline["empty"] = 0
        elif empty == "connect":
            sparkline["empty"] = "span"
        else:
            sparkline["empty"] = "gap"

        # Map the date axis range.
        date_range = options.get("date_axis")

        if date_range and "!" not in date_range:
            date_range = sheetname + "!" + date_range

        sparkline["date_axis"] = date_range

        # Set the sparkline styles.
        style_id = options.get("style", 0)
        style = get_sparkline_style(style_id)

        sparkline["series_color"] = style["series"]
        sparkline["negative_color"] = style["negative"]
        sparkline["markers_color"] = style["markers"]
        sparkline["first_color"] = style["first"]
        sparkline["last_color"] = style["last"]
        sparkline["high_color"] = style["high"]
        sparkline["low_color"] = style["low"]

        # Override the style colors with user defined colors.
        self._set_spark_color(sparkline, options, "series_color")
        self._set_spark_color(sparkline, options, "negative_color")
        self._set_spark_color(sparkline, options, "markers_color")
        self._set_spark_color(sparkline, options, "first_color")
        self._set_spark_color(sparkline, options, "last_color")
        self._set_spark_color(sparkline, options, "high_color")
        self._set_spark_color(sparkline, options, "low_color")

        self.sparklines.append(sparkline)

        return 0

    @convert_range_args
    def set_selection(self, first_row, first_col, last_row, last_col):
        """
        Set the selected cell or cells in a worksheet

        Args:
            first_row:    The first row of the cell range. (zero indexed).
            first_col:    The first column of the cell range.
            last_row:     The last row of the cell range. (zero indexed).
            last_col:     The last column of the cell range.

        Returns:
            0:  Nothing.
        """
        pane = None

        # Range selection. Do this before swapping max/min to allow the
        # selection direction to be reversed.
        active_cell = xl_rowcol_to_cell(first_row, first_col)

        # Swap last row/col for first row/col if necessary
        if first_row > last_row:
            (first_row, last_row) = (last_row, first_row)

        if first_col > last_col:
            (first_col, last_col) = (last_col, first_col)

        sqref = xl_range(first_row, first_col, last_row, last_col)

        # Selection isn't set for cell A1.
        if sqref == "A1":
            return

        self.selections = [[pane, active_cell, sqref]]

    @convert_cell_args
    def set_top_left_cell(self, row=0, col=0):
        """
        Set the first visible cell at the top left of a worksheet.

        Args:
            row: The cell row (zero indexed).
            col: The cell column (zero indexed).

        Returns:
            0:  Nothing.
        """

        if row == 0 and col == 0:
            return

        self.top_left_cell = xl_rowcol_to_cell(row, col)

    def outline_settings(
        self, visible=1, symbols_below=1, symbols_right=1, auto_style=0
    ):
        """
        Control outline settings.

        Args:
            visible:       Outlines are visible. Optional, defaults to True.
            symbols_below: Show row outline symbols below the outline bar.
                           Optional, defaults to True.
            symbols_right: Show column outline symbols to the right of the
                           outline bar. Optional, defaults to True.
            auto_style:    Use Automatic style. Optional, defaults to False.

        Returns:
            0:  Nothing.
        """
        self.outline_on = visible
        self.outline_below = symbols_below
        self.outline_right = symbols_right
        self.outline_style = auto_style

        self.outline_changed = True

    @convert_cell_args
    def freeze_panes(self, row, col, top_row=None, left_col=None, pane_type=0):
        """
        Create worksheet panes and mark them as frozen.

        Args:
            row:      The cell row (zero indexed).
            col:      The cell column (zero indexed).
            top_row:  Topmost visible row in scrolling region of pane.
            left_col: Leftmost visible row in scrolling region of pane.

        Returns:
            0:  Nothing.

        """
        if top_row is None:
            top_row = row

        if left_col is None:
            left_col = col

        self.panes = [row, col, top_row, left_col, pane_type]

    @convert_cell_args
    def split_panes(self, x, y, top_row=None, left_col=None):
        """
        Create worksheet panes and mark them as split.

        Args:
            x:        The position for the vertical split.
            y:        The position for the horizontal split.
            top_row:  Topmost visible row in scrolling region of pane.
            left_col: Leftmost visible row in scrolling region of pane.

        Returns:
            0:  Nothing.

        """
        # Same as freeze panes with a different pane type.
        self.freeze_panes(x, y, top_row, left_col, 2)

    def set_zoom(self, zoom=100):
        """
        Set the worksheet zoom factor.

        Args:
            zoom: Scale factor: 10 <= zoom <= 400.

        Returns:
            Nothing.

        """
        # Ensure the zoom scale is in Excel's range.
        if zoom < 10 or zoom > 400:
            warn("Zoom factor %d outside range: 10 <= zoom <= 400" % zoom)
            zoom = 100

        self.zoom = int(zoom)

    def right_to_left(self):
        """
        Display the worksheet right to left for some versions of Excel.

        Args:
            None.

        Returns:
            Nothing.

        """
        self.is_right_to_left = 1

    def hide_zero(self):
        """
        Hide zero values in worksheet cells.

        Args:
            None.

        Returns:
            Nothing.

        """
        self.show_zeros = 0

    def set_tab_color(self, color):
        """
        Set the color of the worksheet tab.

        Args:
            color: A #RGB color index.

        Returns:
            Nothing.

        """
        self.tab_color = xl_color(color)

    def protect(self, password="", options=None):
        """
        Set the password and protection options of the worksheet.

        Args:
            password: An optional password string.
            options:  A dictionary of worksheet objects to protect.

        Returns:
            Nothing.

        """
        if password != "":
            password = self._encode_password(password)

        if not options:
            options = {}

        # Default values for objects that can be protected.
        defaults = {
            "sheet": True,
            "content": False,
            "objects": False,
            "scenarios": False,
            "format_cells": False,
            "format_columns": False,
            "format_rows": False,
            "insert_columns": False,
            "insert_rows": False,
            "insert_hyperlinks": False,
            "delete_columns": False,
            "delete_rows": False,
            "select_locked_cells": True,
            "sort": False,
            "autofilter": False,
            "pivot_tables": False,
            "select_unlocked_cells": True,
        }

        # Overwrite the defaults with user specified values.
        for key in options.keys():
            if key in defaults:
                defaults[key] = options[key]
            else:
                warn("Unknown protection object: '%s'" % key)

        # Set the password after the user defined values.
        defaults["password"] = password

        self.protect_options = defaults

    def unprotect_range(self, cell_range, range_name=None, password=None):
        """
        Unprotect ranges within a protected worksheet.

        Args:
            cell_range: The cell or cell range to unprotect.
            range_name: An optional name for the range.
            password:   An optional password string. (undocumented)

        Returns:
            Nothing.

        """
        if cell_range is None:
            warn("Cell range must be specified in unprotect_range()")
            return -1

        # Sanitize the cell range.
        cell_range = cell_range.lstrip("=")
        cell_range = cell_range.replace("$", "")

        self.num_protected_ranges += 1

        if range_name is None:
            range_name = "Range" + str(self.num_protected_ranges)

        if password:
            password = self._encode_password(password)

        self.protected_ranges.append((cell_range, range_name, password))

    @convert_cell_args
    def insert_button(self, row, col, options=None):
        """
        Insert a button form object into the worksheet.

        Args:
            row:     The cell row (zero indexed).
            col:     The cell column (zero indexed).
            options: Button formatting options.

        Returns:
            0:  Success.
            -1: Row or column is out of worksheet bounds.

        """
        # Check insert (row, col) without storing.
        if self._check_dimensions(row, col, True, True):
            warn("Cannot insert button at (%d, %d)." % (row, col))
            return -1

        if options is None:
            options = {}

        button = self._button_params(row, col, options)

        self.buttons_list.append(button)

        self.has_vml = 1

        return 0

    ###########################################################################
    #
    # Public API. Page Setup methods.
    #
    ###########################################################################
    def set_landscape(self):
        """
        Set the page orientation as landscape.

        Args:
            None.

        Returns:
            Nothing.

        """
        self.orientation = 0
        self.page_setup_changed = True

    def set_portrait(self):
        """
        Set the page orientation as portrait.

        Args:
            None.

        Returns:
            Nothing.

        """
        self.orientation = 1
        self.page_setup_changed = True

    def set_page_view(self, view=1):
        """
        Set the page view mode.

        Args:
            0: Normal view mode
            1: Page view mode (the default)
            2: Page break view mode

        Returns:
            Nothing.

        """
        self.page_view = view

    def set_pagebreak_view(self, view=1):
        """
        Set the page view mode.

        Args:
            None.

        Returns:
            Nothing.

        """
        self.page_view = 2

    def set_paper(self, paper_size):
        """
        Set the paper type. US Letter = 1, A4 = 9.

        Args:
            paper_size: Paper index.

        Returns:
            Nothing.

        """
        if paper_size:
            self.paper_size = paper_size
            self.page_setup_changed = True

    def center_horizontally(self):
        """
        Center the page horizontally.

        Args:
            None.

        Returns:
            Nothing.

        """
        self.print_options_changed = True
        self.hcenter = 1

    def center_vertically(self):
        """
        Center the page vertically.

        Args:
            None.

        Returns:
            Nothing.

        """
        self.print_options_changed = True
        self.vcenter = 1

    def set_margins(self, left=0.7, right=0.7, top=0.75, bottom=0.75):
        """
        Set all the page margins in inches.

        Args:
            left:   Left margin.
            right:  Right margin.
            top:    Top margin.
            bottom: Bottom margin.

        Returns:
            Nothing.

        """
        self.margin_left = left
        self.margin_right = right
        self.margin_top = top
        self.margin_bottom = bottom

    def set_header(self, header="", options=None, margin=None):
        """
        Set the page header caption and optional margin.

        Args:
            header:  Header string.
            margin:  Header margin.
            options: Header options, mainly for images.

        Returns:
            Nothing.

        """
        header_orig = header
        header = header.replace("&[Picture]", "&G")

        if len(header) > 255:
            warn("Header string cannot be longer than Excel's limit of 255 characters")
            return

        if options is not None:
            # For backward compatibility allow options to be the margin.
            if not isinstance(options, dict):
                options = {"margin": options}
        else:
            options = {}

        # Copy the user defined options so they aren't modified.
        options = options.copy()

        # For backward compatibility.
        if margin is not None:
            options["margin"] = margin

        # Reset the list in case the function is called more than once.
        self.header_images = []

        if options.get("image_left"):
            self.header_images.append(
                [options.get("image_left"), options.get("image_data_left"), "LH"]
            )

        if options.get("image_center"):
            self.header_images.append(
                [options.get("image_center"), options.get("image_data_center"), "CH"]
            )

        if options.get("image_right"):
            self.header_images.append(
                [options.get("image_right"), options.get("image_data_right"), "RH"]
            )

        placeholder_count = header.count("&G")
        image_count = len(self.header_images)

        if placeholder_count != image_count:
            warn(
                "Number of header images (%s) doesn't match placeholder "
                "count (%s) in string: %s"
                % (image_count, placeholder_count, header_orig)
            )
            self.header_images = []
            return

        if "align_with_margins" in options:
            self.header_footer_aligns = options["align_with_margins"]

        if "scale_with_doc" in options:
            self.header_footer_scales = options["scale_with_doc"]

        self.header = header
        self.margin_header = options.get("margin", 0.3)
        self.header_footer_changed = True

        if image_count:
            self.has_header_vml = True

    def set_footer(self, footer="", options=None, margin=None):
        """
        Set the page footer caption and optional margin.

        Args:
            footer:  Footer string.
            margin:  Footer margin.
            options: Footer options, mainly for images.

        Returns:
            Nothing.

        """
        footer_orig = footer
        footer = footer.replace("&[Picture]", "&G")

        if len(footer) > 255:
            warn("Footer string cannot be longer than Excel's limit of 255 characters")
            return

        if options is not None:
            # For backward compatibility allow options to be the margin.
            if not isinstance(options, dict):
                options = {"margin": options}
        else:
            options = {}

        # Copy the user defined options so they aren't modified.
        options = options.copy()

        # For backward compatibility.
        if margin is not None:
            options["margin"] = margin

        # Reset the list in case the function is called more than once.
        self.footer_images = []

        if options.get("image_left"):
            self.footer_images.append(
                [options.get("image_left"), options.get("image_data_left"), "LF"]
            )

        if options.get("image_center"):
            self.footer_images.append(
                [options.get("image_center"), options.get("image_data_center"), "CF"]
            )

        if options.get("image_right"):
            self.footer_images.append(
                [options.get("image_right"), options.get("image_data_right"), "RF"]
            )

        placeholder_count = footer.count("&G")
        image_count = len(self.footer_images)

        if placeholder_count != image_count:
            warn(
                "Number of footer images (%s) doesn't match placeholder "
                "count (%s) in string: %s"
                % (image_count, placeholder_count, footer_orig)
            )
            self.footer_images = []
            return

        if "align_with_margins" in options:
            self.header_footer_aligns = options["align_with_margins"]

        if "scale_with_doc" in options:
            self.header_footer_scales = options["scale_with_doc"]

        self.footer = footer
        self.margin_footer = options.get("margin", 0.3)
        self.header_footer_changed = True

        if image_count:
            self.has_header_vml = True

    def repeat_rows(self, first_row, last_row=None):
        """
        Set the rows to repeat at the top of each printed page.

        Args:
            first_row: Start row for range.
            last_row: End row for range.

        Returns:
            Nothing.

        """
        if last_row is None:
            last_row = first_row

        # Convert rows to 1 based.
        first_row += 1
        last_row += 1

        # Create the row range area like: $1:$2.
        area = "$%d:$%d" % (first_row, last_row)

        # Build up the print titles area "Sheet1!$1:$2"
        sheetname = quote_sheetname(self.name)
        self.repeat_row_range = sheetname + "!" + area

    @convert_column_args
    def repeat_columns(self, first_col, last_col=None):
        """
        Set the columns to repeat at the left hand side of each printed page.

        Args:
            first_col: Start column for range.
            last_col: End column for range.

        Returns:
            Nothing.

        """
        if last_col is None:
            last_col = first_col

        # Convert to A notation.
        first_col = xl_col_to_name(first_col, 1)
        last_col = xl_col_to_name(last_col, 1)

        # Create a column range like $C:$D.
        area = first_col + ":" + last_col

        # Build up the print area range "=Sheet2!$C:$D"
        sheetname = quote_sheetname(self.name)
        self.repeat_col_range = sheetname + "!" + area

    def hide_gridlines(self, option=1):
        """
        Set the option to hide gridlines on the screen and the printed page.

        Args:
            option:    0 : Don't hide gridlines
                       1 : Hide printed gridlines only
                       2 : Hide screen and printed gridlines

        Returns:
            Nothing.

        """
        if option == 0:
            self.print_gridlines = 1
            self.screen_gridlines = 1
            self.print_options_changed = True
        elif option == 1:
            self.print_gridlines = 0
            self.screen_gridlines = 1
        else:
            self.print_gridlines = 0
            self.screen_gridlines = 0

    def print_row_col_headers(self):
        """
        Set the option to print the row and column headers on the printed page.

        Args:
            None.

        Returns:
            Nothing.

        """
        self.print_headers = True
        self.print_options_changed = True

    def hide_row_col_headers(self):
        """
        Set the option to hide the row and column headers on the worksheet.

        Args:
            None.

        Returns:
            Nothing.

        """
        self.row_col_headers = True

    @convert_range_args
    def print_area(self, first_row, first_col, last_row, last_col):
        """
        Set the print area in the current worksheet.

        Args:
            first_row:    The first row of the cell range. (zero indexed).
            first_col:    The first column of the cell range.
            last_row:     The last row of the cell range. (zero indexed).
            last_col:     The last column of the cell range.

        Returns:
            0:  Success.
            -1: Row or column is out of worksheet bounds.

        """
        # Set the print area in the current worksheet.

        # Ignore max print area since it is the same as no  area for Excel.
        if (
            first_row == 0
            and first_col == 0
            and last_row == self.xls_rowmax - 1
            and last_col == self.xls_colmax - 1
        ):
            return

        # Build up the print area range "Sheet1!$A$1:$C$13".
        area = self._convert_name_area(first_row, first_col, last_row, last_col)
        self.print_area_range = area

        return 0

    def print_across(self):
        """
        Set the order in which pages are printed.

        Args:
            None.

        Returns:
            Nothing.

        """
        self.page_order = 1
        self.page_setup_changed = True

    def fit_to_pages(self, width, height):
        """
        Fit the printed area to a specific number of pages both vertically and
        horizontally.

        Args:
            width:  Number of pages horizontally.
            height: Number of pages vertically.

        Returns:
            Nothing.

        """
        self.fit_page = 1
        self.fit_width = width
        self.fit_height = height
        self.page_setup_changed = True

    def set_start_page(self, start_page):
        """
        Set the start page number when printing.

        Args:
            start_page: Start page number.

        Returns:
            Nothing.

        """
        self.page_start = start_page

    def set_print_scale(self, scale):
        """
        Set the scale factor for the printed page.

        Args:
            scale: Print scale. 10 <= scale <= 400.

        Returns:
            Nothing.

        """
        # Confine the scale to Excel's range.
        if scale < 10 or scale > 400:
            warn("Print scale '%d' outside range: 10 <= scale <= 400" % scale)
            return

        # Turn off "fit to page" option when print scale is on.
        self.fit_page = 0

        self.print_scale = int(scale)
        self.page_setup_changed = True

    def print_black_and_white(self):
        """
        Set the option to print the worksheet in black and white.

        Args:
            None.

        Returns:
            Nothing.

        """
        self.black_white = True
        self.page_setup_changed = True

    def set_h_pagebreaks(self, breaks):
        """
        Set the horizontal page breaks on a worksheet.

        Args:
            breaks: List of rows where the page breaks should be added.

        Returns:
            Nothing.

        """
        self.hbreaks = breaks

    def set_v_pagebreaks(self, breaks):
        """
        Set the horizontal page breaks on a worksheet.

        Args:
            breaks: List of columns where the page breaks should be added.

        Returns:
            Nothing.

        """
        self.vbreaks = breaks

    def set_vba_name(self, name=None):
        """
        Set the VBA name for the worksheet. By default this is the
        same as the sheet name: i.e., Sheet1 etc.

        Args:
            name: The VBA name for the worksheet.

        Returns:
            Nothing.

        """
        if name is not None:
            self.vba_codename = name
        else:
            self.vba_codename = "Sheet" + str(self.index + 1)

    def ignore_errors(self, options=None):
        """
        Ignore various Excel errors/warnings in a worksheet for user defined
        ranges.

        Args:
            options: A dict of ignore errors keys with cell range values.

        Returns:
            0: Success.
           -1: Incorrect parameter or option.

        """
        if options is None:
            return -1
        else:
            # Copy the user defined options so they aren't modified.
            options = options.copy()

        # Valid input parameters.
        valid_parameters = {
            "number_stored_as_text",
            "eval_error",
            "formula_differs",
            "formula_range",
            "formula_unlocked",
            "empty_cell_reference",
            "list_data_validation",
            "calculated_column",
            "two_digit_text_year",
        }

        # Check for valid input parameters.
        for param_key in options.keys():
            if param_key not in valid_parameters:
                warn("Unknown parameter '%s' in ignore_errors()" % param_key)
                return -1

        self.ignored_errors = options

        return 0

    ###########################################################################
    #
    # Private API.
    #
    ###########################################################################
    def _initialize(self, init_data):
        self.name = init_data["name"]
        self.index = init_data["index"]
        self.str_table = init_data["str_table"]
        self.worksheet_meta = init_data["worksheet_meta"]
        self.constant_memory = init_data["constant_memory"]
        self.tmpdir = init_data["tmpdir"]
        self.date_1904 = init_data["date_1904"]
        self.strings_to_numbers = init_data["strings_to_numbers"]
        self.strings_to_formulas = init_data["strings_to_formulas"]
        self.strings_to_urls = init_data["strings_to_urls"]
        self.nan_inf_to_errors = init_data["nan_inf_to_errors"]
        self.default_date_format = init_data["default_date_format"]
        self.default_url_format = init_data["default_url_format"]
        self.excel2003_style = init_data["excel2003_style"]
        self.remove_timezone = init_data["remove_timezone"]
        self.max_url_length = init_data["max_url_length"]
        self.use_future_functions = init_data["use_future_functions"]
        self.embedded_images = init_data["embedded_images"]

        if self.excel2003_style:
            self.original_row_height = 12.75
            self.default_row_height = 12.75
            self.default_row_pixels = 17
            self.margin_left = 0.75
            self.margin_right = 0.75
            self.margin_top = 1
            self.margin_bottom = 1
            self.margin_header = 0.5
            self.margin_footer = 0.5
            self.header_footer_aligns = False

        # Open a temp filehandle to store row data in constant_memory mode.
        if self.constant_memory:
            # This is sub-optimal but we need to create a temp file
            # with utf8 encoding in Python < 3.
            (fd, filename) = tempfile.mkstemp(dir=self.tmpdir)
            os.close(fd)
            self.row_data_filename = filename
            self.row_data_fh = open(filename, mode="w+", encoding="utf-8")

            # Set as the worksheet filehandle until the file is assembled.
            self.fh = self.row_data_fh

    def _assemble_xml_file(self):
        # Assemble and write the XML file.

        # Write the XML declaration.
        self._xml_declaration()

        # Write the root worksheet element.
        self._write_worksheet()

        # Write the worksheet properties.
        self._write_sheet_pr()

        # Write the worksheet dimensions.
        self._write_dimension()

        # Write the sheet view properties.
        self._write_sheet_views()

        # Write the sheet format properties.
        self._write_sheet_format_pr()

        # Write the sheet column info.
        self._write_cols()

        # Write the worksheet data such as rows columns and cells.
        if not self.constant_memory:
            self._write_sheet_data()
        else:
            self._write_optimized_sheet_data()

        # Write the sheetProtection element.
        self._write_sheet_protection()

        # Write the protectedRanges element.
        self._write_protected_ranges()

        # Write the phoneticPr element.
        if self.excel2003_style:
            self._write_phonetic_pr()

        # Write the autoFilter element.
        self._write_auto_filter()

        # Write the mergeCells element.
        self._write_merge_cells()

        # Write the conditional formats.
        self._write_conditional_formats()

        # Write the dataValidations element.
        self._write_data_validations()

        # Write the hyperlink element.
        self._write_hyperlinks()

        # Write the printOptions element.
        self._write_print_options()

        # Write the worksheet page_margins.
        self._write_page_margins()

        # Write the worksheet page setup.
        self._write_page_setup()

        # Write the headerFooter element.
        self._write_header_footer()

        # Write the rowBreaks element.
        self._write_row_breaks()

        # Write the colBreaks element.
        self._write_col_breaks()

        # Write the ignoredErrors element.
        self._write_ignored_errors()

        # Write the drawing element.
        self._write_drawings()

        # Write the legacyDrawing element.
        self._write_legacy_drawing()

        # Write the legacyDrawingHF element.
        self._write_legacy_drawing_hf()

        # Write the picture element, for the background.
        self._write_picture()

        # Write the tableParts element.
        self._write_table_parts()

        # Write the extLst elements.
        self._write_ext_list()

        # Close the worksheet tag.
        self._xml_end_tag("worksheet")

        # Close the file.
        self._xml_close()

    def _check_dimensions(self, row, col, ignore_row=False, ignore_col=False):
        # Check that row and col are valid and store the max and min
        # values for use in other methods/elements. The ignore_row /
        # ignore_col flags is used to indicate that we wish to perform
        # the dimension check without storing the value. The ignore
        # flags are use by set_row() and data_validate.

        # Check that the row/col are within the worksheet bounds.
        if row < 0 or col < 0:
            return -1
        if row >= self.xls_rowmax or col >= self.xls_colmax:
            return -1

        # In constant_memory mode we don't change dimensions for rows
        # that are already written.
        if not ignore_row and not ignore_col and self.constant_memory:
            if row < self.previous_row:
                return -2

        if not ignore_row:
            if self.dim_rowmin is None or row < self.dim_rowmin:
                self.dim_rowmin = row
            if self.dim_rowmax is None or row > self.dim_rowmax:
                self.dim_rowmax = row

        if not ignore_col:
            if self.dim_colmin is None or col < self.dim_colmin:
                self.dim_colmin = col
            if self.dim_colmax is None or col > self.dim_colmax:
                self.dim_colmax = col

        return 0

    def _convert_date_time(self, dt_obj):
        # Convert a datetime object to an Excel serial date and time.
        return datetime_to_excel_datetime(dt_obj, self.date_1904, self.remove_timezone)

    def _convert_name_area(self, row_num_1, col_num_1, row_num_2, col_num_2):
        # Convert zero indexed rows and columns to the format required by
        # worksheet named ranges, eg, "Sheet1!$A$1:$C$13".

        range1 = ""
        range2 = ""
        area = ""
        row_col_only = 0

        # Convert to A1 notation.
        col_char_1 = xl_col_to_name(col_num_1, 1)
        col_char_2 = xl_col_to_name(col_num_2, 1)
        row_char_1 = "$" + str(row_num_1 + 1)
        row_char_2 = "$" + str(row_num_2 + 1)

        # We need to handle special cases that refer to rows or columns only.
        if row_num_1 == 0 and row_num_2 == self.xls_rowmax - 1:
            range1 = col_char_1
            range2 = col_char_2
            row_col_only = 1
        elif col_num_1 == 0 and col_num_2 == self.xls_colmax - 1:
            range1 = row_char_1
            range2 = row_char_2
            row_col_only = 1
        else:
            range1 = col_char_1 + row_char_1
            range2 = col_char_2 + row_char_2

        # A repeated range is only written once (if it isn't a special case).
        if range1 == range2 and not row_col_only:
            area = range1
        else:
            area = range1 + ":" + range2

        # Build up the print area range "Sheet1!$A$1:$C$13".
        sheetname = quote_sheetname(self.name)
        area = sheetname + "!" + area

        return area

    def _sort_pagebreaks(self, breaks):
        # This is an internal method used to filter elements of a list of
        # pagebreaks used in the _store_hbreak() and _store_vbreak() methods.
        # It:
        #   1. Removes duplicate entries from the list.
        #   2. Sorts the list.
        #   3. Removes 0 from the list if present.
        if not breaks:
            return

        breaks_set = set(breaks)

        if 0 in breaks_set:
            breaks_set.remove(0)

        breaks_list = list(breaks_set)
        breaks_list.sort()

        # The Excel 2007 specification says that the maximum number of page
        # breaks is 1026. However, in practice it is actually 1023.
        max_num_breaks = 1023
        if len(breaks_list) > max_num_breaks:
            breaks_list = breaks_list[:max_num_breaks]

        return breaks_list

    def _extract_filter_tokens(self, expression):
        # Extract the tokens from the filter expression. The tokens are mainly
        # non-whitespace groups. The only tricky part is to extract string
        # tokens that contain whitespace and/or quoted double quotes (Excel's
        # escaped quotes).
        #
        # Examples: 'x <  2000'
        #           'x >  2000 and x <  5000'
        #           'x = "foo"'
        #           'x = "foo bar"'
        #           'x = "foo "" bar"'
        #
        if not expression:
            return []

        token_re = re.compile(r'"(?:[^"]|"")*"|\S+')
        tokens = token_re.findall(expression)

        new_tokens = []
        # Remove single leading and trailing quotes and un-escape other quotes.
        for token in tokens:
            if token.startswith('"'):
                token = token[1:]

            if token.endswith('"'):
                token = token[:-1]

            token = token.replace('""', '"')

            new_tokens.append(token)

        return new_tokens

    def _parse_filter_expression(self, expression, tokens):
        # Converts the tokens of a possibly conditional expression into 1 or 2
        # sub expressions for further parsing.
        #
        # Examples:
        #          ('x', '==', 2000) -> exp1
        #          ('x', '>',  2000, 'and', 'x', '<', 5000) -> exp1 and exp2

        if len(tokens) == 7:
            # The number of tokens will be either 3 (for 1 expression)
            # or 7 (for 2  expressions).
            conditional = tokens[3]

            if re.match("(and|&&)", conditional):
                conditional = 0
            elif re.match(r"(or|\|\|)", conditional):
                conditional = 1
            else:
                warn(
                    "Token '%s' is not a valid conditional "
                    "in filter expression '%s'" % (conditional, expression)
                )

            expression_1 = self._parse_filter_tokens(expression, tokens[0:3])
            expression_2 = self._parse_filter_tokens(expression, tokens[4:7])

            return expression_1 + [conditional] + expression_2
        else:
            return self._parse_filter_tokens(expression, tokens)

    def _parse_filter_tokens(self, expression, tokens):
        # Parse the 3 tokens of a filter expression and return the operator
        # and token. The use of numbers instead of operators is a legacy of
        # Spreadsheet::WriteExcel.
        operators = {
            "==": 2,
            "=": 2,
            "=~": 2,
            "eq": 2,
            "!=": 5,
            "!~": 5,
            "ne": 5,
            "<>": 5,
            "<": 1,
            "<=": 3,
            ">": 4,
            ">=": 6,
        }

        operator = operators.get(tokens[1], None)
        token = tokens[2]

        # Special handling of "Top" filter expressions.
        if re.match("top|bottom", tokens[0].lower()):
            value = int(tokens[1])

            if value < 1 or value > 500:
                warn(
                    "The value '%d' in expression '%s' "
                    "must be in the range 1 to 500" % (value, expression)
                )

            token = token.lower()

            if token != "items" and token != "%":
                warn(
                    "The type '%s' in expression '%s' "
                    "must be either 'items' or '%%'" % (token, expression)
                )

            if tokens[0].lower() == "top":
                operator = 30
            else:
                operator = 32

            if tokens[2] == "%":
                operator += 1

            token = str(value)

        if not operator and tokens[0]:
            warn(
                "Token '%s' is not a valid operator "
                "in filter expression '%s'" % (token[0], expression)
            )

        # Special handling for Blanks/NonBlanks.
        if re.match("blanks|nonblanks", token.lower()):
            # Only allow Equals or NotEqual in this context.
            if operator != 2 and operator != 5:
                warn(
                    "The operator '%s' in expression '%s' "
                    "is not valid in relation to Blanks/NonBlanks'"
                    % (tokens[1], expression)
                )

            token = token.lower()

            # The operator should always be 2 (=) to flag a "simple" equality
            # in the binary record. Therefore we convert <> to =.
            if token == "blanks":
                if operator == 5:
                    token = " "
            else:
                if operator == 5:
                    operator = 2
                    token = "blanks"
                else:
                    operator = 5
                    token = " "

        # if the string token contains an Excel match character then change the
        # operator type to indicate a non "simple" equality.
        if operator == 2 and re.search("[*?]", token):
            operator = 22

        return [operator, token]

    def _encode_password(self, password):
        # Hash a worksheet password. Based on the algorithm in
        # ECMA-376-4:2016, Office Open XML File Formats  Transitional
        # Migration Features, Additional attributes for workbookProtection
        # element (Part 1, 18.2.29).
        hash = 0x0000

        for char in password[::-1]:
            hash = ((hash >> 14) & 0x01) | ((hash << 1) & 0x7FFF)
            hash ^= ord(char)

        hash = ((hash >> 14) & 0x01) | ((hash << 1) & 0x7FFF)
        hash ^= len(password)
        hash ^= 0xCE4B

        return "%X" % hash

    def _prepare_image(
        self,
        index,
        image_id,
        drawing_id,
        width,
        height,
        name,
        image_type,
        x_dpi,
        y_dpi,
        digest,
    ):
        # Set up images/drawings.
        drawing_type = 2
        (
            row,
            col,
            _,
            x_offset,
            y_offset,
            x_scale,
            y_scale,
            url,
            tip,
            anchor,
            _,
            description,
            decorative,
        ) = self.images[index]

        width *= x_scale
        height *= y_scale

        # Scale by non 96dpi resolutions.
        width *= 96.0 / x_dpi
        height *= 96.0 / y_dpi

        dimensions = self._position_object_emus(
            col, row, x_offset, y_offset, width, height, anchor
        )
        # Convert from pixels to emus.
        width = int(0.5 + (width * 9525))
        height = int(0.5 + (height * 9525))

        # Create a Drawing obj to use with worksheet unless one already exists.
        if not self.drawing:
            drawing = Drawing()
            drawing.embedded = 1
            self.drawing = drawing

            self.external_drawing_links.append(
                ["/drawing", "../drawings/drawing" + str(drawing_id) + ".xml", None]
            )
        else:
            drawing = self.drawing

        drawing_object = drawing._add_drawing_object()
        drawing_object["type"] = drawing_type
        drawing_object["dimensions"] = dimensions
        drawing_object["width"] = width
        drawing_object["height"] = height
        drawing_object["description"] = name
        drawing_object["shape"] = None
        drawing_object["anchor"] = anchor
        drawing_object["rel_index"] = 0
        drawing_object["url_rel_index"] = 0
        drawing_object["tip"] = tip
        drawing_object["decorative"] = decorative

        if description is not None:
            drawing_object["description"] = description

        if url:
            target = None
            rel_type = "/hyperlink"
            target_mode = "External"

            if re.match("(ftp|http)s?://", url):
                target = self._escape_url(url)

            if re.match("^mailto:", url):
                target = self._escape_url(url)

            if re.match("external:", url):
                target = url.replace("external:", "")
                target = self._escape_url(target)
                # Additional escape not required in worksheet hyperlinks.
                target = target.replace("#", "%23")

                if re.match(r"\w:", target) or re.match(r"\\", target):
                    target = "file:///" + target
                else:
                    target = target.replace("\\", "/")

            if re.match("internal:", url):
                target = url.replace("internal:", "#")
                target_mode = None

            if target is not None:
                if len(target) > self.max_url_length:
                    warn(
                        "Ignoring URL '%s' with link and/or anchor > %d "
                        "characters since it exceeds Excel's limit for URLS"
                        % (url, self.max_url_length)
                    )
                else:
                    if not self.drawing_rels.get(url):
                        self.drawing_links.append([rel_type, target, target_mode])

                    drawing_object["url_rel_index"] = self._get_drawing_rel_index(url)

        if not self.drawing_rels.get(digest):
            self.drawing_links.append(
                ["/image", "../media/image" + str(image_id) + "." + image_type]
            )

        drawing_object["rel_index"] = self._get_drawing_rel_index(digest)

    def _prepare_shape(self, index, drawing_id):
        # Set up shapes/drawings.
        drawing_type = 3

        (
            row,
            col,
            x_offset,
            y_offset,
            x_scale,
            y_scale,
            text,
            anchor,
            options,
            description,
            decorative,
        ) = self.shapes[index]

        width = options.get("width", self.default_col_pixels * 3)
        height = options.get("height", self.default_row_pixels * 6)

        width *= x_scale
        height *= y_scale

        dimensions = self._position_object_emus(
            col, row, x_offset, y_offset, width, height, anchor
        )

        # Convert from pixels to emus.
        width = int(0.5 + (width * 9525))
        height = int(0.5 + (height * 9525))

        # Create a Drawing obj to use with worksheet unless one already exists.
        if not self.drawing:
            drawing = Drawing()
            drawing.embedded = 1
            self.drawing = drawing

            self.external_drawing_links.append(
                ["/drawing", "../drawings/drawing" + str(drawing_id) + ".xml", None]
            )
        else:
            drawing = self.drawing

        shape = Shape("rect", "TextBox", options)
        shape.text = text

        drawing_object = drawing._add_drawing_object()
        drawing_object["type"] = drawing_type
        drawing_object["dimensions"] = dimensions
        drawing_object["width"] = width
        drawing_object["height"] = height
        drawing_object["description"] = description
        drawing_object["shape"] = shape
        drawing_object["anchor"] = anchor
        drawing_object["rel_index"] = 0
        drawing_object["url_rel_index"] = 0
        drawing_object["tip"] = options.get("tip")
        drawing_object["decorative"] = decorative

        url = options.get("url", None)
        if url:
            target = None
            rel_type = "/hyperlink"
            target_mode = "External"

            if re.match("(ftp|http)s?://", url):
                target = self._escape_url(url)

            if re.match("^mailto:", url):
                target = self._escape_url(url)

            if re.match("external:", url):
                target = url.replace("external:", "file:///")
                target = self._escape_url(target)
                # Additional escape not required in worksheet hyperlinks.
                target = target.replace("#", "%23")

            if re.match("internal:", url):
                target = url.replace("internal:", "#")
                target_mode = None

            if target is not None:
                if len(target) > self.max_url_length:
                    warn(
                        "Ignoring URL '%s' with link and/or anchor > %d "
                        "characters since it exceeds Excel's limit for URLS"
                        % (url, self.max_url_length)
                    )
                else:
                    if not self.drawing_rels.get(url):
                        self.drawing_links.append([rel_type, target, target_mode])

                    drawing_object["url_rel_index"] = self._get_drawing_rel_index(url)

    def _prepare_header_image(
        self, image_id, width, height, name, image_type, position, x_dpi, y_dpi, digest
    ):
        # Set up an image without a drawing object for header/footer images.

        # Strip the extension from the filename.
        name = re.sub(r"\..*$", "", name)

        if not self.vml_drawing_rels.get(digest):
            self.vml_drawing_links.append(
                ["/image", "../media/image" + str(image_id) + "." + image_type]
            )

        ref_id = self._get_vml_drawing_rel_index(digest)

        self.header_images_list.append(
            [width, height, name, position, x_dpi, y_dpi, ref_id]
        )

    def _prepare_background(self, image_id, image_type):
        # Set up an image without a drawing object for backgrounds.
        self.external_background_links.append(
            ["/image", "../media/image" + str(image_id) + "." + image_type]
        )

    def _prepare_chart(self, index, chart_id, drawing_id):
        # Set up chart/drawings.
        drawing_type = 1

        (
            row,
            col,
            chart,
            x_offset,
            y_offset,
            x_scale,
            y_scale,
            anchor,
            description,
            decorative,
        ) = self.charts[index]

        chart.id = chart_id - 1

        # Use user specified dimensions, if any.
        width = int(0.5 + (chart.width * x_scale))
        height = int(0.5 + (chart.height * y_scale))

        dimensions = self._position_object_emus(
            col, row, x_offset, y_offset, width, height, anchor
        )

        # Set the chart name for the embedded object if it has been specified.
        name = chart.chart_name

        # Create a Drawing obj to use with worksheet unless one already exists.
        if not self.drawing:
            drawing = Drawing()
            drawing.embedded = 1
            self.drawing = drawing

            self.external_drawing_links.append(
                ["/drawing", "../drawings/drawing" + str(drawing_id) + ".xml"]
            )
        else:
            drawing = self.drawing

        drawing_object = drawing._add_drawing_object()
        drawing_object["type"] = drawing_type
        drawing_object["dimensions"] = dimensions
        drawing_object["width"] = width
        drawing_object["height"] = height
        drawing_object["name"] = name
        drawing_object["shape"] = None
        drawing_object["anchor"] = anchor
        drawing_object["rel_index"] = self._get_drawing_rel_index()
        drawing_object["url_rel_index"] = 0
        drawing_object["tip"] = None
        drawing_object["description"] = description
        drawing_object["decorative"] = decorative

        self.drawing_links.append(
            ["/chart", "../charts/chart" + str(chart_id) + ".xml"]
        )

    def _position_object_emus(
        self, col_start, row_start, x1, y1, width, height, anchor
    ):
        # Calculate the vertices that define the position of a graphical
        # object within the worksheet in EMUs.
        #
        # The vertices are expressed as English Metric Units (EMUs). There are
        # 12,700 EMUs per point. Therefore, 12,700 * 3 /4 = 9,525 EMUs per
        # pixel
        (
            col_start,
            row_start,
            x1,
            y1,
            col_end,
            row_end,
            x2,
            y2,
            x_abs,
            y_abs,
        ) = self._position_object_pixels(
            col_start, row_start, x1, y1, width, height, anchor
        )

        # Convert the pixel values to EMUs. See above.
        x1 = int(0.5 + 9525 * x1)
        y1 = int(0.5 + 9525 * y1)
        x2 = int(0.5 + 9525 * x2)
        y2 = int(0.5 + 9525 * y2)
        x_abs = int(0.5 + 9525 * x_abs)
        y_abs = int(0.5 + 9525 * y_abs)

        return (col_start, row_start, x1, y1, col_end, row_end, x2, y2, x_abs, y_abs)

    # Calculate the vertices that define the position of a graphical object
    # within the worksheet in pixels.
    #
    #         +------------+------------+
    #         |     A      |      B     |
    #   +-----+------------+------------+
    #   |     |(x1,y1)     |            |
    #   |  1  |(A1)._______|______      |
    #   |     |    |              |     |
    #   |     |    |              |     |
    #   +-----+----|    OBJECT    |-----+
    #   |     |    |              |     |
    #   |  2  |    |______________.     |
    #   |     |            |        (B2)|
    #   |     |            |     (x2,y2)|
    #   +---- +------------+------------+
    #
    # Example of an object that covers some of the area from cell A1 to  B2.
    #
    # Based on the width and height of the object we need to calculate 8 vars:
    #
    #     col_start, row_start, col_end, row_end, x1, y1, x2, y2.
    #
    # We also calculate the absolute x and y position of the top left vertex of
    # the object. This is required for images.
    #
    # The width and height of the cells that the object occupies can be
    # variable and have to be taken into account.
    #
    # The values of col_start and row_start are passed in from the calling
    # function. The values of col_end and row_end are calculated by
    # subtracting the width and height of the object from the width and
    # height of the underlying cells.
    #
    def _position_object_pixels(
        self, col_start, row_start, x1, y1, width, height, anchor
    ):
        # col_start       # Col containing upper left corner of object.
        # x1              # Distance to left side of object.
        #
        # row_start       # Row containing top left corner of object.
        # y1              # Distance to top of object.
        #
        # col_end         # Col containing lower right corner of object.
        # x2              # Distance to right side of object.
        #
        # row_end         # Row containing bottom right corner of object.
        # y2              # Distance to bottom of object.
        #
        # width           # Width of object frame.
        # height          # Height of object frame.
        #
        # x_abs           # Absolute distance to left side of object.
        # y_abs           # Absolute distance to top side of object.
        x_abs = 0
        y_abs = 0

        # Adjust start column for negative offsets.
        while x1 < 0 and col_start > 0:
            x1 += self._size_col(col_start - 1)
            col_start -= 1

        # Adjust start row for negative offsets.
        while y1 < 0 and row_start > 0:
            y1 += self._size_row(row_start - 1)
            row_start -= 1

        # Ensure that the image isn't shifted off the page at top left.
        if x1 < 0:
            x1 = 0

        if y1 < 0:
            y1 = 0

        # Calculate the absolute x offset of the top-left vertex.
        if self.col_size_changed:
            for col_id in range(col_start):
                x_abs += self._size_col(col_id)
        else:
            # Optimization for when the column widths haven't changed.
            x_abs += self.default_col_pixels * col_start

        x_abs += x1

        # Calculate the absolute y offset of the top-left vertex.
        if self.row_size_changed:
            for row_id in range(row_start):
                y_abs += self._size_row(row_id)
        else:
            # Optimization for when the row heights haven't changed.
            y_abs += self.default_row_pixels * row_start

        y_abs += y1

        # Adjust start column for offsets that are greater than the col width.
        while x1 >= self._size_col(col_start, anchor):
            x1 -= self._size_col(col_start)
            col_start += 1

        # Adjust start row for offsets that are greater than the row height.
        while y1 >= self._size_row(row_start, anchor):
            y1 -= self._size_row(row_start)
            row_start += 1

        # Initialize end cell to the same as the start cell.
        col_end = col_start
        row_end = row_start

        # Don't offset the image in the cell if the row/col is hidden.
        if self._size_col(col_start, anchor) > 0:
            width = width + x1
        if self._size_row(row_start, anchor) > 0:
            height = height + y1

        # Subtract the underlying cell widths to find end cell of the object.
        while width >= self._size_col(col_end, anchor):
            width -= self._size_col(col_end, anchor)
            col_end += 1

        # Subtract the underlying cell heights to find end cell of the object.
        while height >= self._size_row(row_end, anchor):
            height -= self._size_row(row_end, anchor)
            row_end += 1

        # The end vertices are whatever is left from the width and height.
        x2 = width
        y2 = height

        return [col_start, row_start, x1, y1, col_end, row_end, x2, y2, x_abs, y_abs]

    def _size_col(self, col, anchor=0):
        # Convert the width of a cell from character units to pixels. Excel
        # rounds the column width to the nearest pixel. If the width hasn't
        # been set by the user we use the default value. A hidden column is
        # treated as having a width of zero unless it has the special
        # "object_position" of 4 (size with cells).
        max_digit_width = 7  # For Calibri 11.
        padding = 5
        pixels = 0

        # Look up the cell value to see if it has been changed.
        if col in self.col_info:
            width = self.col_info[col][0]
            hidden = self.col_info[col][2]

            if width is None:
                width = self.default_col_width

            # Convert to pixels.
            if hidden and anchor != 4:
                pixels = 0
            elif width < 1:
                pixels = int(width * (max_digit_width + padding) + 0.5)
            else:
                pixels = int(width * max_digit_width + 0.5) + padding
        else:
            pixels = self.default_col_pixels

        return pixels

    def _size_row(self, row, anchor=0):
        # Convert the height of a cell from character units to pixels. If the
        # height hasn't been set by the user we use the default value. A
        # hidden row is treated as having a height of zero unless it has the
        # special "object_position" of 4 (size with cells).
        pixels = 0

        # Look up the cell value to see if it has been changed
        if row in self.row_sizes:
            height = self.row_sizes[row][0]
            hidden = self.row_sizes[row][1]

            if hidden and anchor != 4:
                pixels = 0
            else:
                pixels = int(4.0 / 3.0 * height)
        else:
            pixels = int(4.0 / 3.0 * self.default_row_height)

        return pixels

    def _pixels_to_width(self, pixels):
        # Convert the width of a cell from pixels to character units.
        max_digit_width = 7.0  # For Calabri 11.
        padding = 5.0

        if pixels <= 12:
            width = pixels / (max_digit_width + padding)
        else:
            width = (pixels - padding) / max_digit_width

        return width

    def _pixels_to_height(self, pixels):
        # Convert the height of a cell from pixels to character units.
        return 0.75 * pixels

    def _comment_params(self, row, col, string, options):
        # This method handles the additional optional parameters to
        # write_comment() as well as calculating the comment object
        # position and vertices.
        default_width = 128
        default_height = 74
        anchor = 0

        params = {
            "author": None,
            "color": "#ffffe1",
            "start_cell": None,
            "start_col": None,
            "start_row": None,
            "visible": None,
            "width": default_width,
            "height": default_height,
            "x_offset": None,
            "x_scale": 1,
            "y_offset": None,
            "y_scale": 1,
            "font_name": "Tahoma",
            "font_size": 8,
            "font_family": 2,
        }

        # Overwrite the defaults with any user supplied values. Incorrect or
        # misspelled parameters are silently ignored.
        for key in options.keys():
            params[key] = options[key]

        # Ensure that a width and height have been set.
        if not params["width"]:
            params["width"] = default_width
        if not params["height"]:
            params["height"] = default_height

        # Set the comment background color.
        params["color"] = xl_color(params["color"]).lower()

        # Convert from Excel XML style color to XML html style color.
        params["color"] = params["color"].replace("ff", "#", 1)

        # Convert a cell reference to a row and column.
        if params["start_cell"] is not None:
            (start_row, start_col) = xl_cell_to_rowcol(params["start_cell"])
            params["start_row"] = start_row
            params["start_col"] = start_col

        # Set the default start cell and offsets for the comment. These are
        # generally fixed in relation to the parent cell. However there are
        # some edge cases for cells at the, er, edges.
        row_max = self.xls_rowmax
        col_max = self.xls_colmax

        if params["start_row"] is None:
            if row == 0:
                params["start_row"] = 0
            elif row == row_max - 3:
                params["start_row"] = row_max - 7
            elif row == row_max - 2:
                params["start_row"] = row_max - 6
            elif row == row_max - 1:
                params["start_row"] = row_max - 5
            else:
                params["start_row"] = row - 1

        if params["y_offset"] is None:
            if row == 0:
                params["y_offset"] = 2
            elif row == row_max - 3:
                params["y_offset"] = 16
            elif row == row_max - 2:
                params["y_offset"] = 16
            elif row == row_max - 1:
                params["y_offset"] = 14
            else:
                params["y_offset"] = 10

        if params["start_col"] is None:
            if col == col_max - 3:
                params["start_col"] = col_max - 6
            elif col == col_max - 2:
                params["start_col"] = col_max - 5
            elif col == col_max - 1:
                params["start_col"] = col_max - 4
            else:
                params["start_col"] = col + 1

        if params["x_offset"] is None:
            if col == col_max - 3:
                params["x_offset"] = 49
            elif col == col_max - 2:
                params["x_offset"] = 49
            elif col == col_max - 1:
                params["x_offset"] = 49
            else:
                params["x_offset"] = 15

        # Scale the size of the comment box if required.
        if params["x_scale"]:
            params["width"] = params["width"] * params["x_scale"]

        if params["y_scale"]:
            params["height"] = params["height"] * params["y_scale"]

        # Round the dimensions to the nearest pixel.
        params["width"] = int(0.5 + params["width"])
        params["height"] = int(0.5 + params["height"])

        # Calculate the positions of the comment object.
        vertices = self._position_object_pixels(
            params["start_col"],
            params["start_row"],
            params["x_offset"],
            params["y_offset"],
            params["width"],
            params["height"],
            anchor,
        )

        # Add the width and height for VML.
        vertices.append(params["width"])
        vertices.append(params["height"])

        return [
            row,
            col,
            string,
            params["author"],
            params["visible"],
            params["color"],
            params["font_name"],
            params["font_size"],
            params["font_family"],
        ] + [vertices]

    def _button_params(self, row, col, options):
        # This method handles the parameters passed to insert_button() as well
        # as calculating the button object position and vertices.

        default_height = self.default_row_pixels
        default_width = self.default_col_pixels
        anchor = 0

        button_number = 1 + len(self.buttons_list)
        button = {"row": row, "col": col, "font": {}}
        params = {}

        # Overwrite the defaults with any user supplied values. Incorrect or
        # misspelled parameters are silently ignored.
        for key in options.keys():
            params[key] = options[key]

        # Set the button caption.
        caption = params.get("caption")

        # Set a default caption if none was specified by user.
        if caption is None:
            caption = "Button %d" % button_number

        button["font"]["caption"] = caption

        # Set the macro name.
        if params.get("macro"):
            button["macro"] = "[0]!" + params["macro"]
        else:
            button["macro"] = "[0]!Button%d_Click" % button_number

        # Set the alt text for the button.
        button["description"] = params.get("description")

        # Ensure that a width and height have been set.
        params["width"] = params.get("width", default_width)
        params["height"] = params.get("height", default_height)

        # Set the x/y offsets.
        params["x_offset"] = params.get("x_offset", 0)
        params["y_offset"] = params.get("y_offset", 0)

        # Scale the size of the button if required.
        params["width"] = params["width"] * params.get("x_scale", 1)
        params["height"] = params["height"] * params.get("y_scale", 1)

        # Round the dimensions to the nearest pixel.
        params["width"] = int(0.5 + params["width"])
        params["height"] = int(0.5 + params["height"])

        params["start_row"] = row
        params["start_col"] = col

        # Calculate the positions of the button object.
        vertices = self._position_object_pixels(
            params["start_col"],
            params["start_row"],
            params["x_offset"],
            params["y_offset"],
            params["width"],
            params["height"],
            anchor,
        )

        # Add the width and height for VML.
        vertices.append(params["width"])
        vertices.append(params["height"])

        button["vertices"] = vertices

        return button

    def _prepare_vml_objects(
        self, vml_data_id, vml_shape_id, vml_drawing_id, comment_id
    ):
        comments = []
        # Sort the comments into row/column order for easier comparison
        # testing and set the external links for comments and buttons.
        row_nums = sorted(self.comments.keys())

        for row in row_nums:
            col_nums = sorted(self.comments[row].keys())

            for col in col_nums:
                user_options = self.comments[row][col]
                params = self._comment_params(*user_options)
                self.comments[row][col] = params

                # Set comment visibility if required and not user defined.
                if self.comments_visible:
                    if self.comments[row][col][4] is None:
                        self.comments[row][col][4] = 1

                # Set comment author if not already user defined.
                if self.comments[row][col][3] is None:
                    self.comments[row][col][3] = self.comments_author

                comments.append(self.comments[row][col])

        self.external_vml_links.append(
            ["/vmlDrawing", "../drawings/vmlDrawing" + str(vml_drawing_id) + ".vml"]
        )

        if self.has_comments:
            self.comments_list = comments

            self.external_comment_links.append(
                ["/comments", "../comments" + str(comment_id) + ".xml"]
            )

        count = len(comments)
        start_data_id = vml_data_id

        # The VML o:idmap data id contains a comma separated range when there
        # is more than one 1024 block of comments, like this: data="1,2".
        for i in range(int(count / 1024)):
            vml_data_id = "%s,%d" % (vml_data_id, start_data_id + i + 1)

        self.vml_data_id = vml_data_id
        self.vml_shape_id = vml_shape_id

        return count

    def _prepare_header_vml_objects(self, vml_header_id, vml_drawing_id):
        # Set up external linkage for VML header/footer images.

        self.vml_header_id = vml_header_id

        self.external_vml_links.append(
            ["/vmlDrawing", "../drawings/vmlDrawing" + str(vml_drawing_id) + ".vml"]
        )

    def _prepare_tables(self, table_id, seen):
        # Set the table ids for the worksheet tables.
        for table in self.tables:
            table["id"] = table_id

            if table.get("name") is None:
                # Set a default name.
                table["name"] = "Table" + str(table_id)

            # Check for duplicate table names.
            name = table["name"].lower()

            if name in seen:
                raise DuplicateTableName(
                    "Duplicate name '%s' used in worksheet.add_table()." % table["name"]
                )
            else:
                seen[name] = True

            # Store the link used for the rels file.
            self.external_table_links.append(
                ["/table", "../tables/table" + str(table_id) + ".xml"]
            )
            table_id += 1

    def _table_function_to_formula(self, function, col_name):
        # Convert a table total function to a worksheet formula.
        formula = ""

        # Escape special characters, as required by Excel.
        col_name = col_name.replace("'", "''")
        col_name = col_name.replace("#", "'#")
        col_name = col_name.replace("]", "']")
        col_name = col_name.replace("[", "'[")

        subtotals = {
            "average": 101,
            "countNums": 102,
            "count": 103,
            "max": 104,
            "min": 105,
            "stdDev": 107,
            "sum": 109,
            "var": 110,
        }

        if function in subtotals:
            func_num = subtotals[function]
            formula = "SUBTOTAL(%s,[%s])" % (func_num, col_name)
        else:
            warn("Unsupported function '%s' in add_table()" % function)

        return formula

    def _set_spark_color(self, sparkline, options, user_color):
        # Set the sparkline color.
        if user_color not in options:
            return

        sparkline[user_color] = {"rgb": xl_color(options[user_color])}

    def _get_range_data(self, row_start, col_start, row_end, col_end):
        # Returns a range of data from the worksheet _table to be used in
        # chart cached data. Strings are returned as SST ids and decoded
        # in the workbook. Return None for data that doesn't exist since
        # Excel can chart series with data missing.

        if self.constant_memory:
            return ()

        data = []

        # Iterate through the table data.
        for row_num in range(row_start, row_end + 1):
            # Store None if row doesn't exist.
            if row_num not in self.table:
                data.append(None)
                continue

            for col_num in range(col_start, col_end + 1):
                if col_num in self.table[row_num]:
                    cell = self.table[row_num][col_num]

                    cell_type = cell.__class__.__name__

                    if cell_type in ("Number", "Datetime"):
                        # Return a number with Excel's precision.
                        data.append("%.16g" % cell.number)

                    elif cell_type == "String":
                        # Return a string from it's shared string index.
                        index = cell.string
                        string = self.str_table._get_shared_string(index)

                        data.append(string)

                    elif cell_type in ("Formula", "ArrayFormula"):
                        # Return the formula value.
                        value = cell.value

                        if value is None:
                            value = 0

                        data.append(value)

                    elif cell_type == "Blank":
                        # Return a empty cell.
                        data.append("")
                else:
                    # Store None if column doesn't exist.
                    data.append(None)

        return data

    def _csv_join(self, *items):
        # Create a csv string for use with data validation formulas and lists.

        # Convert non string types to string.
        items = [str(item) if not isinstance(item, str) else item for item in items]

        return ",".join(items)

    def _escape_url(self, url):
        # Don't escape URL if it looks already escaped.
        if re.search("%[0-9a-fA-F]{2}", url):
            return url

        # Can't use url.quote() here because it doesn't match Excel.
        url = url.replace("%", "%25")
        url = url.replace('"', "%22")
        url = url.replace(" ", "%20")
        url = url.replace("<", "%3c")
        url = url.replace(">", "%3e")
        url = url.replace("[", "%5b")
        url = url.replace("]", "%5d")
        url = url.replace("^", "%5e")
        url = url.replace("`", "%60")
        url = url.replace("{", "%7b")
        url = url.replace("}", "%7d")

        return url

    def _get_drawing_rel_index(self, target=None):
        # Get the index used to address a drawing rel link.
        if target is None:
            self.drawing_rels_id += 1
            return self.drawing_rels_id
        elif self.drawing_rels.get(target):
            return self.drawing_rels[target]
        else:
            self.drawing_rels_id += 1
            self.drawing_rels[target] = self.drawing_rels_id
            return self.drawing_rels_id

    def _get_vml_drawing_rel_index(self, target=None):
        # Get the index used to address a vml drawing rel link.
        if self.vml_drawing_rels.get(target):
            return self.vml_drawing_rels[target]
        else:
            self.vml_drawing_rels_id += 1
            self.vml_drawing_rels[target] = self.vml_drawing_rels_id
            return self.vml_drawing_rels_id

    ###########################################################################
    #
    # The following font methods are, more or less, duplicated from the
    # Styles class. Not the cleanest version of reuse but works for now.
    #
    ###########################################################################
    def _write_font(self, xf_format):
        # Write the <font> element.
        xml_writer = self.rstring

        xml_writer._xml_start_tag("rPr")

        # Handle the main font properties.
        if xf_format.bold:
            xml_writer._xml_empty_tag("b")
        if xf_format.italic:
            xml_writer._xml_empty_tag("i")
        if xf_format.font_strikeout:
            xml_writer._xml_empty_tag("strike")
        if xf_format.font_outline:
            xml_writer._xml_empty_tag("outline")
        if xf_format.font_shadow:
            xml_writer._xml_empty_tag("shadow")

        # Handle the underline variants.
        if xf_format.underline:
            self._write_underline(xf_format.underline)

        # Handle super/subscript.
        if xf_format.font_script == 1:
            self._write_vert_align("superscript")
        if xf_format.font_script == 2:
            self._write_vert_align("subscript")

        # Write the font size
        xml_writer._xml_empty_tag("sz", [("val", xf_format.font_size)])

        # Handle colors.
        if xf_format.theme == -1:
            # Ignore for excel2003_style.
            pass
        elif xf_format.theme:
            self._write_color("theme", xf_format.theme)
        elif xf_format.color_indexed:
            self._write_color("indexed", xf_format.color_indexed)
        elif xf_format.font_color:
            color = self._get_palette_color(xf_format.font_color)
            self._write_rstring_color("rgb", color)
        else:
            self._write_rstring_color("theme", 1)

        # Write some other font properties related to font families.
        xml_writer._xml_empty_tag("rFont", [("val", xf_format.font_name)])
        xml_writer._xml_empty_tag("family", [("val", xf_format.font_family)])

        if xf_format.font_name == "Calibri" and not xf_format.hyperlink:
            xml_writer._xml_empty_tag("scheme", [("val", xf_format.font_scheme)])

        xml_writer._xml_end_tag("rPr")

    def _write_underline(self, underline):
        # Write the underline font element.
        attributes = []

        # Handle the underline variants.
        if underline == 2:
            attributes = [("val", "double")]
        elif underline == 33:
            attributes = [("val", "singleAccounting")]
        elif underline == 34:
            attributes = [("val", "doubleAccounting")]

        self.rstring._xml_empty_tag("u", attributes)

    def _write_vert_align(self, val):
        # Write the <vertAlign> font sub-element.
        attributes = [("val", val)]

        self.rstring._xml_empty_tag("vertAlign", attributes)

    def _write_rstring_color(self, name, value):
        # Write the <color> element.
        attributes = [(name, value)]

        self.rstring._xml_empty_tag("color", attributes)

    def _get_palette_color(self, color):
        # Convert the RGB color.
        if color[0] == "#":
            color = color[1:]

        return "FF" + color.upper()

    def _opt_close(self):
        # Close the row data filehandle in constant_memory mode.
        if not self.row_data_fh_closed:
            self.row_data_fh.close()
            self.row_data_fh_closed = True

    def _opt_reopen(self):
        # Reopen the row data filehandle in constant_memory mode.
        if self.row_data_fh_closed:
            filename = self.row_data_filename
            self.row_data_fh = open(filename, mode="a+", encoding="utf-8")
            self.row_data_fh_closed = False
            self.fh = self.row_data_fh

    def _set_icon_props(self, total_icons, user_props=None):
        # Set the sub-properties for icons.
        props = []

        # Set the defaults.
        for _ in range(total_icons):
            props.append({"criteria": False, "value": 0, "type": "percent"})

        # Set the default icon values based on the number of icons.
        if total_icons == 3:
            props[0]["value"] = 67
            props[1]["value"] = 33

        if total_icons == 4:
            props[0]["value"] = 75
            props[1]["value"] = 50
            props[2]["value"] = 25

        if total_icons == 5:
            props[0]["value"] = 80
            props[1]["value"] = 60
            props[2]["value"] = 40
            props[3]["value"] = 20

        # Overwrite default properties with user defined properties.
        if user_props:
            # Ensure we don't set user properties for lowest icon.
            max_data = len(user_props)
            if max_data >= total_icons:
                max_data = total_icons - 1

            for i in range(max_data):
                # Set the user defined 'value' property.
                if user_props[i].get("value") is not None:
                    props[i]["value"] = user_props[i]["value"]

                    # Remove the formula '=' sign if it exists.
                    tmp = props[i]["value"]
                    if isinstance(tmp, str) and tmp.startswith("="):
                        props[i]["value"] = tmp.lstrip("=")

                # Set the user defined 'type' property.
                if user_props[i].get("type"):
                    valid_types = ("percent", "percentile", "number", "formula")

                    if user_props[i]["type"] not in valid_types:
                        warn(
                            "Unknown icon property type '%s' for sub-"
                            "property 'type' in conditional_format()"
                            % user_props[i]["type"]
                        )
                    else:
                        props[i]["type"] = user_props[i]["type"]

                        if props[i]["type"] == "number":
                            props[i]["type"] = "num"

                # Set the user defined 'criteria' property.
                criteria = user_props[i].get("criteria")
                if criteria and criteria == ">":
                    props[i]["criteria"] = True

        return props

    ###########################################################################
    #
    # XML methods.
    #
    ###########################################################################

    def _write_worksheet(self):
        # Write the <worksheet> element. This is the root element.

        schema = "http://schemas.openxmlformats.org/"
        xmlns = schema + "spreadsheetml/2006/main"
        xmlns_r = schema + "officeDocument/2006/relationships"
        xmlns_mc = schema + "markup-compatibility/2006"
        ms_schema = "http://schemas.microsoft.com/"
        xmlns_x14ac = ms_schema + "office/spreadsheetml/2009/9/ac"

        attributes = [("xmlns", xmlns), ("xmlns:r", xmlns_r)]

        # Add some extra attributes for Excel 2010. Mainly for sparklines.
        if self.excel_version == 2010:
            attributes.append(("xmlns:mc", xmlns_mc))
            attributes.append(("xmlns:x14ac", xmlns_x14ac))
            attributes.append(("mc:Ignorable", "x14ac"))

        self._xml_start_tag("worksheet", attributes)

    def _write_dimension(self):
        # Write the <dimension> element. This specifies the range of
        # cells in the worksheet. As a special case, empty
        # spreadsheets use 'A1' as a range.

        if self.dim_rowmin is None and self.dim_colmin is None:
            # If the min dimensions are not defined then no dimensions
            # have been set and we use the default 'A1'.
            ref = "A1"

        elif self.dim_rowmin is None and self.dim_colmin is not None:
            # If the row dimensions aren't set but the column
            # dimensions are set then they have been changed via
            # set_column().

            if self.dim_colmin == self.dim_colmax:
                # The dimensions are a single cell and not a range.
                ref = xl_rowcol_to_cell(0, self.dim_colmin)
            else:
                # The dimensions are a cell range.
                cell_1 = xl_rowcol_to_cell(0, self.dim_colmin)
                cell_2 = xl_rowcol_to_cell(0, self.dim_colmax)
                ref = cell_1 + ":" + cell_2

        elif self.dim_rowmin == self.dim_rowmax and self.dim_colmin == self.dim_colmax:
            # The dimensions are a single cell and not a range.
            ref = xl_rowcol_to_cell(self.dim_rowmin, self.dim_colmin)
        else:
            # The dimensions are a cell range.
            cell_1 = xl_rowcol_to_cell(self.dim_rowmin, self.dim_colmin)
            cell_2 = xl_rowcol_to_cell(self.dim_rowmax, self.dim_colmax)
            ref = cell_1 + ":" + cell_2

        self._xml_empty_tag("dimension", [("ref", ref)])

    def _write_sheet_views(self):
        # Write the <sheetViews> element.
        self._xml_start_tag("sheetViews")

        # Write the sheetView element.
        self._write_sheet_view()

        self._xml_end_tag("sheetViews")

    def _write_sheet_view(self):
        # Write the <sheetViews> element.
        attributes = []

        # Hide screen gridlines if required.
        if not self.screen_gridlines:
            attributes.append(("showGridLines", 0))

        # Hide screen row/column headers.
        if self.row_col_headers:
            attributes.append(("showRowColHeaders", 0))

        # Hide zeroes in cells.
        if not self.show_zeros:
            attributes.append(("showZeros", 0))

        # Display worksheet right to left for Hebrew, Arabic and others.
        if self.is_right_to_left:
            attributes.append(("rightToLeft", 1))

        # Show that the sheet tab is selected.
        if self.selected:
            attributes.append(("tabSelected", 1))

        # Turn outlines off. Also required in the outlinePr element.
        if not self.outline_on:
            attributes.append(("showOutlineSymbols", 0))

        # Set the page view/layout mode if required.
        if self.page_view == 1:
            attributes.append(("view", "pageLayout"))
        elif self.page_view == 2:
            attributes.append(("view", "pageBreakPreview"))

        # Set the first visible cell.
        if self.top_left_cell != "":
            attributes.append(("topLeftCell", self.top_left_cell))

        # Set the zoom level.
        if self.zoom != 100:
            attributes.append(("zoomScale", self.zoom))

            if self.page_view == 0 and self.zoom_scale_normal:
                attributes.append(("zoomScaleNormal", self.zoom))
            if self.page_view == 1:
                attributes.append(("zoomScalePageLayoutView", self.zoom))
            if self.page_view == 2:
                attributes.append(("zoomScaleSheetLayoutView", self.zoom))

        attributes.append(("workbookViewId", 0))

        if self.panes or len(self.selections):
            self._xml_start_tag("sheetView", attributes)
            self._write_panes()
            self._write_selections()
            self._xml_end_tag("sheetView")
        else:
            self._xml_empty_tag("sheetView", attributes)

    def _write_sheet_format_pr(self):
        # Write the <sheetFormatPr> element.
        default_row_height = self.default_row_height
        row_level = self.outline_row_level
        col_level = self.outline_col_level

        attributes = [("defaultRowHeight", default_row_height)]

        if self.default_row_height != self.original_row_height:
            attributes.append(("customHeight", 1))

        if self.default_row_zeroed:
            attributes.append(("zeroHeight", 1))

        if row_level:
            attributes.append(("outlineLevelRow", row_level))
        if col_level:
            attributes.append(("outlineLevelCol", col_level))

        if self.excel_version == 2010:
            attributes.append(("x14ac:dyDescent", "0.25"))

        self._xml_empty_tag("sheetFormatPr", attributes)

    def _write_cols(self):
        # Write the <cols> element and <col> sub elements.

        # Exit unless some column have been formatted.
        if not self.col_info:
            return

        self._xml_start_tag("cols")

        # Use the first element of the column information structures to set
        # the initial/previous properties.
        first_col = (sorted(self.col_info.keys()))[0]
        last_col = first_col
        prev_col_options = self.col_info[first_col]
        del self.col_info[first_col]
        deleted_col = first_col
        deleted_col_options = prev_col_options

        for col in sorted(self.col_info.keys()):
            col_options = self.col_info[col]
            # Check if the column number is contiguous with the previous
            # column and if the properties are the same.
            if col == last_col + 1 and col_options == prev_col_options:
                last_col = col
            else:
                # If not contiguous/equal then we write out the current range
                # of columns and start again.
                self._write_col_info(first_col, last_col, prev_col_options)
                first_col = col
                last_col = first_col
                prev_col_options = col_options

        # We will exit the previous loop with one unhandled column range.
        self._write_col_info(first_col, last_col, prev_col_options)

        # Put back the deleted first column information structure.
        self.col_info[deleted_col] = deleted_col_options

        self._xml_end_tag("cols")

    def _write_col_info(self, col_min, col_max, col_info):
        # Write the <col> element.
        (width, cell_format, hidden, level, collapsed, autofit) = col_info

        custom_width = 1
        xf_index = 0

        # Get the cell_format index.
        if cell_format:
            xf_index = cell_format._get_xf_index()

        # Set the Excel default column width.
        if width is None:
            if not hidden:
                width = 8.43
                custom_width = 0
            else:
                width = 0
        elif width == 8.43:
            # Width is defined but same as default.
            custom_width = 0

        # Convert column width from user units to character width.
        if width > 0:
            # For Calabri 11.
            max_digit_width = 7
            padding = 5

            if width < 1:
                width = (
                    int(
                        (int(width * (max_digit_width + padding) + 0.5))
                        / float(max_digit_width)
                        * 256.0
                    )
                    / 256.0
                )
            else:
                width = (
                    int(
                        (int(width * max_digit_width + 0.5) + padding)
                        / float(max_digit_width)
                        * 256.0
                    )
                    / 256.0
                )

        attributes = [
            ("min", col_min + 1),
            ("max", col_max + 1),
            ("width", "%.16g" % width),
        ]

        if xf_index:
            attributes.append(("style", xf_index))
        if hidden:
            attributes.append(("hidden", "1"))
        if autofit:
            attributes.append(("bestFit", "1"))
        if custom_width:
            attributes.append(("customWidth", "1"))
        if level:
            attributes.append(("outlineLevel", level))
        if collapsed:
            attributes.append(("collapsed", "1"))

        self._xml_empty_tag("col", attributes)

    def _write_sheet_data(self):
        # Write the <sheetData> element.
        if self.dim_rowmin is None:
            # If the dimensions aren't defined there is no data to write.
            self._xml_empty_tag("sheetData")
        else:
            self._xml_start_tag("sheetData")
            self._write_rows()
            self._xml_end_tag("sheetData")

    def _write_optimized_sheet_data(self):
        # Write the <sheetData> element when constant_memory is on. In this
        # case we read the data stored in the temp file and rewrite it to the
        # XML sheet file.
        if self.dim_rowmin is None:
            # If the dimensions aren't defined then there is no data to write.
            self._xml_empty_tag("sheetData")
        else:
            self._xml_start_tag("sheetData")

            # Rewind the filehandle that was used for temp row data.
            buff_size = 65536
            self.row_data_fh.seek(0)
            data = self.row_data_fh.read(buff_size)

            while data:
                self.fh.write(data)
                data = self.row_data_fh.read(buff_size)

            self.row_data_fh.close()
            os.unlink(self.row_data_filename)

            self._xml_end_tag("sheetData")

    def _write_page_margins(self):
        # Write the <pageMargins> element.
        attributes = [
            ("left", self.margin_left),
            ("right", self.margin_right),
            ("top", self.margin_top),
            ("bottom", self.margin_bottom),
            ("header", self.margin_header),
            ("footer", self.margin_footer),
        ]

        self._xml_empty_tag("pageMargins", attributes)

    def _write_page_setup(self):
        # Write the <pageSetup> element.
        #
        # The following is an example taken from Excel.
        #
        # <pageSetup
        #     paperSize="9"
        #     scale="110"
        #     fitToWidth="2"
        #     fitToHeight="2"
        #     pageOrder="overThenDown"
        #     orientation="portrait"
        #     blackAndWhite="1"
        #     draft="1"
        #     horizontalDpi="200"
        #     verticalDpi="200"
        #     r:id="rId1"
        # />
        #
        attributes = []

        # Skip this element if no page setup has changed.
        if not self.page_setup_changed:
            return

        # Set paper size.
        if self.paper_size:
            attributes.append(("paperSize", self.paper_size))

        # Set the print_scale.
        if self.print_scale != 100:
            attributes.append(("scale", self.print_scale))

        # Set the "Fit to page" properties.
        if self.fit_page and self.fit_width != 1:
            attributes.append(("fitToWidth", self.fit_width))

        if self.fit_page and self.fit_height != 1:
            attributes.append(("fitToHeight", self.fit_height))

        # Set the page print direction.
        if self.page_order:
            attributes.append(("pageOrder", "overThenDown"))

        # Set start page for printing.
        if self.page_start > 1:
            attributes.append(("firstPageNumber", self.page_start))

        # Set page orientation.
        if self.orientation:
            attributes.append(("orientation", "portrait"))
        else:
            attributes.append(("orientation", "landscape"))

        # Set the print in black and white option.
        if self.black_white:
            attributes.append(("blackAndWhite", "1"))

        # Set start page for printing.
        if self.page_start != 0:
            attributes.append(("useFirstPageNumber", "1"))

        # Set the DPI. Mainly only for testing.
        if self.is_chartsheet:
            if self.horizontal_dpi:
                attributes.append(("horizontalDpi", self.horizontal_dpi))

            if self.vertical_dpi:
                attributes.append(("verticalDpi", self.vertical_dpi))
        else:
            if self.vertical_dpi:
                attributes.append(("verticalDpi", self.vertical_dpi))

            if self.horizontal_dpi:
                attributes.append(("horizontalDpi", self.horizontal_dpi))

        self._xml_empty_tag("pageSetup", attributes)

    def _write_print_options(self):
        # Write the <printOptions> element.
        attributes = []

        if not self.print_options_changed:
            return

        # Set horizontal centering.
        if self.hcenter:
            attributes.append(("horizontalCentered", 1))

        # Set vertical centering.
        if self.vcenter:
            attributes.append(("verticalCentered", 1))

        # Enable row and column headers.
        if self.print_headers:
            attributes.append(("headings", 1))

        # Set printed gridlines.
        if self.print_gridlines:
            attributes.append(("gridLines", 1))

        self._xml_empty_tag("printOptions", attributes)

    def _write_header_footer(self):
        # Write the <headerFooter> element.
        attributes = []

        if not self.header_footer_scales:
            attributes.append(("scaleWithDoc", 0))

        if not self.header_footer_aligns:
            attributes.append(("alignWithMargins", 0))

        if self.header_footer_changed:
            self._xml_start_tag("headerFooter", attributes)
            if self.header:
                self._write_odd_header()
            if self.footer:
                self._write_odd_footer()
            self._xml_end_tag("headerFooter")
        elif self.excel2003_style:
            self._xml_empty_tag("headerFooter", attributes)

    def _write_odd_header(self):
        # Write the <headerFooter> element.
        self._xml_data_element("oddHeader", self.header)

    def _write_odd_footer(self):
        # Write the <headerFooter> element.
        self._xml_data_element("oddFooter", self.footer)

    def _write_rows(self):
        # Write out the worksheet data as a series of rows and cells.
        self._calculate_spans()

        for row_num in range(self.dim_rowmin, self.dim_rowmax + 1):
            if (
                row_num in self.set_rows
                or row_num in self.comments
                or self.table[row_num]
            ):
                # Only process rows with formatting, cell data and/or comments.

                span_index = int(row_num / 16)

                if span_index in self.row_spans:
                    span = self.row_spans[span_index]
                else:
                    span = None

                if self.table[row_num]:
                    # Write the cells if the row contains data.
                    if row_num not in self.set_rows:
                        self._write_row(row_num, span)
                    else:
                        self._write_row(row_num, span, self.set_rows[row_num])

                    for col_num in range(self.dim_colmin, self.dim_colmax + 1):
                        if col_num in self.table[row_num]:
                            col_ref = self.table[row_num][col_num]
                            self._write_cell(row_num, col_num, col_ref)

                    self._xml_end_tag("row")

                elif row_num in self.comments:
                    # Row with comments in cells.
                    self._write_empty_row(row_num, span, self.set_rows[row_num])
                else:
                    # Blank row with attributes only.
                    self._write_empty_row(row_num, span, self.set_rows[row_num])

    def _write_single_row(self, current_row_num=0):
        # Write out the worksheet data as a single row with cells.
        # This method is used when constant_memory is on. A single
        # row is written and the data table is reset. That way only
        # one row of data is kept in memory at any one time. We don't
        # write span data in the optimized case since it is optional.

        # Set the new previous row as the current row.
        row_num = self.previous_row
        self.previous_row = current_row_num

        if row_num in self.set_rows or row_num in self.comments or self.table[row_num]:
            # Only process rows with formatting, cell data and/or comments.

            # No span data in optimized mode.
            span = None

            if self.table[row_num]:
                # Write the cells if the row contains data.
                if row_num not in self.set_rows:
                    self._write_row(row_num, span)
                else:
                    self._write_row(row_num, span, self.set_rows[row_num])

                for col_num in range(self.dim_colmin, self.dim_colmax + 1):
                    if col_num in self.table[row_num]:
                        col_ref = self.table[row_num][col_num]
                        self._write_cell(row_num, col_num, col_ref)

                self._xml_end_tag("row")
            else:
                # Row attributes or comments only.
                self._write_empty_row(row_num, span, self.set_rows[row_num])

        # Reset table.
        self.table.clear()

    def _calculate_spans(self):
        # Calculate the "spans" attribute of the <row> tag. This is an
        # XLSX optimization and isn't strictly required. However, it
        # makes comparing files easier. The span is the same for each
        # block of 16 rows.
        spans = {}
        span_min = None
        span_max = None

        for row_num in range(self.dim_rowmin, self.dim_rowmax + 1):
            if row_num in self.table:
                # Calculate spans for cell data.
                for col_num in range(self.dim_colmin, self.dim_colmax + 1):
                    if col_num in self.table[row_num]:
                        if span_min is None:
                            span_min = col_num
                            span_max = col_num
                        else:
                            if col_num < span_min:
                                span_min = col_num
                            if col_num > span_max:
                                span_max = col_num

            if row_num in self.comments:
                # Calculate spans for comments.
                for col_num in range(self.dim_colmin, self.dim_colmax + 1):
                    if row_num in self.comments and col_num in self.comments[row_num]:
                        if span_min is None:
                            span_min = col_num
                            span_max = col_num
                        else:
                            if col_num < span_min:
                                span_min = col_num
                            if col_num > span_max:
                                span_max = col_num

            if ((row_num + 1) % 16 == 0) or row_num == self.dim_rowmax:
                span_index = int(row_num / 16)

                if span_min is not None:
                    span_min += 1
                    span_max += 1
                    spans[span_index] = "%s:%s" % (span_min, span_max)
                    span_min = None

        self.row_spans = spans

    def _write_row(self, row, spans, properties=None, empty_row=False):
        # Write the <row> element.
        xf_index = 0

        if properties:
            height, cell_format, hidden, level, collapsed = properties
        else:
            height, cell_format, hidden, level, collapsed = None, None, 0, 0, 0

        if height is None:
            height = self.default_row_height

        attributes = [("r", row + 1)]

        # Get the cell_format index.
        if cell_format:
            xf_index = cell_format._get_xf_index()

        # Add row attributes where applicable.
        if spans:
            attributes.append(("spans", spans))

        if xf_index:
            attributes.append(("s", xf_index))

        if cell_format:
            attributes.append(("customFormat", 1))

        if height != self.original_row_height:
            attributes.append(("ht", "%g" % height))

        if hidden:
            attributes.append(("hidden", 1))

        if height != self.original_row_height:
            attributes.append(("customHeight", 1))

        if level:
            attributes.append(("outlineLevel", level))

        if collapsed:
            attributes.append(("collapsed", 1))

        if self.excel_version == 2010:
            attributes.append(("x14ac:dyDescent", "0.25"))

        if empty_row:
            self._xml_empty_tag_unencoded("row", attributes)
        else:
            self._xml_start_tag_unencoded("row", attributes)

    def _write_empty_row(self, row, spans, properties=None):
        # Write and empty <row> element.
        self._write_row(row, spans, properties, empty_row=True)

    def _write_cell(self, row, col, cell):
        # Write the <cell> element.
        # Note. This is the innermost loop so efficiency is important.

        cell_range = xl_rowcol_to_cell_fast(row, col)
        attributes = [("r", cell_range)]

        if cell.format:
            # Add the cell format index.
            xf_index = cell.format._get_xf_index()
            attributes.append(("s", xf_index))
        elif row in self.set_rows and self.set_rows[row][1]:
            # Add the row format.
            row_xf = self.set_rows[row][1]
            attributes.append(("s", row_xf._get_xf_index()))
        elif col in self.col_info:
            # Add the column format.
            col_xf = self.col_info[col][1]
            if col_xf is not None:
                attributes.append(("s", col_xf._get_xf_index()))

        type_cell_name = cell.__class__.__name__

        # Write the various cell types.
        if type_cell_name in ("Number", "Datetime"):
            # Write a number.
            self._xml_number_element(cell.number, attributes)

        elif type_cell_name in ("String", "RichString"):
            # Write a string.
            string = cell.string

            if not self.constant_memory:
                # Write a shared string.
                self._xml_string_element(string, attributes)
            else:
                # Write an optimized in-line string.

                # Convert control character to a _xHHHH_ escape.
                string = self._escape_control_characters(string)

                # Write any rich strings without further tags.
                if string.startswith("<r>") and string.endswith("</r>"):
                    self._xml_rich_inline_string(string, attributes)
                else:
                    # Add attribute to preserve leading or trailing whitespace.
                    preserve = preserve_whitespace(string)
                    self._xml_inline_string(string, preserve, attributes)

        elif type_cell_name == "Formula":
            # Write a formula. First check the formula value type.
            value = cell.value
            if isinstance(cell.value, bool):
                attributes.append(("t", "b"))
                if cell.value:
                    value = 1
                else:
                    value = 0

            elif isinstance(cell.value, str):
                error_codes = (
                    "#DIV/0!",
                    "#N/A",
                    "#NAME?",
                    "#NULL!",
                    "#NUM!",
                    "#REF!",
                    "#VALUE!",
                )

                if cell.value == "":
                    # Allow blank to force recalc in some third party apps.
                    pass
                elif cell.value in error_codes:
                    attributes.append(("t", "e"))
                else:
                    attributes.append(("t", "str"))

            self._xml_formula_element(cell.formula, value, attributes)

        elif type_cell_name == "ArrayFormula":
            # Write a array formula.

            if cell.atype == "dynamic":
                attributes.append(("cm", 1))

            # First check if the formula value is a string.
            try:
                float(cell.value)
            except ValueError:
                attributes.append(("t", "str"))

            # Write an array formula.
            self._xml_start_tag("c", attributes)

            self._write_cell_array_formula(cell.formula, cell.range)
            self._write_cell_value(cell.value)
            self._xml_end_tag("c")

        elif type_cell_name == "Blank":
            # Write a empty cell.
            self._xml_empty_tag("c", attributes)

        elif type_cell_name == "Boolean":
            # Write a boolean cell.
            attributes.append(("t", "b"))
            self._xml_start_tag("c", attributes)
            self._write_cell_value(cell.boolean)
            self._xml_end_tag("c")

        elif type_cell_name == "Error":
            # Write a boolean cell.
            attributes.append(("t", "e"))
            attributes.append(("vm", cell.value))
            self._xml_start_tag("c", attributes)
            self._write_cell_value(cell.error)
            self._xml_end_tag("c")

    def _write_cell_value(self, value):
        # Write the cell value <v> element.
        if value is None:
            value = ""

        self._xml_data_element("v", value)

    def _write_cell_array_formula(self, formula, cell_range):
        # Write the cell array formula <f> element.
        attributes = [("t", "array"), ("ref", cell_range)]

        self._xml_data_element("f", formula, attributes)

    def _write_sheet_pr(self):
        # Write the <sheetPr> element for Sheet level properties.
        attributes = []

        if (
            not self.fit_page
            and not self.filter_on
            and not self.tab_color
            and not self.outline_changed
            and not self.vba_codename
        ):
            return

        if self.vba_codename:
            attributes.append(("codeName", self.vba_codename))

        if self.filter_on:
            attributes.append(("filterMode", 1))

        if self.fit_page or self.tab_color or self.outline_changed:
            self._xml_start_tag("sheetPr", attributes)
            self._write_tab_color()
            self._write_outline_pr()
            self._write_page_set_up_pr()
            self._xml_end_tag("sheetPr")
        else:
            self._xml_empty_tag("sheetPr", attributes)

    def _write_page_set_up_pr(self):
        # Write the <pageSetUpPr> element.
        if not self.fit_page:
            return

        attributes = [("fitToPage", 1)]
        self._xml_empty_tag("pageSetUpPr", attributes)

    def _write_tab_color(self):
        # Write the <tabColor> element.
        color = self.tab_color

        if not color:
            return

        attributes = [("rgb", color)]

        self._xml_empty_tag("tabColor", attributes)

    def _write_outline_pr(self):
        # Write the <outlinePr> element.
        attributes = []

        if not self.outline_changed:
            return

        if self.outline_style:
            attributes.append(("applyStyles", 1))
        if not self.outline_below:
            attributes.append(("summaryBelow", 0))
        if not self.outline_right:
            attributes.append(("summaryRight", 0))
        if not self.outline_on:
            attributes.append(("showOutlineSymbols", 0))

        self._xml_empty_tag("outlinePr", attributes)

    def _write_row_breaks(self):
        # Write the <rowBreaks> element.
        page_breaks = self._sort_pagebreaks(self.hbreaks)

        if not page_breaks:
            return

        count = len(page_breaks)

        attributes = [
            ("count", count),
            ("manualBreakCount", count),
        ]

        self._xml_start_tag("rowBreaks", attributes)

        for row_num in page_breaks:
            self._write_brk(row_num, 16383)

        self._xml_end_tag("rowBreaks")

    def _write_col_breaks(self):
        # Write the <colBreaks> element.
        page_breaks = self._sort_pagebreaks(self.vbreaks)

        if not page_breaks:
            return

        count = len(page_breaks)

        attributes = [
            ("count", count),
            ("manualBreakCount", count),
        ]

        self._xml_start_tag("colBreaks", attributes)

        for col_num in page_breaks:
            self._write_brk(col_num, 1048575)

        self._xml_end_tag("colBreaks")

    def _write_brk(self, brk_id, brk_max):
        # Write the <brk> element.
        attributes = [("id", brk_id), ("max", brk_max), ("man", 1)]

        self._xml_empty_tag("brk", attributes)

    def _write_merge_cells(self):
        # Write the <mergeCells> element.
        merged_cells = self.merge
        count = len(merged_cells)

        if not count:
            return

        attributes = [("count", count)]

        self._xml_start_tag("mergeCells", attributes)

        for merged_range in merged_cells:
            # Write the mergeCell element.
            self._write_merge_cell(merged_range)

        self._xml_end_tag("mergeCells")

    def _write_merge_cell(self, merged_range):
        # Write the <mergeCell> element.
        (row_min, col_min, row_max, col_max) = merged_range

        # Convert the merge dimensions to a cell range.
        cell_1 = xl_rowcol_to_cell(row_min, col_min)
        cell_2 = xl_rowcol_to_cell(row_max, col_max)
        ref = cell_1 + ":" + cell_2

        attributes = [("ref", ref)]

        self._xml_empty_tag("mergeCell", attributes)

    def _write_hyperlinks(self):
        # Process any stored hyperlinks in row/col order and write the
        # <hyperlinks> element. The attributes are different for internal
        # and external links.
        hlink_refs = []
        display = None

        # Sort the hyperlinks into row order.
        row_nums = sorted(self.hyperlinks.keys())

        # Exit if there are no hyperlinks to process.
        if not row_nums:
            return

        # Iterate over the rows.
        for row_num in row_nums:
            # Sort the hyperlinks into column order.
            col_nums = sorted(self.hyperlinks[row_num].keys())

            # Iterate over the columns.
            for col_num in col_nums:
                # Get the link data for this cell.
                link = self.hyperlinks[row_num][col_num]
                link_type = link["link_type"]

                # If the cell isn't a string then we have to add the url as
                # the string to display.
                if self.table and self.table[row_num] and self.table[row_num][col_num]:
                    cell = self.table[row_num][col_num]
                    if cell.__class__.__name__ != "String":
                        display = link["url"]

                if link_type == 1:
                    # External link with rel file relationship.
                    self.rel_count += 1

                    hlink_refs.append(
                        [
                            link_type,
                            row_num,
                            col_num,
                            self.rel_count,
                            link["str"],
                            display,
                            link["tip"],
                        ]
                    )

                    # Links for use by the packager.
                    self.external_hyper_links.append(
                        ["/hyperlink", link["url"], "External"]
                    )
                else:
                    # Internal link with rel file relationship.
                    hlink_refs.append(
                        [
                            link_type,
                            row_num,
                            col_num,
                            link["url"],
                            link["str"],
                            link["tip"],
                        ]
                    )

        # Write the hyperlink elements.
        self._xml_start_tag("hyperlinks")

        for args in hlink_refs:
            link_type = args.pop(0)

            if link_type == 1:
                self._write_hyperlink_external(*args)
            elif link_type == 2:
                self._write_hyperlink_internal(*args)

        self._xml_end_tag("hyperlinks")

    def _write_hyperlink_external(
        self, row, col, id_num, location=None, display=None, tooltip=None
    ):
        # Write the <hyperlink> element for external links.
        ref = xl_rowcol_to_cell(row, col)
        r_id = "rId" + str(id_num)

        attributes = [("ref", ref), ("r:id", r_id)]

        if location is not None:
            attributes.append(("location", location))
        if display is not None:
            attributes.append(("display", display))
        if tooltip is not None:
            attributes.append(("tooltip", tooltip))

        self._xml_empty_tag("hyperlink", attributes)

    def _write_hyperlink_internal(
        self, row, col, location=None, display=None, tooltip=None
    ):
        # Write the <hyperlink> element for internal links.
        ref = xl_rowcol_to_cell(row, col)

        attributes = [("ref", ref), ("location", location)]

        if tooltip is not None:
            attributes.append(("tooltip", tooltip))
        attributes.append(("display", display))

        self._xml_empty_tag("hyperlink", attributes)

    def _write_auto_filter(self):
        # Write the <autoFilter> element.
        if not self.autofilter_ref:
            return

        attributes = [("ref", self.autofilter_ref)]

        if self.filter_on:
            # Autofilter defined active filters.
            self._xml_start_tag("autoFilter", attributes)
            self._write_autofilters()
            self._xml_end_tag("autoFilter")

        else:
            # Autofilter defined without active filters.
            self._xml_empty_tag("autoFilter", attributes)

    def _write_autofilters(self):
        # Function to iterate through the columns that form part of an
        # autofilter range and write the appropriate filters.
        (col1, col2) = self.filter_range

        for col in range(col1, col2 + 1):
            # Skip if column doesn't have an active filter.
            if col not in self.filter_cols:
                continue

            # Retrieve the filter tokens and write the autofilter records.
            tokens = self.filter_cols[col]
            filter_type = self.filter_type[col]

            # Filters are relative to first column in the autofilter.
            self._write_filter_column(col - col1, filter_type, tokens)

    def _write_filter_column(self, col_id, filter_type, filters):
        # Write the <filterColumn> element.
        attributes = [("colId", col_id)]

        self._xml_start_tag("filterColumn", attributes)

        if filter_type == 1:
            # Type == 1 is the new XLSX style filter.
            self._write_filters(filters)
        else:
            # Type == 0 is the classic "custom" filter.
            self._write_custom_filters(filters)

        self._xml_end_tag("filterColumn")

    def _write_filters(self, filters):
        # Write the <filters> element.
        non_blanks = [filter for filter in filters if str(filter).lower() != "blanks"]
        attributes = []

        if len(filters) != len(non_blanks):
            attributes = [("blank", 1)]

        if len(filters) == 1 and len(non_blanks) == 0:
            # Special case for blank cells only.
            self._xml_empty_tag("filters", attributes)
        else:
            # General case.
            self._xml_start_tag("filters", attributes)

            for autofilter in sorted(non_blanks):
                self._write_filter(autofilter)

            self._xml_end_tag("filters")

    def _write_filter(self, val):
        # Write the <filter> element.
        attributes = [("val", val)]

        self._xml_empty_tag("filter", attributes)

    def _write_custom_filters(self, tokens):
        # Write the <customFilters> element.
        if len(tokens) == 2:
            # One filter expression only.
            self._xml_start_tag("customFilters")
            self._write_custom_filter(*tokens)
            self._xml_end_tag("customFilters")
        else:
            # Two filter expressions.
            attributes = []

            # Check if the "join" operand is "and" or "or".
            if tokens[2] == 0:
                attributes = [("and", 1)]
            else:
                attributes = [("and", 0)]

            # Write the two custom filters.
            self._xml_start_tag("customFilters", attributes)
            self._write_custom_filter(tokens[0], tokens[1])
            self._write_custom_filter(tokens[3], tokens[4])
            self._xml_end_tag("customFilters")

    def _write_custom_filter(self, operator, val):
        # Write the <customFilter> element.
        attributes = []

        operators = {
            1: "lessThan",
            2: "equal",
            3: "lessThanOrEqual",
            4: "greaterThan",
            5: "notEqual",
            6: "greaterThanOrEqual",
            22: "equal",
        }

        # Convert the operator from a number to a descriptive string.
        if operators[operator] is not None:
            operator = operators[operator]
        else:
            warn("Unknown operator = %s" % operator)

        # The 'equal' operator is the default attribute and isn't stored.
        if operator != "equal":
            attributes.append(("operator", operator))
        attributes.append(("val", val))

        self._xml_empty_tag("customFilter", attributes)

    def _write_sheet_protection(self):
        # Write the <sheetProtection> element.
        attributes = []

        if not self.protect_options:
            return

        options = self.protect_options

        if options["password"]:
            attributes.append(("password", options["password"]))
        if options["sheet"]:
            attributes.append(("sheet", 1))
        if options["content"]:
            attributes.append(("content", 1))
        if not options["objects"]:
            attributes.append(("objects", 1))
        if not options["scenarios"]:
            attributes.append(("scenarios", 1))
        if options["format_cells"]:
            attributes.append(("formatCells", 0))
        if options["format_columns"]:
            attributes.append(("formatColumns", 0))
        if options["format_rows"]:
            attributes.append(("formatRows", 0))
        if options["insert_columns"]:
            attributes.append(("insertColumns", 0))
        if options["insert_rows"]:
            attributes.append(("insertRows", 0))
        if options["insert_hyperlinks"]:
            attributes.append(("insertHyperlinks", 0))
        if options["delete_columns"]:
            attributes.append(("deleteColumns", 0))
        if options["delete_rows"]:
            attributes.append(("deleteRows", 0))
        if not options["select_locked_cells"]:
            attributes.append(("selectLockedCells", 1))
        if options["sort"]:
            attributes.append(("sort", 0))
        if options["autofilter"]:
            attributes.append(("autoFilter", 0))
        if options["pivot_tables"]:
            attributes.append(("pivotTables", 0))
        if not options["select_unlocked_cells"]:
            attributes.append(("selectUnlockedCells", 1))

        self._xml_empty_tag("sheetProtection", attributes)

    def _write_protected_ranges(self):
        # Write the <protectedRanges> element.
        if self.num_protected_ranges == 0:
            return

        self._xml_start_tag("protectedRanges")

        for cell_range, range_name, password in self.protected_ranges:
            self._write_protected_range(cell_range, range_name, password)

        self._xml_end_tag("protectedRanges")

    def _write_protected_range(self, cell_range, range_name, password):
        # Write the <protectedRange> element.
        attributes = []

        if password:
            attributes.append(("password", password))

        attributes.append(("sqref", cell_range))
        attributes.append(("name", range_name))

        self._xml_empty_tag("protectedRange", attributes)

    def _write_drawings(self):
        # Write the <drawing> elements.
        if not self.drawing:
            return

        self.rel_count += 1
        self._write_drawing(self.rel_count)

    def _write_drawing(self, drawing_id):
        # Write the <drawing> element.
        r_id = "rId" + str(drawing_id)

        attributes = [("r:id", r_id)]

        self._xml_empty_tag("drawing", attributes)

    def _write_legacy_drawing(self):
        # Write the <legacyDrawing> element.
        if not self.has_vml:
            return

        # Increment the relationship id for any drawings or comments.
        self.rel_count += 1
        r_id = "rId" + str(self.rel_count)

        attributes = [("r:id", r_id)]

        self._xml_empty_tag("legacyDrawing", attributes)

    def _write_legacy_drawing_hf(self):
        # Write the <legacyDrawingHF> element.
        if not self.has_header_vml:
            return

        # Increment the relationship id for any drawings or comments.
        self.rel_count += 1
        r_id = "rId" + str(self.rel_count)

        attributes = [("r:id", r_id)]

        self._xml_empty_tag("legacyDrawingHF", attributes)

    def _write_picture(self):
        # Write the <picture> element.
        if not self.background_image:
            return

        # Increment the relationship id.
        self.rel_count += 1
        r_id = "rId" + str(self.rel_count)

        attributes = [("r:id", r_id)]

        self._xml_empty_tag("picture", attributes)

    def _write_data_validations(self):
        # Write the <dataValidations> element.
        validations = self.validations
        count = len(validations)

        if not count:
            return

        attributes = [("count", count)]

        self._xml_start_tag("dataValidations", attributes)

        for validation in validations:
            # Write the dataValidation element.
            self._write_data_validation(validation)

        self._xml_end_tag("dataValidations")

    def _write_data_validation(self, options):
        # Write the <dataValidation> element.
        sqref = ""
        attributes = []

        # Set the cell range(s) for the data validation.
        for cells in options["cells"]:
            # Add a space between multiple cell ranges.
            if sqref != "":
                sqref += " "

            (row_first, col_first, row_last, col_last) = cells

            # Swap last row/col for first row/col as necessary
            if row_first > row_last:
                (row_first, row_last) = (row_last, row_first)

            if col_first > col_last:
                (col_first, col_last) = (col_last, col_first)

            sqref += xl_range(row_first, col_first, row_last, col_last)

        if options.get("multi_range"):
            sqref = options["multi_range"]

        if options["validate"] != "none":
            attributes.append(("type", options["validate"]))

            if options["criteria"] != "between":
                attributes.append(("operator", options["criteria"]))

        if "error_type" in options:
            if options["error_type"] == 1:
                attributes.append(("errorStyle", "warning"))
            if options["error_type"] == 2:
                attributes.append(("errorStyle", "information"))

        if options["ignore_blank"]:
            attributes.append(("allowBlank", 1))

        if not options["dropdown"]:
            attributes.append(("showDropDown", 1))

        if options["show_input"]:
            attributes.append(("showInputMessage", 1))

        if options["show_error"]:
            attributes.append(("showErrorMessage", 1))

        if "error_title" in options:
            attributes.append(("errorTitle", options["error_title"]))

        if "error_message" in options:
            attributes.append(("error", options["error_message"]))

        if "input_title" in options:
            attributes.append(("promptTitle", options["input_title"]))

        if "input_message" in options:
            attributes.append(("prompt", options["input_message"]))

        attributes.append(("sqref", sqref))

        if options["validate"] == "none":
            self._xml_empty_tag("dataValidation", attributes)
        else:
            self._xml_start_tag("dataValidation", attributes)

            # Write the formula1 element.
            self._write_formula_1(options["value"])

            # Write the formula2 element.
            if options["maximum"] is not None:
                self._write_formula_2(options["maximum"])

            self._xml_end_tag("dataValidation")

    def _write_formula_1(self, formula):
        # Write the <formula1> element.

        if isinstance(formula, list):
            formula = self._csv_join(*formula)
            formula = '"%s"' % formula
        else:
            # Check if the formula is a number.
            try:
                float(formula)
            except ValueError:
                # Not a number. Remove the formula '=' sign if it exists.
                if formula.startswith("="):
                    formula = formula.lstrip("=")

        self._xml_data_element("formula1", formula)

    def _write_formula_2(self, formula):
        # Write the <formula2> element.

        # Check if the formula is a number.
        try:
            float(formula)
        except ValueError:
            # Not a number. Remove the formula '=' sign if it exists.
            if formula.startswith("="):
                formula = formula.lstrip("=")

        self._xml_data_element("formula2", formula)

    def _write_conditional_formats(self):
        # Write the Worksheet conditional formats.
        ranges = sorted(self.cond_formats.keys())

        if not ranges:
            return

        for cond_range in ranges:
            self._write_conditional_formatting(
                cond_range, self.cond_formats[cond_range]
            )

    def _write_conditional_formatting(self, cond_range, params):
        # Write the <conditionalFormatting> element.
        attributes = [("sqref", cond_range)]
        self._xml_start_tag("conditionalFormatting", attributes)
        for param in params:
            # Write the cfRule element.
            self._write_cf_rule(param)
        self._xml_end_tag("conditionalFormatting")

    def _write_cf_rule(self, params):
        # Write the <cfRule> element.
        attributes = [("type", params["type"])]

        if "format" in params and params["format"] is not None:
            attributes.append(("dxfId", params["format"]))

        attributes.append(("priority", params["priority"]))

        if params.get("stop_if_true"):
            attributes.append(("stopIfTrue", 1))

        if params["type"] == "cellIs":
            attributes.append(("operator", params["criteria"]))

            self._xml_start_tag("cfRule", attributes)

            if "minimum" in params and "maximum" in params:
                self._write_formula_element(params["minimum"])
                self._write_formula_element(params["maximum"])
            else:
                self._write_formula_element(params["value"])

            self._xml_end_tag("cfRule")

        elif params["type"] == "aboveAverage":
            if re.search("below", params["criteria"]):
                attributes.append(("aboveAverage", 0))

            if re.search("equal", params["criteria"]):
                attributes.append(("equalAverage", 1))

            if re.search("[123] std dev", params["criteria"]):
                match = re.search("([123]) std dev", params["criteria"])
                attributes.append(("stdDev", match.group(1)))

            self._xml_empty_tag("cfRule", attributes)

        elif params["type"] == "top10":
            if "criteria" in params and params["criteria"] == "%":
                attributes.append(("percent", 1))

            if "direction" in params:
                attributes.append(("bottom", 1))

            rank = params["value"] or 10
            attributes.append(("rank", rank))

            self._xml_empty_tag("cfRule", attributes)

        elif params["type"] == "duplicateValues":
            self._xml_empty_tag("cfRule", attributes)

        elif params["type"] == "uniqueValues":
            self._xml_empty_tag("cfRule", attributes)

        elif (
            params["type"] == "containsText"
            or params["type"] == "notContainsText"
            or params["type"] == "beginsWith"
            or params["type"] == "endsWith"
        ):
            attributes.append(("operator", params["criteria"]))
            attributes.append(("text", params["value"]))
            self._xml_start_tag("cfRule", attributes)
            self._write_formula_element(params["formula"])
            self._xml_end_tag("cfRule")

        elif params["type"] == "timePeriod":
            attributes.append(("timePeriod", params["criteria"]))
            self._xml_start_tag("cfRule", attributes)
            self._write_formula_element(params["formula"])
            self._xml_end_tag("cfRule")

        elif (
            params["type"] == "containsBlanks"
            or params["type"] == "notContainsBlanks"
            or params["type"] == "containsErrors"
            or params["type"] == "notContainsErrors"
        ):
            self._xml_start_tag("cfRule", attributes)
            self._write_formula_element(params["formula"])
            self._xml_end_tag("cfRule")

        elif params["type"] == "colorScale":
            self._xml_start_tag("cfRule", attributes)
            self._write_color_scale(params)
            self._xml_end_tag("cfRule")

        elif params["type"] == "dataBar":
            self._xml_start_tag("cfRule", attributes)
            self._write_data_bar(params)

            if params.get("is_data_bar_2010"):
                self._write_data_bar_ext(params)

            self._xml_end_tag("cfRule")

        elif params["type"] == "expression":
            self._xml_start_tag("cfRule", attributes)
            self._write_formula_element(params["criteria"])
            self._xml_end_tag("cfRule")

        elif params["type"] == "iconSet":
            self._xml_start_tag("cfRule", attributes)
            self._write_icon_set(params)
            self._xml_end_tag("cfRule")

    def _write_formula_element(self, formula):
        # Write the <formula> element.

        # Check if the formula is a number.
        try:
            float(formula)
        except ValueError:
            # Not a number. Remove the formula '=' sign if it exists.
            if formula.startswith("="):
                formula = formula.lstrip("=")

        self._xml_data_element("formula", formula)

    def _write_color_scale(self, param):
        # Write the <colorScale> element.

        self._xml_start_tag("colorScale")

        self._write_cfvo(param["min_type"], param["min_value"])

        if param["mid_type"] is not None:
            self._write_cfvo(param["mid_type"], param["mid_value"])

        self._write_cfvo(param["max_type"], param["max_value"])

        self._write_color("rgb", param["min_color"])

        if param["mid_color"] is not None:
            self._write_color("rgb", param["mid_color"])

        self._write_color("rgb", param["max_color"])

        self._xml_end_tag("colorScale")

    def _write_data_bar(self, param):
        # Write the <dataBar> element.
        attributes = []

        # Min and max bar lengths in in the spec but not supported directly by
        # Excel.
        if param.get("min_length"):
            attributes.append(("minLength", param["min_length"]))

        if param.get("max_length"):
            attributes.append(("maxLength", param["max_length"]))

        if param.get("bar_only"):
            attributes.append(("showValue", 0))

        self._xml_start_tag("dataBar", attributes)

        self._write_cfvo(param["min_type"], param["min_value"])
        self._write_cfvo(param["max_type"], param["max_value"])
        self._write_color("rgb", param["bar_color"])

        self._xml_end_tag("dataBar")

    def _write_data_bar_ext(self, param):
        # Write the <extLst> dataBar extension element.

        # Create a pseudo GUID for each unique Excel 2010 data bar.
        worksheet_count = self.index + 1
        data_bar_count = len(self.data_bars_2010) + 1
        guid = "{DA7ABA51-AAAA-BBBB-%04X-%012X}" % (worksheet_count, data_bar_count)

        # Store the 2010 data bar parameters to write the extLst elements.
        param["guid"] = guid
        self.data_bars_2010.append(param)

        self._xml_start_tag("extLst")
        self._write_ext("{B025F937-C7B1-47D3-B67F-A62EFF666E3E}")
        self._xml_data_element("x14:id", guid)
        self._xml_end_tag("ext")
        self._xml_end_tag("extLst")

    def _write_icon_set(self, param):
        # Write the <iconSet> element.
        attributes = []

        # Don't set attribute for default style.
        if param["icon_style"] != "3TrafficLights":
            attributes = [("iconSet", param["icon_style"])]

        if param.get("icons_only"):
            attributes.append(("showValue", 0))

        if param.get("reverse_icons"):
            attributes.append(("reverse", 1))

        self._xml_start_tag("iconSet", attributes)

        # Write the properties for different icon styles.
        for icon in reversed(param["icons"]):
            self._write_cfvo(icon["type"], icon["value"], icon["criteria"])

        self._xml_end_tag("iconSet")

    def _write_cfvo(self, cf_type, val, criteria=None):
        # Write the <cfvo> element.
        attributes = [("type", cf_type)]

        if val is not None:
            attributes.append(("val", val))

        if criteria:
            attributes.append(("gte", 0))

        self._xml_empty_tag("cfvo", attributes)

    def _write_color(self, name, value):
        # Write the <color> element.
        attributes = [(name, value)]

        self._xml_empty_tag("color", attributes)

    def _write_selections(self):
        # Write the <selection> elements.
        for selection in self.selections:
            self._write_selection(*selection)

    def _write_selection(self, pane, active_cell, sqref):
        # Write the <selection> element.
        attributes = []

        if pane:
            attributes.append(("pane", pane))

        if active_cell:
            attributes.append(("activeCell", active_cell))

        if sqref:
            attributes.append(("sqref", sqref))

        self._xml_empty_tag("selection", attributes)

    def _write_panes(self):
        # Write the frozen or split <pane> elements.
        panes = self.panes

        if not len(panes):
            return

        if panes[4] == 2:
            self._write_split_panes(*panes)
        else:
            self._write_freeze_panes(*panes)

    def _write_freeze_panes(self, row, col, top_row, left_col, pane_type):
        # Write the <pane> element for freeze panes.
        attributes = []

        y_split = row
        x_split = col
        top_left_cell = xl_rowcol_to_cell(top_row, left_col)
        active_pane = ""
        state = ""
        active_cell = ""
        sqref = ""

        # Move user cell selection to the panes.
        if self.selections:
            (_, active_cell, sqref) = self.selections[0]
            self.selections = []

        # Set the active pane.
        if row and col:
            active_pane = "bottomRight"

            row_cell = xl_rowcol_to_cell(row, 0)
            col_cell = xl_rowcol_to_cell(0, col)

            self.selections.append(["topRight", col_cell, col_cell])
            self.selections.append(["bottomLeft", row_cell, row_cell])
            self.selections.append(["bottomRight", active_cell, sqref])

        elif col:
            active_pane = "topRight"
            self.selections.append(["topRight", active_cell, sqref])

        else:
            active_pane = "bottomLeft"
            self.selections.append(["bottomLeft", active_cell, sqref])

        # Set the pane type.
        if pane_type == 0:
            state = "frozen"
        elif pane_type == 1:
            state = "frozenSplit"
        else:
            state = "split"

        if x_split:
            attributes.append(("xSplit", x_split))

        if y_split:
            attributes.append(("ySplit", y_split))

        attributes.append(("topLeftCell", top_left_cell))
        attributes.append(("activePane", active_pane))
        attributes.append(("state", state))

        self._xml_empty_tag("pane", attributes)

    def _write_split_panes(self, row, col, top_row, left_col, pane_type):
        # Write the <pane> element for split panes.
        attributes = []
        has_selection = 0
        active_pane = ""
        active_cell = ""
        sqref = ""

        y_split = row
        x_split = col

        # Move user cell selection to the panes.
        if self.selections:
            (_, active_cell, sqref) = self.selections[0]
            self.selections = []
            has_selection = 1

        # Convert the row and col to 1/20 twip units with padding.
        if y_split:
            y_split = int(20 * y_split + 300)

        if x_split:
            x_split = self._calculate_x_split_width(x_split)

        # For non-explicit topLeft definitions, estimate the cell offset based
        # on the pixels dimensions. This is only a workaround and doesn't take
        # adjusted cell dimensions into account.
        if top_row == row and left_col == col:
            top_row = int(0.5 + (y_split - 300) / 20 / 15)
            left_col = int(0.5 + (x_split - 390) / 20 / 3 * 4 / 64)

        top_left_cell = xl_rowcol_to_cell(top_row, left_col)

        # If there is no selection set the active cell to the top left cell.
        if not has_selection:
            active_cell = top_left_cell
            sqref = top_left_cell

        # Set the Cell selections.
        if row and col:
            active_pane = "bottomRight"

            row_cell = xl_rowcol_to_cell(top_row, 0)
            col_cell = xl_rowcol_to_cell(0, left_col)

            self.selections.append(["topRight", col_cell, col_cell])
            self.selections.append(["bottomLeft", row_cell, row_cell])
            self.selections.append(["bottomRight", active_cell, sqref])

        elif col:
            active_pane = "topRight"
            self.selections.append(["topRight", active_cell, sqref])

        else:
            active_pane = "bottomLeft"
            self.selections.append(["bottomLeft", active_cell, sqref])

        # Format splits to the same precision as Excel.
        if x_split:
            attributes.append(("xSplit", "%.16g" % x_split))

        if y_split:
            attributes.append(("ySplit", "%.16g" % y_split))

        attributes.append(("topLeftCell", top_left_cell))

        if has_selection:
            attributes.append(("activePane", active_pane))

        self._xml_empty_tag("pane", attributes)

    def _calculate_x_split_width(self, width):
        # Convert column width from user units to pane split width.

        max_digit_width = 7  # For Calabri 11.
        padding = 5

        # Convert to pixels.
        if width < 1:
            pixels = int(width * (max_digit_width + padding) + 0.5)
        else:
            pixels = int(width * max_digit_width + 0.5) + padding

        # Convert to points.
        points = pixels * 3 / 4

        # Convert to twips (twentieths of a point).
        twips = points * 20

        # Add offset/padding.
        width = twips + 390

        return width

    def _write_table_parts(self):
        # Write the <tableParts> element.
        tables = self.tables
        count = len(tables)

        # Return if worksheet doesn't contain any tables.
        if not count:
            return

        attributes = [
            (
                "count",
                count,
            )
        ]

        self._xml_start_tag("tableParts", attributes)

        for _ in tables:
            # Write the tablePart element.
            self.rel_count += 1
            self._write_table_part(self.rel_count)

        self._xml_end_tag("tableParts")

    def _write_table_part(self, r_id):
        # Write the <tablePart> element.

        r_id = "rId" + str(r_id)

        attributes = [
            (
                "r:id",
                r_id,
            )
        ]

        self._xml_empty_tag("tablePart", attributes)

    def _write_ext_list(self):
        # Write the <extLst> element for data bars and sparklines.
        has_data_bars = len(self.data_bars_2010)
        has_sparklines = len(self.sparklines)

        if not has_data_bars and not has_sparklines:
            return

        # Write the extLst element.
        self._xml_start_tag("extLst")

        if has_data_bars:
            self._write_ext_list_data_bars()

        if has_sparklines:
            self._write_ext_list_sparklines()

        self._xml_end_tag("extLst")

    def _write_ext_list_data_bars(self):
        # Write the Excel 2010 data_bar subelements.
        self._write_ext("{78C0D931-6437-407d-A8EE-F0AAD7539E65}")

        self._xml_start_tag("x14:conditionalFormattings")

        # Write the Excel 2010 conditional formatting data bar elements.
        for data_bar in self.data_bars_2010:
            # Write the x14:conditionalFormatting element.
            self._write_conditional_formatting_2010(data_bar)

        self._xml_end_tag("x14:conditionalFormattings")
        self._xml_end_tag("ext")

    def _write_conditional_formatting_2010(self, data_bar):
        # Write the <x14:conditionalFormatting> element.
        xmlns_xm = "http://schemas.microsoft.com/office/excel/2006/main"

        attributes = [("xmlns:xm", xmlns_xm)]

        self._xml_start_tag("x14:conditionalFormatting", attributes)

        # Write the x14:cfRule element.
        self._write_x14_cf_rule(data_bar)

        # Write the x14:dataBar element.
        self._write_x14_data_bar(data_bar)

        # Write the x14 max and min data bars.
        self._write_x14_cfvo(data_bar["x14_min_type"], data_bar["min_value"])
        self._write_x14_cfvo(data_bar["x14_max_type"], data_bar["max_value"])

        if not data_bar["bar_no_border"]:
            # Write the x14:borderColor element.
            self._write_x14_border_color(data_bar["bar_border_color"])

        # Write the x14:negativeFillColor element.
        if not data_bar["bar_negative_color_same"]:
            self._write_x14_negative_fill_color(data_bar["bar_negative_color"])

        # Write the x14:negativeBorderColor element.
        if (
            not data_bar["bar_no_border"]
            and not data_bar["bar_negative_border_color_same"]
        ):
            self._write_x14_negative_border_color(data_bar["bar_negative_border_color"])

        # Write the x14:axisColor element.
        if data_bar["bar_axis_position"] != "none":
            self._write_x14_axis_color(data_bar["bar_axis_color"])

        self._xml_end_tag("x14:dataBar")
        self._xml_end_tag("x14:cfRule")

        # Write the xm:sqref element.
        self._xml_data_element("xm:sqref", data_bar["range"])

        self._xml_end_tag("x14:conditionalFormatting")

    def _write_x14_cf_rule(self, data_bar):
        # Write the <x14:cfRule> element.
        rule_type = "dataBar"
        guid = data_bar["guid"]
        attributes = [("type", rule_type), ("id", guid)]

        self._xml_start_tag("x14:cfRule", attributes)

    def _write_x14_data_bar(self, data_bar):
        # Write the <x14:dataBar> element.
        min_length = 0
        max_length = 100

        attributes = [
            ("minLength", min_length),
            ("maxLength", max_length),
        ]

        if not data_bar["bar_no_border"]:
            attributes.append(("border", 1))

        if data_bar["bar_solid"]:
            attributes.append(("gradient", 0))

        if data_bar["bar_direction"] == "left":
            attributes.append(("direction", "leftToRight"))

        if data_bar["bar_direction"] == "right":
            attributes.append(("direction", "rightToLeft"))

        if data_bar["bar_negative_color_same"]:
            attributes.append(("negativeBarColorSameAsPositive", 1))

        if (
            not data_bar["bar_no_border"]
            and not data_bar["bar_negative_border_color_same"]
        ):
            attributes.append(("negativeBarBorderColorSameAsPositive", 0))

        if data_bar["bar_axis_position"] == "middle":
            attributes.append(("axisPosition", "middle"))

        if data_bar["bar_axis_position"] == "none":
            attributes.append(("axisPosition", "none"))

        self._xml_start_tag("x14:dataBar", attributes)

    def _write_x14_cfvo(self, rule_type, value):
        # Write the <x14:cfvo> element.
        attributes = [("type", rule_type)]

        if rule_type in ("min", "max", "autoMin", "autoMax"):
            self._xml_empty_tag("x14:cfvo", attributes)
        else:
            self._xml_start_tag("x14:cfvo", attributes)
            self._xml_data_element("xm:f", value)
            self._xml_end_tag("x14:cfvo")

    def _write_x14_border_color(self, rgb):
        # Write the <x14:borderColor> element.
        attributes = [("rgb", rgb)]
        self._xml_empty_tag("x14:borderColor", attributes)

    def _write_x14_negative_fill_color(self, rgb):
        # Write the <x14:negativeFillColor> element.
        attributes = [("rgb", rgb)]
        self._xml_empty_tag("x14:negativeFillColor", attributes)

    def _write_x14_negative_border_color(self, rgb):
        # Write the <x14:negativeBorderColor> element.
        attributes = [("rgb", rgb)]
        self._xml_empty_tag("x14:negativeBorderColor", attributes)

    def _write_x14_axis_color(self, rgb):
        # Write the <x14:axisColor> element.
        attributes = [("rgb", rgb)]
        self._xml_empty_tag("x14:axisColor", attributes)

    def _write_ext_list_sparklines(self):
        # Write the sparkline extension sub-elements.
        self._write_ext("{05C60535-1F16-4fd2-B633-F4F36F0B64E0}")

        # Write the x14:sparklineGroups element.
        self._write_sparkline_groups()

        # Write the sparkline elements.
        for sparkline in reversed(self.sparklines):
            # Write the x14:sparklineGroup element.
            self._write_sparkline_group(sparkline)

            # Write the x14:colorSeries element.
            self._write_color_series(sparkline["series_color"])

            # Write the x14:colorNegative element.
            self._write_color_negative(sparkline["negative_color"])

            # Write the x14:colorAxis element.
            self._write_color_axis()

            # Write the x14:colorMarkers element.
            self._write_color_markers(sparkline["markers_color"])

            # Write the x14:colorFirst element.
            self._write_color_first(sparkline["first_color"])

            # Write the x14:colorLast element.
            self._write_color_last(sparkline["last_color"])

            # Write the x14:colorHigh element.
            self._write_color_high(sparkline["high_color"])

            # Write the x14:colorLow element.
            self._write_color_low(sparkline["low_color"])

            if sparkline["date_axis"]:
                self._xml_data_element("xm:f", sparkline["date_axis"])

            self._write_sparklines(sparkline)

            self._xml_end_tag("x14:sparklineGroup")

        self._xml_end_tag("x14:sparklineGroups")
        self._xml_end_tag("ext")

    def _write_sparklines(self, sparkline):
        # Write the <x14:sparklines> element and <x14:sparkline> sub-elements.

        # Write the sparkline elements.
        self._xml_start_tag("x14:sparklines")

        for i in range(sparkline["count"]):
            spark_range = sparkline["ranges"][i]
            location = sparkline["locations"][i]

            self._xml_start_tag("x14:sparkline")
            self._xml_data_element("xm:f", spark_range)
            self._xml_data_element("xm:sqref", location)
            self._xml_end_tag("x14:sparkline")

        self._xml_end_tag("x14:sparklines")

    def _write_ext(self, uri):
        # Write the <ext> element.
        schema = "http://schemas.microsoft.com/office/"
        xmlns_x14 = schema + "spreadsheetml/2009/9/main"

        attributes = [
            ("xmlns:x14", xmlns_x14),
            ("uri", uri),
        ]

        self._xml_start_tag("ext", attributes)

    def _write_sparkline_groups(self):
        # Write the <x14:sparklineGroups> element.
        xmlns_xm = "http://schemas.microsoft.com/office/excel/2006/main"

        attributes = [("xmlns:xm", xmlns_xm)]

        self._xml_start_tag("x14:sparklineGroups", attributes)

    def _write_sparkline_group(self, options):
        # Write the <x14:sparklineGroup> element.
        #
        # Example for order.
        #
        # <x14:sparklineGroup
        #     manualMax="0"
        #     manualMin="0"
        #     lineWeight="2.25"
        #     type="column"
        #     dateAxis="1"
        #     displayEmptyCellsAs="span"
        #     markers="1"
        #     high="1"
        #     low="1"
        #     first="1"
        #     last="1"
        #     negative="1"
        #     displayXAxis="1"
        #     displayHidden="1"
        #     minAxisType="custom"
        #     maxAxisType="custom"
        #     rightToLeft="1">
        #
        empty = options.get("empty")
        attributes = []

        if options.get("max") is not None:
            if options["max"] == "group":
                options["cust_max"] = "group"
            else:
                attributes.append(("manualMax", options["max"]))
                options["cust_max"] = "custom"

        if options.get("min") is not None:
            if options["min"] == "group":
                options["cust_min"] = "group"
            else:
                attributes.append(("manualMin", options["min"]))
                options["cust_min"] = "custom"

        # Ignore the default type attribute (line).
        if options["type"] != "line":
            attributes.append(("type", options["type"]))

        if options.get("weight"):
            attributes.append(("lineWeight", options["weight"]))

        if options.get("date_axis"):
            attributes.append(("dateAxis", 1))

        if empty:
            attributes.append(("displayEmptyCellsAs", empty))

        if options.get("markers"):
            attributes.append(("markers", 1))

        if options.get("high"):
            attributes.append(("high", 1))

        if options.get("low"):
            attributes.append(("low", 1))

        if options.get("first"):
            attributes.append(("first", 1))

        if options.get("last"):
            attributes.append(("last", 1))

        if options.get("negative"):
            attributes.append(("negative", 1))

        if options.get("axis"):
            attributes.append(("displayXAxis", 1))

        if options.get("hidden"):
            attributes.append(("displayHidden", 1))

        if options.get("cust_min"):
            attributes.append(("minAxisType", options["cust_min"]))

        if options.get("cust_max"):
            attributes.append(("maxAxisType", options["cust_max"]))

        if options.get("reverse"):
            attributes.append(("rightToLeft", 1))

        self._xml_start_tag("x14:sparklineGroup", attributes)

    def _write_spark_color(self, element, color):
        # Helper function for the sparkline color functions below.
        attributes = []

        if color.get("rgb"):
            attributes.append(("rgb", color["rgb"]))

        if color.get("theme"):
            attributes.append(("theme", color["theme"]))

        if color.get("tint"):
            attributes.append(("tint", color["tint"]))

        self._xml_empty_tag(element, attributes)

    def _write_color_series(self, color):
        # Write the <x14:colorSeries> element.
        self._write_spark_color("x14:colorSeries", color)

    def _write_color_negative(self, color):
        # Write the <x14:colorNegative> element.
        self._write_spark_color("x14:colorNegative", color)

    def _write_color_axis(self):
        # Write the <x14:colorAxis> element.
        self._write_spark_color("x14:colorAxis", {"rgb": "FF000000"})

    def _write_color_markers(self, color):
        # Write the <x14:colorMarkers> element.
        self._write_spark_color("x14:colorMarkers", color)

    def _write_color_first(self, color):
        # Write the <x14:colorFirst> element.
        self._write_spark_color("x14:colorFirst", color)

    def _write_color_last(self, color):
        # Write the <x14:colorLast> element.
        self._write_spark_color("x14:colorLast", color)

    def _write_color_high(self, color):
        # Write the <x14:colorHigh> element.
        self._write_spark_color("x14:colorHigh", color)

    def _write_color_low(self, color):
        # Write the <x14:colorLow> element.
        self._write_spark_color("x14:colorLow", color)

    def _write_phonetic_pr(self):
        # Write the <phoneticPr> element.
        attributes = [
            ("fontId", "0"),
            ("type", "noConversion"),
        ]

        self._xml_empty_tag("phoneticPr", attributes)

    def _write_ignored_errors(self):
        # Write the <ignoredErrors> element.
        if not self.ignored_errors:
            return

        self._xml_start_tag("ignoredErrors")

        if self.ignored_errors.get("number_stored_as_text"):
            ignored_range = self.ignored_errors["number_stored_as_text"]
            self._write_ignored_error("numberStoredAsText", ignored_range)

        if self.ignored_errors.get("eval_error"):
            ignored_range = self.ignored_errors["eval_error"]
            self._write_ignored_error("evalError", ignored_range)

        if self.ignored_errors.get("formula_differs"):
            ignored_range = self.ignored_errors["formula_differs"]
            self._write_ignored_error("formula", ignored_range)

        if self.ignored_errors.get("formula_range"):
            ignored_range = self.ignored_errors["formula_range"]
            self._write_ignored_error("formulaRange", ignored_range)

        if self.ignored_errors.get("formula_unlocked"):
            ignored_range = self.ignored_errors["formula_unlocked"]
            self._write_ignored_error("unlockedFormula", ignored_range)

        if self.ignored_errors.get("empty_cell_reference"):
            ignored_range = self.ignored_errors["empty_cell_reference"]
            self._write_ignored_error("emptyCellReference", ignored_range)

        if self.ignored_errors.get("list_data_validation"):
            ignored_range = self.ignored_errors["list_data_validation"]
            self._write_ignored_error("listDataValidation", ignored_range)

        if self.ignored_errors.get("calculated_column"):
            ignored_range = self.ignored_errors["calculated_column"]
            self._write_ignored_error("calculatedColumn", ignored_range)

        if self.ignored_errors.get("two_digit_text_year"):
            ignored_range = self.ignored_errors["two_digit_text_year"]
            self._write_ignored_error("twoDigitTextYear", ignored_range)

        self._xml_end_tag("ignoredErrors")

    def _write_ignored_error(self, type, ignored_range):
        # Write the <ignoredError> element.
        attributes = [
            ("sqref", ignored_range),
            (type, 1),
        ]

        self._xml_empty_tag("ignoredError", attributes)

```

---

### File: `tmp\xlsxwriter_sdist\XlsxWriter-3.2.0\xlsxwriter\xmlwriter.py`

```python
###############################################################################
#
# XMLwriter - A base class for XlsxWriter classes.
#
# Used in conjunction with XlsxWriter.
#
# SPDX-License-Identifier: BSD-2-Clause
# Copyright 2013-2024, John McNamara, jmcnamara@cpan.org
#

# Standard packages.
import re
from io import StringIO

# Compile performance critical regular expressions.
re_control_chars_1 = re.compile("(_x[0-9a-fA-F]{4}_)")
re_control_chars_2 = re.compile(r"([\x00-\x08\x0b-\x1f])")
xml_escapes = re.compile('["&<>\n]')


class XMLwriter(object):
    """
    Simple XML writer class.

    """

    def __init__(self):
        self.fh = None
        self.internal_fh = False

    def _set_filehandle(self, filehandle):
        # Set the writer filehandle directly. Mainly for testing.
        self.fh = filehandle
        self.internal_fh = False

    def _set_xml_writer(self, filename):
        # Set the XML writer filehandle for the object.
        if isinstance(filename, StringIO):
            self.internal_fh = False
            self.fh = filename
        else:
            self.internal_fh = True
            self.fh = open(filename, "w", encoding="utf-8")

    def _xml_close(self):
        # Close the XML filehandle if we created it.
        if self.internal_fh:
            self.fh.close()

    def _xml_declaration(self):
        # Write the XML declaration.
        self.fh.write("""<?xml version="1.0" encoding="UTF-8" standalone="yes"?>\n""")

    def _xml_start_tag(self, tag, attributes=[]):
        # Write an XML start tag with optional attributes.
        for key, value in attributes:
            value = self._escape_attributes(value)
            tag += ' %s="%s"' % (key, value)

        self.fh.write("<%s>" % tag)

    def _xml_start_tag_unencoded(self, tag, attributes=[]):
        # Write an XML start tag with optional, unencoded, attributes.
        # This is a minor speed optimization for elements that don't
        # need encoding.
        for key, value in attributes:
            tag += ' %s="%s"' % (key, value)

        self.fh.write("<%s>" % tag)

    def _xml_end_tag(self, tag):
        # Write an XML end tag.
        self.fh.write("</%s>" % tag)

    def _xml_empty_tag(self, tag, attributes=[]):
        # Write an empty XML tag with optional attributes.
        for key, value in attributes:
            value = self._escape_attributes(value)
            tag += ' %s="%s"' % (key, value)

        self.fh.write("<%s/>" % tag)

    def _xml_empty_tag_unencoded(self, tag, attributes=[]):
        # Write an empty XML tag with optional, unencoded, attributes.
        # This is a minor speed optimization for elements that don't
        # need encoding.
        for key, value in attributes:
            tag += ' %s="%s"' % (key, value)

        self.fh.write("<%s/>" % tag)

    def _xml_data_element(self, tag, data, attributes=[]):
        # Write an XML element containing data with optional attributes.
        end_tag = tag

        for key, value in attributes:
            value = self._escape_attributes(value)
            tag += ' %s="%s"' % (key, value)

        data = self._escape_data(data)
        data = self._escape_control_characters(data)

        self.fh.write("<%s>%s</%s>" % (tag, data, end_tag))

    def _xml_string_element(self, index, attributes=[]):
        # Optimized tag writer for <c> cell string elements in the inner loop.
        attr = ""

        for key, value in attributes:
            value = self._escape_attributes(value)
            attr += ' %s="%s"' % (key, value)

        self.fh.write("""<c%s t="s"><v>%d</v></c>""" % (attr, index))

    def _xml_si_element(self, string, attributes=[]):
        # Optimized tag writer for shared strings <si> elements.
        attr = ""

        for key, value in attributes:
            value = self._escape_attributes(value)
            attr += ' %s="%s"' % (key, value)

        string = self._escape_data(string)

        self.fh.write("""<si><t%s>%s</t></si>""" % (attr, string))

    def _xml_rich_si_element(self, string):
        # Optimized tag writer for shared strings <si> rich string elements.

        self.fh.write("""<si>%s</si>""" % string)

    def _xml_number_element(self, number, attributes=[]):
        # Optimized tag writer for <c> cell number elements in the inner loop.
        attr = ""

        for key, value in attributes:
            value = self._escape_attributes(value)
            attr += ' %s="%s"' % (key, value)

        self.fh.write("""<c%s><v>%.16G</v></c>""" % (attr, number))

    def _xml_formula_element(self, formula, result, attributes=[]):
        # Optimized tag writer for <c> cell formula elements in the inner loop.
        attr = ""

        for key, value in attributes:
            value = self._escape_attributes(value)
            attr += ' %s="%s"' % (key, value)

        self.fh.write(
            """<c%s><f>%s</f><v>%s</v></c>"""
            % (attr, self._escape_data(formula), self._escape_data(result))
        )

    def _xml_inline_string(self, string, preserve, attributes=[]):
        # Optimized tag writer for inlineStr cell elements in the inner loop.
        attr = ""
        t_attr = ""

        # Set the <t> attribute to preserve whitespace.
        if preserve:
            t_attr = ' xml:space="preserve"'

        for key, value in attributes:
            value = self._escape_attributes(value)
            attr += ' %s="%s"' % (key, value)

        string = self._escape_data(string)

        self.fh.write(
            """<c%s t="inlineStr"><is><t%s>%s</t></is></c>""" % (attr, t_attr, string)
        )

    def _xml_rich_inline_string(self, string, attributes=[]):
        # Optimized tag writer for rich inlineStr in the inner loop.
        attr = ""

        for key, value in attributes:
            value = self._escape_attributes(value)
            attr += ' %s="%s"' % (key, value)

        self.fh.write("""<c%s t="inlineStr"><is>%s</is></c>""" % (attr, string))

    def _escape_attributes(self, attribute):
        # Escape XML characters in attributes.
        try:
            if not xml_escapes.search(attribute):
                return attribute
        except TypeError:
            return attribute

        attribute = (
            attribute.replace("&", "&amp;")
            .replace('"', "&quot;")
            .replace("<", "&lt;")
            .replace(">", "&gt;")
            .replace("\n", "&#xA;")
        )
        return attribute

    def _escape_data(self, data):
        # Escape XML characters in data sections of tags.  Note, this
        # is different from _escape_attributes() in that double quotes
        # are not escaped by Excel.
        try:
            if not xml_escapes.search(data):
                return data
        except TypeError:
            return data

        data = data.replace("&", "&amp;").replace("<", "&lt;").replace(">", "&gt;")
        return data

    @staticmethod
    def _escape_control_characters(data):
        # Excel escapes control characters with _xHHHH_ and also escapes any
        # literal strings of that type by encoding the leading underscore.
        # So "\0" -> _x0000_ and "_x0000_" -> _x005F_x0000_.
        # The following substitutions deal with those cases.
        try:
            # Escape the escape.
            data = re_control_chars_1.sub(r"_x005F\1", data)
        except TypeError:
            return data

        # Convert control character to the _xHHHH_ escape.
        data = re_control_chars_2.sub(
            lambda match: "_x%04X_" % ord(match.group(1)), data
        )

        # Escapes non characters in strings.
        data = data.replace("\uFFFE", "_xFFFE_").replace("\uFFFF", "_xFFFF_")

        return data

```

---

### File: `wasm\Cargo.toml`

```toml
[package]
name = "excel_diff_wasm"
version = "0.1.0"
edition = "2024"
description = "WebAssembly bindings for excel_diff"
license = "MIT"
repository = "https://github.com/dvora/excel_diff"
homepage = "https://github.com/dvora/excel_diff"

[lib]
crate-type = ["cdylib", "rlib"]

[dependencies]
excel_diff = { path = "../core", default-features = false, features = ["excel-open-xml"] }
wasm-bindgen = "0.2"
serde = { version = "1.0", features = ["derive"] }
serde_json = "1.0"


```

---

### File: `wasm\src\lib.rs`

```rust
use wasm_bindgen::prelude::*;
use std::io::Cursor;

#[wasm_bindgen]
pub fn diff_workbooks_json(old_bytes: &[u8], new_bytes: &[u8]) -> Result<String, JsValue> {
    let old_cursor = Cursor::new(old_bytes.to_vec());
    let new_cursor = Cursor::new(new_bytes.to_vec());

    let pkg_old = excel_diff::WorkbookPackage::open(old_cursor)
        .map_err(|e| JsValue::from_str(&format!("Failed to open old file: {}", e)))?;
    let pkg_new = excel_diff::WorkbookPackage::open(new_cursor)
        .map_err(|e| JsValue::from_str(&format!("Failed to open new file: {}", e)))?;

    let report = pkg_old.diff(&pkg_new, &excel_diff::DiffConfig::default());

    excel_diff::serialize_diff_report(&report)
        .map_err(|e| JsValue::from_str(&format!("Failed to serialize report: {}", e)))
}

#[wasm_bindgen]
pub fn get_version() -> String {
    env!("CARGO_PKG_VERSION").to_string()
}

#[wasm_bindgen]
pub struct DiffSummary {
    pub op_count: usize,
    pub sheets_old: usize,
    pub sheets_new: usize,
}

#[wasm_bindgen]
pub fn diff_summary(old_bytes: &[u8], new_bytes: &[u8]) -> Result<DiffSummary, JsValue> {
    let old_cursor = Cursor::new(old_bytes.to_vec());
    let new_cursor = Cursor::new(new_bytes.to_vec());

    let pkg_old = excel_diff::WorkbookPackage::open(old_cursor)
        .map_err(|e| JsValue::from_str(&format!("Failed to open old file: {}", e)))?;
    let pkg_new = excel_diff::WorkbookPackage::open(new_cursor)
        .map_err(|e| JsValue::from_str(&format!("Failed to open new file: {}", e)))?;

    let report = pkg_old.diff(&pkg_new, &excel_diff::DiffConfig::default());

    Ok(DiffSummary {
        op_count: report.ops.len(),
        sheets_old: pkg_old.workbook.sheets.len(),
        sheets_new: pkg_new.workbook.sheets.len(),
    })
}


```

---
